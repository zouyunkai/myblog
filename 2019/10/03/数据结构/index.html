<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>数据结构上机实验 | Sweet@</title>
  <meta name="description" content="对分易作业：表的操作算法设计作业内容：所有操作的函数头已经给出，分别写出函数体。1）已知单链表L，设计算法求单链表的表长。 int ListLength ( LinkList L )2）设计一个算法，求顺序表中值最大的结点的值。  int Max (SqList L )3)设计一个算法，求单链表中值最大的结点的值。  int Max (LinkList L )4）设计一个算法，删除数组s中的最大元">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构上机实验">
<meta property="og:url" content="https://zouyunkai.github.io/myblog/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Sweet@">
<meta property="og:description" content="对分易作业：表的操作算法设计作业内容：所有操作的函数头已经给出，分别写出函数体。1）已知单链表L，设计算法求单链表的表长。 int ListLength ( LinkList L )2）设计一个算法，求顺序表中值最大的结点的值。  int Max (SqList L )3)设计一个算法，求单链表中值最大的结点的值。  int Max (LinkList L )4）设计一个算法，删除数组s中的最大元">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-10-03T12:36:00.000Z">
<meta property="article:modified_time" content="2022-02-26T03:52:50.986Z">
<meta property="article:author" content="zouqingzhi">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="https://zouyunkai.github.io/myblog/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Sweet@" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/myblog/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.0.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/zouyunkai" target="_blank">
          <img class="img-circle img-rotate" src="/myblog/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">云开</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Stay Hungry , Stay Foolish .</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/myblog/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/myblog/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/myblog/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/myblog/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/myblog/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/myblog/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/zouyunkai" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/zouyunkai" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/zouyunkai" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/zouyunkai" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/myblog/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E8%BD%AF%E8%80%83/">软考</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/04/19/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0%20(%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)/" class="title">软考笔记 （操作系统）</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-19T13:29:00.000Z" itemprop="datePublished">2022-04-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E8%BD%AF%E8%80%83/">软考</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/04/19/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0%20(%E8%AE%A1%E7%BD%91)/" class="title">软考笔记（计网）</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-19T13:29:00.000Z" itemprop="datePublished">2022-04-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E8%BD%AF%E8%80%83/">软考</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/04/19/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0%EF%BC%88%E6%9C%BA%E7%BB%84%E4%BD%93%E7%B3%BB%EF%BC%89/" class="title">软考笔记 （计算机组成与体系结构）</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-19T13:29:00.000Z" itemprop="datePublished">2022-04-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E8%BD%AF%E8%80%83/">软考</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/04/19/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93)/" class="title">软考笔记 （数据库）</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-19T13:29:00.000Z" itemprop="datePublished">2022-04-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/">所长的跨学科工具箱</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/04/04/12%E6%A6%82%E7%8E%87%E6%80%9D%E7%BB%B4/" class="title">概率思维—把握不确定性</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-04T13:29:00.000Z" itemprop="datePublished">2022-04-04</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/myblog/tags/" style="font-size: 13px;">  </a> <a href="/myblog/tags/2019%E6%A0%A1%E8%B5%9B/" style="font-size: 13px;">2019校赛</a> <a href="/myblog/tags/BFS/" style="font-size: 13.2px;">BFS</a> <a href="/myblog/tags/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/" style="font-size: 13px;">C++字符串处理</a> <a href="/myblog/tags/CF/" style="font-size: 13px;">CF</a> <a href="/myblog/tags/DFS/" style="font-size: 13.2px;">DFS</a> <a href="/myblog/tags/DOM/" style="font-size: 13px;">DOM</a> <a href="/myblog/tags/DP/" style="font-size: 13px;">DP</a> <a href="/myblog/tags/FFT/" style="font-size: 13px;">FFT</a> <a href="/myblog/tags/KMP/" style="font-size: 13px;">KMP</a> <a href="/myblog/tags/boos/" style="font-size: 13px;">boos</a> <a href="/myblog/tags/c/" style="font-size: 13px;">c</a> <a href="/myblog/tags/c/" style="font-size: 13px;">c#</a> <a href="/myblog/tags/c/" style="font-size: 13.4px;">c++</a> <a href="/myblog/tags/codeforce/" style="font-size: 13.2px;">codeforce</a> <a href="/myblog/tags/comparable-and-comparator/" style="font-size: 13px;">comparable and comparator</a> <a href="/myblog/tags/crypto/" style="font-size: 13px;">crypto</a> <a href="/myblog/tags/c%E8%AF%AD%E8%A8%80%E5%B0%8F%E7%9F%A5%E8%AF%86/" style="font-size: 13px;">c语言小知识</a> <a href="/myblog/tags/git/" style="font-size: 13px;">git</a> <a href="/myblog/tags/html/" style="font-size: 13px;">html</a> <a href="/myblog/tags/iis%E9%85%8D%E7%BD%AE/" style="font-size: 13px;">iis配置</a> <a href="/myblog/tags/java/" style="font-size: 13.2px;">java</a> <a href="/myblog/tags/java-se/" style="font-size: 13.2px;">java se</a> <a href="/myblog/tags/java-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" style="font-size: 13px;">java 深浅拷贝</a> <a href="/myblog/tags/java%E7%AE%97%E6%B3%95/" style="font-size: 13px;">java算法</a> <a href="/myblog/tags/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 13px;">java网络编程</a> <a href="/myblog/tags/js/" style="font-size: 13px;">js</a> <a href="/myblog/tags/linux%E6%95%99%E7%A8%8B/" style="font-size: 13px;">linux教程</a> <a href="/myblog/tags/mysql/" style="font-size: 13px;">mysql</a> <a href="/myblog/tags/param/" style="font-size: 13px;">param</a> <a href="/myblog/tags/qluoj/" style="font-size: 13px;">qluoj</a> <a href="/myblog/tags/sql/" style="font-size: 13px;">sql</a> <a href="/myblog/tags/stl/" style="font-size: 13px;">stl</a> <a href="/myblog/tags/web/" style="font-size: 13.2px;">web</a> <a href="/myblog/tags/%E4%BA%8C%E5%88%86%E6%B3%95/" style="font-size: 13px;">二分法</a> <a href="/myblog/tags/%E4%BA%94%E5%AD%90%E6%A3%8B/" style="font-size: 13px;">五子棋</a> <a href="/myblog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 13.2px;">动态规划</a> <a href="/myblog/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 13px;">单调栈</a> <a href="/myblog/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" style="font-size: 13px;">单调队列</a> <a href="/myblog/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" style="font-size: 13px;">博弈论</a> <a href="/myblog/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/" style="font-size: 13px;">哈夫曼编码</a> <a href="/myblog/tags/%E5%93%B2%E5%AD%A6/" style="font-size: 13px;">哲学</a> <a href="/myblog/tags/%E5%9B%BD%E7%8E%8B%E6%8C%96%E9%87%91%E5%AD%90/" style="font-size: 13px;">国王挖金子</a> <a href="/myblog/tags/%E5%9B%BE/" style="font-size: 13.2px;">图</a> <a href="/myblog/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 13px;">图论</a> <a href="/myblog/tags/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/" style="font-size: 13px;">大数运算</a> <a href="/myblog/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/" style="font-size: 13.2px;">小游戏</a> <a href="/myblog/tags/%E5%B1%B1%E7%90%86%E5%B7%A5/" style="font-size: 13px;">山理工</a> <a href="/myblog/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/" style="font-size: 13px;">快速幂</a> <a href="/myblog/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 13px;">排序算法</a> <a href="/myblog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 13.4px;">数据库</a> <a href="/myblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13px;">数据结构</a> <a href="/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/" style="font-size: 14px;">新生训练</a> <a href="/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83-02/" style="font-size: 13px;">新生训练_02</a> <a href="/myblog/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 13.2px;">最小生成树</a> <a href="/myblog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" style="font-size: 13.2px;">最短路径</a> <a href="/myblog/tags/%E6%9D%AD%E7%94%B5/" style="font-size: 13px;">杭电</a> <a href="/myblog/tags/%E6%A0%88/" style="font-size: 13px;">栈</a> <a href="/myblog/tags/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96/" style="font-size: 13px;">棋盘覆盖</a> <a href="/myblog/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 13px;">模板</a> <a href="/myblog/tags/%E7%89%9B%E5%AE%A2/" style="font-size: 13.8px;">牛客</a> <a href="/myblog/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.2px;">算法</a> <a href="/myblog/tags/%E7%B4%A0%E6%95%B0/" style="font-size: 13px;">素数</a> <a href="/myblog/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/" style="font-size: 13px;">聊天室</a> <a href="/myblog/tags/%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9B/" style="font-size: 13px;">联盟周赛</a> <a href="/myblog/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" style="font-size: 13px;">背包问题</a> <a href="/myblog/tags/%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D/" style="font-size: 13px;">英文单词</a> <a href="/myblog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" style="font-size: 13px;">蓝桥杯</a> <a href="/myblog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%97%E6%B3%95/" style="font-size: 13px;">蓝桥杯算法</a> <a href="/myblog/tags/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B/" style="font-size: 13.6px;">蓝桥省赛</a> <a href="/myblog/tags/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/" style="font-size: 13px;">计网笔记</a> <a href="/myblog/tags/%E8%AE%AD%E7%BB%83/" style="font-size: 13.6px;">训练</a> <a href="/myblog/tags/%E8%B4%AA%E5%90%83%E8%9B%87/" style="font-size: 13px;">贪吃蛇</a> <a href="/myblog/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 13px;">贪心</a> <a href="/myblog/tags/%E9%80%92%E5%BD%92/" style="font-size: 13.4px;">递归</a> <a href="/myblog/tags/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/" style="font-size: 13px;">递归与分治</a> <a href="/myblog/tags/%E9%98%9F%E5%88%97/" style="font-size: 13px;">队列</a> <a href="/myblog/tags/%E9%9A%90%E5%86%99/" style="font-size: 13px;">隐写</a> <a href="/myblog/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13px;">面试</a>
    </div>
  </div>

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-数据结构" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      数据结构上机实验
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/myblog/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
	  <time datetime="2019-10-03T12:36:00.000Z" itemprop="datePublished">2019-10-03</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/myblog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/myblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/myblog/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 17.4k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 77(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h4 id="对分易作业：表的操作"><a href="#对分易作业：表的操作" class="headerlink" title="对分易作业：表的操作"></a>对分易作业：表的操作</h4><p>算法设计作业内容：所有操作的函数头已经给出，分别写出函数体。<br>1）已知单链表L，设计算法求单链表的表长。 int ListLength ( LinkList L )<br>2）设计一个算法，求顺序表中值最大的结点的值。  int Max (SqList L )<br>3)设计一个算法，求单链表中值最大的结点的值。  int Max (LinkList L )<br>4）设计一个算法，删除数组s中的最大元素。  void DeleteMax (int s[], int n)<br>5）设计一个算法，删除单链表中值最大的结点。  void DeleteMax (LinkList L )<br>6）设计算法删除单链表L中所有值为x的结点。   void DeleteX (LinkList L, int x )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">//后插法 顺序相同 </span><br><span class="line">void CreateList_R(LinkList &amp;L,int n)&#123;</span><br><span class="line">	L=new LNode;    //头结点 </span><br><span class="line">	L-&gt;next=NULL;</span><br><span class="line">	LinkList r=L;	//r为尾指针 </span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		LinkList p=new LNode;</span><br><span class="line">		cin&gt;&gt;p-&gt;data;</span><br><span class="line">		p-&gt;next=NULL;</span><br><span class="line">		r-&gt;next=p;</span><br><span class="line">		r=p;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">//第一题 求表长度 </span><br><span class="line">int ListLength(LinkList L)&#123;</span><br><span class="line">	int len=0;</span><br><span class="line">	LinkList p=L-&gt;next;</span><br><span class="line">	while(p)&#123;</span><br><span class="line">		len++;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三题 求表中最大的节点的值 </span><br><span class="line">int Max(LinkList L)&#123;</span><br><span class="line">	LinkList p=L-&gt;next;</span><br><span class="line">	int maxnum=L-&gt;data;</span><br><span class="line">	while(p)&#123;</span><br><span class="line">		if(p-&gt;data&gt;maxnum)</span><br><span class="line">			maxnum=p-&gt;data;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return maxnum;</span><br><span class="line">&#125; </span><br><span class="line">//第四题 删除数组中最大元素 </span><br><span class="line">void DeleteMax(int s[],int n)&#123;</span><br><span class="line">	int maxid=0;</span><br><span class="line">	int maxnum=s[0];</span><br><span class="line">	//假设s[0]是最小的那个元素 </span><br><span class="line">	for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">		if(s[i]&gt;maxnum)&#123; </span><br><span class="line">			maxid=i;</span><br><span class="line">			maxnum=s[i];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;for(int i=maxid;i&lt;n-1;i++)&#123;</span><br><span class="line">		//注意这时候这个i到n-1，因为那个数组的最大下标是i-1 </span><br><span class="line">		s[i]=s[i+1];</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line">//第五题 删单链表中值最大的节点 </span><br><span class="line">void DeleteMax( LinkList L)&#123;</span><br><span class="line">	LinkList p=L-&gt;next;</span><br><span class="line">	int maxx=p-&gt;data;</span><br><span class="line">	while(p)&#123;</span><br><span class="line">		if(p-&gt;data&gt;maxx)</span><br><span class="line">			maxx=p-&gt;data;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	p=L;</span><br><span class="line">	while(p-&gt;next)&#123;</span><br><span class="line">		bool flag=false;</span><br><span class="line">		if(p-&gt;next-&gt;data==maxx)&#123;</span><br><span class="line">			flag=true;</span><br><span class="line">			LinkList q=p-&gt;next;</span><br><span class="line">			p-&gt;next=q-&gt;next;</span><br><span class="line">			delete q;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag)continue;</span><br><span class="line">		else p=p-&gt;next;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//第六题 删除单链表中所有值为x的节点 </span><br><span class="line">void DeleteX(LinkList L,int x)&#123;</span><br><span class="line">	LinkList p=L;</span><br><span class="line">	while(p-&gt;next)&#123;</span><br><span class="line">		bool flag=false;</span><br><span class="line">		if(p-&gt;next-&gt;data==x)&#123;</span><br><span class="line">			flag=true;</span><br><span class="line">			LinkList q=p-&gt;next;</span><br><span class="line">			p-&gt;next=q-&gt;next;</span><br><span class="line">			delete q;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag)continue;</span><br><span class="line">		else p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	LinkList L;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	CreateList_R(L,n);</span><br><span class="line">	//测试第一题 </span><br><span class="line">	cout&lt;&lt;ListLength(L)&lt;&lt;endl; </span><br><span class="line">	//测试第三题 </span><br><span class="line">	cout&lt;&lt;MAX(L)&lt;&lt;endl; </span><br><span class="line">	//测试第五题 </span><br><span class="line">	DeleteMax(L);</span><br><span class="line">	//输出链表的内容 </span><br><span class="line">	LinkList p=L-&gt;next;</span><br><span class="line">while(p)&#123;</span><br><span class="line">		cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">		p=p-&gt;next; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	//测试第六题 </span><br><span class="line">	DeleteX(L,4);</span><br><span class="line">	p=L-&gt;next;</span><br><span class="line">	while(p)&#123;</span><br><span class="line">		cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">		p=p-&gt;next; </span><br><span class="line">	&#125;</span><br><span class="line">/*测试第四题 </span><br><span class="line">	int s[4];</span><br><span class="line">	for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">		cin&gt;&gt;s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	DeleteMax(s,4);</span><br><span class="line">	for(int i=0;i&lt;3;i++)cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//顺序表的后插法 顺序相同 </span><br><span class="line">void CreateList_R(LinkList &amp;L,int n)&#123;</span><br><span class="line">	L=new LNode;    //头结点 </span><br><span class="line">	L-&gt;next=NULL;</span><br><span class="line">	LinkList r;	//r为尾指针 </span><br><span class="line">	int len=ListLength(L);</span><br><span class="line">	cin&gt;&gt;r.data;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		if(p)</span><br><span class="line">	&#125; </span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		LinkList p=new LNode;</span><br><span class="line">		cin&gt;&gt;p-&gt;data;</span><br><span class="line">		p-&gt;next=NULL;</span><br><span class="line">		r-&gt;next=p;</span><br><span class="line">		r=p;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//前插法 顺序相反 </span><br><span class="line">void CreateList_H(LinkList &amp;L,int n)&#123;</span><br><span class="line">	L=new LNode;</span><br><span class="line">	L-&gt;next=NULL;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		LinkList p=new LNode ;</span><br><span class="line">		cin&gt;&gt;p-&gt;data;</span><br><span class="line">		p-&gt;next=L-&gt;next;</span><br><span class="line">		L-&gt;next=p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LNode *locateElem(LinkList L,int e)&#123;</span><br><span class="line">	LinkList p=L-&gt;next;</span><br><span class="line">	while(p&amp;&amp;p-&gt;data!=e)</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">还有一部分作业就是顺序表那部分：</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">#define OVERFLOW 0</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	int *elem;</span><br><span class="line">	int length;</span><br><span class="line">&#125;SQList;</span><br><span class="line">void InitList(SQList &amp;L)&#123;</span><br><span class="line">	L.elem=new int[MAXSIZE];</span><br><span class="line">	if(!L.elem)exit(OVERFLOW);</span><br><span class="line">	L.length=0;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">/*产生一个顺序表，先输入n，在输入n个数据，</span><br><span class="line">思想就是先输入n，在输入一个数存到L.elem[0],然后比较一下顺序表中元素的</span><br><span class="line">值，然后插入元素 </span><br><span class="line">*/ </span><br><span class="line">void CreatList(SQList &amp;L)&#123;</span><br><span class="line">	int n,num;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cin&gt;&gt;L.elem[0];</span><br><span class="line">	L.length=1;</span><br><span class="line">	for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;num;</span><br><span class="line">		int j;</span><br><span class="line">		for(j=1;j&lt;L.length;j++)&#123;</span><br><span class="line">			if(num&lt;L.elem[j])&#123;</span><br><span class="line">			break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">			for(int k=L.length-1;k&gt;=j-1;k--)&#123;</span><br><span class="line">					L.elem[k+1]=L.elem[k];</span><br><span class="line">			&#125;</span><br><span class="line">			++L.length;</span><br><span class="line">			L.elem[j]=num;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">//第二题 求顺序表中值最大的节点的值 </span><br><span class="line">int MAX(SQList L)&#123;</span><br><span class="line">	int maxx=L.elem[0];</span><br><span class="line">	int maxid;</span><br><span class="line">	for(int i=1;i&lt;L.length;i++)&#123;</span><br><span class="line">		if(L.elem[i]&gt;maxx)&#123;</span><br><span class="line">			maxid=i;</span><br><span class="line">			maxx=L.elem[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return maxid;</span><br><span class="line">&#125;</span><br><span class="line">//测试函数 </span><br><span class="line">int main()&#123;</span><br><span class="line">	SQList L;</span><br><span class="line">	InitList(L);</span><br><span class="line">	CreatList(L);</span><br><span class="line">	for(int i=0;i&lt;L.length;i++)&#123;</span><br><span class="line">		cout&lt;&lt;L.elem[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;L.elem[MAX(L)];</span><br><span class="line">&#125;</span><br><span class="line">int MAX_1(SQList L,int e)&#123;</span><br><span class="line">	int maxx=e;</span><br><span class="line">	int maxid;</span><br><span class="line">	for(int i=0;i&lt;L.length;i++)&#123;</span><br><span class="line">		if(L.elem[i]&gt;maxx)&#123;</span><br><span class="line">			maxid=i;</span><br><span class="line">			maxx=L.elem[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return maxid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListInsert(SQList &amp;L,int i,int e)&#123;</span><br><span class="line">	if((i&lt;1)||(i&gt;L.length+1)) return error;</span><br><span class="line">	if(L.length==MAXSIZE) return error;</span><br><span class="line">	for(int j=L.length-1;j&gt;=i-1;j--)</span><br><span class="line">		L.elem[j+1]=L.elem[j];</span><br><span class="line">	L.elem[i-1]=e;</span><br><span class="line">	++L.length;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="上机实验1（字符串链表的插入，删除，查找）"><a href="#上机实验1（字符串链表的插入，删除，查找）" class="headerlink" title="上机实验1（字符串链表的插入，删除，查找）"></a>上机实验1（字符串链表的插入，删除，查找）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line">#include&quot;string.h&quot;</span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line">#include&quot;ctype.h&quot;</span><br><span class="line">typedef struct node //定义结点</span><br><span class="line">&#123;</span><br><span class="line">	char data[10]; //结点的数据域为字符串</span><br><span class="line">	struct node *next; //结点的指针域</span><br><span class="line">&#125;ListNode;</span><br><span class="line">typedef ListNode * LinkList; // 自定义 LinkList 单链表类型</span><br><span class="line">LinkList CreatListR1(); //函数，用尾插入法建立带头结点的单链表</span><br><span class="line">LinkList CreatList(void); //函数，用头插入法建立带头结点的单链表</span><br><span class="line">ListNode *LocateNode(); //函数，按值查找结点</span><br><span class="line">void DeleteList(); //函数，删除指定值的结点</span><br><span class="line">void printlist(); //函数，打印链表中的所有值</span><br><span class="line">void DeleteAll(); //函数，删除所有结点，释放内存</span><br><span class="line">ListNode * AddNode(); //修改程序：增加节点。用头插法，返回头指针</span><br><span class="line">//==========主函数==============</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	char ch[10], num[5];</span><br><span class="line">	LinkList head;</span><br><span class="line">	head = CreatList(); //用头插入法建立单链表，返回头指针</span><br><span class="line">	printlist(head); //遍历链表输出其值</span><br><span class="line">	printf(&quot; Delete node (y/n):&quot;); //输入&quot;y&quot;或&quot;n&quot;去选择是否删除结点</span><br><span class="line">	scanf(&quot;%s&quot;, num);</span><br><span class="line">	if (strcmp(num, &quot;y&quot;) == 0 || strcmp(num, &quot;Y&quot;) == 0) &#123;</span><br><span class="line">		printf(&quot;Please input Delete_data:&quot;);</span><br><span class="line">		scanf(&quot;%s&quot;, ch); //输入要删除的字符串</span><br><span class="line">		DeleteList(head, ch);</span><br><span class="line">		printlist(head);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot; Add node ? (y/n):&quot;); //输入&quot;y&quot;或&quot;n&quot;去选择是否增加结点</span><br><span class="line">	scanf(&quot;%s&quot;, num);</span><br><span class="line">	if (strcmp(num, &quot;y&quot;) == 0 || strcmp(num, &quot;Y&quot;) == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		head = AddNode(head);</span><br><span class="line">	&#125;</span><br><span class="line">	printlist(head);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	DeleteAll(head); //删除所有结点，释放内存</span><br><span class="line">&#125;</span><br><span class="line">////==========用尾插入法建立带头结点的单链表===========</span><br><span class="line">//LinkList CreatListR1(void)</span><br><span class="line">//&#123;</span><br><span class="line">//	char ch[10];</span><br><span class="line">//	LinkList head = (LinkList)malloc(sizeof(ListNode)); //生成头结点</span><br><span class="line">//	ListNode *s, *r, *pp;</span><br><span class="line">//	r = head;</span><br><span class="line">//	r-&gt;next = NULL;</span><br><span class="line">//	printf(&quot;Input # to end &quot;); //输入&quot;#&quot;代表输入结束</span><br><span class="line">//	printf(&quot;\nPlease input Node_data:&quot;);</span><br><span class="line">//	scanf(&quot;%s&quot;, ch); //输入各结点的字符串</span><br><span class="line">//	while (strcmp(ch, &quot;#&quot;) != 0) &#123;</span><br><span class="line">//		pp = LocateNode(head, ch); //按值查找结点，返回结点指针</span><br><span class="line">//		if (pp == NULL) &#123; //没有重复的字符串，插入到链表中</span><br><span class="line">//			s = (ListNode *)malloc(sizeof(ListNode));</span><br><span class="line">//			strcpy(s-&gt;data, ch);</span><br><span class="line">//			r-&gt;next = s;</span><br><span class="line">//			r = s;</span><br><span class="line">//			r-&gt;next = NULL;</span><br><span class="line">//		&#125;</span><br><span class="line">//		printf(&quot;Input # to end &quot;);</span><br><span class="line">//		printf(&quot;Please input Node_data:&quot;);</span><br><span class="line">//		scanf(&quot;%s&quot;, ch);</span><br><span class="line">//	&#125;</span><br><span class="line">//	return head; //返回头指针</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//==========用头插入法建立带头结点的单链表===========</span><br><span class="line">LinkList CreatList(void)</span><br><span class="line">&#123;</span><br><span class="line">	char ch[100];</span><br><span class="line">	LinkList head, p;</span><br><span class="line">	head = (LinkList)malloc(sizeof(ListNode));//只声明一个数据空间 </span><br><span class="line">	head-&gt;next = NULL;</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Input # to end &quot;);</span><br><span class="line">		printf(&quot;Please input Node_data:&quot;);</span><br><span class="line">		scanf(&quot;%s&quot;, ch);</span><br><span class="line">		if (strcmp(ch, &quot;#&quot;))</span><br><span class="line">		&#123;</span><br><span class="line">			if (LocateNode(head, ch) == NULL)//只有一个字符串 </span><br><span class="line">			&#123;</span><br><span class="line">				strcpy(head-&gt;data, ch);</span><br><span class="line">				p = (LinkList)malloc(sizeof(ListNode));</span><br><span class="line">				p-&gt;next = head;</span><br><span class="line">				head = p;//p只是一个临时的节点，并没有存到LinkList中 </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br><span class="line">//==========按值查找结点，找到则返回该结点的位置，否则返回 NULL==========</span><br><span class="line">ListNode *LocateNode(LinkList head, char *key)</span><br><span class="line">&#123;</span><br><span class="line">	ListNode *p = head-&gt;next; //从开始结点比较</span><br><span class="line">	while (p != NULL &amp;&amp; strcmp(p-&gt;data, key) != 0) //直到 p 为 NULL 或 p-&gt;data 为 key 止</span><br><span class="line">		p = p-&gt;next; //扫描下一个结点</span><br><span class="line">	return p; //若 p=NULL 则查找失败，否则 p 指向找到的值为 key 的结点</span><br><span class="line">&#125;</span><br><span class="line">//==========修改程序：增加节点=======</span><br><span class="line">ListNode * AddNode(LinkList head)</span><br><span class="line">&#123;</span><br><span class="line">	char ch[10];int pos; int i;</span><br><span class="line">	ListNode *s, *pp,*p;</span><br><span class="line">	printf(&quot;\nPlease input Insert_data:&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;, ch); //输入各结点的字符串</span><br><span class="line">	printf(&quot;\nposition:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;pos); //c语言的scanf中一定要加&amp;，上面那个赋值给ch不用加，因为ch本身就是地质 </span><br><span class="line">	pp = LocateNode(head, ch); //按值查找结点，返回结点指针</span><br><span class="line">//	p = (ListNode *)malloc(sizeof(ListNode));</span><br><span class="line">	p=head-&gt;next;</span><br><span class="line">	</span><br><span class="line">	if (pp == NULL) &#123; //没有重复的字符串，插入到链表中</span><br><span class="line">	</span><br><span class="line">		s = (ListNode *)malloc(sizeof(ListNode));</span><br><span class="line">		</span><br><span class="line">		strcpy(s-&gt;data, ch);</span><br><span class="line">		for(i=1;i&lt;pos-1;i++)p=p-&gt;next;</span><br><span class="line">		</span><br><span class="line">		s-&gt;next = p-&gt;next;</span><br><span class="line">		p-&gt;next = s;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br><span class="line">//==========删除带头结点的单链表中的指定结点=======</span><br><span class="line">void DeleteList(LinkList head, char *key)</span><br><span class="line">&#123;</span><br><span class="line">	ListNode *p, *r, *q = head;</span><br><span class="line">	p = LocateNode(head, key); //按 key 值查找结点的</span><br><span class="line">	if (p == NULL) &#123; //若没有找到结点，退出</span><br><span class="line">		printf(&quot;position error&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	while (q-&gt;next != p) //p 为要删除的结点，q 为 p 的前结点</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	r = q-&gt;next;</span><br><span class="line">	q-&gt;next = r-&gt;next;</span><br><span class="line">	free(r); //释放结点</span><br><span class="line">&#125;</span><br><span class="line">//===========打印链表=======</span><br><span class="line">void printlist(LinkList head)</span><br><span class="line">&#123;</span><br><span class="line">	ListNode *p = head-&gt;next; //从开始结点打印</span><br><span class="line">	while (p) &#123;</span><br><span class="line">		if(p-&gt;next==NULL)printf(&quot;%s&quot;, p-&gt;data);</span><br><span class="line">		else printf(&quot;%s, &quot;, p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//==========删除所有结点，释放空间===========</span><br><span class="line">void DeleteAll(LinkList head)</span><br><span class="line">&#123;</span><br><span class="line">	ListNode *p = head, *r;</span><br><span class="line">	while (p-&gt;next) &#123;</span><br><span class="line">		r = p-&gt;next;</span><br><span class="line">		free(p);</span><br><span class="line">		p = r;</span><br><span class="line">	&#125;</span><br><span class="line">	free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*1,首先明白了头插法和尾插法的区别：头插法是从一个表开始，重复读入数据，</span><br><span class="line">生成新节点，将读入数据存放到新节点的数据域中，</span><br><span class="line">然后将新节点插入到当前链表的头结点之后，直至读入结束标志为止。</span><br><span class="line">其插入的顺序和存储的逻辑顺序相反，而尾插法相同。</span><br><span class="line">2，在按值查找这个函数中，要返回指定值的节点，</span><br><span class="line">可以这么写：while (p != NULL &amp;&amp; strcmp(p-&gt;data, key) != 0)p = p-&gt;next;</span><br><span class="line">这样的话，当程序跳出while循环之后，p就只要求的节点（p为NULL说明链表中没有该值的节点）。</span><br><span class="line">3，在打印链表的时候while（）中要写p而不是p-&gt;next,</span><br><span class="line">否则的话最后一个节点就打印不出来了；</span><br><span class="line">在删除所有节点的函数中，while函数中写的是p-&gt;next,而不是p，</span><br><span class="line">这样的话，p走到最后一个节点的时候就不会进入while循环了，</span><br><span class="line">那么在while循环外面还要写free(p)来删除最后那个节点</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="上机实验二-实验二：顺序表的基本操作"><a href="#上机实验二-实验二：顺序表的基本操作" class="headerlink" title="上机实验二 实验二：顺序表的基本操作"></a><strong>上机实验二 实验二：顺序表的基本操作</strong></h4><p>实验目的：<br>1、理解什么是顺序表；<br>2、掌握顺序表的基本操作，如建立、查找、插入和删除等。<br>实验内容：<br>定义一个包含学生信息（学号，姓名，成绩）的顺序表，使其具有如下功能：<br>(1) 根据指定学生个数，逐个输入学生信息；<br>(2) 逐个显示学生表中所有学生的相关信息；<br>(3) 根据姓名进行查找，返回此学生的学号和成绩；<br>(4) 根据指定的位置可返回相应的学生信息（学号，姓名，成绩）；<br>(5) 给定一个学生信息，插入到表中指定的位置；<br>(6) 删除指定位置的学生记录；<br>(7) 统计表中学生个数。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;malloc.h&gt;  </span><br><span class="line">#include&lt;stdlib.h&gt;  </span><br><span class="line">#include&lt;string.h&gt;  </span><br><span class="line">#define OK 1  </span><br><span class="line">#define ERROR 0  </span><br><span class="line">#define OVERFLOW -2  </span><br><span class="line">#define MAXSIZE 100  </span><br><span class="line">  </span><br><span class="line">typedef int Status; // 定义函数返回值类型  </span><br><span class="line">  </span><br><span class="line">typedef struct  </span><br><span class="line">&#123;  </span><br><span class="line">    char num[10]; // 学号  </span><br><span class="line">    char name[20]; // 姓名  </span><br><span class="line">    double grade; // 成绩   </span><br><span class="line">&#125;student;  </span><br><span class="line">  </span><br><span class="line">typedef student ElemType;  </span><br><span class="line">  </span><br><span class="line">typedef struct  </span><br><span class="line">&#123;  </span><br><span class="line">    ElemType *elem; // 存储空间的基地址   </span><br><span class="line">    int length; // 当前长度   </span><br><span class="line">&#125;SqList;  </span><br><span class="line">  </span><br><span class="line">Status InitList(SqList *L) // 构造空的顺序表 L   </span><br><span class="line">&#123;     </span><br><span class="line">    L-&gt;elem=(ElemType *)malloc(sizeof(ElemType)*MAXSIZE);  </span><br><span class="line">    if(!L-&gt;elem)  exit(OVERFLOW);  </span><br><span class="line">    L-&gt;length=0;  </span><br><span class="line">    return OK;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">ElemType GetElem(SqList &amp;L,int i) // 访问顺序表，找到 i位置，返回给 e  </span><br><span class="line">&#123;  </span><br><span class="line">    return L.elem[i];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int Search(SqList &amp;L,char str[]) // 根据名字查找，返回该同学在顺序表中的编号   </span><br><span class="line">&#123;  </span><br><span class="line">    for(int i=1;i&lt;=L.length;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(strcmp(L.elem[i].name,str)==0)  </span><br><span class="line">            return i;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">Status ListInsert(SqList &amp;L,int i,ElemType e) // 在 i位置插入某个学生的信息   </span><br><span class="line">&#123;  </span><br><span class="line">    if((i&lt;1)||(i&gt;L.length+1)) return ERROR;  </span><br><span class="line">    if(L.length==MAXSIZE)   return ERROR;  </span><br><span class="line">    for(int j=L.length;j&gt;=i;j--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        L.elem[j+1]=L.elem[j];  </span><br><span class="line">    &#125;  </span><br><span class="line">    L.elem[i]=e;  </span><br><span class="line">    ++L.length;  </span><br><span class="line">    return OK;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">Status ListDelete(SqList &amp;L,int i) // 在顺序表中删除 i位置的学生信息   </span><br><span class="line">&#123;  </span><br><span class="line">    if((i&lt;1)||(i&gt;L.length))   return ERROR;  </span><br><span class="line">    for(int j=i;j&lt;=L.length;j++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        L.elem[j]=L.elem[j+1];  </span><br><span class="line">    &#125;  </span><br><span class="line">    --L.length;  </span><br><span class="line">    return OK;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void Input(ElemType *e)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;姓名:&quot;);  scanf(&quot;%s&quot;,e-&gt;name);  </span><br><span class="line">    printf(&quot;学号:&quot;);  scanf(&quot;%s&quot;,e-&gt;num);  </span><br><span class="line">    printf(&quot;成绩:&quot;);  scanf(&quot;%lf&quot;,&amp;e-&gt;grade);  </span><br><span class="line">    printf(&quot;输入完成\n\n&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void Output(ElemType *e)  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">	printf(&quot;\t%s\t%s\t%f\n&quot;,e-&gt;name,e-&gt;num,e-&gt;grade);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    SqList L;  </span><br><span class="line">    ElemType a,b,c,d;  </span><br><span class="line">    printf(&quot;\n********************************\n\n&quot;);  </span><br><span class="line">    puts(&quot;1. 构造顺序表&quot;);   </span><br><span class="line">    puts(&quot;2. 录入学生信息&quot;);  </span><br><span class="line">    puts(&quot;3. 显示学生信息&quot;);  </span><br><span class="line">    puts(&quot;4. 输入姓名，查找该学生&quot;);  </span><br><span class="line">    puts(&quot;5. 显示某位置该学生信息&quot;);   </span><br><span class="line">    puts(&quot;6. 在指定位置插入学生信息&quot;);  </span><br><span class="line">    puts(&quot;7. 在指定位置删除学生信息&quot;);  </span><br><span class="line">    puts(&quot;8. 统计学生个数&quot;);  </span><br><span class="line">    puts(&quot;0. 退出&quot;);  </span><br><span class="line">    printf(&quot;\n********************************\n\n&quot;);  </span><br><span class="line">    int x,choose;  </span><br><span class="line">    while(1)  </span><br><span class="line">    &#123;  </span><br><span class="line">        puts(&quot;请选择:&quot;);  </span><br><span class="line">        scanf(&quot;%d&quot;,&amp;choose);  </span><br><span class="line">        if(choose==0)   break;  </span><br><span class="line">        switch(choose)  </span><br><span class="line">        &#123;  </span><br><span class="line">            case 1:  </span><br><span class="line">                    if(InitList(&amp;L))  </span><br><span class="line">                        printf(&quot;成功建立顺序表\n\n&quot;);  </span><br><span class="line">                    else  </span><br><span class="line">                        printf(&quot;顺序表建立失败\n\n&quot;);  </span><br><span class="line">                    break;  </span><br><span class="line">            case 2:  </span><br><span class="line">                    printf(&quot;请输入要录入学生的人数（小于100）:&quot;);  </span><br><span class="line">                    scanf(&quot;%d&quot;,&amp;x);  </span><br><span class="line">                    for(int i=1;i&lt;=x;i++)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        printf(&quot;第%d个学生:\n&quot;,i);  </span><br><span class="line">                        Input(&amp;L.elem[i]);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    L.length=x;  </span><br><span class="line">                    puts(&quot;&quot;);  </span><br><span class="line">                    break;  </span><br><span class="line">            case 3:  </span><br><span class="line">                    printf(&quot;\t姓名\t学号\t成绩\n&quot;);</span><br><span class="line">				    for(int i=1;i&lt;=x;i++)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        a=GetElem(L,i);  </span><br><span class="line">                        Output(&amp;a);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    break;  </span><br><span class="line">            case 4:  </span><br><span class="line">                    char s[20];  </span><br><span class="line">                    printf(&quot;请输入要查找的学生姓名:&quot;);  </span><br><span class="line">                    scanf(&quot;%s&quot;,s);  </span><br><span class="line">                    if(Search(L,s))  </span><br><span class="line">                        Output(&amp;L.elem[Search(L,s)]);  </span><br><span class="line">                    else  </span><br><span class="line">                        puts(&quot;对不起，查无此人&quot;);  </span><br><span class="line">                    puts(&quot;&quot;);  </span><br><span class="line">                    break;  </span><br><span class="line">			case 5:  </span><br><span class="line">				printf(&quot;请输入要查询的位置:&quot;);    </span><br><span class="line">				int id1;                   </span><br><span class="line">				scanf(&quot;%d&quot;,&amp;id1);  </span><br><span class="line">				if((id1&lt;1)||(id1&gt;L.length+1)) &#123;</span><br><span class="line">					puts(&quot;要查询的位置不合法&quot;);</span><br><span class="line">					continue;</span><br><span class="line">				&#125;   </span><br><span class="line">				b=GetElem(L,id1);           </span><br><span class="line">				Output(&amp;b);       </span><br><span class="line">				break;</span><br><span class="line">            case 6:  </span><br><span class="line">                    printf (&quot;请输入要插入的位置:&quot;);  </span><br><span class="line">                    int id2;  </span><br><span class="line">                    scanf(&quot;%d&quot;,&amp;id2);  </span><br><span class="line">                    printf(&quot;请输入学生信息:\n&quot;);  </span><br><span class="line">                    Input(&amp;c);  </span><br><span class="line">                    if(ListInsert(L,id2,c))  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        x++;  </span><br><span class="line">                        puts(&quot;插入成功&quot;);  </span><br><span class="line">                        puts(&quot;&quot;);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    else  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        puts(&quot;插入失败&quot;);  </span><br><span class="line">                        puts(&quot;&quot;);     </span><br><span class="line">                    &#125;  </span><br><span class="line">                    break;  </span><br><span class="line">            case 7:  </span><br><span class="line">                    printf(&quot;请输入要删除的位置:&quot;);  </span><br><span class="line">                    int id3;  </span><br><span class="line">                    scanf(&quot;%d&quot;,&amp;id3);  </span><br><span class="line">                    if(ListDelete(L,id3))  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        x--;  </span><br><span class="line">                        puts(&quot;删除成功&quot;);  </span><br><span class="line">                        puts(&quot;&quot;);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    else  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        puts(&quot;删除失败&quot;);  </span><br><span class="line">                        puts(&quot;&quot;);     </span><br><span class="line">                    &#125;  </span><br><span class="line">                    break;  </span><br><span class="line">            case 8:  </span><br><span class="line">                    printf(&quot;已录入的学生个数为:%d\n\n&quot;,L.length);  </span><br><span class="line">                    break;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;\n\n谢谢您的使用，请按任意键退出\n\n\n&quot;);  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">预习报告</span><br><span class="line">1.	按学生的姓名来查找学生信息时，声明一个sceach的函数判断一下顺序表中</span><br><span class="line">是否有该同学，如果存在，那么返回该同学在顺序表中的位置k，然后output函数返</span><br><span class="line">回第k个位置的学生信息；如果不存在，就输出信息提示没有该同学。</span><br><span class="line"></span><br><span class="line">预习报告代码：</span><br><span class="line">int Search(SqList &amp;L,char str[]) // 根据名字查找，返回该同学在顺序表中的编号   </span><br><span class="line">&#123;  </span><br><span class="line">    for(int i=1;i&lt;=L.length;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(strcmp(L.elem[i].name,str)==0)  </span><br><span class="line">            return i;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line">2.	删除的顺序应该先声明一个用来计数的变量，该变量的值从第i个元素开始，</span><br><span class="line">依次加1，直到j大于表长度，让每个变量对应存储的值向前移动，实现删除第i个元素的功能 </span><br><span class="line">实现for循环</span><br><span class="line"> for(int j=i;j&lt;=L.length;j++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        L.elem[j]=L.elem[j+1];  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">3.在指定位置插入元素，实现ListInsert函数，把顺序表，id2（要插入的位置），</span><br><span class="line">c（包含一个学生的信息的student类型的结构体变量），该函数应该判断插入的位置id2是否合法，</span><br><span class="line">然后在id2以后的所有已经存在的结构题变量往后一一个位置，</span><br><span class="line">空出要插入的位置，插入要插入的位置，表长加1。如果插入成功返回1，否则放那会0.</span><br><span class="line"></span><br><span class="line">4.要查询指定位置的学生信息时，首先把顺序表和指定位置i当作参数，实现GetElem的方法，</span><br><span class="line">让该方法返回指定位置的学生信息。</span><br><span class="line"></span><br><span class="line">实验心得</span><br><span class="line">1.	程序的健壮性是指程序能对输入的非法数据进行处理，并不会因为输入非法数据导致程序的崩溃。</span><br><span class="line">写程序要考虑程序的健壮性，比如本次实验在ListDelete这个方法中要对传进来的参数i（要插入的位置）进行判断，</span><br><span class="line">如果插入的位置小于1或者大于表长度+1，就提示输入数据有误。</span><br><span class="line">2.	为了方便阅读，书写程序要有层次的缩进，这样一眼就能看出来每个语句块的内容，方便理解 </span><br><span class="line">3.	Input函数中，那个向传过来的参数e赋值grade语句时，一定要加&amp;，因为name和num都是引用型数据，</span><br><span class="line">可以不加&amp;。</span><br><span class="line">4.	switch语句，要在每个case语句中加入break语句，否则的话，执行完一条case语句，</span><br><span class="line">就会接着执行下一跳语句。可以在if语句之后写continue和break，但满足if条件时，就执行该语句，跳过循环或者退出循环 </span><br><span class="line"></span><br><span class="line">5.	删除指定位置的元素时，该方法首先要判断删除的位置是否合法，</span><br><span class="line">然后从第i个位置到最后一个元素依次往前移动，覆盖要删除的位置，表长减1.</span><br><span class="line"></span><br><span class="line">6.	Output(&amp;a);这一条语句调用output函数要加&amp;来运行，因为原函数当中是ElemType *e当作形参的，</span><br><span class="line">那个a是student类型的，&amp;a就代表这个参数为指向student类型的地址。</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="上机实验三-栈"><a href="#上机实验三-栈" class="headerlink" title="上机实验三 栈"></a><strong>上机实验三 栈</strong></h4><p>一、实验目的<br>熟悉栈的顺序表示与实现。<br>熟悉栈的应用。<br>理解并掌握递归函数的设计与实现。<br>二、实验内容<br>1  问题描述：利用栈实现十进制数n转化为d（分别是2,8,16）进制数<br>要求：<br>输入一个n和d，打印输出d进制数序列。<br>利用顺序栈来实现十进制数n转化为其他d进制数。此时，需要同时实现初始化空栈、入栈、出栈、判栈空等辅助功能。<br>测试数据：<br>8进制：输入n:1348       输出：2504<br>2进制：输入n:1348        输出：101 0100 0100‬<br>16进制：输入n:1348        输出：544  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">#include&lt;stdlib.h&gt; </span><br><span class="line">#define STACK_INIT_SIZE 10 /* 存储空间初始分配量 */ </span><br><span class="line">#define STACK_INCREMENT 2 /* 存储空间分配增量 */ </span><br><span class="line">#define TRUE 1 </span><br><span class="line">#define FALSE 0 </span><br><span class="line">#define OK 1 </span><br><span class="line">#define ERROR 0 </span><br><span class="line">#define OVERFLOW 0 </span><br><span class="line">typedef struct SqStack &#123;</span><br><span class="line"> 	int *base; </span><br><span class="line"> 	/* 在栈构造之前和销毁之后，base 的值为 NULL */ </span><br><span class="line">	int *top; /* 栈顶指针 */ </span><br><span class="line"> 	int stacksize; /* 当前已分配的存储空间，以元素为单位 */ </span><br><span class="line"> 	//整个sqStack的大小是24，所以base，top和stacksize各为8 </span><br><span class="line"> &#125;SqStack; /* 顺序栈 */ </span><br><span class="line"> </span><br><span class="line"> void InitStack(SqStack *s) &#123; </span><br><span class="line"> /* 构造一个空栈 S */ </span><br><span class="line"> 	s-&gt;base=(int *)malloc(STACK_INIT_SIZE*sizeof(int)); </span><br><span class="line"> 	if(!s-&gt;base) exit(OVERFLOW); /* 存储分配失败 */ </span><br><span class="line">	s-&gt;top=s-&gt;base; </span><br><span class="line"> 	s-&gt;stacksize=STACK_INIT_SIZE; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> int StackEmpty(SqStack s) &#123; </span><br><span class="line"> /* 若栈 S 为空栈，则返回 TRUE，否则返回 FALSE */ </span><br><span class="line">	 if(s.top==s.base) return TRUE; </span><br><span class="line">	 else return FALSE; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> int StackLength(SqStack s) &#123; </span><br><span class="line"> </span><br><span class="line">	 /* 返回 S 的元素个数，即栈的长度 */ </span><br><span class="line"> 	return s.top-s.base; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> void Push(SqStack *s,int e) &#123; </span><br><span class="line"> /* 插入元素 e 为新的栈顶元素 */ </span><br><span class="line">	 if(s-&gt;top-s-&gt;base&gt;=s-&gt;stacksize) //这两个相等的时候重新分配内存 </span><br><span class="line"> /* 栈满，追加存储空间 */ </span><br><span class="line"> 	&#123; </span><br><span class="line"> 		s-&gt;base=(int *)realloc(s-&gt;base,(s-&gt;stacksize+STACK_INCREMENT)*sizeof(int)); </span><br><span class="line"> 		//每次开辟两个空间，下一次让top指针指向刚stacksisze的位置，然后s-&gt;top++之后也不会溢出 </span><br><span class="line">		 if(!s-&gt;base) exit(1); </span><br><span class="line"> /* 存储分配失败 */ </span><br><span class="line"> 		s-&gt;top=s-&gt;base+s-&gt;stacksize; //s-&gt;stacksize这个是原来没改变之前的那个</span><br><span class="line">		 //是为了让top指针指向刚刚大一size之后的第一个位置; </span><br><span class="line">		s-&gt;stacksize+=STACK_INCREMENT; </span><br><span class="line">	&#125; </span><br><span class="line">	*(s-&gt;top)++=e;   //这是数值和数值的赋值，*(s-&gt;top)是指向这个地址的数值 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int Pop(SqStack *s,int *e) &#123; </span><br><span class="line">/* 若栈不空，则删除 S 的栈顶元素，用 e 返回其值，并返回 OK；否则 返回 ERROR */ </span><br><span class="line">	if(s-&gt;top==s-&gt;base) return ERROR; </span><br><span class="line">	*e=*--s-&gt;top; </span><br><span class="line">	return OK;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> void conversion_16() &#123; </span><br><span class="line"> /* 对于输入的任意一个非负 10 进制整数，打印输出与其等值的 16 进制数 */ </span><br><span class="line"> 	SqStack s; int n; /* 非负整数 */ </span><br><span class="line"> 	int e; InitStack(&amp;s); /* 初始化栈 */ </span><br><span class="line"> 	printf(&quot;将 10 进制整数 n 转换为 16 进制数\n 请输入 n( &gt;0 )：&quot;); </span><br><span class="line"> 	scanf(&quot;%d&quot;,&amp;n); /* 输入非负十进制整数 n */ </span><br><span class="line"> 	while(n)&#123;/* 当 n 不等于 0 */</span><br><span class="line"> 		 Push(&amp;s,n%16); /* 入栈 n 除以 16 的余数(16 进制的低位) */ </span><br><span class="line"> 		 n=n/16; </span><br><span class="line">	  &#125; </span><br><span class="line">  	while(!StackEmpty(s)) /* 当栈不空 */ </span><br><span class="line">  	&#123; </span><br><span class="line">  		Pop(&amp;s,&amp;e); /* 弹出栈顶元素且赋值给 e */ </span><br><span class="line"> 		 if(e&lt;=9) printf(&quot;%d&quot;,e); </span><br><span class="line"> 		 else printf(&quot;%c&quot;,e+55); /* 大于 9 的余数，输出相应的字符*/ </span><br><span class="line"> 	 &#125; </span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> void conversion_8() &#123; </span><br><span class="line"> /* 对于输入的任意一个非负 10 进制整数，打印输出与其等值的 8 进制数 */ </span><br><span class="line"> 	SqStack s; int n; /* 非负整数 */ </span><br><span class="line"> 	int e; InitStack(&amp;s); /* 初始化栈 */ </span><br><span class="line"> 	printf(&quot;将 10 进制整数 n 转换为 8 进制数\n 请输入 n( &gt;0 )：&quot;); </span><br><span class="line"> 	scanf(&quot;%d&quot;,&amp;n); /* 输入非负十进制整数 n */ </span><br><span class="line"> 	while(n)&#123;/* 当 n 不等于 0 */</span><br><span class="line"> 		 Push(&amp;s,n%8); /* 入栈 n 除以 8 的余数(8 进制的低位) */ </span><br><span class="line"> 		 n=n/8; </span><br><span class="line">	  &#125; </span><br><span class="line">  	while(!StackEmpty(s)) /* 当栈不空 */ </span><br><span class="line">  	&#123; </span><br><span class="line">  		Pop(&amp;s,&amp;e); /* 弹出栈顶元素且赋值给 e */ </span><br><span class="line"> 		 printf(&quot;%d&quot;,e);</span><br><span class="line"> 	 &#125; </span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void conversion_2() &#123; </span><br><span class="line"> /* 对于输入的任意一个非负 10 进制整数，打印输出与其等值的 2进制数 */ </span><br><span class="line"> 	SqStack s; int n; /* 非负整数 */ </span><br><span class="line"> 	int e; InitStack(&amp;s); /* 初始化栈 */ </span><br><span class="line"> 	printf(&quot;将 10 进制整数 n 转换为 2 进制数\n 请输入 n( &gt;0 )：&quot;); </span><br><span class="line"> 	scanf(&quot;%d&quot;,&amp;n); /* 输入非负十进制整数 n */ </span><br><span class="line"> 	while(n)&#123;/* 当 n 不等于 0 */</span><br><span class="line"> 		 Push(&amp;s,n%2); /* 入栈 n 除以 2 的余数(2 进制的低位) */ </span><br><span class="line"> 		 n=n/2; </span><br><span class="line">	  &#125; </span><br><span class="line">  	while(!StackEmpty(s)) /* 当栈不空 */ </span><br><span class="line">  	&#123; </span><br><span class="line">  		Pop(&amp;s,&amp;e); /* 弹出栈顶元素且赋值给 e */ </span><br><span class="line"> 		 printf(&quot;%d&quot;,e);</span><br><span class="line"> 	 &#125; </span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 	 </span><br><span class="line">  int main() &#123; </span><br><span class="line">  </span><br><span class="line">  SqStack s; int n; /* 非负整数 */ </span><br><span class="line"> 	int e; InitStack(&amp;s); /* 初始化栈 */ </span><br><span class="line">// 	Push(&amp;s,3);</span><br><span class="line">// 	Push(&amp;s,4);	Push(&amp;s,4);</span><br><span class="line"> 	printf(&quot;%d&quot;,s.stacksize); //ans是10</span><br><span class="line">	 	printf(&quot;%d&quot;,sizeof(s));  //ans24</span><br><span class="line"> 	</span><br><span class="line"> 	</span><br><span class="line"> 	</span><br><span class="line"> 	</span><br><span class="line"> 	</span><br><span class="line">//  int choice;</span><br><span class="line">//   printf(&quot;%s&quot;,&quot;1.十进制转二进制\n&quot;);</span><br><span class="line">//  	  printf(&quot;%s&quot;,&quot;2.十进制转八进制\n&quot;);</span><br><span class="line">//  	  printf(&quot;%s&quot;,&quot;3.十进制转十六进制\n&quot;);</span><br><span class="line">//  while(1)&#123;</span><br><span class="line">//  	 </span><br><span class="line">//  	  printf(&quot;%s&quot;,&quot;请输入序号：&quot;);</span><br><span class="line">//	  scanf(&quot;%d&quot;,&amp;choice);</span><br><span class="line">//	  switch(choice)&#123;</span><br><span class="line">//	  	case 1: conversion_2(); break;</span><br><span class="line">//	  	case 2: conversion_8();break;</span><br><span class="line">//	  	case 3: conversion_16();break;</span><br><span class="line">//	  	default: return 0;</span><br><span class="line">//	  &#125; </span><br><span class="line">// 	 &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  /* </span><br><span class="line">  	预习报告 </span><br><span class="line">  	1.进制转换可以使用顺序栈这种数据结构，SqStack 结构包括两个int</span><br><span class="line">	类型的指针，top和base，还保存着顺序栈的存储空间的大小。</span><br><span class="line">其结构体定义如下： </span><br><span class="line">	typedef struct SqStack &#123;</span><br><span class="line"> 		int *base; </span><br><span class="line">		int *top; </span><br><span class="line"> 		int stacksize;  </span><br><span class="line"> 	&#125;SqStack; </span><br><span class="line">  		2.栈是一种只在表尾进行插入或者删除的操作的线性表，表尾</span><br><span class="line">	  叫栈顶（本题中的top指针），表头端称为栈底（本题中的base指针）；栈的修改是按照后进先出的原则</span><br><span class="line">	  进行的。本题目正好符合进制转换中先得到的余数后输出，即先得到的余数</span><br><span class="line">	  是低位，可以用栈这种数据结构来实现。 </span><br><span class="line">  	3.ASCII表中A对应的十进制数为65，9对应的十进制数为57，若对</span><br><span class="line">	  16取余的余数大于9，则可用余数+55得到其相应字母对应的10进制数</span><br><span class="line">	  然后将该十进制数转换为相应的字符，这种方法实现了10进制转换为相应的16进制数。</span><br><span class="line">	4.5.八进制转换 </span><br><span class="line"> 	 void conversion_8() &#123; </span><br><span class="line"> 	/* 对于输入的任意一个非负 10 进制整数，打印输出与其等值的 8 进制数 */ </span><br><span class="line">// 	SqStack s; int n; /* 非负整数 */ </span><br><span class="line">// 	int e; InitStack(&amp;s); /* 初始化栈 */ </span><br><span class="line">// 	printf(&quot;将 10 进制整数 n 转换为 8 进制数\n 请输入 n( &gt;0 )：&quot;); </span><br><span class="line">// 	scanf(&quot;%d&quot;,&amp;n); /* 输入非负十进制整数 n */ </span><br><span class="line">// 	while(n)&#123;/* 当 n 不等于 0 */</span><br><span class="line">// 		 Push(&amp;s,n%8); /* 入栈 n 除以 8 的余数(8 进制的低位) */ </span><br><span class="line">// 		 n=n/8; </span><br><span class="line">//	  &#125; </span><br><span class="line">//  	while(!StackEmpty(s)) /* 当栈不空 */ </span><br><span class="line">//  	&#123; </span><br><span class="line">//  		Pop(&amp;s,&amp;e); /* 弹出栈顶元素且赋值给 e */ </span><br><span class="line">// 		 printf(&quot;%d&quot;,e);</span><br><span class="line">// 	 &#125; </span><br><span class="line">//	printf(&quot;\n&quot;);</span><br><span class="line">//&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	/* </span><br><span class="line">	心得 </span><br><span class="line">		1.对于输入一个任意的非负十进制整数n，对n除以16结果为a，余数为b，</span><br><span class="line">	将余数b压入顺序栈，继续对a进行此操作，直至a为0；</span><br><span class="line">	当栈不为空时，弹出相应的数输出即可；对于16进制输出，首先判断弹出的元素e</span><br><span class="line">	是否小于9，若大于9输出（e+55）对应的字符即可 。 </span><br><span class="line">	</span><br><span class="line">	2. 根据问题的要求，利用顺序栈实现将十进制数n转换为 16,2,8进制数， </span><br><span class="line">	此时 同时要实现初始化空栈，入栈，出栈，判栈空，栈的长度等功能。</span><br><span class="line">	其中：判断栈空的条件是栈顶指针和栈底指针相等。栈的长度是 栈顶指针和栈底指针的差值</span><br><span class="line">	。</span><br><span class="line">	 </span><br><span class="line">	3.在栈顶插入元素，即入栈操作 ，首先是先判断栈是否已满，如果栈满就realloc</span><br><span class="line">	函数重新为栈分配新的空间， 初始化栈顶到没扩展之前的base+stacksize的位置 </span><br><span class="line">	</span><br><span class="line">  */</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="上机实验四-实验题目：循环队列基本操作-循环队列基本操作"><a href="#上机实验四-实验题目：循环队列基本操作-循环队列基本操作" class="headerlink" title="上机实验四  实验题目：循环队列基本操作 循环队列基本操作"></a><strong>上机实验四  实验题目：循环队列基本操作 循环队列基本操作</strong></h4><p>【 实验目的 】<br>1、 掌握用 VC 工具上机调试循环队列的基本方法；<br>2、 掌握循环队列的基本操作，循环队列初始化、入队、出队、判断队空、判断队满<br>以及求队列长度操作；<br>3、 掌握队列的先进先出运算规则及其在病人看病模拟程序中的应用，理解队列在运算过程<br>中状态的变化。<br>【 实验要求 】  </p>
<ol>
<li>循环队列的初始化、入队、出队、判断是否为空、求队列长度及队列输出操作的实现；  </li>
<li>编写程序模拟实现病人看病排队。<br>【 需求分析 】<br>1、 程序应该达到的功能：<br>在病人排队看医生的过程中，主要重复两件事：<br>（1） 病人到达诊室，将病历本交给护士，排到等待队列中候诊；<br>（2） 护士从等待队列中取出下一位病人的病历，该病人进入诊室就诊。<br>要求程序能够模拟病人等待就诊这一过程，因此程序应采取菜单方式，且各选项的功能<br>如下：<br>（1） 排队——输入排队病人的病历号，加入病人排队队列中；<br>（2） 就诊——病人排队队列中最前面的病人就诊，并将其从队列中删除；<br>（3） 查看队列——从队首到队尾依次列出所有的排队病人的病历号；<br>（4） 不再接受排队，队列中现有病人依次就诊。<br>（5） 下班——退出系统。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef int ElementType;</span><br><span class="line">#define MaxSize 5</span><br><span class="line">// 队列结构体定义</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	ElementType patient[MaxSize];</span><br><span class="line">	int front, rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line">// 排队(入队)</span><br><span class="line">void AddQ(Queue *PtrQ) &#123;</span><br><span class="line">	int flag = 0, i, item;</span><br><span class="line">	i = PtrQ-&gt;front;//第一次加的时候，i指向front初始值为0 </span><br><span class="line">	if( (PtrQ-&gt;rear+1)%MaxSize == PtrQ-&gt;front ) &#123;//判断队满了没有 </span><br><span class="line">		printf(&quot; &gt;&gt;排队人数已超出范围, 请先诊断病人.\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	do &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;item);</span><br><span class="line">		while((i++)%MaxSize != PtrQ-&gt;rear ) &#123;</span><br><span class="line">			//如果只有两个的话，++i之后就会直接不运行下面这个while了 </span><br><span class="line">		//这地方不能改为++i，为什么呀，font队头本身就不用判断呀，因为有时候要 </span><br><span class="line">			if(item == PtrQ-&gt;patient[i%MaxSize]) &#123;//i修改为i%MaxSize，因为i++之后有可能会跳过一些数 </span><br><span class="line">				</span><br><span class="line">				flag = 1;</span><br><span class="line">				break;</span><br><span class="line">			&#125; else</span><br><span class="line">				flag = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		if( flag == 1 ) &#123;</span><br><span class="line">			printf(&quot; &gt;&gt;病历号重复, 请重新输入:&quot;);</span><br><span class="line">			i = PtrQ-&gt;front;//重新跟新一下i，新加上的 </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; while( flag );</span><br><span class="line">	PtrQ-&gt;rear = (PtrQ-&gt;rear+1) % MaxSize;</span><br><span class="line">	PtrQ-&gt;patient[PtrQ-&gt;rear] = item;//没与下一行调换顺序 ，为了让在0的位置存一下数据 ？？ </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">// 就诊(出队)</span><br><span class="line">void Treatment(Queue *PtrQ) &#123;</span><br><span class="line">	int patient;</span><br><span class="line">	if( PtrQ-&gt;front == PtrQ-&gt;rear ) &#123;//不要+1 ，相等就是队满了 </span><br><span class="line">		printf(&quot; &gt;&gt;没人在排队看病.\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		</span><br><span class="line">		 </span><br><span class="line">		PtrQ-&gt;front = (PtrQ-&gt;front+1) % MaxSize;</span><br><span class="line">		patient = PtrQ-&gt;patient[PtrQ-&gt;front];</span><br><span class="line">		printf(&quot; &gt;&gt;病人%d 就诊\n&quot;, patient);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 查看排队情况(遍历循环队列)</span><br><span class="line">void print(Queue *PtrQ) &#123;</span><br><span class="line">	int i = PtrQ-&gt;front;//头部指向数据的前一个没有数据的节点 </span><br><span class="line">	if( PtrQ-&gt;front == PtrQ-&gt;rear ) &#123;</span><br><span class="line">		printf(&quot; &gt;&gt;没有人在排队.\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		printf(&quot; &gt;&gt;排队的人有:&quot;);</span><br><span class="line">		while( (i % MaxSize) != PtrQ-&gt;rear) &#123;</span><br><span class="line">		//while中i修改为(i % MaxSize)  </span><br><span class="line">		//如果i是队尾了，就不用输出了，因为队尾在上一次就已经输出来了 </span><br><span class="line">			printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]);//i+1修改为 (i+1)%MaxSize</span><br><span class="line">			//最开始的时候从下标为1的头开始读取 </span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">// 余下依次就诊，不再排队(遍历队列)</span><br><span class="line">void NoMoreQueue(Queue *PtrQ) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	if(PtrQ-&gt;front == PtrQ-&gt;rear) &#123;</span><br><span class="line">		printf(&quot; &gt;&gt;没有排队的人.\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		i = PtrQ-&gt;front;</span><br><span class="line">		printf(&quot; &gt;&gt;病人按以下顺序就诊:&quot;);</span><br><span class="line">		while( i%MaxSize != PtrQ-&gt;rear ) &#123;</span><br><span class="line">			printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]);</span><br><span class="line">			//第一次就输出队头的下一个元素 ，i+1修改为 (i+1)%MaxSize </span><br><span class="line">			</span><br><span class="line">			i++;</span><br><span class="line">			PtrQ-&gt;front = (PtrQ-&gt;front+1) % MaxSize;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int flag = 1, sel;</span><br><span class="line">	Queue *p;</span><br><span class="line">	p = (Queue *)malloc(sizeof(Queue));</span><br><span class="line">	p-&gt;front = 0;</span><br><span class="line">	p-&gt;rear = 0;</span><br><span class="line">	while( flag ) &#123;</span><br><span class="line">		printf(&quot;1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:&quot;);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;sel);</span><br><span class="line">		switch( sel ) &#123;</span><br><span class="line">			case 1 :</span><br><span class="line">				printf(&quot; &gt;&gt;请输入病历号:&quot;);</span><br><span class="line">				AddQ( p );</span><br><span class="line">				break;</span><br><span class="line">			case 2 :</span><br><span class="line">				Treatment( p );</span><br><span class="line">				break;</span><br><span class="line">			case 3 :</span><br><span class="line">				print( p );</span><br><span class="line">				break;</span><br><span class="line">			case 4 :</span><br><span class="line">				NoMoreQueue( p );</span><br><span class="line">				break;</span><br><span class="line">			case 5 :</span><br><span class="line">				if(p-&gt;front != p-&gt;rear )</span><br><span class="line">					printf(&quot; &gt;&gt;请排队的病人明天就医!现在要下班了\n&quot;);</span><br><span class="line">				else</span><br><span class="line">					printf(&quot; &gt;&gt;已经没有排队的病人,现在准备下班!\n&quot;);</span><br><span class="line">				flag = 0;</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*1:</span><br><span class="line"></span><br><span class="line">bug1:那个不再排队直接一次就诊之后还要不要能看那个查看排队</span><br><span class="line">bug2：为什么在排队时第一次输入一个重复的病历单后，之后输入</span><br><span class="line">不同的病历单也会出现病历单重复的信息，而且程序会直接会崩 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 预习报告：</span><br><span class="line"> 1.余下的一次就诊的方法设计思路：首先是判断一下队列的头指针和尾指针是否相同，相同的话队列</span><br><span class="line">为空，就显示没有正在排队的人，否则，声明一个临时变量i，让它指向队列的头部， printf(&quot;%d &quot;, PtrQ-&gt;patient[i+1]);</span><br><span class="line">因为i+1 有可能比5要大，不对 MaxSize取模的话就会出现显示未知数据的情况，所以应该这样写:printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]);</span><br><span class="line"> 并且应该在i++之后写PtrQ-&gt;front = (PtrQ-&gt;front+1) % MaxSize;，这样的话每一个病人就诊完后，头指针+1(将该病人从队列中删除)，</span><br><span class="line"> 这样的话选择4之后就还可以选择1，再添加病人。 </span><br><span class="line"> </span><br><span class="line"> 2. 入队操作的设计思路，应该先判断队列是否已满，已满的话就提示信息；否则获取要排队的</span><br><span class="line"> 序号，与此同时对队列中已有的序号与输入的序号进行比较，如果相同就提示再次输入</span><br><span class="line"> ，然后队列尾指针向后移动一位，在尾指针处存入相应的数据，头部指针是不存储数据的。</span><br><span class="line"> </span><br><span class="line"> 实验心得： </span><br><span class="line">1. 在AddQ方法中判断输入的序号是否出现时，while(i++!=PtrQ-&gt;rear) </span><br><span class="line">该条语句应该改为 while((i++)%MaxSize != PtrQ-&gt;rear )</span><br><span class="line">并且本条语句if(item == PtrQ-&gt;patient[i]) 也应该 改为if(item == PtrQ-&gt;patient[i%MaxSize]) </span><br><span class="line">否则会因为在while语句中i++后i的值比原来增加1，少比较一些值，会出现在队列中加入</span><br><span class="line">与原来相同的序号</span><br><span class="line">2.在NoMoreQueue方法中，printf(&quot;%d &quot;, PtrQ-&gt;patient[i+1]);也会出现显示相同序号的问题，</span><br><span class="line">printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]);</span><br><span class="line">	同样在print方法中， printf(&quot;%d &quot;, PtrQ-&gt;patient[i+1]);该条语句的后果可能会出现</span><br><span class="line">	两个相同的序号，但是在选择2挨个就诊的时候并不会出现两个相同的序号 ，所以该条语句应改为</span><br><span class="line">printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">实验结果	</span><br><span class="line">	1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1</span><br><span class="line"> &gt;&gt;请输入病历号:1</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1</span><br><span class="line"> &gt;&gt;请输入病历号:2</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1</span><br><span class="line"> &gt;&gt;请输入病历号:3</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1</span><br><span class="line"> &gt;&gt;请输入病历号:4</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:3</span><br><span class="line"> &gt;&gt;排队的人有:1 2 3 4</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:2</span><br><span class="line"> &gt;&gt;病人1 就诊</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:2</span><br><span class="line"> &gt;&gt;病人2 就诊</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1</span><br><span class="line"> &gt;&gt;请输入病历号:1</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:4</span><br><span class="line"> &gt;&gt;病人按以下顺序就诊:3 4 1</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:5</span><br><span class="line"> &gt;&gt;已经没有排队的病人,现在准备下班!</span><br><span class="line"></span><br><span class="line"> */ </span><br></pre></td></tr></table></figure>

<h4 id="上机实验五-二叉树"><a href="#上机实验五-二叉树" class="headerlink" title="上机实验五  二叉树"></a><strong>上机实验五  二叉树</strong></h4><p>一、实验目的<br>　　　1．掌握二叉树树的结构及非线性特点，递归特点和动态性。<br>　　　2．巩固对指针的使用和二叉树的三种遍历方法、建立方法。<br>二、实验内容<br>　　　二叉树的实现和运算    </p>
<p>预习报告：    </p>
<ol>
<li><p>首先是树的节点的声明<br>typedef struct BitNode {<br> &#x2F;&#x2F;节点存放char类型的数据<br> char data;<br> &#x2F;&#x2F;声明两个节点类型的左指针和右指针<br> struct BitNode *lchild,*rchild;<br>}*BitTree;  </p>
</li>
<li><p>先序建立二叉树BinTreeCreat的方法，首先本算法要在叶子结点下<br>输入#来代表下面没有节点了，所以先获取输入节点的值，如果该节点<br>的值为#，那么该节点的子树为空，如果该节点的值不为#，那么<br>递归的建立左子树右子树。</p>
</li>
<li><p>先序遍历二叉树BinTraverse方法，首先应该判断输入的树是否为<br>不为空就输出该节点的值，递归的输出左子树和右子树的值  </p>
</li>
<li><p>求二叉树的深度BinTreeDepth函数的设计思路为：首先声明一个<br>int类型的变量depthval，判断二叉树是否为空，不为空就<br>递归的调用该方法求左子树右子树的深度，求完的时候还要<br>在 depthLeft和depthRight中求最大值还要+1，该结果就是<br>二叉树的深度。   </p>
</li>
<li><p>求二叉树中所有结点数的BinTreeCount方法，首先要声明int<br>类型的变量node，和求二叉树的深度的函数的设计方法相似，<br>判断二叉树是否为空，不为空就递归的调用该方法求左子树右<br>子树的节点，最后总的节点数为左子树+右子树+1。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">实验代码：</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef char DataType;</span><br><span class="line">typedef struct BitNode &#123;</span><br><span class="line">	DataType data;</span><br><span class="line">	struct BitNode *lchild,*rchild;</span><br><span class="line">&#125;*BitTree;</span><br><span class="line">void BinTreeInit(BitTree &amp;BT) &#123; // 初始化二叉树，即把树根指针置空</span><br><span class="line">	BT=(BitTree)malloc(sizeof(BitNode));</span><br><span class="line">	BT-&gt;data=NULL;</span><br><span class="line">	cout&lt;&lt;&quot; 二叉树初始化成功 !&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int BinTreeCreat(BitTree &amp;BT) &#123; // 按先序次序建立一个二叉树</span><br><span class="line">	char ch;</span><br><span class="line">	cin&gt;&gt;ch;</span><br><span class="line">	if(ch==&#x27;#&#x27;) BT=NULL;</span><br><span class="line">	else &#123;</span><br><span class="line">		if(!(BT=(BitTree)malloc(sizeof(BitNode))))</span><br><span class="line">			exit(0);</span><br><span class="line">		BT-&gt;data=ch;</span><br><span class="line">		BinTreeCreat(BT-&gt;lchild);</span><br><span class="line">		BinTreeCreat(BT-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">void BinTreeEmpty(BitTree &amp;BT) &#123; // 检查二叉树是否为空</span><br><span class="line">	if(BT-&gt;data==NULL)</span><br><span class="line">		cout&lt;&lt;&quot; 是空二叉树 !&quot;&lt;&lt;endl;</span><br><span class="line">	else</span><br><span class="line">		cout&lt;&lt;&quot; 不是空二叉树 !&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void BinTraverse(BitTree &amp;BT) &#123; // 先序序列遍历二叉树</span><br><span class="line">	if(BT!=NULL) &#123;</span><br><span class="line">		cout&lt;&lt;BT-&gt;data;</span><br><span class="line">		BinTraverse(BT-&gt;lchild);</span><br><span class="line">		BinTraverse(BT-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int BinTreeDepth(BitTree BT) &#123; // 求二叉树的深度</span><br><span class="line">	int depthval;</span><br><span class="line">	if(BT)&#123;</span><br><span class="line">		int depthLeft=BinTreeDepth(BT-&gt;lchild);</span><br><span class="line">		int depthRight=BinTreeDepth(BT-&gt;rchild);</span><br><span class="line">		depthval = 1+(depthLeft&gt;depthRight?depthLeft:depthRight);</span><br><span class="line">	&#125; else depthval=0;</span><br><span class="line">	return depthval;</span><br><span class="line">&#125;</span><br><span class="line">int BinTreeCount(BitTree BT) &#123; // 求二叉树中所有结点数</span><br><span class="line">	int node;</span><br><span class="line">	if(BT) &#123;</span><br><span class="line">		int lchild=BinTreeCount(BT-&gt;lchild);</span><br><span class="line">		int rchild=BinTreeCount(BT-&gt;rchild);</span><br><span class="line">		node=lchild+rchild+1;</span><br><span class="line">	&#125; else node= 0;</span><br><span class="line">	return node;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int i;</span><br><span class="line">	BitTree BT;</span><br><span class="line">	cout&lt;&lt;&quot;1 、初始化二叉树 :&quot;&lt;&lt;&quot;\n2 、按先序序列建立二叉树 &quot;&lt;&lt;&quot;\n3 、判断二叉树是否为空 :&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;\n4 、先序序列遍历二叉树 &quot;&lt;&lt;&quot;\n5 、求二叉树的深度 &quot;&lt;&lt;&quot;\n6 、求二叉树节点的个数 &quot;&lt;&lt;endl;</span><br><span class="line">	for(;;) &#123;</span><br><span class="line">		cout&lt;&lt;&quot; 输出你所需的操作 :&quot;;</span><br><span class="line">		cin&gt;&gt;i;</span><br><span class="line">		if(i==1)</span><br><span class="line">			BinTreeInit(BT);</span><br><span class="line">		else if(i==2) &#123;</span><br><span class="line">			cout&lt;&lt;&quot; 输入你要建立的二叉树 :&quot;&lt;&lt;endl;</span><br><span class="line">			BinTreeCreat(BT);</span><br><span class="line">		&#125; else if(i==3)</span><br><span class="line">			BinTreeEmpty(BT);</span><br><span class="line">		else if(i==4)</span><br><span class="line">			BinTraverse(BT);</span><br><span class="line">		else if(i==5)</span><br><span class="line">			cout&lt;&lt;&quot; 二叉树的深度 :&quot;&lt;&lt;BinTreeDepth(BT)&lt;&lt;endl;</span><br><span class="line">		else if(i==6)</span><br><span class="line">			cout&lt;&lt;&quot; 二叉树的节点数 &quot;&lt;&lt;BinTreeCount(BT)&lt;&lt;endl;</span><br><span class="line">		else</span><br><span class="line">			return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">实验结果：</span><br><span class="line">1 、初始化二叉树 :</span><br><span class="line">2 、按先序序列建立二叉树</span><br><span class="line">3 、判断二叉树是否为空 :</span><br><span class="line">4 、先序序列遍历二叉树</span><br><span class="line">5 、求二叉树的深度</span><br><span class="line">6 、求二叉树节点的个数</span><br><span class="line"> 输出你所需的操作 :1</span><br><span class="line"> 二叉树初始化成功 !</span><br><span class="line"> 输出你所需的操作 :2</span><br><span class="line"> 输入你要建立的二叉树 :</span><br><span class="line">1 2 4 # # 5 # # 3 # 6 # #</span><br><span class="line"> 输出你所需的操作 :3</span><br><span class="line"> 不是空二叉树 !</span><br><span class="line"> 输出你所需的操作 :4</span><br><span class="line">124536 输出你所需的操作 :5</span><br><span class="line"> 二叉树的深度 :3</span><br><span class="line"> 输出你所需的操作 :6</span><br><span class="line"> 二叉树的节点数 6 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="上机实验六-实验题目-：-图的-存储与遍历"><a href="#上机实验六-实验题目-：-图的-存储与遍历" class="headerlink" title="上机实验六 实验题目 ： 图的 存储与遍历"></a><strong>上机实验六 实验题目 ： 图的 存储与遍历</strong></h4><p>实验目的 ：<br>掌握有向图和无向图的概念；掌握邻接矩阵和邻接链表建立图的存储结构；掌握 DFS 及<br>BFS 对图的遍历操作。<br>实验要求：<br>采用邻接矩阵作为图的存储结构，完成有向图和无向图的 DFS 和 BFS 操作。<br>实验主要步骤：<br>设计一个有向图和一个无向图，任选一种存储结构，完成有向图和无向图的 DFS（深度优<br>先遍历）和 BFS（广度优先遍历）的操作。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line">#define MaxVertexNum 100</span><br><span class="line">//定义最大顶点数</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	char vexs[MaxVertexNum];</span><br><span class="line">	//顶点表</span><br><span class="line">	int edges[MaxVertexNum][MaxVertexNum];</span><br><span class="line">	//邻接矩阵，可看作边表</span><br><span class="line">	int n,e;</span><br><span class="line">	//图中的顶点数 n 和边数 e</span><br><span class="line"></span><br><span class="line">&#125; MGraph;</span><br><span class="line"></span><br><span class="line">//用邻接矩阵表示的图的类型</span><br><span class="line">//=========建立邻接矩阵=======</span><br><span class="line">void CreatMGraph(MGraph *G) &#123;</span><br><span class="line">	int i,j,k;</span><br><span class="line">	char a;</span><br><span class="line">	printf(&quot;Input VertexNum(n) and EdgesNum(e): &quot;);</span><br><span class="line">	scanf(&quot;%d,%d&quot;,&amp;G-&gt;n,&amp;G-&gt;e);</span><br><span class="line">	//输入顶点数和边数</span><br><span class="line">	scanf(&quot;%c&quot;,&amp;a);</span><br><span class="line"></span><br><span class="line">	printf(&quot;Input Vertex string:&quot;);</span><br><span class="line"></span><br><span class="line">	for(i=0; i&lt;G-&gt;n; i++)         &#123;</span><br><span class="line">		scanf(&quot;%c&quot;,&amp;a);</span><br><span class="line">		G-&gt;vexs[i]=a;</span><br><span class="line">		//读入顶点信息，建立顶点表</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	for(i=0; i&lt;G-&gt;n; i++)</span><br><span class="line">		for(j=0; j&lt;G-&gt;n; j++)</span><br><span class="line">			G-&gt;edges[i][j]=0;</span><br><span class="line">	//初始化邻接矩阵</span><br><span class="line">	printf(&quot;Input edges,Creat Adjacency Matrix\n&quot;);</span><br><span class="line">	for(k=0; k&lt;G-&gt;e; k++) &#123;</span><br><span class="line">		//读入 e 条边，建立邻接矩阵</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;i,&amp;j);</span><br><span class="line">		//输入边（Vi，Vj）的顶点序号</span><br><span class="line">		G-&gt;edges[i][j]=1;</span><br><span class="line"></span><br><span class="line">		G-&gt;edges[j][i]=1;</span><br><span class="line">		//若为无向图，矩阵为对称矩阵；若建立有向图，去掉该条语句</span><br><span class="line">	&#125;</span><br><span class="line">&#125; //=========定义标志向量，为全局变量=======</span><br><span class="line">typedef enum &#123;FALSE,TRUE&#125; Boolean;</span><br><span class="line"></span><br><span class="line">Boolean visited[MaxVertexNum];</span><br><span class="line">//========DFS：深度优先遍历的递归算法======</span><br><span class="line">void DFSM(MGraph *G,int i) &#123;</span><br><span class="line">//以 Vi 为出发点对邻接矩阵表示的图 G 进行 DFS 搜索，邻接矩阵是 0，1 矩阵</span><br><span class="line">	int j;</span><br><span class="line">	printf(&quot;%c&quot;,G-&gt;vexs[i]);</span><br><span class="line">	//访问顶点 Vi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	visited[i]=TRUE;</span><br><span class="line">	//置已访问标志</span><br><span class="line">	for(j=0; j&lt;G-&gt;n; j++)</span><br><span class="line">		//依次搜索 Vi 的邻接点</span><br><span class="line">		if(G-&gt;edges[i][j]==1 &amp;&amp; ! visited[j])      DFSM(G,j);</span><br><span class="line">	//（Vi，Vj）∈E，且 Vj 未访问过，故 Vj 为新出发点</span><br><span class="line">&#125;</span><br><span class="line">void DFS(MGraph *G) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=0; i&lt;G-&gt;n; i++)</span><br><span class="line">		visited[i]=FALSE;</span><br><span class="line">	//标志向量初始化</span><br><span class="line">	for(i=0; i&lt;G-&gt;n; i++)  if(!visited[i])</span><br><span class="line">			//Vi 未访问过</span><br><span class="line"></span><br><span class="line">			DFSM(G,i);</span><br><span class="line">	//以 Vi 为源点开始 DFS 搜索</span><br><span class="line">&#125;</span><br><span class="line">//===========BFS：广度优先遍历=======</span><br><span class="line">void BFS(MGraph *G,int k) &#123;</span><br><span class="line">	//以 Vk 为源点对用邻接矩阵表示的图 G 进行广度优先搜索</span><br><span class="line">	int i,j,f=0,r=0;</span><br><span class="line">	int cq[MaxVertexNum];</span><br><span class="line">	//定义队列</span><br><span class="line"></span><br><span class="line">	for(i=0; i&lt;G-&gt;n; i++)  visited[i]=FALSE;</span><br><span class="line">	//标志向量初始化</span><br><span class="line"></span><br><span class="line">	for(i=0; i&lt;G-&gt;n; i++)  cq[i]=-1;</span><br><span class="line">	//队列初始化</span><br><span class="line">	printf(&quot;%c&quot;,G-&gt;vexs[k]);</span><br><span class="line">	//访问源点 Vk</span><br><span class="line">	visited[k]=TRUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cq[r]=k;</span><br><span class="line">	//Vk 已访问，将其入队。注意，实际上是将其序号入队</span><br><span class="line">	while(cq[f]!=-1) &#123;</span><br><span class="line">		//队非空则执行</span><br><span class="line">		i=cq[f];</span><br><span class="line">		f=f+1;             //Vf 出队</span><br><span class="line">		for(j=0; j&lt;G-&gt;n; j++)       //依次 Vi 的邻接点 Vj</span><br><span class="line">			if(G-&gt;edges[i][j]==1 &amp;&amp; !visited[j]) &#123;  //Vj 未访问</span><br><span class="line">				printf(&quot;%c&quot;,G-&gt;vexs[j]);         //访问 Vj</span><br><span class="line">				visited[j]=TRUE;</span><br><span class="line">				r=r+1;</span><br><span class="line">				cq[r]=j;</span><br><span class="line">				//访问过 Vj 入队</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; //==========main=====</span><br><span class="line">int main() &#123;</span><br><span class="line">	int i;</span><br><span class="line">	MGraph *G;</span><br><span class="line">	G=(MGraph *)malloc(sizeof(MGraph));</span><br><span class="line">	//为图 G 申请内存空间</span><br><span class="line"></span><br><span class="line">	CreatMGraph(G);</span><br><span class="line">	//建立邻接矩阵</span><br><span class="line">	printf(&quot;Print Graph DFS: &quot;);</span><br><span class="line">	DFS(G);</span><br><span class="line">	//深度优先遍历</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;Print Graph BFS: &quot;);</span><br><span class="line">	BFS(G,3);</span><br><span class="line">	//以序号为 3 的顶点开始广度优先遍历</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* </span><br><span class="line">实验结果： </span><br><span class="line">Input VertexNum(n) and EdgesNum(e): 8,9</span><br><span class="line">Input Vertex string:01234567</span><br><span class="line">Input edges,Creat Adjacency Matrix</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">4 7</span><br><span class="line">5 6</span><br><span class="line">Print Graph DFS: 01374256</span><br><span class="line">Print Graph BFS: 31704256</span><br><span class="line"> </span><br><span class="line"> 预习报告：</span><br><span class="line"> 	1,在树形结构中，数据元素之间有着明显的层次关系，并且每一层</span><br><span class="line">	 中和上一层中的元素可能和下一层中的多个元素相关；而在图的</span><br><span class="line">	 结构中，节点之间的关系可以是任意的，图中任意两个数据元素之间</span><br><span class="line">	 都有可能相关。</span><br><span class="line">	2. 关于图的一些基本术语，邻接点：对于无向图G，如果图的边(v,v&#x27;)</span><br><span class="line">	 属于E，那么顶点v,v&#x27;互为邻接点。</span><br><span class="line">	 路径：从一个顶点到另一个顶点的顶点序列叫做路径。</span><br><span class="line">	 路径长度：是一条路径上经过的边或弧的数目。</span><br><span class="line">	 连通：在无向图中，两个顶点之间存在路径，就说这两个顶点是连通的。</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">实验心得：</span><br><span class="line">	1.深度优先搜索遍历类似于数的先序遍历，是树的先序遍历的推广。	  </span><br><span class="line">	本实验中：首先进行标志向量初始化，对没有访问过的节点进行</span><br><span class="line">	DFS搜索，对于顶点vi进行搜索时，先输出本节点的值，在输出与本节点</span><br><span class="line">	的邻接点。这样就对整个图进行了搜索。</span><br><span class="line">	2.广度优先搜索遍历类似于数的按层次遍历的过程，设x和y是来给你个相继</span><br><span class="line">	被访问的顶点，若当前是以x为出发点进行搜索，则在访问x的所有未曾访问</span><br><span class="line">	过的领节点之后，紧接着是以y为出发点进行横向搜索；</span><br><span class="line">	3.本此实验中用到的是邻接矩阵，骑士表示是顶点之间相邻关系的矩阵，</span><br><span class="line">	用他表示图，可以很容易的通过邻接矩阵的值来判断两个顶点之间是否有边</span><br><span class="line">	也很容易的计算各个顶点的度。 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="上机实验七-题目：-顺序查找与二分查找"><a href="#上机实验七-题目：-顺序查找与二分查找" class="headerlink" title="上机实验七 题目： 顺序查找与二分查找"></a>上机实验七 题目： 顺序查找与二分查找</h4><p>【 实验目的 】<br>本次实习的主要目的在于熟悉顺序表和有序表的查找方法和特点。其中以熟悉各种顺序表的<br>操作为侧重点。通过本次实习还可帮助读者复习高级语言的使用方法。<br>【实验要求】<br>【问题描述】<br>①建立一个查找表，使用顺序查找算法对其元素进行查找，并输出查找时比较的元素和最<br>终的比较的次数。如果没有找到，则把该元素插入到该查找表中。<br>②建立一个有序查找表，使用二分查找算法对其元素进行查找，并输出查找时比较的元素<br>和最终的比较的次数；如果没有找到，则把该元素插入到该查找表中。<br>【基本要求】<br>查找过程中，同时输出查找时比较的元素和最终的比较的次数，当没有找到元素时输出<br>“没有此元素”，然后把该元素插入到该查找表中；否则输出此元素在查找表中的位置。<br>【测试数据】<br>1、查找表中的元素{1，5，7，2，8，9，6，0，4，3}，查找元素为 8，查找元素 10。<br>2、查找表中的元素{0，1，2，3，4，5，6，7，8，9}，查找元素为 8，查找元素 10。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;process.h&gt; 		// exit()函数包含在此头文件中 </span><br><span class="line">#define LIST_INIT_SIZE 100 // 初始化大小</span><br><span class="line">#define LISTINCREMENT 15</span><br><span class="line">#define EQ(a,b) ((a)==(b))</span><br><span class="line">#define LT(a,b) ((a)&lt;(b))</span><br><span class="line">#define LQ(a,b) ((a)&lt;=(b))</span><br><span class="line">#define MT(a,b) ((a)&gt;(b))</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define OVERFLOW 0</span><br><span class="line">typedef int ElemType;	 // 基本(元素)类型</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	ElemType * elem;</span><br><span class="line">	int length;</span><br><span class="line">	int listsize;</span><br><span class="line">&#125; SSTable;</span><br><span class="line">int InitTable(SSTable *L)</span><br><span class="line">// 操作结果：构造一个空的顺序线性表</span><br><span class="line">&#123;</span><br><span class="line">	(*L).elem=(ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType));</span><br><span class="line">	if(!(*L).elem) // 存储分配失败</span><br><span class="line">		exit(OVERFLOW);</span><br><span class="line">	(*L).length=0; // 空表长度为 0</span><br><span class="line">	(*L).listsize=LIST_INIT_SIZE; // 初始存储容量</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line">int TableInsert(SSTable *L,int i,ElemType e)</span><br><span class="line">// 初始条件：顺序线性表 L 已存在，1≤i≤ListLength(L)+1 。操作结果：在 L 中第 i 个位置</span><br><span class="line">//之前插入新的数据元素 e，L 的长度加 1</span><br><span class="line">&#123;</span><br><span class="line">	ElemType *newbase,*q,*p;</span><br><span class="line">	if(i&lt;1||i&gt;(*L).length+1) // i 值不合法</span><br><span class="line">		return ERROR;</span><br><span class="line">	if((*L).length&gt;=(*L).listsize) &#123; // 当前存储空间已满，增加分配</span><br><span class="line">		newbase=(ElemType</span><br><span class="line">		         *)realloc((*L).elem,((*L).listsize+LISTINCREMENT)*sizeof(ElemType));</span><br><span class="line">		if(!newbase) // 存储分配失败</span><br><span class="line">			exit(OVERFLOW);</span><br><span class="line">		(*L).elem=newbase; // 新基址</span><br><span class="line">		(*L).listsize+=LISTINCREMENT; // 增加存储容量</span><br><span class="line">	&#125;</span><br><span class="line">	q=(*L).elem+i-1; // q 为插入位置</span><br><span class="line">	for(p=(*L).elem+(*L).length-1; p&gt;=q; --p) // 插入位置及之后的元素右移</span><br><span class="line">		*(p+1)=*p;</span><br><span class="line">	*q=e; // 插入 e</span><br><span class="line">	++(*L).length; // 表长增 1</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line">int Search_Seq(SSTable ST,ElemType key) &#123;</span><br><span class="line">//在顺序表 ST 中顺序查找其关键字等于 key 的数据元素。若找到，则函数值为该元素</span><br><span class="line">	//在表中的位置，否则为 0。</span><br><span class="line">	int i,j,k=0;</span><br><span class="line">	for(i=ST.length-1; !EQ(ST.elem[i],key)&amp;&amp;i&gt;=0; --i) &#123; //从后往前找，因为啥？？不从头忘后找呀</span><br><span class="line">		k++;</span><br><span class="line">		printf(&quot;比较的元素为：%d\n&quot;,ST.elem[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	if(!EQ(ST.elem[i],key)) &#123;</span><br><span class="line">		//这句话就是在for循环比较完了之后在判断</span><br><span class="line">		//一下，如果表中没有这个key就添加进去，</span><br><span class="line">		//否则就输出比较的次数</span><br><span class="line">		printf(&quot;查找该元素，比较的次数为：%d\n&quot;,k);</span><br><span class="line">		j=TableInsert(&amp;ST,ST.length+1,key);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		k++;</span><br><span class="line">		printf(&quot;比较的元素为：%d\n&quot;,ST.elem[i]);</span><br><span class="line">		printf(&quot;查找该元素，比较的次数为：%d\n&quot;,k);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int Search_Bin(SSTable ST,ElemType key) &#123;</span><br><span class="line">//在有序表 ST 中折半查找其他关键字等于 key 的数据元素。若找到，则函数值为该元</span><br><span class="line">	//素在表中的位置，否则为 0。</span><br><span class="line">	int low,high,mid,j,k=0;</span><br><span class="line">	low=0;</span><br><span class="line">	high=ST.length-1; //置区间初值</span><br><span class="line">	while(low&lt;=high) &#123;</span><br><span class="line">		mid=(low+high)/2;</span><br><span class="line">		if(EQ(key,ST.elem[mid])) &#123;</span><br><span class="line">			k++;</span><br><span class="line">			printf(&quot;比较的元素为：%d\n&quot;,ST.elem[mid]);</span><br><span class="line">			printf(&quot;查找该元素，比较的次数为：%d\n&quot;,k); //找到待查元素</span><br><span class="line">			return 0;</span><br><span class="line">		&#125; else if(LT(key,ST.elem[mid])) &#123;</span><br><span class="line">			k++;</span><br><span class="line">			printf(&quot;比较的元素为：%d\n&quot;,ST.elem[mid]);</span><br><span class="line">			high=mid-1; //继续在前半区间进行查找</span><br><span class="line">		&#125; else if(MT(key,ST.elem[mid])) &#123;</span><br><span class="line">			k++;</span><br><span class="line">			printf(&quot;比较的元素为：%d\n&quot;,ST.elem[mid]);</span><br><span class="line">			low=mid+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(!EQ(key,ST.elem[mid])) &#123;</span><br><span class="line">		printf(&quot;查找该元素，比较的次数为：%d\n&quot;,k);//没有找到待查元素</span><br><span class="line">		if(LT(key,ST.elem[mid]))</span><br><span class="line">			j=TableInsert(&amp;ST,mid+1,key);</span><br><span class="line">		else if(MT(key,ST.elem[mid]))</span><br><span class="line">			j=TableInsert(&amp;ST,ST.length+1,key);</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">int Menu() &#123;</span><br><span class="line">	int choice;</span><br><span class="line">	printf(&quot;************************\n&quot;);</span><br><span class="line">	printf(&quot; 1.新建静态查找表\n&quot;);</span><br><span class="line">	printf(&quot; 2.输出静态查找表\n&quot;);</span><br><span class="line">	printf(&quot; 3.顺序查找\n&quot;);</span><br><span class="line">	printf(&quot; 4.二分查找查找\n&quot;);</span><br><span class="line">	printf(&quot; 5.退出\n&quot;);</span><br><span class="line">	printf(&quot;============================\n&quot;);</span><br><span class="line">	printf(&quot;请选择：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;choice);</span><br><span class="line">	return choice;</span><br><span class="line">&#125;</span><br><span class="line">void print(ElemType *c) &#123;</span><br><span class="line">	printf(&quot;%d &quot;,*c);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	SSTable L;</span><br><span class="line">	int i,j,k,m,n,ch;</span><br><span class="line">	while (ch!=5) &#123;</span><br><span class="line">		ch=Menu();</span><br><span class="line">		switch(ch) &#123;</span><br><span class="line">			case 1:</span><br><span class="line">				printf(&quot;请输入表 L 的元素个数 n 的值：&quot;);</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">				InitTable(&amp;L); // 创建空表 L 成功</span><br><span class="line">				printf(&quot;请输入顺序表 L 的%d 个元素（格式为：元素 1 元素 2）：\n&quot;,n);</span><br><span class="line">				for(j=1; j&lt;=n; j++) &#123; // 在表 L 中插入 n 个元素</span><br><span class="line">					scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">					i=TableInsert(&amp;L,j,k);</span><br><span class="line">				&#125;</span><br><span class="line">				break;</span><br><span class="line">			case 2:</span><br><span class="line">				printf(&quot;顺序表 L 的元素分别为：&quot;); // 输出表 L 的内容</span><br><span class="line">				for(i=0; i&lt;L.length; i++)</span><br><span class="line">					print(&amp;L.elem[i]);</span><br><span class="line">				printf(&quot;\n&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case 3:</span><br><span class="line">				printf(&quot;请输入查找的元素的值 m(顺序查找)：&quot;);</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">				if(Search_Seq(L,m))</span><br><span class="line">					L.length=L.length+1;</span><br><span class="line">				break;</span><br><span class="line">			case 4:</span><br><span class="line">				printf(&quot;请输入查找的元素的值 m(折半查找)：&quot;);</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">				if(Search_Bin(L,m))</span><br><span class="line">					L.length=L.length+1;</span><br><span class="line">				break;</span><br><span class="line">			case 5:</span><br><span class="line">				printf(&quot;结束程序。\n&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">				break;</span><br><span class="line">			default:</span><br><span class="line">				printf(&quot;输入错误！请重新输入！\n\n&quot;);</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*  测试数据1：</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：1</span><br><span class="line">请输入表 L 的元素个数 n 的值：10</span><br><span class="line">请输入顺序表 L 的10 个元素（格式为：元素 1 元素 2）：</span><br><span class="line">1 5 7 2 8 9 6 0 4 3</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：2</span><br><span class="line">顺序表 L 的元素分别为：1 5 7 2 8 9 6 0 4 3</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：3</span><br><span class="line">请输入查找的元素的值 m(顺序查找)：8</span><br><span class="line">比较的元素为：3</span><br><span class="line">比较的元素为：4</span><br><span class="line">比较的元素为：0</span><br><span class="line">比较的元素为：6</span><br><span class="line">比较的元素为：9</span><br><span class="line">比较的元素为：8</span><br><span class="line">查找该元素，比较的次数为：6     (因为是从后往前比较的)</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：4</span><br><span class="line">请输入查找的元素的值 m(折半查找)：10</span><br><span class="line">比较的元素为：8</span><br><span class="line">比较的元素为：0</span><br><span class="line">比较的元素为：4</span><br><span class="line">比较的元素为：3</span><br><span class="line">查找该元素，比较的次数为：4</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：5</span><br><span class="line">结束程序。</span><br><span class="line"></span><br><span class="line">测试数据 2：</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：1</span><br><span class="line">请输入表 L 的元素个数 n 的值：10</span><br><span class="line">请输入顺序表 L 的10 个元素（格式为：元素 1 元素 2）：</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：2</span><br><span class="line">顺序表 L 的元素分别为：0 1 2 3 4 5 6 7 8 9</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：3</span><br><span class="line">请输入查找的元素的值 m(顺序查找)：8</span><br><span class="line">比较的元素为：9</span><br><span class="line">比较的元素为：8</span><br><span class="line">查找该元素，比较的次数为：2</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：4</span><br><span class="line">请输入查找的元素的值 m(折半查找)：10</span><br><span class="line">比较的元素为：4</span><br><span class="line">比较的元素为：7</span><br><span class="line">比较的元素为：8</span><br><span class="line">比较的元素为：9</span><br><span class="line">查找该元素，比较的次数为：4</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：5</span><br><span class="line">结束程序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">预习报告：</span><br><span class="line">1.顺序查找定义：从线性表中的第一个（或最后一个）</span><br><span class="line"> 数据元素开始，逐个进行数据元素关键字和给定值的比</span><br><span class="line"> 较，若某个数据元素的关键字和给定值相等则查找成功；</span><br><span class="line"> 如果直到最后一个（或第一个）</span><br><span class="line"> 数据元素，其关键字和给定值都不等时，则查找失败。</span><br><span class="line"> 若有n个数据，其查找次数为（n+1）/2；</span><br><span class="line">2.折半查找：先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或找不到记录为止。</span><br><span class="line"></span><br><span class="line">基本思想：</span><br><span class="line">首先将查找表进行排序；</span><br><span class="line">取中间数据元素进行比较；</span><br><span class="line">    当给定值与中间数据元素的关键字相等时，查找成功；</span><br><span class="line">    当给定值小于中间元素时，在中间元素左区间进行二分查找；</span><br><span class="line">    当给定值大于中间元素时，在中间元素右区间进行二分查找；</span><br><span class="line">当任意区间均无记录时，查找失败。</span><br><span class="line">其时间复杂度是O(log2 n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实验心得：</span><br><span class="line">1. TableInsert方法： 顺序线性表 L 已存在，1≤i≤List</span><br><span class="line">Length(L)+1 。操作结果：在 L 中第 i 个位置</span><br><span class="line">之前插入新的数据元素 e，L 的长度加 1 。</span><br><span class="line"> 其中一个重要的思想就是在插入位置之后的元素要</span><br><span class="line"> 从最后一个元素开始位往后移。并且表长+1</span><br><span class="line">2. Search_Seq方法的目的是在顺序表 ST 中顺序查</span><br><span class="line">找其关键字等于 key 的数据元素。若找到，则函数值为该元素</span><br><span class="line"> 在表中的位置，否则为 0。</span><br><span class="line"> 在for循环比较完了之后在判断一下，如果表中没有这个key就添加进去，</span><br><span class="line">否则就输出比较的次数。</span><br><span class="line"></span><br><span class="line">其中for循环这样设计会减少判断是否到达表尾的次数</span><br><span class="line">从而一定程度上加快程序执行的速度。</span><br><span class="line"></span><br><span class="line">3.Search_Bin方法 的执行结果是有序表 ST 中折半查找其他关键字等于</span><br><span class="line">key 的数据元素。若找到，则函数值为该元</span><br><span class="line">素在表中的位置，否则为 0。</span><br><span class="line">在这个方法中用到了折半查找的思维，</span><br><span class="line"> 首先将查找的整个区间的左端点置为0，右端点</span><br><span class="line"> 置为表长-1；然后进行while语句，其中while的</span><br><span class="line"> 判断条件是low&lt;=high;因为当退出本循环的时候</span><br><span class="line"> 双指针会交错；如果key和mid的值相等就输出该比较的</span><br><span class="line"> 元素，如果key小于mid就对左半区间查找，若果key</span><br><span class="line"> 大于mid就对右半区间查找。</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="实验题目：-内部排序"><a href="#实验题目：-内部排序" class="headerlink" title="实验题目： 内部排序"></a>实验题目： 内部排序</h4><p>【 实验目的 】<br>１． 掌握常见的排序算法的思想及其适用条件。<br>２． 掌握常见的排序算法的程序实现。<br>【实验要求】<br>输入一组关键字序列分别实现下列排序: :   </p>
<ol>
<li><ol>
<li>实现直接插入排序、折半插入排序和希尔排序算法。 实现直接插入排序、折半插入排序和希尔排序算法。</li>
</ol>
</li>
<li><ol start="2">
<li>实现 实现 快速排序算法。</li>
</ol>
</li>
<li><ol start="3">
<li>实现归并排序算法。 实现归并排序算法。</li>
</ol>
</li>
<li><ol start="4">
<li>在主函数中设计一个简单的菜单，分别测试上述算法。 在主函数中设计一个简单的菜单，分别测试上述算法。</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">//函数结果状态代码</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define INFEASIBLE -1</span><br><span class="line">typedef int Status;</span><br><span class="line">typedef int Boolean;</span><br><span class="line">//对两个数值型关键字的比较</span><br><span class="line">#define EQ(a,b) ((a)==(b))</span><br><span class="line">#define LT(a,b) ((a)&lt;(b))</span><br><span class="line">#define LQ(a,b) ((a)&lt;=(b))</span><br><span class="line">//待排记录的数据类型</span><br><span class="line">#define MAXSIZE 20 //一个用作示例的小顺序表的最大长度</span><br><span class="line">typedef int KeyType; //定义关键字类型为整型</span><br><span class="line">typedef int InfoType; //定义其它数据项的类型</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	KeyType key; //关键字项</span><br><span class="line">	InfoType otherinfo;//其他数据项</span><br><span class="line">&#125; RedType; //记录类型</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	RedType r[MAXSIZE+1];//r[0]闲置或用作哨兵单元</span><br><span class="line">	int length;//顺序表长度</span><br><span class="line">&#125; SqList; //顺序表类型</span><br><span class="line">typedef SqList HeapType; // 堆采用顺序表存储表示</span><br><span class="line">//顺序表插入排序的函数</span><br><span class="line">void InsertSort(SqList &amp;L);</span><br><span class="line">void BInsertSort(SqList &amp;L);</span><br><span class="line">void ShellInsert(SqList &amp;L,int dk);</span><br><span class="line">void ShellSort(SqList &amp;L,int dlta[],int t);</span><br><span class="line">//快速排序</span><br><span class="line">int Partition(SqList &amp;L,int low,int high);</span><br><span class="line">void QSort(SqList &amp;L,int low,int high);</span><br><span class="line">void QuickSort(SqList &amp;L);</span><br><span class="line">//归并排序</span><br><span class="line">void Merge(RedType SR[],RedType TR[],int i,int m,int n);</span><br><span class="line">void MSort(RedType SR[],RedType TR1[],int s, int t);</span><br><span class="line">void MergeSort(SqList &amp;L);</span><br><span class="line">//输出函数</span><br><span class="line">void print(SqList L);</span><br><span class="line">#define N 8</span><br><span class="line">#define T 3</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	RedType d[N]= &#123;&#123;20,6&#125;,&#123;52,1&#125;,&#123;65,3&#125;,&#123;88,9&#125;,&#123;47,8&#125;,&#123;22,4&#125;,&#123;39,5&#125;,&#123;74,7&#125;&#125;;</span><br><span class="line">	int i;</span><br><span class="line">	SqList LL;</span><br><span class="line">	int dt[T]= &#123;5,3,1&#125;; // 增量序列数组</span><br><span class="line">	int choice;</span><br><span class="line">s123:</span><br><span class="line">	cout&lt;&lt;&quot;请选择要使用的排序算法：\n0..............退出\n&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;1..............插入排序\n2..............交换排序\n&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;3..............归并排序\n&quot;;</span><br><span class="line">	cin&gt;&gt;choice;</span><br><span class="line">	switch(choice) &#123;</span><br><span class="line">		case 0:</span><br><span class="line">			break;</span><br><span class="line">		case 1: //插入排序</span><br><span class="line">			for(i=0; i&lt;N; i++) //给 LL.r 赋值</span><br><span class="line">				LL.r[i+1]=d[i];</span><br><span class="line">			LL.length=N;</span><br><span class="line">			printf(&quot;直接插入排序前:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			InsertSort(LL);</span><br><span class="line">			printf(&quot;直接插入排序后:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			for(i=0; i&lt;N; i++)</span><br><span class="line">				LL.r[i+1]=d[i];</span><br><span class="line">			LL.length=N;</span><br><span class="line">			printf(&quot;\n 折半插入排序前:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			BInsertSort(LL);</span><br><span class="line">			printf(&quot;折半插入排序后:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			for(i=0; i&lt;N; i++)</span><br><span class="line">				LL.r[i+1]=d[i];</span><br><span class="line">			LL.length=N;</span><br><span class="line">			printf(&quot;\n 希尔排序前: \n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			ShellSort(LL,dt,T);</span><br><span class="line">			printf(&quot;希尔排序后: \n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			goto s123;</span><br><span class="line">		case 2: //交换排序</span><br><span class="line">			for(i=0; i&lt;N; i++)</span><br><span class="line">				LL.r[i+1]=d[i];</span><br><span class="line">			LL.length=N;</span><br><span class="line">			printf(&quot;快速排序前:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			QuickSort(LL);</span><br><span class="line">			printf(&quot;快速排序后:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			goto s123;</span><br><span class="line">		case 3: //归并排序</span><br><span class="line">			for(i=0; i&lt;N; i++)</span><br><span class="line">				LL.r[i+1]=d[i];</span><br><span class="line">			LL.length=N;</span><br><span class="line">			printf(&quot;归并排序前:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			MergeSort(LL);</span><br><span class="line">			printf(&quot;归并排序后:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			goto s123;</span><br><span class="line">		default:</span><br><span class="line">			cout&lt;&lt;&quot;输入有误，请输入正确的选项！\n&quot;;</span><br><span class="line">			goto s123;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//顺序表插入排序的函数(3 个)</span><br><span class="line">//InsertSort</span><br><span class="line">void InsertSort(SqList &amp;L) &#123;</span><br><span class="line">	// 对顺序表 L 作直接插入排序。</span><br><span class="line">	int i,j;</span><br><span class="line">	for(i=2; i&lt;=L.length; ++i)</span><br><span class="line">		if(LT(L.r[i].key,L.r[i-1].key)) &#123;</span><br><span class="line">			L.r[0]=L.r[i];</span><br><span class="line">			L.r[i]=L.r[i-1];</span><br><span class="line">			for(j=i-2; LT(L.r[0].key,L.r[j].key); --j)</span><br><span class="line">				L.r[j+1]=L.r[j];</span><br><span class="line">			L.r[j+1]=L.r[0];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BInsertSort</span><br><span class="line">void BInsertSort(SqList &amp;L) &#123;</span><br><span class="line">	//对顺序表 L 作折半插入排序。</span><br><span class="line">	int low,high,m;</span><br><span class="line">	for(int i=2; i&lt;=L.length; ++i) &#123;</span><br><span class="line">		L.r[0]=L.r[i];</span><br><span class="line">		low=1;</span><br><span class="line">		high=i-1;</span><br><span class="line">		while(low&lt;=high) &#123;</span><br><span class="line">			m=(low+high)/2;</span><br><span class="line">			if(LT(L.r[0].key,L.r[m].key))</span><br><span class="line">				high=m-1;</span><br><span class="line">			else</span><br><span class="line">				low=m+1;</span><br><span class="line">		&#125;//while</span><br><span class="line">		for(int j=i-1; j&gt;=high+1; --j)</span><br><span class="line">			L.r[j+1]=L.r[j];</span><br><span class="line">		L.r[high+1]=L.r[0];</span><br><span class="line">	&#125;//for</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//希尔排序 </span><br><span class="line">void ShellInsert(SqList &amp;L,int dk) &#123;</span><br><span class="line">	//对顺序表 L 作一趟希尔插入排序。本算法是和一趟直接插入排序相比，作了以下修改：</span><br><span class="line">// 1.前后记录位置的增量是 dk,而不是 1;</span><br><span class="line">// 2.r[0]只是暂存单元,不是哨兵。当 j&lt;=0 时,插入位置已找到。</span><br><span class="line">	int i,j;</span><br><span class="line">	for(i=dk+1; i&lt;=L.length; ++i)</span><br><span class="line">		if LT(L.r[i].key,L.r[i-dk].key) &#123;</span><br><span class="line">			//需将 L.r[i]插入有序增量子表</span><br><span class="line">			L.r[0]=L.r[i]; //暂存在 L.r[0]</span><br><span class="line">			for(j=i-dk; j&gt;0&amp;&amp;LT(L.r[0].key,L.r[j].key); j-=dk)</span><br><span class="line">				L.r[j+dk]=L.r[j]; //记录后移，查找插入位置</span><br><span class="line">			L.r[j+dk]=L.r[0]; //插入</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">void ShellSort(SqList &amp;L,int dlta[],int t) &#123;</span><br><span class="line">	//按增量序列 dlta[0..t-1]对顺序表 L 作希尔排序。</span><br><span class="line">	int k;</span><br><span class="line">	for(k=0; k&lt;t; ++k) &#123;</span><br><span class="line">		ShellInsert(L,dlta[k]); //一趟增量为 dlta[k]的插入排序</span><br><span class="line">		printf(&quot;第%d 趟排序结果: \n&quot;,k+1);</span><br><span class="line">		print(L);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//QuickSort</span><br><span class="line">int Partition(SqList &amp;L,int low,int high) &#123;</span><br><span class="line">	//交换顺序表 L 中子表 r[low..high]的记录，枢轴记录到位，并返回其</span><br><span class="line">//所在位置，此时在它之前（后）的记录均不大（小）于它。</span><br><span class="line">	KeyType pivotkey;</span><br><span class="line">	L.r[0]=L.r[low]; //用子表的第一个记录作枢轴记录</span><br><span class="line">	pivotkey=L.r[low].key; //枢轴记录关键字</span><br><span class="line">	while(low&lt; high) &#123;</span><br><span class="line">		//从表的两端交替地向中间扫描</span><br><span class="line">		while(low&lt;high&amp;&amp;L.r[high].key&gt;=pivotkey)</span><br><span class="line">			--high;</span><br><span class="line">		L.r[low]=L.r[high]; //将比枢轴记录小的记录移到低端</span><br><span class="line">		while(low&lt;high&amp;&amp;L.r[low].key&lt;=pivotkey)</span><br><span class="line">			++low;</span><br><span class="line">		L.r[high]=L.r[low]; //将比枢轴记录大的记录移到高端</span><br><span class="line">	&#125;</span><br><span class="line">	L.r[low]=L.r[0]; //枢轴记录到位</span><br><span class="line">	return low; //返回枢轴位置</span><br><span class="line">&#125;</span><br><span class="line">void QSort(SqList &amp;L,int low,int high) &#123;</span><br><span class="line">	//对顺序表 L 中的子序列 L.r[low..high]作快速排序。</span><br><span class="line">	if(low&lt;high) &#123;</span><br><span class="line">		int pivotloc;</span><br><span class="line">		pivotloc=Partition(L,low,high);</span><br><span class="line">		QSort(L,low,pivotloc-1);</span><br><span class="line">		QSort(L,pivotloc+1,high);</span><br><span class="line">	&#125;//if</span><br><span class="line">&#125;//QSort</span><br><span class="line">void QuickSort(SqList &amp;L) &#123;</span><br><span class="line">	//对顺序表 L 作快速排序。</span><br><span class="line">	QSort(L,1,L.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//归并排序 </span><br><span class="line">void Merge(RedType SR[],RedType TR[],int i,int m,int n) &#123;</span><br><span class="line">	//将有序的 SR[i..m]和 SR[m+1..n]归并为有序的 TR[i..n]</span><br><span class="line">	int j,k,l;</span><br><span class="line">	for(j=m+1,k=i; i&lt;=m&amp;&amp;j&lt;=n; ++k) //将 SR 中记录由小到大地并入 TR</span><br><span class="line">		if LQ(SR[i].key,SR[j].key)</span><br><span class="line">			TR[k]=SR[i++];</span><br><span class="line">		else</span><br><span class="line">			TR[k]=SR[j++];</span><br><span class="line">	if(i&lt;=m)</span><br><span class="line">		for(l=0; l&lt;=m-i; l++)</span><br><span class="line">			TR[k+l]=SR[i+l]; //将剩余的 SR[i..m]复制到 TR</span><br><span class="line">	if(j&lt;=n)</span><br><span class="line">		for(l=0; l&lt;=n-j; l++)</span><br><span class="line">			TR[k+l]=SR[j+l]; //将剩余的 SR[j..n]复制到 TR</span><br><span class="line">&#125;</span><br><span class="line">void MSort(RedType SR[],RedType TR1[],int s, int t) &#123;</span><br><span class="line">	//将 SR[s..t]归并排序为 TR1[s..t]。</span><br><span class="line">	RedType TR2[MAXSIZE];</span><br><span class="line">	if(s==t)</span><br><span class="line">		TR1[s]=SR[s];</span><br><span class="line">	else &#123;</span><br><span class="line">		int m=(s+t)/2;</span><br><span class="line">		MSort(SR,TR2,s,m);</span><br><span class="line">		MSort(SR,TR2,m+1,t);</span><br><span class="line">		Merge(TR2,TR1,s,m,t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void MergeSort(SqList &amp;L) &#123;</span><br><span class="line">	//对顺序表 L 作归并排序。</span><br><span class="line">	MSort(L.r,L.r,1,L.length);</span><br><span class="line">&#125;</span><br><span class="line">void print(SqList L) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=1; i&lt;=L.length; i++)</span><br><span class="line">		printf(&quot; (%d,%d) &quot;,L.r[i].key,L.r[i].otherinfo);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">实验结果：</span><br><span class="line"> </span><br><span class="line">请选择要使用的排序算法：</span><br><span class="line">0..............退出</span><br><span class="line">1..............插入排序</span><br><span class="line">2..............交换排序</span><br><span class="line">3..............归并排序</span><br><span class="line">1</span><br><span class="line">直接插入排序前:</span><br><span class="line"> (20,6)  (52,1)  (65,3)  (88,9)  (47,8)  (22,4)  (39,5)  (74,7)</span><br><span class="line">直接插入排序后:</span><br><span class="line"> (20,6)  (22,4)  (39,5)  (47,8)  (52,1)  (65,3)  (74,7)  (88,9)</span><br><span class="line"></span><br><span class="line"> 折半插入排序前:</span><br><span class="line"> (20,6)  (52,1)  (65,3)  (88,9)  (47,8)  (22,4)  (39,5)  (74,7)</span><br><span class="line">折半插入排序后:</span><br><span class="line"> (20,6)  (22,4)  (39,5)  (47,8)  (52,1)  (65,3)  (74,7)  (88,9)</span><br><span class="line"></span><br><span class="line"> 希尔排序前:</span><br><span class="line"> (20,6)  (52,1)  (65,3)  (88,9)  (47,8)  (22,4)  (39,5)  (74,7)</span><br><span class="line">第1 趟排序结果:</span><br><span class="line"> (20,6)  (39,5)  (65,3)  (88,9)  (47,8)  (22,4)  (52,1)  (74,7)</span><br><span class="line">第2 趟排序结果:</span><br><span class="line"> (20,6)  (39,5)  (22,4)  (52,1)  (47,8)  (65,3)  (88,9)  (74,7)</span><br><span class="line">第3 趟排序结果:</span><br><span class="line"> (20,6)  (22,4)  (39,5)  (47,8)  (52,1)  (65,3)  (74,7)  (88,9)</span><br><span class="line">希尔排序后:</span><br><span class="line"> (20,6)  (22,4)  (39,5)  (47,8)  (52,1)  (65,3)  (74,7)  (88,9)</span><br><span class="line">请选择要使用的排序算法：</span><br><span class="line">0..............退出</span><br><span class="line">1..............插入排序</span><br><span class="line">2..............交换排序</span><br><span class="line">3..............归并排序</span><br><span class="line">2</span><br><span class="line">快速排序前:</span><br><span class="line"> (20,6)  (52,1)  (65,3)  (88,9)  (47,8)  (22,4)  (39,5)  (74,7)</span><br><span class="line">快速排序后:</span><br><span class="line"> (20,6)  (22,4)  (39,5)  (47,8)  (52,1)  (65,3)  (74,7)  (88,9)</span><br><span class="line">请选择要使用的排序算法：</span><br><span class="line">0..............退出</span><br><span class="line">1..............插入排序</span><br><span class="line">2..............交换排序</span><br><span class="line">3..............归并排序</span><br><span class="line">3</span><br><span class="line">归并排序前:</span><br><span class="line"> (20,6)  (52,1)  (65,3)  (88,9)  (47,8)  (22,4)  (39,5)  (74,7)</span><br><span class="line">归并排序后:</span><br><span class="line"> (20,6)  (22,4)  (39,5)  (47,8)  (52,1)  (65,3)  (74,7)  (88,9)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 预习报告： </span><br><span class="line"> 1.直接插入排序的核心思想就是：将数组中的所</span><br><span class="line"> 有元素依次跟前面已经排好的元素相比较，如果</span><br><span class="line"> 选择的元素比已排序的元素小，则交换，直到全</span><br><span class="line"> 部元素都比较过。</span><br><span class="line"> </span><br><span class="line"> 2.尔排序的算法思想：将待排序数组按照步长gap</span><br><span class="line"> 进行分组，然后将每组的元素利用直接插入排序的</span><br><span class="line"> 方法进行排序；每次将增量折半减小，循环上述操作</span><br><span class="line"> ；当增量=1时，利用直接插入，完成排序。</span><br><span class="line"> 3.堆的概念</span><br><span class="line">堆：本质是一种数组对象。特别重要的一点性质：</span><br><span class="line">任意的叶子节点小于（或大于）它所有的父节</span><br><span class="line">点。对此，又分为大顶堆和小顶堆，大顶堆</span><br><span class="line">要求节点的元素都要大于其孩子，小顶堆要求节</span><br><span class="line">点元素都小于其左右孩子，两者对左右孩子的大小</span><br><span class="line">关系不做任何要求。</span><br><span class="line">利用堆排序，就是基于大顶堆或者小顶堆的一种</span><br><span class="line">排序方法。下面，我们通过大顶堆来实现。</span><br><span class="line"> </span><br><span class="line"> 实验心得： </span><br><span class="line"> 1.在写冒泡排序的时候因为没有想到因为第一个位置</span><br><span class="line"> 空闲不用，而导致写错了，是每次都把最小的冒到最上面</span><br><span class="line"> 然后最大的就沉到最下面，从上向下就成了有序的。</span><br><span class="line"> 所以冒泡排序思路为：</span><br><span class="line">    将序列当中的左右元素，依次比较，保证右边的元素始终大于左边的元素；</span><br><span class="line">    （ 第一轮结束后，序列最后一个元素一定是当前序列的最大值；）</span><br><span class="line">    对序列当中剩下的n-1个元素再次执行步骤1。</span><br><span class="line">    对于长度为n的序列，一共需要执行n-1轮比较</span><br><span class="line">    （利用while循环可以减少执行次数）</span><br><span class="line"> 2.快速排序的基本思想：挖坑填数+分治法</span><br><span class="line">    从序列当中选择一个基准数(pivot)</span><br><span class="line">    在这里我们选择序列当中第一个数最为基准数</span><br><span class="line">    将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧</span><br><span class="line">    重复步骤1.2，直到所有子集当中只有一个元素为止。</span><br><span class="line">    用伪代码描述如下：</span><br><span class="line">    1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。</span><br><span class="line">    2．j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</span><br><span class="line">    3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</span><br><span class="line">    4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中</span><br><span class="line">3.基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</span><br><span class="line">分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</span><br><span class="line">收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[ ]</span><br><span class="line">对新形成的序列L[]重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束</span><br><span class="line"> </span><br><span class="line"> */ </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://zouyunkai.github.io/myblog/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构上机实验" target="_blank" rel="external">https://zouyunkai.github.io/myblog/2019/10/03/数据结构/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/zouyunkai" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/myblog/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/zouyunkai" target="_blank"><span class="text-dark">云开</span><small class="ml-1x">Stay Hungry , Stay Foolish .</small></a></h3>
        <div>when the facts change , I change my mind .</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/myblog/2019/10/06/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%97%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/" title=" Longest Increasing Subsequence"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/myblog/2019/10/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" title="排序算法"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/myblog/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/myblog/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/zouyunkai" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/zouyunkai" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/zouyunkai" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/zouyunkai" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/myblog/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/myblog/js/plugin.min.js"></script>


<script src="/myblog/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/myblog/',
        CONTENT_URL: '/myblog/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/myblog/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '9f5iImvmYajPaJ79pRkbVNU9-gzGzoHsz',
    appKey: 'n3qUzkAGTOqjKi9k5LKGLfgV',
    placeholder: 'Just go go',
    avatar: 'wavatar',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>