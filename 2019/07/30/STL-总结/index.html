<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>STL_总结 | Sweet@</title>
  <meta name="description" content="STL_总结STL pairSTL setSTL vectorSTL stringSTL stackSTL queueSTL mapSTL bitsetSTL iteratorSTL algorithm      pair类模板：template＜class T1,class T2＞struct pair参数：T1是第一个值的数据类型，T2是第二个值的数据类型。作用：将两个元素（可以是不同类型的元">
<meta property="og:type" content="article">
<meta property="og:title" content="STL_总结">
<meta property="og:url" content="https://zouyunkai.github.io/myblog/2019/07/30/STL-%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Sweet@">
<meta property="og:description" content="STL_总结STL pairSTL setSTL vectorSTL stringSTL stackSTL queueSTL mapSTL bitsetSTL iteratorSTL algorithm      pair类模板：template＜class T1,class T2＞struct pair参数：T1是第一个值的数据类型，T2是第二个值的数据类型。作用：将两个元素（可以是不同类型的元">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-07-30T11:50:00.000Z">
<meta property="article:modified_time" content="2022-02-26T03:52:51.873Z">
<meta property="article:author" content="zouqingzhi">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="stl">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="https://zouyunkai.github.io/myblog/2019/07/30/STL-%E6%80%BB%E7%BB%93/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Sweet@" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/myblog/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.0.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/zouyunkai" target="_blank">
          <img class="img-circle img-rotate" src="/myblog/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">云开</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Stay Hungry , Stay Foolish .</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/myblog/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/myblog/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/myblog/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/myblog/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/myblog/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/myblog/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/zouyunkai" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/zouyunkai" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/zouyunkai" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/zouyunkai" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/myblog/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/">所长的跨学科工具箱</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/04/04/12%E6%A6%82%E7%8E%87%E6%80%9D%E7%BB%B4/" class="title">概率思维—把握不确定性</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-04T13:29:00.000Z" itemprop="datePublished">2022-04-04</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E6%9D%82%E8%AE%B0/">杂记</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/04/03/%E5%85%B3%E4%BA%8E%E8%80%83%E7%A0%94%E6%88%91%E6%83%B3%E8%AF%B4%E7%9A%84/" class="title">关于考研</a>
              </p>
              <p class="item-date">
                <time datetime="2022-04-03T07:29:00.000Z" itemprop="datePublished">2022-04-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E9%9D%A2%E8%AF%95/">面试</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/02/24/%E7%AE%80%E5%8E%86/" class="title">个人简历</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-24T13:46:00.000Z" itemprop="datePublished">2022-02-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E6%9D%82%E8%AE%B0/">杂记</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/01/25/%E5%85%B3%E4%BA%8E%E5%A4%87%E8%80%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/" class="title">关于备考的方法</a>
              </p>
              <p class="item-date">
                <time datetime="2022-01-25T13:29:00.000Z" itemprop="datePublished">2022-01-25</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/">所长的跨学科工具箱</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/01/19/01%E6%A8%A1%E6%9D%BF/" class="title">脑科学重要模型</a>
              </p>
              <p class="item-date">
                <time datetime="2022-01-19T13:29:00.000Z" itemprop="datePublished">2022-01-19</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/myblog/tags/" style="font-size: 13px;">  </a> <a href="/myblog/tags/2019%E6%A0%A1%E8%B5%9B/" style="font-size: 13px;">2019校赛</a> <a href="/myblog/tags/BFS/" style="font-size: 13.2px;">BFS</a> <a href="/myblog/tags/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/" style="font-size: 13px;">C++字符串处理</a> <a href="/myblog/tags/CF/" style="font-size: 13px;">CF</a> <a href="/myblog/tags/DFS/" style="font-size: 13.2px;">DFS</a> <a href="/myblog/tags/DOM/" style="font-size: 13px;">DOM</a> <a href="/myblog/tags/DP/" style="font-size: 13px;">DP</a> <a href="/myblog/tags/FFT/" style="font-size: 13px;">FFT</a> <a href="/myblog/tags/KMP/" style="font-size: 13px;">KMP</a> <a href="/myblog/tags/boos/" style="font-size: 13px;">boos</a> <a href="/myblog/tags/c/" style="font-size: 13px;">c</a> <a href="/myblog/tags/c/" style="font-size: 13px;">c#</a> <a href="/myblog/tags/c/" style="font-size: 13.4px;">c++</a> <a href="/myblog/tags/codeforce/" style="font-size: 13.2px;">codeforce</a> <a href="/myblog/tags/comparable-and-comparator/" style="font-size: 13px;">comparable and comparator</a> <a href="/myblog/tags/crypto/" style="font-size: 13px;">crypto</a> <a href="/myblog/tags/c%E8%AF%AD%E8%A8%80%E5%B0%8F%E7%9F%A5%E8%AF%86/" style="font-size: 13px;">c语言小知识</a> <a href="/myblog/tags/git/" style="font-size: 13px;">git</a> <a href="/myblog/tags/html/" style="font-size: 13px;">html</a> <a href="/myblog/tags/iis%E9%85%8D%E7%BD%AE/" style="font-size: 13px;">iis配置</a> <a href="/myblog/tags/java/" style="font-size: 13.2px;">java</a> <a href="/myblog/tags/java-se/" style="font-size: 13.2px;">java se</a> <a href="/myblog/tags/java-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" style="font-size: 13px;">java 深浅拷贝</a> <a href="/myblog/tags/java%E7%AE%97%E6%B3%95/" style="font-size: 13px;">java算法</a> <a href="/myblog/tags/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 13px;">java网络编程</a> <a href="/myblog/tags/js/" style="font-size: 13px;">js</a> <a href="/myblog/tags/linux%E6%95%99%E7%A8%8B/" style="font-size: 13px;">linux教程</a> <a href="/myblog/tags/mysql/" style="font-size: 13px;">mysql</a> <a href="/myblog/tags/param/" style="font-size: 13px;">param</a> <a href="/myblog/tags/qluoj/" style="font-size: 13px;">qluoj</a> <a href="/myblog/tags/sql/" style="font-size: 13px;">sql</a> <a href="/myblog/tags/stl/" style="font-size: 13px;">stl</a> <a href="/myblog/tags/web/" style="font-size: 13.2px;">web</a> <a href="/myblog/tags/%E4%BA%8C%E5%88%86%E6%B3%95/" style="font-size: 13px;">二分法</a> <a href="/myblog/tags/%E4%BA%94%E5%AD%90%E6%A3%8B/" style="font-size: 13px;">五子棋</a> <a href="/myblog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 13.2px;">动态规划</a> <a href="/myblog/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 13px;">单调栈</a> <a href="/myblog/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" style="font-size: 13px;">单调队列</a> <a href="/myblog/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" style="font-size: 13px;">博弈论</a> <a href="/myblog/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/" style="font-size: 13px;">哈夫曼编码</a> <a href="/myblog/tags/%E5%93%B2%E5%AD%A6/" style="font-size: 13px;">哲学</a> <a href="/myblog/tags/%E5%9B%BD%E7%8E%8B%E6%8C%96%E9%87%91%E5%AD%90/" style="font-size: 13px;">国王挖金子</a> <a href="/myblog/tags/%E5%9B%BE/" style="font-size: 13.2px;">图</a> <a href="/myblog/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 13px;">图论</a> <a href="/myblog/tags/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/" style="font-size: 13px;">大数运算</a> <a href="/myblog/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/" style="font-size: 13.2px;">小游戏</a> <a href="/myblog/tags/%E5%B1%B1%E7%90%86%E5%B7%A5/" style="font-size: 13px;">山理工</a> <a href="/myblog/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/" style="font-size: 13px;">快速幂</a> <a href="/myblog/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 13px;">排序算法</a> <a href="/myblog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 13.4px;">数据库</a> <a href="/myblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13px;">数据结构</a> <a href="/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/" style="font-size: 14px;">新生训练</a> <a href="/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83-02/" style="font-size: 13px;">新生训练_02</a> <a href="/myblog/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 13.2px;">最小生成树</a> <a href="/myblog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" style="font-size: 13.2px;">最短路径</a> <a href="/myblog/tags/%E6%9D%AD%E7%94%B5/" style="font-size: 13px;">杭电</a> <a href="/myblog/tags/%E6%A0%88/" style="font-size: 13px;">栈</a> <a href="/myblog/tags/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96/" style="font-size: 13px;">棋盘覆盖</a> <a href="/myblog/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 13px;">模板</a> <a href="/myblog/tags/%E7%89%9B%E5%AE%A2/" style="font-size: 13.8px;">牛客</a> <a href="/myblog/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.2px;">算法</a> <a href="/myblog/tags/%E7%B4%A0%E6%95%B0/" style="font-size: 13px;">素数</a> <a href="/myblog/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/" style="font-size: 13px;">聊天室</a> <a href="/myblog/tags/%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9B/" style="font-size: 13px;">联盟周赛</a> <a href="/myblog/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" style="font-size: 13px;">背包问题</a> <a href="/myblog/tags/%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D/" style="font-size: 13px;">英文单词</a> <a href="/myblog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" style="font-size: 13px;">蓝桥杯</a> <a href="/myblog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%97%E6%B3%95/" style="font-size: 13px;">蓝桥杯算法</a> <a href="/myblog/tags/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B/" style="font-size: 13.6px;">蓝桥省赛</a> <a href="/myblog/tags/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/" style="font-size: 13px;">计网笔记</a> <a href="/myblog/tags/%E8%AE%AD%E7%BB%83/" style="font-size: 13.6px;">训练</a> <a href="/myblog/tags/%E8%B4%AA%E5%90%83%E8%9B%87/" style="font-size: 13px;">贪吃蛇</a> <a href="/myblog/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 13px;">贪心</a> <a href="/myblog/tags/%E9%80%92%E5%BD%92/" style="font-size: 13.4px;">递归</a> <a href="/myblog/tags/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/" style="font-size: 13px;">递归与分治</a> <a href="/myblog/tags/%E9%98%9F%E5%88%97/" style="font-size: 13px;">队列</a> <a href="/myblog/tags/%E9%9A%90%E5%86%99/" style="font-size: 13px;">隐写</a> <a href="/myblog/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13px;">面试</a>
    </div>
  </div>

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-STL-总结" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      STL_总结
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/myblog/2019/07/30/STL-%E6%80%BB%E7%BB%93/" class="article-date">
	  <time datetime="2019-07-30T11:50:00.000Z" itemprop="datePublished">2019-07-30</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/myblog/categories/ACM/">ACM</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/myblog/tags/c/" rel="tag">c++</a>, <a class="article-tag-link-link" href="/myblog/tags/stl/" rel="tag">stl</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/myblog/2019/07/30/STL-%E6%80%BB%E7%BB%93/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 11.9k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 53(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h3 id="STL-总结"><a href="#STL-总结" class="headerlink" title="STL_总结"></a>STL_总结</h3><p><a href="#pair">STL pair</a><br><a href="#set">STL set</a><br><a href="#vector">STL vector</a><br><a href="">STL string</a><br><a href="#stack">STL stack</a><br><a href="#queue">STL queue</a><br><a href="#map">STL map</a><br><a href="#bitset">STL bitset</a><br><a href="#iterator">STL iterator</a><br><a href="#algorithm">STL algorithm</a>  </p>
<h3 id="pair"></h3> 

<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>类模板：<br>template＜class T1,class T2＞struct pair<br>参数：<br>T1是<strong>第一个值</strong>的数据类型，T2是<strong>第二个值</strong>的数据类型。<br>作用：将两个元素（可以是不同类型的元素）整合为一种。<br>用法：  </p>
<ol>
<li>怎么构造这样一个类型（<strong>定义方法</strong>）：</li>
</ol>
<ul>
<li>方法1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int ,double&gt;p1;    //两个参数的数据类型可以是不同的</span><br><span class="line">pair&lt;int ,int &gt;p2，p4;</span><br><span class="line">pair&lt;string ,string&gt;p3;</span><br><span class="line">pair&lt;string,double&gt;p2 (&quot;aa&quot;,5.0);   //声明的时候直接赋值</span><br></pre></td></tr></table></figure>

<ul>
<li>方法2：<br>通过typedef简化声明定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;string, string&gt;author; </span><br><span class="line">author pro(&quot;May&quot;, &quot;Lily&quot;);   //这时就可以直接这样写，来给	pair对象赋值，而不是通过访问属性或者调用make_pair（）方法</span><br><span class="line">author joye(&quot;James&quot;, &quot;Joyce&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>方法3：<br> pair类数组的定义方法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pair&lt;int ,int &gt;a[4];</span><br><span class="line">    for(int i=0;i&lt;=3;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a[i].first,&amp;a[i].second);</span><br><span class="line">        printf(&quot;first=%d second=%d\n&quot;,a[i].first,a[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>赋值方法：</li>
</ol>
<ul>
<li>方法1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int ,double &gt;p1;</span><br><span class="line">p1.first=1;       //这是属性值，而不是调用方法</span><br><span class="line">p1.second=2.2;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法2：<br>利用make_pair(a1,a2)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1;</span><br><span class="line">p1 = make_pair(1, 1.2);</span><br></pre></td></tr></table></figure>

<ul>
<li>方法3：<br>这种是用于一个pair给另一个pair赋值：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;int, double&gt; p1(1, 1.2);//定义时赋值</span><br><span class="line">pair&lt;int, double&gt; p2 = p1;//类对类赋值</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>获取pair的值<br>cout&lt;&lt;p1.first&lt;&lt;p1.second;   &#x2F;&#x2F;获取pair对象的属性值</p>
</li>
<li><p>pair的运算方式：<br>在中已经定义了pair上的六个比较运算符：&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D;<br>其规则是先比较first，first相等时再比较second，这符合大多数应用的逻辑。<em>当然，也可以通过重载这几个运算符来重新指定自⼰的比较逻辑。</em>   </p>
</li>
<li><p>pair的类型：</p>
</li>
</ol>
<p><em>pair 是 一种模版类型。每个pair 可以存储两个值</em>。这两种值无限制。也可以将自己写的struct的对象放进去。<br><strong>如在返回值中的应用，在一个对象有多个属性的时候 ，一般自己写一个struct ，如果就是两个属性的话，就可以用pair 进行操作 。</strong><br>如果有三个属性的话，其实也是可以用的pair 的 ，极端的写法：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pair &lt;int ,pair&lt;int ,int &gt; &gt;  </span><br><span class="line">   //（后边的两个 &gt; &gt; 要有空格，否则就会是 &gt;&gt; 位移运算符）</span><br></pre></td></tr></table></figure>

<p><strong>pair实质上是一个结构体</strong>，其主要的两个成员变量是first和second，这两个变量可以直接使用。初始化一个pair可以使用构造函数，也可以使用std::make_pair函数，make_pair函数的定义如下：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template pair make_pair(T1 a, T2 b) &#123; return pair(a, b); &#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>小结: <br>　　make_pair创建的是一个pair对象。使用都很方便，针对成对出现的数据，如书的ISBN对应一个书名。 <br>　　pair是单个数据对的操作，pair是一struct类型，有两个成员变量，通过first,second来访问，用的是“.”访问。   <br>　　map是一个关联容器，里面存放的是键值对，容器中每一元素都是pair类型，通过map的insert()方法来插入元素(pair类型)。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">pair和priority_queue连用：</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;int, int&gt; P;</span><br><span class="line"></span><br><span class="line">struct cmp</span><br><span class="line">&#123;</span><br><span class="line"> /*默认是less算子也就是返回a&lt;b，也就是小的优先级也小,即值大的优先级高，而greater算子返回a&gt;b，小的优先级高。*/</span><br><span class="line"> bool operator()(const P p1, const P p2)</span><br><span class="line">    &#123;</span><br><span class="line">        return p1 &gt; p2; </span><br><span class="line">        //小值优先,当第一个元素相等时，比较第二个元素（同样是小者优先出队 </span><br><span class="line">        //return p1 &lt; p2;  大值优先，即大值先出队 </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    priority_queue&lt;P, vector&lt;P&gt;, cmp&gt; que;</span><br><span class="line">    que.push(P(10,20));</span><br><span class="line">    que.push(P(15,30));</span><br><span class="line">    que.push(P(10,1));</span><br><span class="line">    P p;</span><br><span class="line">    while(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        p=que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        cout&lt;&lt;p.first&lt;&lt;&quot; &quot;&lt;&lt;p.second&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="set"></h3>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ol>
<li><strong>set是STL中一种标准关联容器</strong>。它底层使用平衡的搜索树——红黑树实现，插入删除操作时仅仅需要指针操作节点即可完成，不涉及到内存移动和拷贝，所以效率比较高。<br>　　set，顾名思义是“集合”的意思，<strong>在set中元素都是唯一的，而且默认情况下会对元素自动进行升序排列</strong>，支持集合的交(set_intersection),差(set_difference) 并(set_union)，对称差(set_symmetric_difference) 等一些集合上的操作，如果需要集合中的元素允许重复那么可以使用multiset。</li>
<li>Set容器的定义与创建：<br>set模板原型：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class Key, class Compare=less&lt;Key&gt;, class Alloc=STL_DEFAULT_ALLOCATOR(Key) &gt;		//Key为元素(键值)类型 </span><br></pre></td></tr></table></figure>

<p>set&lt;类型&gt; 对象名; 如：set＜int＞ s;  <br>set&lt;类型，比较结构体&gt; 对象名; 如：set＜int，myComp＞ s; Set容器在插入时，默认情况下按从小到大的顺序存储，可以通过自定义比较结构体，按从大到小的顺序存储或者按照多个关键字序列插入。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">set&lt;int&gt; s;</span><br><span class="line">int main()&#123;</span><br><span class="line">   set&lt;int &gt; seta; 					//默认是小于比较器less&lt;int&gt;的set</span><br><span class="line">   set&lt;int, greater&lt;int&gt; &gt; setb;	 //创建一个大于比较器的set，需包含头文件functional</span><br><span class="line">   int a[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">   set&lt;int &gt; setc(a,a+5);		 //数组a初始化一个set；</span><br><span class="line">   set&lt;int &gt; setd(setc.begin(),setc.end()); 	//setc初始化一个set</span><br><span class="line">   //上述两例均为区间初始化</span><br><span class="line">   set&lt;int &gt; sete(setd); 		//拷贝构造创建set</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>set容器的增删改查</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">set&lt;int &gt;s;</span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">- 插入</span><br><span class="line">s.insert(2);  //把2插入到集合中</span><br><span class="line">s.insert(2); //set只允许用一个值出现一次，要插入相同元素请用	multiset</span><br><span class="line">   /*</span><br><span class="line">   </span><br><span class="line">   定义multiset对象的示例代码如下：</span><br><span class="line">multiset&lt;int&gt; s;</span><br><span class="line">multiset&lt;double&gt; ss;</span><br><span class="line">multiset和set的基本操作相似，需要注意的是，集合的count()能返回0（无）或者		1（有），而多重集合是有多少个返回多少个。</span><br><span class="line">   </span><br><span class="line">   */</span><br><span class="line">int a[4] = &#123;11,12,13,14&#125;;</span><br><span class="line">s.insert(a,a+4); //将区间[a, a+4]里的元素插入容器</span><br><span class="line"></span><br><span class="line">- 删除   </span><br><span class="line">s.erase(2)       //删除2这个元素</span><br><span class="line">s.clear()       //删除set容器中的所有的元素</span><br><span class="line">set&lt;int&gt;::iterator ita = s.begin();</span><br><span class="line">set&lt;int&gt;::iterator itb = s.begin();</span><br><span class="line">s.erase(ita);  	   //删除迭代器指向位置的元素</span><br><span class="line">ita = s.begin();</span><br><span class="line">  itb = s.begin();</span><br><span class="line">  itb++; itb++;</span><br><span class="line">  s.erase(ita,itb);  //删除区间[ita,itb]的元素</span><br><span class="line"></span><br><span class="line">- 修改</span><br><span class="line">不能直接修改容器内数据，所以只能删除某元素再插入要修改的数值。</span><br><span class="line"></span><br><span class="line">- 查找</span><br><span class="line">s.find()        查找一个元素，如果容器中不存在该元素，返回值等于s.end()</span><br><span class="line">if(s.find(2) != s.end()) </span><br><span class="line"> 	      cout &lt;&lt; &quot;2 is existent&quot; &lt;&lt; endl;</span><br><span class="line">	   else </span><br><span class="line">        cout &lt;&lt; &quot;2 is non-existent&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>set的其他常用操作<br>s.lower_bound() 返回<em>第一个大于或等于给定关键值</em>的元素<br>s.upper_bound() 返回<em>第一个大于给定关键值</em>的元素<br>s.equal_range() 返回一对定位器，分别表示 <em>第一个大于或等于给定关键值的元素 和 第一个大于给定关键值的元素</em>，**这个返回值是一个pair类型，如果这一对定位器中只要有一个返回失败，就会等于s.end()  **</li>
</ol>
<p><strong>lower_bound()；upper_bound()的使用原则为，数组有序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> cout &lt;&lt; &quot;equal_range test:&quot; &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; &quot;第一个大于或等于2的元素: &quot; &lt;&lt;  *s.equal_range(2).first &lt;&lt; endl;</span><br><span class="line"> cout &lt;&lt; &quot;第一个大于2的元素: &quot; &lt;&lt; *s.equal_range(2).second &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  其他方法：</span><br><span class="line">s.size() 　　　　返回当前set容器中的元素个数</span><br><span class="line">s.empty() 　　　 判断set容器是否为空</span><br><span class="line">   </span><br><span class="line"> 判断元素是否在set中 &amp; 判断set是否为空</span><br><span class="line"> if(s.empty()) cout &lt;&lt; &quot;容器为空&quot; &lt;&lt; endl;</span><br><span class="line"> s.insert(1);</span><br><span class="line"> if(!s.empty()) cout &lt;&lt; &quot;容器不为空&quot; &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> if(s.count(1)) cout &lt;&lt; &quot;1在容器中&quot; &lt;&lt; endl;</span><br><span class="line"> if(!s.count(2)) cout &lt;&lt; &quot;2不在容器中&quot; &lt;&lt; endl;</span><br><span class="line"> //集合的count()能返回0（无）或者1（有）</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>自定义比较函数<br> （1）当set中存储的数据，需要按自定义的规则进行比较大小时：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> //定义比较函数，这地方还有点不懂？？？</span><br><span class="line">struct cmp&#123;</span><br><span class="line">    bool operator () (const int &amp;a, const int &amp;b)&#123;</span><br><span class="line">        return a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;int, cmp&gt;s; 		//自定义排序函数构造set</span><br><span class="line">void setprint(int cnt)&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Test output :&quot; &lt;&lt; cnt &lt;&lt; &quot;:&quot; &lt;&lt; endl;</span><br><span class="line">    for(set&lt;int,cmp&gt;::iterator it = s.begin(); it!= s.end(); it++)</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;   //这能够实现从大到小排列</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    s.insert(1);</span><br><span class="line">    s.insert(2);</span><br><span class="line">    s.insert(6);</span><br><span class="line">    setprint(1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）当set中存储的是自定义数据时，如结构体，类等。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   首先，在结构体中，增加“operator &lt;”函数</span><br><span class="line">   struct 结构体&#123;</span><br><span class="line">		bool operator &lt; (const 结构体类型 &amp;a)&#123;</span><br><span class="line">		……return（…）;</span><br><span class="line">		&#125;</span><br><span class="line"> &#125;;</span><br><span class="line">   然后，定义set</span><br><span class="line">set&lt;类型&gt; s；</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct non</span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    float score;</span><br><span class="line">    bool operator&lt; (const non &amp;a) const&#123;</span><br><span class="line">       //运算符重载，来按结构体中的分数从高到低排列</span><br><span class="line">        return a.score&lt;score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; STU; </span><br><span class="line">//要是不加typedef的话，STU应该是结构体的一个变量，否则STU为结构体的一个别名（要是不不用别名定义结构体的变量，应该struct non STU;即struct 结构体名 变量名这样声明 ，比较繁琐）。</span><br><span class="line">	 </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    set&lt;STU&gt; v;</span><br><span class="line">    STU s;   //因为STU是non这个结构体的别名，所以可以这样定义</span><br><span class="line">    s.name=&quot;Jack&quot;;</span><br><span class="line">    s.score=80.5;</span><br><span class="line">    v.insert(s);</span><br><span class="line">    s.name=&quot;Nacy&quot;;</span><br><span class="line">    s.score=60.5;</span><br><span class="line">    v.insert(s);</span><br><span class="line">    s.name=&quot;Tomi&quot;;</span><br><span class="line">    s.score=20;</span><br><span class="line">    v.insert(s);</span><br><span class="line">    set&lt;STU&gt;::iterator p;</span><br><span class="line">	 for(p=v.begin(); p!=v.end(); p++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;(*p).name&lt;&lt;&quot; : &quot;&lt;&lt;(*p).score&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">Jack : 80.5</span><br><span class="line">Nacy : 60.5</span><br><span class="line">Tomi : 20</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>实例：输入多个时间，对其排序</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">struct time</span><br><span class="line">&#123;</span><br><span class="line">    int hour;</span><br><span class="line">    int minute;</span><br><span class="line">    int second;</span><br><span class="line">    bool operator &lt; (const time &amp;a)const</span><br><span class="line">    &#123;</span><br><span class="line">        if(hour!=a.hour)</span><br><span class="line">            return(hour&lt;a.hour);</span><br><span class="line">        else if(minute!=a.minute)</span><br><span class="line">            return(minute&lt;a.minute);</span><br><span class="line">        else</span><br><span class="line">            return(second&lt;a.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ifstream fin(&quot;input.txt&quot;);</span><br><span class="line">    ofstream fout(&quot;output.txt&quot;);</span><br><span class="line">    set&lt;struct time&gt; s;</span><br><span class="line">    struct time t;</span><br><span class="line">    int n;</span><br><span class="line">    fin&gt;&gt;n;</span><br><span class="line">    for(int i=0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fin&gt;&gt;t.hour;</span><br><span class="line">	    fin.get();      //这句话的意思是什么,就是从文件流中获取到一个int类型的值</span><br><span class="line">        fin&gt;&gt;t.minute;</span><br><span class="line">	    fin.get();</span><br><span class="line">        fin&gt;&gt;t.second;</span><br><span class="line">        s.insert(t);</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;struct time&gt;::iterator it;</span><br><span class="line">    for(it=s.begin(); it!=s.end(); it++)</span><br><span class="line">        fout&lt;&lt;(*it).hour&lt;&lt;&quot;:&quot;&lt;&lt;(*it).minute&lt;&lt;&quot;:&quot;&lt;&lt;(*it).second&lt;&lt;endl;</span><br><span class="line">    fin.close();</span><br><span class="line">    fout.close();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="vector"><h3>
### vector

<p>1、vector创建<br>    vector是一个能够存放<strong>任意类型的动态数组</strong>，能够增加和压缩数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; v;</span><br><span class="line">//定义一个空的动态数组,存储int类型元素</span><br><span class="line">vector&lt;int&gt; v(5);</span><br><span class="line">//定义一个初始大小为5的动态数组(默认初始值都为0)，存储int类型元素</span><br><span class="line">vector&lt;int&gt; v(5,1);</span><br><span class="line">//定义一个初始大小为5的动态数组,赋值都为1，存储int类型元素</span><br></pre></td></tr></table></figure>
<p>2、基本操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    v[i]; // 以下标方式访问元素,很方便.</span><br><span class="line">    v.push_back(x); //往尾部插入元素x (常用）</span><br><span class="line">    v.insert(it, x); //向迭代器it指向的位置插入x,原位置后移 (蛮方便的，速度也快）。</span><br><span class="line">             //举例：v.insert(v.begin(),1); 比较神奇5w次这样的操作 大概0.5s，自己写的O(n)函数大概2.5s</span><br><span class="line">    v.size();//返回表长,注意是unsigned类型,如果v.size()为1，减去2就是一个很大的正整数数,看情况转(int)v.size()</span><br><span class="line">    v.begin(); // 返回指向首元素的迭代器 </span><br><span class="line">    v.end();    // 返回指向尾元素 下一个位置的 迭代器.</span><br><span class="line">    </span><br><span class="line">    v.front(); //取首元素的值 </span><br><span class="line">    v.back(); // 取尾元素的值</span><br><span class="line">    </span><br><span class="line">    v.empty(); //表为空返回真，否则返回假</span><br><span class="line">    v.clear(); //清空表中所有元素</span><br><span class="line">    v.pop_back(); // 删除表尾元素</span><br><span class="line">    v.erase(it); //删除迭代器it指向的元素</span><br><span class="line">    v.erase(st, ed); //删除迭代器st和ed指定的元素[st,ed) (左闭右开）</span><br><span class="line">    v.reserve(x); //预分配空间大小为x</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、排序方法sort<br>（sort的第三个参数是一个函数指针或一个函数对象，不写就使用默认（自己定义的结构体要排序必须要写比较规则） )</p>
<p>（1）默认或使用标准库函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一个参数：</span><br><span class="line"> 	vector&lt;int &gt;v;</span><br><span class="line">    sort(v.begin(), v.end());		 //默认，从小到大，升序排列</span><br><span class="line">    sort(v.begin(), v.end(), greater&lt;int&gt;()); 	//从大到小，降序排列</span><br><span class="line">    sort(v.begin(), v.end(), less&lt;int&gt;());		 // 从小到大，升序排列</span><br><span class="line"></span><br><span class="line"> 两个参数（不想写结构体的话可以用pair&lt;int,int&gt;)</span><br><span class="line"> vector&lt;pair&lt;int,int&gt; &gt;v;	 //pair实质上是一个结构体，其主要的两个成员变量是first和second</span><br><span class="line">    v.push_back(make_pair(3,4));	 //用make_pair来构造我们需要的pair.</span><br><span class="line">    v.push_back(make_pair(4,5));</span><br><span class="line">    sort(v.begin(), v.end()); 	//默认，按第一个数升序排列，若相同则按第二个数升序。</span><br><span class="line">    sort(v.begin(), v.end(), greater&lt;pair&lt;int,int&gt; &gt;()); 	//按第一个数降序排列，若相同按第二个数降序。</span><br><span class="line">    sort(v.begin(), v.end(), less&lt;pair&lt;int,int&gt; &gt;()); 	// 同默认，升序排列</span><br><span class="line">    cout &lt;&lt; v[0].first &lt;&lt; &quot; &quot; &lt;&lt; v[0].second; // 用v[i].first 和 v[i].second 取值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）自定义比较函数,多个参数的时候（常用）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">vector&lt;int&gt; v; </span><br><span class="line">bool cmp(int a, int b) &#123; // 比较函数</span><br><span class="line">    return a &gt; b; // 降序</span><br><span class="line">    // return a &lt; b; 升序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(v.begin(),v.end(), cmp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct test &#123;</span><br><span class="line">    int x,y;</span><br><span class="line">    test(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;test&gt; v;</span><br><span class="line">bool cmp(test a, test b) &#123;</span><br><span class="line">    return a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line">int main(void ) &#123;</span><br><span class="line">    v.push_back(test(1,2)); 	//写个构造函数方便很多.</span><br><span class="line">    v.push_back(test(3,4));</span><br><span class="line">    sort(v.begin(), v.end(), cmp);</span><br><span class="line">    cout &lt;&lt; v[0].x &lt;&lt; endl; 	// 结果为3</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）重载结构体或类的比较运算符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//情况一：在结构体内部重载</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct test &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    test(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">    friend bool operator &lt; (test a, test b) &#123;</span><br><span class="line">        return a.x &gt; b.x; //按x降序排序</span><br><span class="line">    &#125;</span><br><span class="line">  /*或(也可以加上const &amp;更规范，比如在第三个参数写less&lt;test&gt;()时，必须按标准格式写）</span><br><span class="line">    bool operator &lt; (const test &amp;a)const &#123;</span><br><span class="line">        return x &gt; a.x; //按x降序排序</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;test&gt; v;</span><br><span class="line">int main(void ) &#123;</span><br><span class="line">    v.push_back(test(1,2)); 	//写个构造函数pb时方便很多.</span><br><span class="line">    v.push_back(test(3,4)); 	</span><br><span class="line">    sort(v.begin(), v.end()); 	//不用写第三个参数</span><br><span class="line">    cout &lt;&lt; v[0].x &lt;&lt; endl;	 	// 结果为3</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//情况二：在外部重载</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct test &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    test(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bool operator &lt; (test a,test b) &#123; 	//写在外面就不要friend了，参数要写全,更规范就写const &amp;</span><br><span class="line">    return a.x &gt; b.x; 	//按x降序排序</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;test&gt; v;</span><br><span class="line">int main(void ) &#123;</span><br><span class="line">    v.push_back(test(1,2)); 	//写个构造函数pb时方便很多.</span><br><span class="line">    v.push_back(test(3,4)); 	</span><br><span class="line">    sort(v.begin(), v.end()); 	//不用写第三个参数</span><br><span class="line">    cout &lt;&lt; v[0].x &lt;&lt; endl; 	// 结果3</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4） 补充下重载pair，写在全局里无效，主要原因是不在一个namespace中，是先在同名字空间下里找，没找到才会外面找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define pb push_back   //少写点字的作用</span><br><span class="line">#define mp make_pair</span><br><span class="line">namespace std &#123;</span><br><span class="line">    bool operator &lt; (const pair&lt;int,int&gt; &amp;a, const pair&lt;int,int&gt; &amp;b) &#123;</span><br><span class="line">        return a.first &gt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator &gt; (const pair&lt;int,int&gt; &amp;a, const pair&lt;int,int&gt; &amp;b) &#123;</span><br><span class="line">        return a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;pair&lt;int,int&gt; &gt; v;</span><br><span class="line">int main() &#123;</span><br><span class="line">    v.pb(mp(1, 2));</span><br><span class="line">    v.pb(mp(3, 4));</span><br><span class="line">    sort(v.begin(),v.end());</span><br><span class="line">     cout &lt;&lt; v[0].first &lt;&lt; endl; 	// 结果为3</span><br><span class="line">    sort(v.begin(),v.end(), greater&lt;pair&lt;int,int&gt; &gt;());</span><br><span class="line">    cout &lt;&lt; v[0].first &lt;&lt; endl; 	// 结果为1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  （5）使用仿函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">struct test &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">    test(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;test&gt; v;</span><br><span class="line">struct cmp &#123;</span><br><span class="line">    //const 这里编译没有约束，但是对于明确的不可变参加上更严谨,上面的我有的没写，可以比较。</span><br><span class="line">    bool operator() (const test &amp;a, const test &amp;b) &#123;</span><br><span class="line">        return  a.x &gt; b.x; // 按x降序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main(void ) &#123;</span><br><span class="line">    v.push_back(test(1,2)); //写个构造函数pb时方便很多.甚至可以</span><br><span class="line">    v.push_back(test(3,4)); //用的多了，手速狗可以 #define pb pusb_back</span><br><span class="line">    sort(v.begin(), v.end(), cmp()); //传入函数对象.</span><br><span class="line">    cout &lt;&lt; v[0].x &lt;&lt; endl; // 3</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  4、  其他常用<br>  （1）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">swap(v[1], v[2]); //交换元素.</span><br><span class="line">reverse(v.begin(), v.end()); //反转1234 -&gt; 4321</span><br><span class="line"></span><br><span class="line">*max_element(v.begin(), v.end()); //找表里最大的数</span><br><span class="line">（max_element返回的是迭代器，所以输出值的话要在前面加 *,即取指针的值）</span><br><span class="line">*min_element(v.begin(), v.end()); //找表里最小的数</span><br><span class="line">这两个函数还可以用于 vector&lt;int&gt; 或者 vector&lt;string&gt;  ，也可以用于结构体vector或者结构体数组，他们 **默认** 是从小到大排列，所以要加上第三个参数cmp的话（比如从大到小排列，那么max_element返回的就是最小的那个）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lower_bound(v.begin(), v.end(), x) - v.begin(); //二分法找第一个 大于等于x的下标</span><br><span class="line">upper_bound(v.begin(), v.end(), x) - v.begin(); //二分法找第一个 大于x的下标</span><br><span class="line"></span><br><span class="line">v.erase(unique(v.begin(), v.end()), v.end());//去重，1220330770.结果是1203070。一般是排序、去重、离散化时用到.</span><br><span class="line">vector &lt;pair&lt;int,int&gt; &gt;E[maxn]; // 一种建图思路.E[i][j] i为源点,E[i][j].first为第j条边终点， .second为距离  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2)max_element实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct node &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp1(node a, node b) &#123;</span><br><span class="line">    return a.x &gt; b.x;</span><br><span class="line">    //从大到小排列，即降序排列</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    vector&lt;int&gt; v(3);</span><br><span class="line">    int arr[4];</span><br><span class="line">        int arr1[2][4];</span><br><span class="line">    vector&lt;node&gt; v1(3);</span><br><span class="line">    cout &lt;&lt; *max_element(v.begin(), v.end());</span><br><span class="line">    cout &lt;&lt; *min_element(arr, arr + 4);</span><br><span class="line">        cout &lt;&lt; *min_element(&amp;arr1[0][0], &amp;arr1[2][4]);</span><br><span class="line">        //是求arr1[0][0],到arr1[2][4]这个区间内的最大值</span><br><span class="line">    cout &lt;&lt; (*max_element(v1.begin(), v1.end(), cmp1)).y;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std; </span><br><span class="line">struct node &#123;</span><br><span class="line">    int x, y;</span><br><span class="line">&#125;;</span><br><span class="line">bool cmp1(node a, node b) &#123;</span><br><span class="line">    return a.x &gt; b.x;</span><br><span class="line">    //从大到小排列，即降序排列</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;node&gt; v1(3);</span><br><span class="line">    for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">        cin&gt;&gt;v1[i].x&gt;&gt;v1[i].y;</span><br><span class="line">    &#125;   </span><br><span class="line">    cout &lt;&lt; (*max_element(v1.begin(), v1.end(), cmp1)).y;</span><br><span class="line">    return 0;</span><br><span class="line">  这样的话会输出结构体中y值最小的那个结构体的y；因为max_element是相对于从小到大顺序排列的最下面的那个值，但是本题中加入了cmp1，就会输出最下面那个最小的值。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="stack"><h3>

<h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>1、定义：<br>　　  <strong>堆栈是一个线性表，插入和删除只在表的一端进行</strong>。这一端称为栈顶，另一端称为栈底。堆栈的元素插入称为入栈，元素的删除则为出栈。  <strong>元素的入栈和出栈总在栈顶进行，因此，堆栈是一个后进先出(Last In First Out)表，即 LIFO 表。</strong><br>　　  <strong>C++ STL 的堆栈泛化是直接通过现有的序列容器来实现的，默认使用双端队列deque的数据结构</strong>，当然，可以采用其他线性结构（vector 或 list等），只要提供堆栈的入栈、出栈、栈顶元素访问和判断是否为空的操作即可。由于堆栈的底层使用的是其他容器，因此，堆栈可看做是一种适配器，将一种容器转换为另一种容器(堆栈容器)。<br>　　为了严格遵循堆栈的数据后进先出原则，<strong>stack 不提供元素的任何迭代器操作</strong>，因此，stack 容器也就不会向外部提供可用的前向或反向迭代器类型。<br>2、常见用法：<br>（1）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认构造函数，创建一个空的stack对象： stack&lt;int&gt; s;     </span><br><span class="line">复制构造函数，用一个 stack 堆栈创建一个新的堆栈。  stack(const stack&amp;)</span><br></pre></td></tr></table></figure>

<p>    例如，下面的代码利用 s1 ，创建一个以双向链表为底层容器的空堆栈对象 s2 。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int, list&lt;int&gt; &gt;   s1;</span><br><span class="line">stack&lt;int, list&lt;int&gt; &gt;   s2(s1);</span><br></pre></td></tr></table></figure>

<p>（2）  元素入栈<br>在栈顶添加元素   void push(const value_type&amp; x)<br>　　由于c++ STL的堆栈函数是不预设大小的。<strong>因此，入栈函数就不考虑堆栈空间是否为满，均将元素压入堆栈，从而函数没有标明入栈成功与否的返回值。</strong><br>(3) 移除栈顶元素<br>　　stack容器的元素出栈函数为 pop 函数，由于函数并没有判断堆栈是否为空，才进行元素的弹出，<strong>因此，需要自行判断堆栈是否为空，才可执行 pop 函数。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void pop()   //这不会返回栈顶元素，只是移除栈顶元素 </span><br><span class="line">    下面的示例代码，将堆栈的所有元素全部出栈</span><br><span class="line">    stack&lt;int&gt;  s;</span><br><span class="line">    while(!s.empty())&#123;    //  bool  empty() 判断堆栈是否为空，返回 true 表示堆栈已空，false 表示堆栈非空。</span><br><span class="line">        s.pop();	// 出栈</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>  ( 4 )计算栈对象元素个数   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  size_type size()  const;</span><br><span class="line">  </span><br><span class="line">  stack 堆栈是不设最大容量的，如果自己定义了栈的容量，可以用这种方法在栈未满之前压入元素：</span><br><span class="line">  #define STACK_SIZE  100   	// 堆栈最大容量</span><br><span class="line">  if (s.size() &lt; STACK_SIZE)</span><br><span class="line">      s.push(68);</span><br><span class="line">~~~  </span><br><span class="line">  </span><br><span class="line">  (5)访问栈顶元素  ，** top（）是取栈顶元素，不会删掉栈里边的元素，pop（）是弹出栈顶元素，并且会删除栈顶元素。**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>value_type&amp; top();           //执行top不会弹出栈顶元素，只会读取
const value_type&amp; top() const;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3、实例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  #include <stack><br>  #include <list><br>  #include <iostream><br>  #define STACK_SIZE  100   &#x2F;&#x2F; 堆栈最大容量<br>  using namespace std;<br>  int main()<br>  {<br>      &#x2F;&#x2F; 用双向链表作堆栈的底层结构<br>      stack&lt;int, list<int> &gt;   s;<br>      &#x2F;&#x2F; 堆栈未满，元素才能入栈<br>      if (s.size() &lt; STACK_SIZE)<br>          s.push(68);<br>      if (s.size() &lt; STACK_SIZE)<br>          s.push(1);<br>      if (s.size() &lt; STACK_SIZE)<br>          s.push(17);<br>      &#x2F;&#x2F; 元素出栈<br>      while (!s.empty())<br>      {<br>          &#x2F;&#x2F; 打印 17 1 68<br>          cout &lt;&lt; s.top() &lt;&lt; endl;  &#x2F;&#x2F;这一句写成cout&lt;&lt;s.pop();是不可以的<br>          s.pop();    &#x2F;&#x2F;只是移除栈顶元素，不会返回栈顶元素的值<br>      }<br>      return 0;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">---</span><br><span class="line">&lt;h3 id=&quot;queue&quot;&gt;&lt;h3&gt;</span><br><span class="line">#### queue</span><br><span class="line">1、 用法：  </span><br><span class="line">　　queue表示的是队列的数据结构，是常用的数据结构之一。队列主要特点就是“先进先出”。 **在队尾添加元素，在队头删除元素。**  </span><br><span class="line"> 　　 **定义queue模板需要定义两个模版参数，一个是元素类型，一个是容器类型，元素类型是必要的，容器类型可选。**    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<pre><code>queue&lt;int&gt; q;
queue&lt;double&gt; qq;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2、基本函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  back()    返回一个引用，指向队列的最后一个元素。</p>
<p>  empty()   函数返回真(true)如果队列为空，否则返回假(false)。</p>
<p>  front()   返回队列第一个元素的引用。</p>
<p>  pop()    函数删除队列头部的一个元素，但不返回其值，（清空队列没有clear方法，用这个就行）</p>
<p>  push()    在队列末尾加入一个元素</p>
<p>  size()   返回队列中元素的个数<br>  那么我们如何判断队列是空队列还是已满呢？</p>
<pre><code>    a、栈空： 队首标志=队尾标志时，表示栈空。

    b、栈满 : 队尾+1 = 队首时，表示栈满。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3、 priority_queue  (优先队列)   </span><br><span class="line">　　在＜queue＞　头文件中，还定义了另一个非常有用的模版类priority_queue（优先队列）。**优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权出队列（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）。**   </span><br><span class="line">　　priority_queue模版类有三个模版参数，第一个是元素类型，第二个是容器类型，第三个是比较算子。**其中后两者都可以忽略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队列时列尾元素先出队）。**   </span><br><span class="line">(1)定义priority_queue对象的代码示例： </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  priority_queue<int> q;<br>  priority_queue&lt;pair&lt;int, int&gt; &gt; qq;   &#x2F;&#x2F;  注意在两个尖括号之间一定要留空格，防止误判，默认为less算子，此时大值先出队列<br>  priority_queue&lt;int, vector<int>, greater<int> &gt; qqq;    &#x2F;&#x2F;  greater算子，大值优先，但是队列从队尾出队，所以小值先出队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> (2)priority_queue的基本操作与queue的略微不同。   </span><br><span class="line">priority_queue的基本操作：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  q.empty()     &#x2F;&#x2F;  如果队列为空，则返回true，否则返回false<br>  q.size()      &#x2F;&#x2F;  返回队列中元素的个数<br>  q.pop()       &#x2F;&#x2F;  删除队首元素，但不返回其值<br>  q.top()       &#x2F;&#x2F;  返回具有最高优先级的元素值，但不删除该元素<br>  q.push(item)  &#x2F;&#x2F;  在 <em>基于优先级 的 适当位置</em> 插入新元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(3）如果是基本数据类型，或已定义了比较运算符的类，可以直接使用STL的less算子和greater算子——默认为使用less算子。如果要定义自己的比较算子，方法有多种。</span><br><span class="line">重载比较运算符方法。优先队列试图这两个元素x和y代入比较运算符（对于less算子（operator后面的&lt;，返回结果为真，就从小到大排列），调用x &lt; y，对于greater算子（operator后面的&gt;,返回结果为真就是从大到小），调用x &gt; y），若返回结果为真，则x排在y前面，y将先出队列，反之，则y排在x前面，x将先出队列（因为队尾先出队）。 </span><br><span class="line">如下算子示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>#include &lt;iostream&gt;
#include &lt;queue&gt;

using namespace std;

class T
&#123;
public:
    int x, y, z;
    T(int a, int b, int c) : x(a), y(b), z(c) &#123;&#125;
&#125;;

bool operator &lt; (const T &amp;tOne, const T &amp;tTwo)
&#123;
    return tOne.z &lt; tTwo.z;   //  按照z的顺序来决定tOne和tTwo的顺序
&#125;

int main()
&#123;
    priority_queue&lt;T&gt; q;
    q.push(T(4, 4, 3));
    q.push(T(2, 2, 5));
    q.push(T(1, 5, 4));
    q.push(T(3, 3, 6));

    while (!q.empty())
    &#123;
        T t = q.top();
        q.pop();
        cout &lt;&lt; t.x &lt;&lt; &quot; &quot; &lt;&lt; t.y &lt;&lt; &quot; &quot; &lt;&lt; t.z &lt;&lt; &#39;\n&#39;;
    &#125;
    return 0;
&#125;
输出结果为（注意是按照z的顺序从大到小出队列，因为less算子，然后队尾先出队）： 
3 3 6 
2 2 5 
1 5 4 
4 4 3
另外：如果想要按照z的顺序从小到大出队列，只需要改动比较运算符重载为：
bool operator &gt; (const T &amp;tOne, const T &amp;tTwo)
&#123;
    return tOne.z &gt; tTwo.z;  //  按照z的顺序来决定tOne和tTwo的顺序
&#125;
</code></pre>
<p>  对于自定义类型的数据进行排序：<br>    less算子，即默认算子为：大的往前排，小的往后排（出队时队列头的元素出队，即大者先出队）。（但是不放在优先队列里less算子从小到大排序）<br>    greater算子，即默认算子为：小的往前排，大的往后排（出队时队列头的元素出队，即小者先出队）。</p>
<p>  #include <iostream><br>  #include <queue><br>  using namespace std;</p>
<p>  &#x2F;&#x2F;方法1<br>  struct tmp1 &#x2F;&#x2F;运算符重载&lt;<br>  {<br>      int x;<br>      tmp1(int a) {x &#x3D; a;}<br>      bool operator&lt;(const tmp1&amp; a) const<br>      {&#x2F;&#x2F;自定义less算子，x &lt; a.x返回true，从小到大，队尾出队，所以从大到小出队<br>          return x &lt; a.x; &#x2F;&#x2F;从大到小出队<br>      }<br>  };</p>
<p>  &#x2F;&#x2F;方法2<br>  struct tmp2 &#x2F;&#x2F;重写仿函数（必须放在结构体中）<br>  {<br>      bool operator() (tmp1 a, tmp1 b)<br>      {<br>          return a.x &lt; b.x; &#x2F;&#x2F;从大到小出队<br>      }<br>  };</p>
<p>  int main()<br>  {<br>      tmp1 a(1);<br>      tmp1 b(2);<br>      tmp1 c(3);<br>      priority_queue<tmp1> d;<br>      d.push(b);<br>      d.push(c);<br>      d.push(a);<br>      while (!d.empty())<br>      {<br>          cout &lt;&lt; d.top().x &lt;&lt; ‘\n’;<br>          d.pop();<br>      }<br>      cout &lt;&lt; endl;</p>
<pre><code>  priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;
  f.push(c);
  f.push(b);
  f.push(a);
  while (!f.empty()) 
  &#123;
      cout &lt;&lt; f.top().x &lt;&lt; &#39;\n&#39;;
      f.pop();
  &#125;
</code></pre>
<p>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">４、循环队列   </span><br><span class="line">　　**以数组作为底层数据结构时，一般讲队列实现为循环队列。**这是因为队列在顺序存储上的不足：每次从数组头部删除元素（出队）后，需要将头部以后的所有元素往前移动一个位置，这是一个时间复杂度为O（n）的操作。   </span><br><span class="line">　　**可能有人说，把队首标志往后移动不就不用移动元素了吗？的确，但那样会造成数组空间的“流失”。**  </span><br><span class="line">　　我们希望队列的插入与删除操作都是O(1)的时间复杂度，同时不会造成数组空间的浪费，我们应该使用循环队列。  </span><br><span class="line">　　**定义：** *所谓的循环队列，可以把数组看出一个首尾相连的圆环，删除元素时将队首标志往后移动，添加元素时若数组尾部已经没有空间，则考虑数组头部的空间是否空闲，如果是，则在数组头部进行插入。*</span><br><span class="line"></span><br><span class="line">![upload successful](\aoyue\images\pasted-24.png)  </span><br><span class="line">那么我们如何判断队列是空队列还是已满呢？  </span><br><span class="line">栈空： 队首标志=队尾标志时，表示栈空，即红绿两个标志在图中重叠时为栈空。</span><br><span class="line">栈满 : 队尾+1 = 队首时，表示栈满。图的最下面的队列即为一个满队列。尽管还有一个空位，我们不存储元素。</span><br><span class="line">(１)判断循环队列是“空”还是“ 满”，有以下两种处理方法：  </span><br><span class="line">　　1）设置状态标志位以区别空还是满  </span><br><span class="line">　　2）少用一个元素，约定“队头front在队尾rear的下一个位置（指的是环的下一个位置）”作为“满”的标志  </span><br><span class="line">　　C语言中，不能用动态分配的一维数组来实现循环队列，如果用户的应用程序中设有循环队列，则必须为它设定一个最大队列长度；**如果用户无法预估所用队列的最大长度，则宜采用链队列。**  </span><br><span class="line">　　*定义front为队列头元素的位置，rear为队列尾元素的位置，MAXSIZE为循环队列的最大长度。*注意以下几点，循环队列迎刃而解：  </span><br><span class="line">　　1）求元素的个数：(rear - front + MAXSIZE) % MAXSIZE  </span><br><span class="line">　　2）rear指向逻辑的下一个空间;  front =（front+1)%MAXSIZE ，rear = (rear+1)%MAXSIZE     ？？对maxsize取余的意义何在？？  </span><br><span class="line">　　3）判空：front == rear  </span><br><span class="line">　　4）判满：(rear+1+MAXSZIE) == front  </span><br><span class="line">　　5)循环队列中判断队空的方法是判断front==rear，队满的方法是判断front=（rear+1）%MAXSIZE。（为什么不用一个length表示队长，当length==maxSize时表示队满，原因就是，在频繁的队列操作中，多出一个变量会大量的增加执行时间，所以不如浪费一个数组空间来得划算。）</span><br><span class="line">(２)循环队列的c++实现：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <queue><br>  #include <string><br>  using namespace std;</p>
<p>  template <typename T><br>  class LoopQueue<br>  {<br>  public:<br>      LoopQueue(int c &#x3D; 10);<br>      ~LoopQueue();<br>      bool isEmpty();        &#x2F;&#x2F;队列的判空<br>      int size();            &#x2F;&#x2F;队列的大小<br>      bool push(T t);        &#x2F;&#x2F;入队列<br>      bool pop();            &#x2F;&#x2F;出队列<br>      T front();            &#x2F;&#x2F;队首元素</p>
<p>  private:<br>      int capacity;<br>      int begin;<br>      int end;<br>      T*  queue;<br>  };</p>
<p>  template<typename T><br>  LoopQueue<T>::LoopQueue(int c &#x3D; 10)<br>      :capacity(c), begin(0), end(0), queue(nullptr)<br>  {<br>      queue &#x3D; new T[capacity];<br>  };</p>
<p>  template<typename T><br>  LoopQueue<T>::~LoopQueue()<br>  {<br>      delete[]queue;<br>  }</p>
<p>  template <typename T><br>  bool LoopQueue<T>::isEmpty()                   &#x2F;&#x2F;判断循环队列是否为空<br>  {<br>      if (begin &#x3D;&#x3D; end)<br>          return true;<br>      return false;<br>  };</p>
<p>  template<typename T><br>  int LoopQueue<T>::size()<br>  {<br>      return (end - begin + capacity) % capacity; &#x2F;&#x2F;计算循环队列的长度<br>  };</p>
<p>  template<typename T><br>  bool LoopQueue<T>::push(T t)<br>  {<br>      if (end + 1 % capacity &#x3D;&#x3D; begin)            &#x2F;&#x2F;判断队列是否已满<br>      {<br>          return false;<br>      }<br>      queue[end] &#x3D; t;<br>      end &#x3D; (end + 1) % capacity;<br>      return true;<br>  };</p>
<p>  template <typename T><br>  bool LoopQueue<T>::pop()                        &#x2F;&#x2F;判断队列是否为空<br>  {<br>      if (end &#x3D;&#x3D; begin)<br>      {<br>          return false;<br>      }<br>      begin &#x3D; (begin + 1) % capacity;<br>      return true;<br>  };</p>
<p>  template <typename T><br>  T LoopQueue<T>::front()<br>  {<br>      if (end &#x3D;&#x3D; begin)<br>      {<br>          return false;<br>      }<br>      return queue[begin];<br>  };</p>
<p>  int main()  &#x2F;&#x2F;测试代码<br>  {<br>      LoopQueue<string> queue(6);<br>      queue.push(“one”);<br>      queue.push(“two”);<br>      queue.push(“three”);<br>      queue.push(“four”);<br>      queue.push(“five”);<br>      cout &lt;&lt; “队列长度” &lt;&lt; queue.size() &lt;&lt; endl;<br>      while (!queue.isEmpty())<br>      {<br>          cout &lt;&lt; queue.front() &lt;&lt; endl;<br>          queue.pop();<br>      }<br>      getchar();<br>      &#x2F;&#x2F;system(“pause”);<br>      return 0;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">5、链队列  </span><br><span class="line">　　**链队列是基于链表实现的队列，它不存在数组的O（n）的元素移动问题或空间浪费问题。**我们所要确定的就是链表哪头做队首，哪头做队尾。  </span><br><span class="line">　　(1)*显然我们应该以链表头部为队首，链表尾部为队尾。存储一个指向队尾的指针，方便**从链表尾插入元素**；使用带头节点的链表，方便**从链表头删除元素。** *</span><br><span class="line">  </span><br><span class="line">![upload successful](\aoyue\images\pasted-25.png)</span><br><span class="line"></span><br><span class="line">       用单链表表示的链式队列特别适合于数据元素变动较大的情形，而且不存在溢出的情况。</span><br><span class="line"></span><br><span class="line">(2)代码实现：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  template<typename T><br>  struct Node<br>  {<br>      Node(T t) :value(t), next(nullptr){}<br>      Node() &#x3D; default;<br>      T value;                &#x2F;&#x2F;vaule : 链表节点的值<br>      Node<T> * next;        &#x2F;&#x2F;next : 指针，指向下一个节点<br>  };</p>
<p>  template<typename T><br>  class LinkQueue<br>  {<br>  public:<br>      LinkQueue();<br>      ~LinkQueue();</p>
<pre><code>  bool isEmpty();
  int size();
  bool pop();
  void push(T t);
  T front();
</code></pre>
<p>  private:<br>      Node<T>* phead;<br>      Node<T>* pend;<br>      int count;<br>  };<br>  template<typename T><br>  LinkQueue<T>::LinkQueue()<br>      :phead(nullptr),pend(nullptr),count(0)<br>  {<br>      phead &#x3D; new Node<T>();<br>      pend &#x3D; phead;<br>      count &#x3D; 0;<br>  };</p>
<p>  template <typename T><br>  LinkQueue<T>::~LinkQueue()<br>  {<br>      while (phead-&gt;next !&#x3D; nullptr)<br>      {<br>          Node<T> * pnode &#x3D; phead;<br>          phead &#x3D; phead-&gt;next;<br>      }<br>  };</p>
<p>  template <typename T><br>  bool LinkQueue<T>:: isEmpty()<br>  {<br>      return count&#x3D;&#x3D;0;<br>  };</p>
<p>  template <typename T><br>  int LinkQueue<T>::size()<br>  {<br>      return count;<br>  };</p>
<p>  &#x2F;&#x2F;在队尾插入<br>  template <typename T><br>  void LinkQueue<T>::push(T t)<br>  {<br>      Node<T>* pnode &#x3D; new Node<T>(t);<br>      pend-&gt;next &#x3D; pnode;<br>      pend &#x3D; pnode;<br>      count++;<br>  };</p>
<p>  &#x2F;&#x2F;在队首弹出<br>  template <typename T><br>  bool LinkQueue<T>::pop()<br>  {<br>      if (count &#x3D;&#x3D; 0)<br>          return false;<br>      Node<T>* pnode &#x3D; phead-&gt;next;<br>      phead-&gt;next &#x3D; phead-&gt;next-&gt;next;<br>      delete pnode;<br>      count–;<br>      return true;<br>  };</p>
<p>  &#x2F;&#x2F;获取队首元素<br>  template<typename T><br>  T LinkQueue<T>::front()<br>  {<br>      return phead-&gt;next-&gt;value;<br>  };</p>
<p>  int _tmain(int argc, _TCHAR* argv[])<br>  {<br>      LinkQueue<string> lqueue;<br>      lqueue.push(“one”);<br>      lqueue.push(“two”);<br>      lqueue.push(“three”);<br>      lqueue.push(“four”);<br>      lqueue.push(“five”);<br>      cout &lt;&lt; “队列的大小” &lt;&lt; lqueue.size() &lt;&lt; endl;<br>      while (!lqueue.isEmpty())<br>      {<br>          cout &lt;&lt; lqueue.front() &lt;&lt; endl;<br>          lqueue.pop();<br>      }<br>      getchar();<br>      return 0;<br>  }</p>
<p>  运行结果：<br>  队列的大小5<br>  one<br>  two<br>  three<br>  four<br>  five</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">&lt;h3 id=&quot;map&quot;&gt;&lt;h3&gt;</span><br><span class="line">#### map</span><br><span class="line">1、 Map是c++的一个标准容器，它提供了很好的一对一的关系，在一些程序中建立一个map可以起到事半功倍的效果。   </span><br><span class="line">　　在STL的头文件中＜map＞中定义了模版类map和multimap，用有序二叉树表存储类型为pair&lt;const Key, T&gt;的元素对序列。　**序列中的元素以const Key部分作为标识，map中所有元素的Key值必须是唯一的，multimap则允许有重复的Key值。**  </span><br><span class="line">2、定义map对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>map&lt;int,string&gt;m;
 typedef map&lt;int,string&gt; MAP;  // 这时候可以用MAP来声明一个        int，string类型的对象，例如：MAP m；这和map&lt;int,string&gt;m;等价
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3、map的基本操作：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  &#x2F;*  向map中插入元素  <em>&#x2F;<br>  m[key] &#x3D; value;         &#x2F;&#x2F;  [key]操作是map很有特色的操作,如果在map中存在键值为key的元素对, 则返回该元素对的</em>值域部分*,<em>否则将会创建一个键值为key的元素对,值域为默认值。</em>所以可以用该操作向map中插入元素对或修改已经存在的元素对的值域部分。<br>  m.insert(make_pair(key, value));    &#x2F;&#x2F;  也可以直接调用insert方法插入元素对,insert操作会返回一个pair,当map中没有与key相匹配的键值时,其first是指向插入元素对的迭代器,其second为true;若map中已经存在与key相等的键值时,其first是指向该元素对的迭代器,second为false。</p>
<p>  &#x2F;*  查找元素  *&#x2F;<br>  int i &#x3D; m[key];     &#x2F;&#x2F;  要注意的是,当与该键值相匹配的元素对不存在时,会创建键值为key（当另一个元素是整形时，m[key]&#x3D;0）的元素对。<br>  map&lt;string, int&gt;::iterator it &#x3D; m.find(key);    &#x2F;&#x2F;  如果map中存在与key相匹配的键值时,find操作将返回指向该元素对的迭代器,<em>否则,返回的迭代器等于map的end()</em>(参见vector中提到的begin()和end()操作)。<br>  map.count(k);   &#x2F;&#x2F;返回map中键k的出现次数(对于map而言，由于一个key对应一个value，因此返回只有0和1，因此可以用此函数判断k是否在map中)</p>
<p>  &#x2F;*  删除元素  *&#x2F;<br>  m.erase(key);   &#x2F;&#x2F;  删除与指定key键值相匹配的元素对,并返回被删除的元素的个数。<br>  m.erase(it);    &#x2F;&#x2F;  删除由迭代器it所指定的元素对,并返回指向下一个元素对的迭代器。</p>
<p>  &#x2F;*  其他操作  *&#x2F;<br>  m.size();       &#x2F;&#x2F;  返回元素个数<br>  m.empty();      &#x2F;&#x2F;  判断是否为空<br>  m.clear();      &#x2F;&#x2F;  清空所有元素<br>  m1.swap(m2);   &#x2F;&#x2F;m1,m2两个容器互换，Map中的swap不是一个容器中的元素交换，而是两个容器交换；<br>  Map中的元素是自动按key升序排序,所以不能对map用sort函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4、实例：  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <map></p>
<p>  using namespace std;</p>
<p>  typedef map&lt;int, string, less<int> &gt; M_TYPE<br>  typedef M_TYPE::iterator M_IT<br>  typedef M_TYPR::const_iterator M_CIT</p>
<p>  int main()<br>  {<br>      M_TYPR myTestMap;</p>
<pre><code>  myTestMap[3] = &quot;No.3&quot;;
  myTestMap[5] = &quot;No.5&quot;;
  myTestMap[1] = &quot;No.1&quot;;
  myTestMap[2] = &quot;No.2&quot;;
  myTestMap[4] = &quot;No.4&quot;;

  M_IT itStop = myTestMap.find(2);

  cout &lt;&lt; &quot;myTestMap[2] = &quot; &lt;&lt; itStop-&gt;second &lt;&lt; endl;
  itStop-&gt;second = &quot;No.2 After modification&quot;;
  cout &lt;&lt; &quot;myTestMap[2] = &quot; &lt;&lt; itStop-&gt;second &lt;&lt; endl;
  cout &lt;&lt; &quot;Map contents:&quot; &lt;&lt; endl;

  for (M_CIT it = myTestMap.begin(); it != myTestMap.end(); it++)
  &#123;
      cout &lt;&lt; it-&gt;second &lt;&lt; endl;
  &#125;
  return 0;
</code></pre>
<p>  }</p>
<p>  程序执行的输出结果为：<br>  MyTestMap[2] &#x3D; No.2<br>  MyTestMap[2] &#x3D; No.2 After modification Map contents :<br>  No.1<br>  No.2 After modification<br>  No.3<br>  No.4<br>  No.5</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;h3 id=&quot;bitset&quot;&gt;&lt;h3&gt;</span><br><span class="line">#### bitset</span><br><span class="line">1、在 STL 的头文件中＜bitset＞中定义了模版类 bitset，用来方便地管理一系列的 bit　位的类。bitset 除了可以访问指定下标的 bit 位以外，还可以把它们作为一个整数来进行某些统计。  </span><br><span class="line">2、定义bitset时，要明确bitset有多少位：  </span><br><span class="line">bitset&lt;32&gt; bitvec     // 32位二进制，初始化为0，0~31  </span><br><span class="line">**当用unsigned 值初始化bitset 对象时，该值将转化为二进制的位模式。**如果bitset类型长度大于 unsigned 值的二进制位数，则其余的高阶位将置为0；如果bitset 类型长度小于unsigned 值的二进制位数，则只使用unsigned值中的低阶位，超过bitset类型长度的高阶位将被丢弃。</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>   例如：<br>  bitset&lt;16&gt; bit ( 0xFFFF )              &#x2F;&#x2F; 0<del>15位都置1<br>  bitset&lt;32&gt; bit ( 0xFFFF )              &#x2F;&#x2F; 0</del>15位置1，16~31位置0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3、https://blog.csdn.net/ACM_10000h/article/details/40951033</span><br><span class="line">https://blog.csdn.net/chaiwenjun000/article/details/71154235</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">&lt;h3 id=&quot;iterator&quot;&gt;&lt;h3&gt;</span><br><span class="line">#### iterator</span><br><span class="line">1、iterator（迭代器）是用于访问容器中元素的指示器，从这个意义上说，iterator（迭代器）相当于数据结构中所说的“遍历指针”，也可以把iterator（迭代器）看作是一种泛化的指针。**每种STL容器都有自己的iterator（迭代器）子类**  </span><br><span class="line">**定义：迭代器是一种检查容器内元素并遍历元素的数据类型。 </span><br><span class="line">迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围。**  </span><br><span class="line">- 迭代器和指针的区别：   </span><br><span class="line">容器和string有迭代器类型同时拥有返回迭代器的成员。如：容器有成员begin和end,其中begin成员复制返回指向第一个元素的迭代器，**而end成员返回指向容器尾元素的下一个位置的迭代器，也就是说end指示的是一个不存在的元素，所以end返回的是尾后迭代器。**</span><br><span class="line"></span><br><span class="line">2、简单的说，STL中有以下几类iterator（迭代器）：   </span><br><span class="line">输入iterator（迭代器），在容器的连续区内向前移动，可以读取容器内任意值；   </span><br><span class="line">输出iterator（迭代器），把值写进它所指向的容器中；   </span><br><span class="line">前向iterator（迭代器），读取队列中的值，并可以向前移动到下一个位置(++p, p++)；   </span><br><span class="line">双向iterator（迭代器），读取队列中的值，并可以向前后遍历容器；随机访问向iterator（迭代器），可以直接以下标方式对容器进行访问，vector的iterator（迭代器）就是这种iterator（迭代器）； *插入和删除所花费的时间是固定的，与位置无关。*    </span><br><span class="line">流iterator（迭代器），可以直接输入、输出流中的值； </span><br><span class="line"></span><br><span class="line">![upload successful](\aoyue\images\pasted-26.png)</span><br><span class="line">1）随机访问：提供了对数组元素进行快速随机访问以及在序列尾部进行快速插入和删除操作。   </span><br><span class="line">2）双向访问：插入和删除所花费的时间是固定的，与位置无关。  </span><br><span class="line"></span><br><span class="line">![upload successful](\aoyue\images\pasted-27.png)</span><br><span class="line"></span><br><span class="line">![upload successful](\aoyue\images\pasted-28.png)</span><br><span class="line"></span><br><span class="line">3、**当用iterator删除容器中元素时，该迭代器会失效，或者当改变了容器的内存分配时，所有相关的迭代器都会失效。**  </span><br><span class="line">4、实例：    </span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <vector><br>  using namespace std;</p>
<p>  int main()<br>  {<br>      vector<int> s;<br>      for (int i &#x3D; 0; i &lt; 10; i++)<br>      {<br>          s.push_back(i);<br>      }<br>      for (vector<int>::iterator it &#x3D; s.begin(); it !&#x3D; s.end(); it++)<br>      {<br>          cout &lt;&lt; *it &lt;&lt; “ “;<br>      }<br>      cout &lt;&lt; ‘\n’;<br>      return 0;<br>  }<br>  &#x2F;&#x2F;vector的begin()和end()方法都会返回一个vector::iterator对象，分别指向vector的首元素位置和尾元素的下一个位置（我们可以称之为结束标志位）。</p>
<p>  #include <iostream><br>  #include <vector><br>  using namespace std;</p>
<p>  int main()<br>  {<br>      vector<int> s;<br>      s.push_back(1);<br>      s.push_back(2);<br>      s.push_back(3);<br>      copy(s.begin(), s.end(), ostream_iterator<int> (cout, “ “));<br>      &#x2F;&#x2F;这段代码中的copy就是STL中定义的一个模版函数，copy(s.begin(), s.end(), ostream_iterator<int>(cout, ” “));的意思是将由s.begin()至s.end()（不含s.end()）所指定的序列复制到标准输出流out中，用” “作为每个元素的间隔。也就是说，这句话的作用其实就是将表中的所有内容依次输出。<br>      cout &lt;&lt; ‘\n’;<br>      return 0;<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">---</span><br><span class="line">&lt;h3 id=&quot;algorithm&quot;&gt;&lt;h3&gt;</span><br><span class="line">#### algorithm</span><br><span class="line">1、for_each遍历容器</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <vector><br>  #include <algorithm></p>
<p>  using namespace std;</p>
<p>  int visit(int v)    &#x2F;&#x2F;  遍历算子函数<br>  {<br>      cout &lt;&lt; v &lt;&lt; “ “;<br>      return 1;<br>  }</p>
<p>  class multInt       &#x2F;&#x2F;  定义遍历算子类<br>  {<br>  private:<br>      int factor;<br>  public:<br>      multInt(int f) : factor(f) {}    &#x2F;&#x2F;这是构造函数，给factor赋值的</p>
<pre><code>  void operator() (int &amp;elem) const
  &#123;
      elem *= factor;
  &#125;
</code></pre>
<p>  };</p>
<p>  int main()<br>  {<br>      vector<int> L;<br>      for (int i &#x3D; 0; i &lt; 10; i++)<br>      {<br>          L.push_back(i);<br>      }<br>      for_each(L.begin(), L.end(), visit);<br>      cout &lt;&lt; ‘\n’;<br>      for_each(L.begin(), L.end(), multInt(2));<br>      for_each(L.begin(), L.end(), visit);<br>      cout &lt;&lt; ‘\n’;</p>
<pre><code>  return 0;
</code></pre>
<p>  }<br>  程序输出结果为：<br>  0 1 2 3 4 5 6 7 8 9<br>  0 2 4 6 8 10 12 14 16 18</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2、min_element/max_element找出容器中的最小/最大值   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <vector><br>  #include <algorithm></p>
<p>  using namespace std;</p>
<p>  int main()<br>  {<br>      vector<int> L;<br>      for (int i&#x3D;0; i&lt;10; i++)<br>      {<br>          L.push_back(i);<br>      }<br>      vector<int>::iterator min_it &#x3D; min_element(L.begin(), L.end());<br>      vector<int>::iterator max_it &#x3D; max_element(L.begin(), L.end());<br>      cout &lt;&lt; “Min is “ &lt;&lt; *min_it &lt;&lt; endl;<br>      cout &lt;&lt; “Max is “ &lt;&lt; *max_it &lt;&lt; endl;</p>
<pre><code>  return 0;
</code></pre>
<p>  }<br>  程序的输出结果：<br>  Min is 0<br>  Max is 9</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">3、sort对容器进行排序    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <vector><br>  #include <algorithm></p>
<p>  using namespace std;</p>
<p>  void Print(vector<int> &amp;L)<br>  {<br>      for (vector<int>::iterator it &#x3D; L.begin(); it !&#x3D; L.end(); it++)<br>      {<br>          cout &lt;&lt; *it &lt;&lt; “ “;<br>      }<br>      cout &lt;&lt; endl;<br>      return ;<br>  }</p>
<p>  int main()<br>  {<br>      vector<int> L;<br>      for (int i &#x3D; 0; i &lt; 5; i++)<br>      {<br>          L.push_back(i);<br>      }<br>      for (int i &#x3D; 9; i &gt;&#x3D; 5; i–)<br>      {<br>          L.push_back(i);<br>      }<br>      Print(L);<br>      sort(L.begin(), L.end());<br>      Print(L);<br>      sort(L.begin(), L.end(), greater<int> ());  &#x2F;&#x2F;  按降序排序<br>      Print(L);</p>
<pre><code>  return 0;
</code></pre>
<p>  }<br>  程序的输出结果：<br>  0 1 2 3 4 9 8 7 6 5<br>  0 1 2 3 4 5 6 7 8 9<br>  9 8 7 6 5 4 3 2 1 0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4、copy在容器间复制元素   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <vector><br>  #include <algorithm></p>
<p>  using namespace std;</p>
<p>  int main()<br>  {<br>      &#x2F;&#x2F;  先初始化两个向量vOne和vTwo<br>      vector<int> vOne, vTwo;<br>      for (int i &#x3D; 0; i &lt;&#x3D; 5; i++)<br>      {<br>          vOne.push_back(10 * i);<br>      }<br>      for (int i &#x3D; 0; i &lt;&#x3D; 10; i++)<br>      {<br>          vTwo.push_back(3 * i);<br>      }</p>
<pre><code>  cout &lt;&lt; &quot;vOne = ( &quot;;
  for (vector&lt;int&gt;::iterator it = vOne.begin(); it != vOne.end(); it++)
  &#123;
      cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
  &#125;
  cout &lt;&lt; &quot;)&quot; &lt;&lt; &#39;\n&#39;;

  cout &lt;&lt; &quot;vTwo = ( &quot;;
  for (vector&lt;int&gt;::iterator it = vTwo.begin(); it != vTwo.end(); it++)
  &#123;
      cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
  &#125;
  cout &lt;&lt; &quot;)&quot; &lt;&lt; &#39;\n&#39;;

  //  将vOne的前三个元素复制到vTwo的中间（覆盖掉原来数据）
  copy(vOne.begin(), vOne.begin() + 3, vTwo.begin() + 4);

  cout &lt;&lt; &quot;vTwo with vOne insert = ( &quot; ;
  for (vector &lt;int&gt;::iterator it = vTwo.begin(); it != vTwo.end(); it++)
  &#123;
      cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
  &#125;
  cout &lt;&lt; &quot;)&quot; &lt;&lt; &#39;\n&#39;;

  //  在vTwo内部进行复制，注意参数2表示结束位置，结束位置不参与复制
  copy(vTwo.begin() + 4, vTwo.begin() + 7, vTwo.begin() + 2);

  cout &lt;&lt; &quot;vTwo with shifted insert = ( &quot; ;
  for (vector &lt;int&gt;::iterator it = vTwo.begin(); it != vTwo.end(); it++)
  &#123;
      cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
  &#125;
  cout &lt;&lt; &quot;)&quot; &lt;&lt; &#39;\n&#39;;

  return 0;
</code></pre>
<p>  }<br>  程序的输出结果：<br>  vOne &#x3D; ( 0 10 20 30 40 50 )<br>  vTwo &#x3D; ( 0 3 6 9 12 15 18 21 24 27 30 )<br>  vTwo with vOne insert &#x3D; ( 0 3 6 9 0 10 20 21 24 27 30 )<br>  vTwo with shifted insert &#x3D; ( 0 3 0 10 20 10 20 21 24 27 30 )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### queal函数   </span><br><span class="line">bool equal( InputIt1 first1, InputIt1 last1,  InputIt2 first2);   </span><br><span class="line"></span><br><span class="line">first1, last1-the first range of the elements to compare  </span><br><span class="line"></span><br><span class="line">first2-the beginning element of the second range to compare   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注解：</span><br><span class="line"></span><br><span class="line">它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回true，否则返回false。</span><br><span class="line"></span><br><span class="line">由于equal利用迭代器完成操作，因此可以通过equal比较两个不同类型容器中的元素。而且，元素的类型也不必一样，只要我们能用==来比较两个元素类型即可。</span><br><span class="line"></span><br><span class="line">equal基于一个非常重要的假设：它假设第二个序列至少与第一个序列一样长。     </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  #include <algorithm><br>  #include <vector><br>  #include <iostream><br>  using namespace std;</p>
<p>  int main()<br>  {<br>      vector<int> vi1,vi2;<br>      for(int i&#x3D;0;i&lt;10;i++)<br>      {<br>          vi1.push_back(i);<br>          vi2.push_back(i);<br>      }</p>
<pre><code>  if(equal(vi1.begin(),vi1.end(),vi2.begin()))
      cout&lt;&lt;&quot;vi1 equal vi2\n&quot;;
  else
      cout&lt;&lt;&quot;vi1 not equal vi2\n&quot;;


  if(equal(vi1.begin()+5,vi1.end(),vi2.begin()))
      cout&lt;&lt;&quot;vi1 equal vi2\n&quot;;
  else
      cout&lt;&lt;&quot;vi1 not equal vi2\n&quot;;

 return 0;
</code></pre>
<p>  }</p>
<p>  相应的，可以利用反向迭代器来实现判断回文<br>  bool testHW(string str)<br>  {<br>      return equal(str.begin(), str.end(), str.rbegin());<br>  }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- G Jessica&#x27;s Reading Problem   </span><br><span class="line"></span><br><span class="line">题目大意：   </span><br><span class="line">XXX要准备考试，书总共有P页，第i页恰好有一个知识点ai，书中的同一个知识点可能会被多次提到，所以他希望看其中连续的一些页的书来把所有的知识点都给看完。。  </span><br><span class="line">题目分析：  </span><br><span class="line">其实页数可以看作连续的序列，然后就是要求出一个子序列，子序列的要求的包涵所有知识点都有的页数，且子序列的长度要最短。  </span><br><span class="line">首先我们并不知道总共有多少个知识点，这是个先要记录的。  </span><br><span class="line">不断的把序列中的元素加入到子序列中，知识点的数目会不断的增加，当知识点是数目满了之后，把子序列前面的元素开始剔除，再看看现在的子序列还是否满足这个条件。满足继续删除子序列前面的元素，否则的话把后面的元素加入到子序列中。   </span><br><span class="line">注意中间过程知识点数的增加或减少的维护。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  #include <iostream><br>  #include <algorithm><br>  #include <cstdio><br>  #include <cstring><br>  #include <cmath><br>  #include <queue><br>  #include <map><br>  #include <set><br>  #include <vector><br>  using namespace std;<br>  typedef long long LL;<br>  const int N&#x3D;100000+999;<br>  int n,m;<br>  int num[N];<br>  &#x2F;&#x2F;尺取法<br>  int main()<br>  {<br>      while(scanf(“%d”,&amp;n)!&#x3D;EOF)<br>      {<br>          memset(num,0,sizeof(num));<br>          set<int> all; &#x2F;&#x2F;利用集合元素的单一性<br>          map&lt;int,int&gt; cot;<br>          for(int i&#x3D;0; i&lt;n; i++)<br>          {<br>              scanf(“%d”,&amp;num[i]);<br>              all.insert(num[i]);<br>          }<br>          int res&#x3D;n;<br>          m&#x3D;all.size(); &#x2F;&#x2F;算出种类<br>          int s&#x3D;0,e&#x3D;0,sum&#x3D;0;<br>          while(1)<br>          {<br>              while(e&lt;n &amp;&amp; sum&lt;m)<br>              {<br>                  if(cot[ num[e++] ]++ &#x3D;&#x3D; 0) &#x2F;&#x2F;如果这个种类未出现 则sum++<br>                      sum++;<br>              }<br>              if(sum&lt;m) break;<br>              res&#x3D;min(res,e-s);<br>              if(–cot[ num[s++] ] &#x3D;&#x3D; 0) &#x2F;&#x2F;如果这个种类-1后为0 则sum-1<br>                  sum–;<br>          }<br>          printf(“%d\n”,res);<br>      }<br>      return 0;<br>  }</p>
<pre><code>
</code></pre>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://zouyunkai.github.io/myblog/2019/07/30/STL-%E6%80%BB%E7%BB%93/" title="STL_总结" target="_blank" rel="external">https://zouyunkai.github.io/myblog/2019/07/30/STL-总结/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/zouyunkai" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/myblog/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/zouyunkai" target="_blank"><span class="text-dark">云开</span><small class="ml-1x">Stay Hungry , Stay Foolish .</small></a></h3>
        <div>when the facts change , I change my mind .</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/myblog/2019/08/02/C%E8%AF%AD%E8%A8%80%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/" title="C++语言零碎知识点汇总"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/myblog/2019/07/29/Untitled/" title="web_sql注入"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/myblog/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/myblog/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/zouyunkai" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/zouyunkai" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/zouyunkai" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/zouyunkai" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/myblog/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/myblog/js/plugin.min.js"></script>


<script src="/myblog/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/myblog/',
        CONTENT_URL: '/myblog/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/myblog/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '9f5iImvmYajPaJ79pRkbVNU9-gzGzoHsz',
    appKey: 'n3qUzkAGTOqjKi9k5LKGLfgV',
    placeholder: 'Just go go',
    avatar: 'wavatar',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>