<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="https://zouyunkai.github.io/myblog">
  <title>Sweet@</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Stay Hungry , Stay Foolish.">
<meta property="og:type" content="website">
<meta property="og:title" content="Sweet@">
<meta property="og:url" content="https://zouyunkai.github.io/myblog/page/22/index.html">
<meta property="og:site_name" content="Sweet@">
<meta property="og:description" content="Stay Hungry , Stay Foolish.">
<meta property="og:locale">
<meta property="article:author" content="zouqingzhi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Sweet@" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/myblog/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="https://gitee.com/aoyuehanzhi/blogpic/raw/master/images1/20220228160844.png" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/myblog/">主页</a></li>
	        
				<li><a href="/myblog/archives/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="/myblog/" title="github"><i class="icon-github"></i></a>
		        
					<a class="qq" target="_blank" href="/myblog/2661444606" title="qq"><i class="icon-qq"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="https://gitee.com/aoyuehanzhi/blogpic/raw/master/images1/20220228160844.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author"></h1>
			</hgroup>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/myblog/" title="github"><i class="icon-github"></i></a>
			        
						<a class="qq" target="_blank" href="/myblog/2661444606" title="qq"><i class="icon-qq"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/myblog/">主页</a></li>
		        
					<li style="width: 50%"><a href="/myblog/archives/">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-java开发" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/myblog/2019/10/31/java%E5%BC%80%E5%8F%91/">java开发</a>
    </h1>
  

        
        <a href="/myblog/2019/10/31/java%E5%BC%80%E5%8F%91/" class="archive-article-date">
  	<time datetime="2019-10-31T12:49:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-10-31</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sunnyyoona/article/category/9264957">https://blog.csdn.net/sunnyyoona/article/category/9264957</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">java</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/myblog/categories/JAVA开发//" class="article-tag-list-link color2">JAVA开发</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/myblog/2019/10/31/java%E5%BC%80%E5%8F%91/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-常用技巧的例题" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/myblog/2019/10/30/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%9A%84%E4%BE%8B%E9%A2%98/">常用技巧的例题</a>
    </h1>
  

        
        <a href="/myblog/2019/10/30/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%9A%84%E4%BE%8B%E9%A2%98/" class="archive-article-date">
  	<time datetime="2019-10-30T12:58:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-10-30</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/acgoto/category/1286070.html">https://www.cnblogs.com/acgoto/category/1286070.html</a></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/myblog/categories/编程刷题//" class="article-tag-list-link color5">编程刷题</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/myblog/2019/10/30/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%9A%84%E4%BE%8B%E9%A2%98/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-新生训练class2-暴力" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/myblog/2019/10/29/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83class2-%E6%9A%B4%E5%8A%9B/">新生训练class2_暴力</a>
    </h1>
  

        
        <a href="/myblog/2019/10/29/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83class2-%E6%9A%B4%E5%8A%9B/" class="archive-article-date">
  	<time datetime="2019-10-29T11:53:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-10-29</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>A New Year and Counting Cards<br>题意：每张牌两面分别是字母和数字。定义一个规则：如果一张牌的字母是元音字母那么另一面一定对照着偶数。给你n个牌的一面，问你最少翻多少张牌最终判断这些牌的对照是正确的。<br>解题思路：直接统计有多少个是元音字母或者是奇数。<br>根据以上规则，1.元音字母只能对应偶数。2.偶数可以对应所有字母，而奇数只能对应非元音字母。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&lt;ctype.h&gt;//isdigit(),isalpha()函数的头文件 </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool isyuanyin(char s)&#123;</span><br><span class="line">	if(s==&#x27;a&#x27;||s==&#x27;e&#x27;||s==&#x27;i&#x27;||s==&#x27;o&#x27;||s==&#x27;u&#x27;)return true;</span><br><span class="line">	else return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	string s;</span><br><span class="line">	int cnt;</span><br><span class="line">	int tmp1;</span><br><span class="line">	char tmp2;</span><br><span class="line">	while(getline(cin,s))&#123;</span><br><span class="line">		cnt=0;</span><br><span class="line">		for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">			if(isdigit(s[i]))&#123;//判断是否为数字 </span><br><span class="line">				tmp1=int(s[i]);</span><br><span class="line">				if(tmp1&amp;1==1)cnt++;	//判断是否为奇数 </span><br><span class="line">			&#125;</span><br><span class="line">			else if(isalpha(s[i]))&#123;//判断是否为字母 </span><br><span class="line">				tmp2=s[i];</span><br><span class="line">				if(isyuanyin(tmp2))&#123;</span><br><span class="line">					cnt++;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">		//要清空 s吗,不需要每次都清空s，在getline的时候就会把s清空的 </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">解法二（统计元音和奇数个数）：</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string c=&quot;aeiou13579&quot;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(int i=0;s[i];i++)</span><br><span class="line">        for(int j=0;c[j];j++)</span><br><span class="line">            if(s[i]==c[j])</span><br><span class="line">                ans++;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>B New Year and Buggy Bot</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[55][55];</span><br><span class="line">// 1上 2 下 3 左 4 右</span><br><span class="line">int s1,s2,e1,e2;</span><br><span class="line">int ans;</span><br><span class="line">int n,m;</span><br><span class="line">string abc;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    mem(a,0);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    string str;</span><br><span class="line">    ans=0;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;str;</span><br><span class="line">        for(int j=0;j&lt;str.length();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[j]==&#x27;.&#x27;)</span><br><span class="line">                a[i][j]=1;</span><br><span class="line">            else if(str[j]==&#x27;#&#x27;)</span><br><span class="line">                a[i][j]=2;</span><br><span class="line">            else if(str[j]==&#x27;S&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                s1=i,s2=j;</span><br><span class="line">                //a[i][j]=1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(str[j]==&#x27;E&#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                //a[i][j]=1;</span><br><span class="line">                e1=i;e2=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //cout&lt;&lt;s1&lt;&lt;&quot; &quot;&lt;&lt;s2&lt;&lt;&quot; &quot;&lt;&lt;e1&lt;&lt;&quot; &quot;&lt;&lt;e2&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;abc;</span><br><span class="line">    for(int x=1;x&lt;=4;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int y=1;y&lt;=4;y++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int z=1;z&lt;=4;z++)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int d=1;d&lt;=4;d++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(x!=y&amp;&amp;x!=z&amp;&amp;x!=d&amp;&amp;y!=z&amp;&amp;y!=d&amp;&amp;z!=d)</span><br><span class="line">                    &#123;</span><br><span class="line">                       // cout&lt;&lt;x&lt;&lt;y&lt;&lt;z&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">                        int i,j,c;</span><br><span class="line">                        for(i=s1,j=s2,c=0;c&lt;abc.length();c++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            if(abc[c]==&#x27;0&#x27;)</span><br><span class="line">                            &#123;</span><br><span class="line">                                if(x==1)//shang</span><br><span class="line">                                    i-=1;</span><br><span class="line">                                else if(x==2)//xia</span><br><span class="line">                                    i+=1;</span><br><span class="line">                                else if(x==3)//zuo</span><br><span class="line">                                    j-=1;</span><br><span class="line">                                else if(x==4)//you</span><br><span class="line">                                    j+=1;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else if(abc[c]==&#x27;1&#x27;)</span><br><span class="line">                            &#123;</span><br><span class="line">                                if(y==1)</span><br><span class="line">                                    i-=1;</span><br><span class="line">                                else if(y==2)</span><br><span class="line">                                    i+=1;</span><br><span class="line">                                else if(y==3)</span><br><span class="line">                                    j-=1;</span><br><span class="line">                                else if(y==4)</span><br><span class="line">                                    j+=1;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else if(abc[c]==&#x27;2&#x27;)</span><br><span class="line">                            &#123;</span><br><span class="line">                                if(z==1)</span><br><span class="line">                                    i-=1;</span><br><span class="line">                                else if(z==2)</span><br><span class="line">                                    i+=1;</span><br><span class="line">                                else if(z==3)</span><br><span class="line">                                    j-=1;</span><br><span class="line">                                else if(z==4)</span><br><span class="line">                                    j+=1;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else if(abc[c]==&#x27;3&#x27;)</span><br><span class="line">                            &#123;</span><br><span class="line">                                if(d==1)</span><br><span class="line">                                    i-=1;</span><br><span class="line">                                else if(d==2)</span><br><span class="line">                                    i+=1;</span><br><span class="line">                                else if(d==3)</span><br><span class="line">                                    j-=1;</span><br><span class="line">                                else if(d==4)</span><br><span class="line">                                    j+=1;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if(a[i][j]==2)</span><br><span class="line">                                break;</span><br><span class="line">                            if(i&lt;0||i&gt;=n||j&lt;0||j&gt;=m)</span><br><span class="line">                                break;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                if(i==e1&amp;&amp;j==e2)</span><br><span class="line">                                &#123;</span><br><span class="line">                                   // cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">                                    ans++;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">解法二：</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string s[51];</span><br><span class="line">int a[6],sx,sy;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//4！=24种  最大24种  24种排列，就是a4 4 </span><br><span class="line">//a[0],a[1],a[2],a[3]分别带别上下左右，来全排列找到结果 </span><br><span class="line">    int n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++)</span><br><span class="line">        if(s[i][j]==&#x27;S&#x27;)sx=i,sy=j;</span><br><span class="line">    string c;</span><br><span class="line">    cin&gt;&gt;c;</span><br><span class="line">    for(int i=0;i&lt;4;i++)</span><br><span class="line">        a[i]=i+48;//把a[i]转换为与字符型相对应的a[i] </span><br><span class="line">    int ans=0;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        int f=0;</span><br><span class="line">        int tx=sx,ty=sy;</span><br><span class="line">        for(int i=0;c[i];i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(c[i]==a[0])</span><br><span class="line">                tx-=1;</span><br><span class="line">            else if(c[i]==a[1])</span><br><span class="line">                tx+=1;</span><br><span class="line">            else if(c[i]==a[2])</span><br><span class="line">                ty-=1;</span><br><span class="line">            else ty+=1;</span><br><span class="line">            if(tx&lt;0||ty&lt;0||tx&gt;=n||ty&gt;=m)</span><br><span class="line">                break;</span><br><span class="line">            if(s[tx][ty]==&#x27;#&#x27;)break;</span><br><span class="line">            if(s[tx][ty]==&#x27;E&#x27;)&#123;f=1;break;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=f;</span><br><span class="line">    &#125;while(next_permutation(a,a+4));</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;*/ </span><br></pre></td></tr></table></figure>

<ul>
<li>C - Water The Garden</li>
</ul>
<p>题意：给你编号1~n的花园，花园从左到右排成一排。其中有k个花园有水龙头，当水龙头所在的花园浇满后，会流向左右相邻花园，现在同时打开所有水龙头，问你多长时间后n个花园能被浇满。  </p>
<p><strong>解法一：</strong>思路：这个题目很有意思，只用把握一点就好：所有水龙头同时开启，所有水流同时流动。所以先看边界情况，从编号最小的水龙头到最左端，这一段只有一个方向的水流，最右端也是同理，这两个边界都只有一个方向的水流，而且它们同时流动，所以边界所花时间是两者中较大的：ans&#x3D;max（a[1]-1,n-a[k]）。然后是中间部分，一定是来自两个方向的水流，此时要看间隔的个数x，如果x是奇数，那么时间就是x&#x2F;2+1，偶数就是x&#x2F;2，这个自己想一下就能想明白，而且所有中间间隔的双向水流都是同时流动，所以依然是取最大值即可，而不是累加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">解法一：</span><br><span class="line">    #include&lt;bits/stdc++.h&gt;</span><br><span class="line">    #define ll long long</span><br><span class="line">    using namespace std;</span><br><span class="line">    ll a[110],n,k;</span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">        ll t;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;t);</span><br><span class="line">        while(t--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);</span><br><span class="line">            for(ll i=1;i&lt;=k;i++)scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">            ll ans=max(a[1]-1,n-a[k]);         //处理边界的单向水流</span><br><span class="line">            for(ll i=2;i&lt;=k;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ll tmp=a[i]-a[i-1]-1;</span><br><span class="line">                if(tmp&amp;1)tmp=tmp/2+1;</span><br><span class="line">                else tmp/=2;</span><br><span class="line">                ans=max(ans,tmp);            //更新中间的双向水流</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%lld\n&quot;,ans+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解法二：</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool check(bool flag[], int n) &#123;</span><br><span class="line">	for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">		if (flag[i] == false) return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int cas;</span><br><span class="line">	cin &gt;&gt; cas;</span><br><span class="line">	for (int i = 1; i &lt;= cas; i++) &#123;</span><br><span class="line">		int n, k;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		int val[k];</span><br><span class="line">		for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">			cin &gt;&gt; val[j];</span><br><span class="line">		&#125;</span><br><span class="line">		//1-n</span><br><span class="line">		bool flag[n+1];//对应1-n</span><br><span class="line">		for (int j = 1; j &lt;= n; j++) flag[j] = false;</span><br><span class="line">		for (int j = 0; j &lt; k; j++) &#123;</span><br><span class="line">			flag[val[j]] = true;//标记已填满	</span><br><span class="line">		&#125;</span><br><span class="line">		int cnt = 1;</span><br><span class="line">		while (check(flag, n)) &#123;</span><br><span class="line">			//对每次的进行遍历，每次都遍历val数组中的每个元素</span><br><span class="line">			int change[n];</span><br><span class="line">			int count = 0;</span><br><span class="line">			for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">				if (flag[j] == true) &#123;</span><br><span class="line">					int left = j-1;//</span><br><span class="line">					int right = j+1;</span><br><span class="line">					if (left &gt;= 1 &amp;&amp; flag[left] == false) &#123;</span><br><span class="line">						// flag[left] = true;</span><br><span class="line">						change[count++] = left;</span><br><span class="line">					&#125; </span><br><span class="line">					if (right &lt;= n &amp;&amp; flag[right] == false) &#123;</span><br><span class="line">						// flag[right] = true;</span><br><span class="line">						change[count++] = right;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			for (int j = 0; j &lt; count; j++) flag[change[j]] = true;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>D - Tea Queue<br>题意： 已知n个人来接水，每秒可以接一个人的水，给出每个人的到达接水地点的时间，和走的时间，如果同一时间来的，先来的可以接到水，如果可以接到水，记录下这个人的接水时间，如果接不到，记录为0  </p>
<p>  分析： 我们可以枚举时间轴，当当前时间大于这个人走的时间，则这人的最后记录为0，否则记录答案</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const int maxn = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">bool vis[maxn];</span><br><span class="line">int l[maxn];</span><br><span class="line">int r[maxn];</span><br><span class="line">int res[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int T;cin&gt;&gt;T;</span><br><span class="line">    while(T--) &#123;</span><br><span class="line">        memset(vis,0,sizeof vis);</span><br><span class="line">        int n;cin&gt;&gt;n;</span><br><span class="line">        for(int i = 0;i &lt; n;i++) cin&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line">        for(int i = 1;i &lt;= 5100;i++) &#123;</span><br><span class="line">            bool flg = false;</span><br><span class="line">            for(int j = 0;j &lt; n;j++) &#123;</span><br><span class="line">                if(!vis[j]) &#123;</span><br><span class="line">                    flg = true;break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(!flg) break;</span><br><span class="line">            for(int j = 0;j &lt; n;j++) &#123;</span><br><span class="line">                if(vis[j]) continue;</span><br><span class="line">                if(i &gt; r[j]) &#123;</span><br><span class="line">                    vis[j] = true;</span><br><span class="line">                    res[j] = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                if(l[j] &lt;= i &amp;&amp; r[j] &gt;= i) &#123;</span><br><span class="line">                    vis[j] = true;</span><br><span class="line">                    res[j] = i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0;i &lt; n;i++) &#123;</span><br><span class="line">            printf(&quot;%d &quot;,res[i]);</span><br><span class="line">        &#125;cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>E-A Compatible Pair<br>就是两个数组，其中前一个数组中去掉一个最大之后，与后一个数组相乘，求这个相乘的最大值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define IO ios::sync_with_stdio(false);cin.tie(0);</span><br><span class="line">#define INF 1e18</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">ll n, m, a[110], b[110];</span><br><span class="line">ll maxm;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	while(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">		for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">			cin &gt;&gt; b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(a,a+n);</span><br><span class="line">		sort(b,b+m);</span><br><span class="line">		maxm=max(a[n-2]*b[m-1],a[1]*b[0]);</span><br><span class="line">		//为什么最大值不是排序完了之后这两个的值呐，因为最大值有可能如下面那种解法 </span><br><span class="line">		</span><br><span class="line">		cout &lt;&lt; maxm &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*解法一： </span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line">const ll INF_LL = 9223372036854775807LL;</span><br><span class="line"></span><br><span class="line">ll a[maxn];</span><br><span class="line">ll b[maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    ios_base::sync_with_stdio(0);</span><br><span class="line">    int n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i = 0;i &lt; n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    for(int i = 0;i &lt; m;i++) cin&gt;&gt;b[i];</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    sort(b,b+m);</span><br><span class="line">    ll a1 = a[0],a2 = a[1],a3 = a[n - 2],a4 = a[n - 1];</span><br><span class="line">    ll b1 = b[0],b2 = b[1],b3 = b[m - 2],b4 = b[m - 1];</span><br><span class="line">    ll res = -INF_LL;</span><br><span class="line">    if(n &gt; 2) &#123;</span><br><span class="line">        res = max(res,a2*b1);</span><br><span class="line">        res = max(res,a2*b4);</span><br><span class="line">        res = max(res,a3*b1);</span><br><span class="line">        res = max(res,a3*b4);</span><br><span class="line">        res = max(res,min(a[n - 1]*b[m - 1],a[0]*b[0]));</span><br><span class="line">		//就有可能少了这种情况，所以只比较那两种结果会漏掉 </span><br><span class="line">        res = max(res,min(a[n - 1]*b[0],a[0]*b[m - 1]));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        res = max(res,a2*b1);</span><br><span class="line">        res = max(res,a3*b4);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">*/ </span><br><span class="line"></span><br><span class="line">/*解法二： </span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define IO ios::sync_with_stdio(false);cin.tie(0);</span><br><span class="line">#define INF 1e18</span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">ll n, m, a[110], b[110];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	while(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">		for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		for(int i = 0; i &lt; m; i++)&#123;</span><br><span class="line">			cin &gt;&gt; b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		ll maxm = -INF, loc;</span><br><span class="line">		for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">			for(int j = 0; j &lt; m; j++)&#123;</span><br><span class="line">				if(a[i]*b[j] &gt; maxm)&#123;</span><br><span class="line">					maxm = a[i]*b[j];</span><br><span class="line">					loc=i;//记录最大值的下标，然后再一次遍历求最大值 </span><br><span class="line">				&#125; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		maxm=-INF;//这样写代表maxn为负无穷小，这样就不会在比较时把更小的数给漏掉了 </span><br><span class="line">		for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">			for(int j = 0; j &lt; m; j++)&#123;</span><br><span class="line">				if(i == loc)</span><br><span class="line">					continue;</span><br><span class="line">				if(a[i]*b[j] &gt;maxm)&#123;</span><br><span class="line">					maxm = a[i]*b[j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		cout &lt;&lt; maxm &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*解法三： </span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m;LL a[55],b[55],c[55];</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;++i)cin&gt;&gt;a[i];</span><br><span class="line">    for(int i=0;i&lt;m;++i)cin&gt;&gt;b[i];</span><br><span class="line">    for(int i=0;i&lt;n;++i)&#123;</span><br><span class="line">        c[i]=a[i]*b[0];</span><br><span class="line">        for(int j=1;j&lt;m;++j)</span><br><span class="line">            c[i]=max(c[i],a[i]*b[j]);</span><br><span class="line">			//其实这个把那个c[i]的值存放 b[0]到b[m-1],b这一整个数组的最大值</span><br><span class="line">			// ？？？？那有可能第二大的值是从a[i]*b[j]  里面运算的时候出现了呐 </span><br><span class="line">			//,不会的因为a[i]取得的最大值要把此时的a[i]去掉,所以才会有 最大值，第二大，，，，第n*m-n大的值只能从c[]中取得</span><br><span class="line">    &#125;</span><br><span class="line">    sort(c,c+n);cout&lt;&lt;c[n-2]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">*/ </span><br></pre></td></tr></table></figure>

<ul>
<li>F-A Prosperous Lot<br>题意： 0 4 6 9有一个环，8有两个环，其他没有环。求出一个数字，上面数位的环和答案为给定的x。如果这个数字超过1e18，输出-1.<br>思路： 很明显，贪8就可以了。到了37，就超过1e18了。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    if(n &gt; 36)printf(&quot;-1\n&quot;);</span><br><span class="line">    else if(n % 2 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 1;i &lt;= n / 2;i++)</span><br><span class="line">            printf(&quot;%d&quot;,8);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;4&quot;);</span><br><span class="line">        for(int i = 1;i &lt;= n / 2;i++)</span><br><span class="line">            printf(&quot;%d&quot;,8);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>G Subsequence<br>给定长度n的数列整数，以及整数s，求出总和不小于S的连续子序列的长度的最小值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">解法一（不利用尺取法，利用lower_bound（）：</span><br><span class="line">    #include &lt;iostream&gt;</span><br><span class="line">    #include &lt;algorithm&gt;</span><br><span class="line">    #include &lt;cstring&gt;</span><br><span class="line">    #include&lt;cstdio&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    int n,ss;</span><br><span class="line">    int a[100005],s[100005];</span><br><span class="line">    int main()&#123;</span><br><span class="line">        int t;</span><br><span class="line">        cin&gt;&gt;t;</span><br><span class="line">        while(t--)&#123;</span><br><span class="line">            memset(a,0,sizeof(a));</span><br><span class="line">            memset(s,0,sizeof(s));</span><br><span class="line">            int kk=100005;</span><br><span class="line">            cin&gt;&gt;n&gt;&gt;ss;</span><br><span class="line">            for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">                cin&gt;&gt;a[i];</span><br><span class="line">                s[i]=s[i-1]+a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            if(s[n]&lt;ss)</span><br><span class="line">                cout&lt;&lt;&quot;0&quot;&lt;&lt;endl;</span><br><span class="line">            else&#123;</span><br><span class="line">                for(int i=1;s[i]+ss&lt;=s[n];i++)&#123;</span><br><span class="line">                    int k=lower_bound(s+i,s+n+1,s[i]+ss)-s;</span><br><span class="line">                    kk=min(kk,k-i);</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;kk&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> 其中lower_bound该函数的用法：</span><br><span class="line"> 在从小到大的排序数组中，</span><br><span class="line"></span><br><span class="line">lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="line"></span><br><span class="line">upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="line"></span><br><span class="line">在从大到小的排序数组中，重载lower_bound()和upper_bound()</span><br><span class="line"></span><br><span class="line">lower_bound( begin,end,num,greater&lt;type&gt;() ):从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="line"></span><br><span class="line">upper_bound( begin,end,num,greater&lt;type&gt;() ):从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解法二：<br>因为枚举满足条件的区间，要枚举起点和终点，所以时间复杂度是o(n^3)，所以考虑只枚举起点或者终点,即要去掉最后一个循环，所以：我们试试只枚举终点。对于终点j，我们的目标是要找到一个让Bj-Bi-1≥S，且i尽量大（i越大，序列长度j-i+1就越小）的i值，也就是找一个让Bi-1≤Bj-S最大的i。考虑图1-29所示的序列。（前缀和技巧，数组B就是存储前几项的和）   </p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-184.png" alt="upload successful"><br>当j&#x3D;5时，B5&#x3D;12，因此目标是找一个Bi-1≤12-7&#x3D;5的最大i。注意到B是递增的（别忘了，本题中所有Ai均为整数），所以可以用二分查找。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">#define N 100001</span><br><span class="line"> </span><br><span class="line">int A[N];</span><br><span class="line">int B[N];</span><br><span class="line"> </span><br><span class="line">//二分查找最接近target但不大于target</span><br><span class="line">int BinarySerach(int target,int R)&#123;</span><br><span class="line">    int L = 0;</span><br><span class="line">    int mid = 0;</span><br><span class="line">    while(L &lt; R)&#123;</span><br><span class="line">        mid = L + (R - L) / 2;</span><br><span class="line">        if(B[mid] &gt; target)&#123;</span><br><span class="line">            R = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            L = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return L;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,s,i,j;</span><br><span class="line">    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;s) != EOF)&#123;</span><br><span class="line">        int minLen = n+1;</span><br><span class="line">        B[0] = 0;</span><br><span class="line">        for(i = 1;i &lt;= n;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;A[i]);</span><br><span class="line">            //序列前缀和</span><br><span class="line">            B[i] = B[i-1] + A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(j = 1;j &lt;= n;j++)&#123;</span><br><span class="line">            int target = B[j] - s;</span><br><span class="line">            //二分查找</span><br><span class="line">            int index = BinarySerach(target,j-1);</span><br><span class="line">            if(index &gt; 0)&#123;</span><br><span class="line">                minLen = min(minLen,j-index+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //没有满足条件的序列</span><br><span class="line">        if(minLen == n+1)&#123;</span><br><span class="line">            minLen = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;minLen&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">解法三（尺取法求前多少项的和，就是l和r两个指针，找到一个符合条件的区间，l++，子区间和减左边的第一个元素，然后在向后比较，这样把整个区间都走一遍，就能得到最重的结果。）：</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define min(a,b) a&gt;b?b:a;</span><br><span class="line">#define MAXN 100010</span><br><span class="line">#define INF 0xfffffff</span><br><span class="line">int a[MAXN];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,N,S,l,r,len;</span><br><span class="line">	long long sum  = 0;</span><br><span class="line">	cin &gt;&gt;n;</span><br><span class="line">	while(n--)&#123;</span><br><span class="line">		cin&gt;&gt;N&gt;&gt;S;</span><br><span class="line">		for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">			cin&gt;&gt;a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		l = r = 0;//初始化 </span><br><span class="line">		sum = 0;</span><br><span class="line">		len = INF;</span><br><span class="line">		while(1)&#123;</span><br><span class="line">			while(r&lt;N &amp;&amp; sum&lt;S)&#123; </span><br><span class="line">				sum+=a[r];</span><br><span class="line">				r++;</span><br><span class="line">			&#125;//此时的sum是区间[l,r)上的和 </span><br><span class="line">			if(sum&lt;S)&#123;//如果说 sum&lt;S但是r&gt;=N了 结束循环 </span><br><span class="line">				break;</span><br><span class="line">			&#125; </span><br><span class="line">			len = min(len,r-l);//更新长度 取较小的 </span><br><span class="line">			sum -= a[l];//看看减去左边一个元素 还满不满足sum&gt;=S </span><br><span class="line">			l++; //l右移一个 </span><br><span class="line">		&#125;</span><br><span class="line">		if(len == INF)&#123;//如果说len没有变化 说明所有的数加起来&lt;S </span><br><span class="line">			cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; </span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">变式：最大子列和问题</span><br><span class="line">给定N个整数的序列 a1,a2,,,,,, an 求 求做大子列和，如果子列和为负数，那么结果为0</span><br><span class="line">    #include&lt;iostream&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    int a[100100];</span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">    	int maxsum,sum,N;</span><br><span class="line">    	maxsum = sum = 0;</span><br><span class="line">    	cin&gt;&gt;N;</span><br><span class="line">    	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">    		cin&gt;&gt;a[i];</span><br><span class="line">    	&#125;//先读入数据 </span><br><span class="line">    	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">    		sum += a[i];</span><br><span class="line">    		if(sum &gt; maxsum)&#123;</span><br><span class="line">    			maxsum = sum;</span><br><span class="line">    		&#125;</span><br><span class="line">    		else if(sum &lt;0 )&#123;</span><br><span class="line">    			sum = 0;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	cout&lt;&lt;maxsum&lt;&lt;endl;</span><br><span class="line">    	return 0;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>本题的变题：编程之美求子数组最大值：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sunnyyoona/article/details/26288943">https://blog.csdn.net/sunnyyoona/article/details/26288943</a></p>
</li>
<li><p>CodeForces - 908C New Year and Curling（圆与圆之间的关系的问题）<br>题意： 已知一些圆在(xi,10100)处，然后依次落下，下落时只要碰到某个圆，就会停止，求这些圆的最后的y值，也即是水平高度<br>分析： 首先看了下n的范围很小，可以到O(n2)<br>的复杂度，直接暴力枚举，可以画图分析下，见下图</p>
</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-185.png" alt="upload successful"><br>  可以看到高度h &#x3D; y1 + sqrt(2r*2r - (x2-x1)(x2-x1));枚举个最高的高度即可，因为   一旦碰到就不会落下了  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int h[1500];</span><br><span class="line">double res[1500];</span><br><span class="line">int abs(int x,int y) &#123;if(x - y &gt; 0) return x - y;return y - x;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    ios_base::sync_with_stdio(0);</span><br><span class="line">    int n;</span><br><span class="line">    double r;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;r;</span><br><span class="line">    for(int i = 0;i &lt; n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;h[i];</span><br><span class="line">        double rs = r;</span><br><span class="line">        for(int j = 0;j &lt; i;j++) &#123;</span><br><span class="line">            int dx = abs(h[i],h[j]);</span><br><span class="line">            if(dx &lt;= 2*r) &#123;</span><br><span class="line">                rs = max(rs,res[j] + sqrt(4*r*r - dx*dx));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = rs;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i = 0;i &lt; n;i++) printf(&quot;%.10f &quot;,res[i]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>H-Jessica’s Reading Problem<br>题目大意：</li>
</ul>
<p>XXX要准备考试，书总共有P页，第i页恰好有一个知识点ai，书中的同一个知识点可能会被多次提到，所以他希望看其中连续的一些页的书来把所有的知识点都给看完。。</p>
<p>题目分析：</p>
<p>其实页数可以看作连续的序列，然后就是要求出一个子序列，子序列的要求的包涵所有知识点都有的页数，且子序列的长度要最短。</p>
<p>首先我们并不知道总共有多少个知识点，这是个先要记录的。</p>
<p>不断的把序列中的元素加入到子序列中，知识点的数目会不断的增加，当知识点是数目满了之后，把子序列前面的元素开始剔除，再看看现在的子序列还是否满足这个条件。满足继续删除子序列前面的元素，否则的话把后面的元素加入到子序列中，然后按上述步骤继续执行。</p>
<p>注意中间过程知识点数的增加或减少的维护。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">尺取法求前多少项出现的次数（与前面那种求前多少项的和区别开来）：</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int N=100000+999;</span><br><span class="line">int n,m;</span><br><span class="line">int num[N];</span><br><span class="line">//尺取法</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(num,0,sizeof(num));</span><br><span class="line">        set&lt;int&gt; all; //利用集合元素的单一性</span><br><span class="line">        map&lt;int,int&gt; cot;</span><br><span class="line">        for(int i=0; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;num[i]);</span><br><span class="line">            all.insert(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int res=n;</span><br><span class="line">        m=all.size(); //算出种类</span><br><span class="line">        int s=0,e=0,sum=0;</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">            while(e&lt;n &amp;&amp; sum&lt;m)</span><br><span class="line">            &#123;</span><br><span class="line">                if(cot[ num[e++] ]++ == 0) //如果这个种类未出现 则sum++</span><br><span class="line">                    sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(sum&lt;m) break;//这一句是为了让最后e=n之后，能跳出外层的while循环。</span><br><span class="line">            res=min(res,e-s);</span><br><span class="line">            if(--cot[ num[s++] ] == 0) //如果这个种类-1后为0 则sum-1</span><br><span class="line">                sum--;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,res);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>I Graveyard Design<br>求一组连续整数的平方和的问题，可以用尺取法模拟一个符合要去的区间的左边和右边，找到符合要求的区间就记录下来。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#define LL __int64</span><br><span class="line">/*</span><br><span class="line">一般来说，64位整型的定义方式有long long和__int64两种(VC还支持_int64)，</span><br><span class="line">而输出到标准输出</span><br><span class="line">方式有printf(“%lld”,a)，printf(“%I64d”,a)，和cout &lt;&lt; a三种方式。</span><br><span class="line">*/</span><br><span class="line">int num[2000],left[2000],right[2000];</span><br><span class="line"> //对于数组，若下标大于1e7，就应该放到数组外面声明才可以</span><br><span class="line">void solve(LL n)</span><br><span class="line">&#123;</span><br><span class="line">	int i,j;</span><br><span class="line">	LL m=(LL)sqrt(n*1.0);//因为sqrt只能对double类型运算 </span><br><span class="line">	LL sum=0,l=1,r=0;</span><br><span class="line">	int cnt=0;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		while(sum&lt;n)</span><br><span class="line">		&#123;</span><br><span class="line">			r++;</span><br><span class="line">			sum+=r*r;</span><br><span class="line">		&#125;</span><br><span class="line">		if(r&gt;m)</span><br><span class="line">			break;</span><br><span class="line">			//这一步是为了让当r&gt;m的时候，已经不会有连续整数的平方和大于m了，</span><br><span class="line">			//所以要跳出外层的while循环 </span><br><span class="line">		if(sum==n)</span><br><span class="line">		&#123;</span><br><span class="line">			num[cnt]=r-l+1;</span><br><span class="line">			left[cnt]=l;</span><br><span class="line">			right[cnt]=r;</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		sum-=(l*l);</span><br><span class="line">		l++;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d\n&quot;,cnt);</span><br><span class="line">	for(i=0;i&lt;cnt;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;%d &quot;,num[i]);</span><br><span class="line">		for(j=left[i];j&lt;right[i];++j)</span><br><span class="line">			printf(&quot;%d &quot;,j);</span><br><span class="line">		printf(&quot;%d\n&quot;,right[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	LL n;</span><br><span class="line">	while(scanf(&quot;%I64d&quot;,&amp;n)!=EOF)</span><br><span class="line">		solve(n);</span><br><span class="line">	return 0; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>J-骗分导论–ODT珂朵莉树</p>
</li>
<li><p><strong>讲义</strong>：</p>
</li>
<li><p>1.区间求和：<br>  前缀和，o(1)时间内求出前n项的和，或者某个区间的和（两个区间头减尾）<br>前缀和<br>前缀和S[i]&#x3D;A[1]+A[2]+……+A[i];<br>可以用A[i]&#x3D;S[i]-S[i-1]来还原;<br>还有二维的前缀和S[i][j] &#x3D; S[i-1][j] + S[i][j-1] - S[i-1][j-1] + A[i][j];<br>这个公式可以用容斥原理推得。   </p>
</li>
<li><p>2.区间修改：<br>  单点查询（差分法）   </p>
<p>  差分就是将数列中的每一项分别与前一项数做差，例如：<br>  一个序列　　　　　1 2 5, 4 7 3，　　差分后得到1 1 3, -1 3 -4, -3<br>  上面整个序列+2后:　3 4 7, 6 9 5　　　　　　　　3 1 3, -1 3 -4, -5<br>  &#x2F;&#x2F; 只有整个区间的首和尾不同，其他的差分相同 ，即将首+2,(尾+1)的位置-2<br>  这里注意得到的差分序列第一个数和原来的第一个数一样（相当于第一个数减0）<br>  差分序列最后比原序列多一个数（相当于0减最后一个数）<br>  性质：<br>  1、差分序列求前缀和可得原序列<br>  2、将原序列区间[L,R]中的元素全部+x，可以转化操作为差分序列L处+x，R+1处-x<br>  3、按照性质2得到，每次修改原序列一个区间+x，那么每次差分序列修改相应的位置 增加的和减少的相同<br>  tips：前缀和与差分是一对逆运算。差分操作有助于把原序列上的“区间操作”<br>  转化为差分序列上的“单点操作”，在树上有着独特的应用。  </p>
</li>
<li><ol start="3">
<li>尺取法：<br>  头尾双指针  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   形式为：  </span><br><span class="line">while(1)&#123;   </span><br><span class="line">	while(表达式1)&#123;  </span><br><span class="line">		if(条件1)语句1 </span><br><span class="line">	&#125;</span><br><span class="line">	if(条件2)&#123;break;&#125; </span><br><span class="line">	语句2 </span><br><span class="line">	if(条件3)语句3 </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
<p>  其中：表达式1为边界判断条件，目的是让在语句1中移动左指针，直到移动到符合要求的那个地方；条件2是边界判断（如：个数超过要求的总个数，sum超过要求的总和，其实就是左指针从头跑到尾了，可以结束外层while了;语句2可以执行一些操作，如对结果的处理，如res&#x3D;min(res,e-s);条件3为边界判断，是左指针右移后对结果的处理，<br>  如：<br>  if(–cot[ num[s++] ] &#x3D;&#x3D; 0)　　　&#x2F;&#x2F;如果这个种类-1后为0 则sum-1</p>
</li>
</ul>
<p>sum–; 　　　　　　 &#x2F;&#x2F;这样的话，就是集合中少了那一种元素，对结果产生了影响， 就应该对结果进行相应的处理；<br>    其中语句2和语句3试情况而定，可调换顺序或者没有该语句； </p>
<ul>
<li><p>4.要想区间求和并且实现单点查询   分为根下n块，每一块就有根下n个数<br>  5 4 1, 8 10 1, 8 7 6, 5 4   &#x3D;&gt; 求区间第三个到第十个的和<br>  10      19     21    9     &#x3D;&gt;那么结果就是1+19+21+5   </p>
</li>
<li><ol start="5">
<li><pre><code>          5 4 6, 8 10 1, 8 7 6,10 4                    
</code></pre>
  重新分块后： 5 4 6, 8 1 2,  3 4 10, 1 8 7, 6 10 4<br>  &#x3D;&gt;若果在第四个位置插入4个数，那么可以用再分块(当插入的数大于<br>   根下12为3，所以先3个一组，)的方法来维系块的性质</li>
</ol>
</li>
<li><ol start="6">
<li>[省选题]（<a target="_blank" rel="noopener" href="https://www.luogu.org/problem/P4799%EF%BC%89">https://www.luogu.org/problem/P4799）</a><br>  100 1500, 500 500 1000<br>  &#x3D;&gt;分为两块进行搜索，在第一个块中进行搜索，在第二个快中进行搜索，再拼凑起来，对结果是没有影响的<br>  折半搜索，分治<br>  参考blog:<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZAGER/p/9827160.html">https://www.cnblogs.com/ZAGER/p/9827160.html</a></li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">其中：1-4组数据N≤20，爆搜就可以解决。</span><br><span class="line">	inline void dfs(R ll dep,R ll sum)&#123;</span><br><span class="line">	 if(sum&gt;m)return;//只要sum大于总的m就可以结束本次递归 </span><br><span class="line">	 if(dep==n+1)&#123;//只要满足搜索到的深度到了n+1了，就可以退回上一步了 </span><br><span class="line">	     ans++;//ans初始化为0 </span><br><span class="line">	     return;</span><br><span class="line">	 &#125;</span><br><span class="line">	 dfs(dep+1,sum+a[dep]);// 买这一次的票 </span><br><span class="line">	 dfs(dep+1,sum);//不买这一次票 </span><br><span class="line">	&#125;</span><br><span class="line">	int main()&#123;</span><br><span class="line">	 read(n);read(m);</span><br><span class="line">	 for(R int i=1;i&lt;=n;i++)read(a[i]);</span><br><span class="line">	 if(n&lt;=20)&#123;</span><br><span class="line">	     dfs(1,0);  //从深度为1，到n+1， 一共有n次 </span><br><span class="line">	     printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">	 &#125;</span><br><span class="line">	    return 0;</span><br><span class="line">	&#125; </span><br><span class="line">	5-7组数据M≤106，裸的背包啊。</span><br><span class="line">		int main()&#123;</span><br><span class="line">		 read(n);read(m);</span><br><span class="line">		 for(R int i=1;i&lt;=n;i++)read(a[i]);</span><br><span class="line">		    if(m&lt;=1e6)&#123;</span><br><span class="line">		        f[0]=1;</span><br><span class="line">		        for(R int i=1;i&lt;=n;i++)</span><br><span class="line">		            for(R int j=m;j&gt;=a[i];j--)</span><br><span class="line">		                f[j]+=f[j-a[i]];    //这一句到底是什么意思 </span><br><span class="line">		        for(R int i=0;i&lt;=m;i++)ans+=f[i];</span><br><span class="line">		        printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">		    &#125;</span><br><span class="line">		    return 0;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-188.png" alt="upload successful"></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-189.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cctype&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define R register</span><br><span class="line">#define N 55</span><br><span class="line">using namespace std;</span><br><span class="line">template&lt;typename T&gt;inline void read(T &amp;a)&#123;</span><br><span class="line">    char c=getchar();T x=0,f=1;</span><br><span class="line">    while(!isdigit(c))&#123;if(c==&#x27;-&#x27;)f=-1;c=getchar();&#125;</span><br><span class="line">    while(isdigit(c))&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#x27;0&#x27;;c=getchar();&#125;</span><br><span class="line">    a=f*x;</span><br><span class="line">&#125;</span><br><span class="line">ll n,m,w[N],mid,suma[1&lt;&lt;21],sumb[1&lt;&lt;21],cnta,cntb,ans;</span><br><span class="line">inline void dfs(R int l,R int r,R ll sum,R ll a[],R ll &amp;cnt)&#123;</span><br><span class="line">    if(sum&gt;m)return;</span><br><span class="line">    if(l&gt;r)&#123;</span><br><span class="line">        a[++cnt]=sum;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(l+1,r,sum+w[l],a,cnt);</span><br><span class="line">    dfs(l+1,r,sum,a,cnt);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    read(n);read(m);</span><br><span class="line">    for(R int i=1;i&lt;=n;i++)read(w[i]);</span><br><span class="line">    mid=n&gt;&gt;1;</span><br><span class="line">    dfs(1,mid,0,suma,cnta);</span><br><span class="line">    dfs(mid+1,n,0,sumb,cntb);</span><br><span class="line">    sort(suma+1,suma+1+cnta);</span><br><span class="line">    for(R int i=1;i&lt;=cntb;i++)</span><br><span class="line">        ans+=upper_bound(suma+1,suma+1+cnta,m-sumb[i])-suma-1;</span><br><span class="line">    printf(&quot;%lld\n&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tips:</span><br><span class="line">在从小到大的排序数组中:</span><br><span class="line">lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br><span class="line">upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>7.P2572 [SCOI2010]序列操作 </p>
<p>  区间染色问题，老司机树(Chtholly Tree (珂朵莉树) ODT)模板；思想和分块差不多，减少无效的访问次数<br>  [codeforces 896C Willem, Chtholly and Seniorious]</p>
</li>
</ul>
<p>暴力可以加上点技巧（技巧性的暴力）：如分块，前缀和，差分 </p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">新生训练</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/myblog/categories/ACM//" class="article-tag-list-link color4">ACM</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/myblog/2019/10/29/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83class2-%E6%9A%B4%E5%8A%9B/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-新生训练class-1-熟悉oj的使用方法-贪心" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/myblog/2019/10/23/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83class-1-%E7%86%9F%E6%82%89oj%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E8%B4%AA%E5%BF%83/">新生训练class 1- 熟悉oj的使用方法&amp;&amp;贪心 </a>
    </h1>
  

        
        <a href="/myblog/2019/10/23/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83class-1-%E7%86%9F%E6%82%89oj%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E8%B4%AA%E5%BF%83/" class="archive-article-date">
  	<time datetime="2019-10-23T11:15:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-10-23</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>Calculate a+b</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; a+b &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>B ASCII码排序（输入三个字符后，按各字符的ASCII码从小到大的顺序输出这三个字符。 ）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt; //sort函数  时间复杂度为 n*log2n </span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=3;</span><br><span class="line">struct ascii&#123;</span><br><span class="line">	char zi;</span><br><span class="line">//	ascii(char a,char b,char c):a(a),b(b),c(c)&#123;&#125;  如果有多个数的话，可以用构造函数来赋值 </span><br><span class="line">&#125;asc[maxn];</span><br><span class="line">bool cmp(ascii x, ascii y)&#123;</span><br><span class="line">	return (int )x.zi&lt;(int)y.zi;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	//方法一： </span><br><span class="line">	char a,b,c;</span><br><span class="line">	char tmp;</span><br><span class="line">	//这种方法三个if，各个if之间可以相互调换顺序 </span><br><span class="line">	//比较的逻辑是a&gt;b,a&gt;c,b&gt;c;这样就实现了大的往后排 </span><br><span class="line">	while((cin&gt;&gt;a&gt;&gt;b&gt;&gt;c))&#123;</span><br><span class="line">		</span><br><span class="line">		if((int)a&gt;(int)b)&#123;</span><br><span class="line">			tmp=a;</span><br><span class="line">			a=b;</span><br><span class="line">			b=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		if((int)a&gt;(int)c)&#123;</span><br><span class="line">			tmp=a;</span><br><span class="line">			a=c;</span><br><span class="line">			c=tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		if((int )b&gt;(int )c)&#123;</span><br><span class="line">			tmp=b;</span><br><span class="line">			b=c;</span><br><span class="line">			c=tmp;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">		//cout&lt;&lt;&quot;\n&quot;;这样要比cout&lt;&lt;endl;要快 </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//方法二：sort(a,a+3);这样写可以对一个char类型的char数组按ascii码进行排序 </span><br><span class="line">	</span><br><span class="line">	//方法三，利用结构体排序： </span><br><span class="line">	while(cin&gt;&gt;asc[0].zi&gt;&gt;asc[1].zi&gt;&gt;asc[2].zi)&#123;</span><br><span class="line">		sort(asc,asc+3,cmp);</span><br><span class="line">		for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">			if(i==2)cout&lt;&lt;asc[i].zi&lt;&lt;endl;</span><br><span class="line">			else cout&lt;&lt;asc[i].zi&lt;&lt;&quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>C  计算两点间的距离 （输入两点坐标（X1,Y1）,（X2,Y2）,计算并输出两点间的距离。 ）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include &lt;iomanip&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">//c语言版 </span><br><span class="line">//编写时scanf写为scanf(&quot;%lf,%lf,%lf,%lf&quot;,x1,x2,y1,y2); ,一直出错 </span><br><span class="line">//int main()&#123;</span><br><span class="line">//	float  x1,x2,y1,y2;</span><br><span class="line">//	while(~scanf(&quot;%f%f%f%f&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2))&#123;</span><br><span class="line">//	printf(&quot;%.2f\n&quot;,sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));</span><br><span class="line">//	&#125;</span><br><span class="line">//&#125; </span><br><span class="line"></span><br><span class="line">//c++版本</span><br><span class="line">int main()&#123;</span><br><span class="line">	//切断cin和cout的联系，加快速度 </span><br><span class="line">	std::ios::sync_with_stdio(false);</span><br><span class="line">	std::cin.tie(0);</span><br><span class="line">	</span><br><span class="line">	double x1,x2,y1,y2;</span><br><span class="line">	while(cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2)&#123;</span><br><span class="line">		cout&lt;&lt;setprecision(2)&lt;&lt;fixed&lt;&lt;sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>D - 计算球体积（根据输入的半径值，计算球的体积。 ）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include &lt;iomanip&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">#define PI 3.1415927</span><br><span class="line">int main()&#123;</span><br><span class="line">	//切断cin和cout的联系，加快速度 </span><br><span class="line">	std::ios::sync_with_stdio(false);</span><br><span class="line">	std::cin.tie(0);</span><br><span class="line">	</span><br><span class="line">	double r;</span><br><span class="line">	while(cin&gt;&gt;r)&#123;</span><br><span class="line">		cout&lt;&lt;setprecision(3)&lt;&lt;fixed&lt;&lt;4*PI*pow(r,3)/3&lt;&lt;endl;</span><br><span class="line">//		cout&lt;&lt;setprecision(3)&lt;&lt;fixed&lt;&lt;(4/3)*PI*pow(r,3)&lt;&lt;endl;</span><br><span class="line">//上面这样的结果是不对的，应该乘完了之后在去除 </span><br><span class="line">//		cout&lt;&lt;setprecision(3)&lt;&lt;fixed&lt;&lt;4*PI*r*r*r/3&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>E - 求绝对值(求实数的绝对值。 )</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include &lt;iomanip&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//切断cin和cout的联系，加快速度 </span><br><span class="line">	std::ios::sync_with_stdio(false);</span><br><span class="line">	std::cin.tie(0);</span><br><span class="line">	</span><br><span class="line">	double r;</span><br><span class="line">	while(cin&gt;&gt;r)&#123;</span><br><span class="line">		if(r&lt;0)&#123;</span><br><span class="line">			//cout&lt;&lt;setprecision(2)&lt;&lt;fixed&lt;&lt;r*(-1)&lt;&lt;endl;  这两种方法都可以 </span><br><span class="line">			cout&lt;&lt;setprecision(2)&lt;&lt;fixed&lt;&lt;-r&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">		else&#123;</span><br><span class="line">			cout&lt;&lt;setprecision(2)&lt;&lt;fixed&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-<br>F - 成绩转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include &lt;iomanip&gt; </span><br><span class="line">using namespace std;</span><br><span class="line">#define PI 3.1415927</span><br><span class="line">int main()&#123;</span><br><span class="line">	//切断cin和cout的联系，加快速度 </span><br><span class="line">	std::ios::sync_with_stdio(false);</span><br><span class="line">	std::cin.tie(0);</span><br><span class="line">	int n;</span><br><span class="line">	while(cin&gt;&gt;n)&#123;</span><br><span class="line">		if(90&lt;=n&amp;&amp;n&lt;=100 )cout&lt;&lt;&quot;A&quot;&lt;&lt;endl;</span><br><span class="line">		else if(80&lt;=n&amp;&amp;n&lt;=89)cout&lt;&lt;&quot;B&quot;&lt;&lt;endl;</span><br><span class="line">		else if(70&lt;=n&amp;&amp;n&lt;=79)cout&lt;&lt;&quot;C&quot;&lt;&lt;endl;</span><br><span class="line">		else if(60&lt;=n&amp;&amp;n&lt;=69)cout&lt;&lt;&quot;D&quot;&lt;&lt;endl;</span><br><span class="line">		else if(0&lt;=n&amp;&amp;n&lt;=59)cout&lt;&lt;&quot;E&quot;&lt;&lt;endl;</span><br><span class="line">		else cout&lt;&lt;&quot;Score is error!&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>G - 第几天？(给定一个日期，输出这个日期是该年的第几天。 )</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool isLeapYear(int y) &#123;</span><br><span class="line">    return (y % 4 == 0 &amp;&amp; y % 100 != 0) || (y % 400 == 0);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int m,d,y,tianshu;</span><br><span class="line">	int rn[13]=&#123;0,31,29,31,30,31,30,31,31,30,31,30,31&#125;;</span><br><span class="line">	int pn[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;</span><br><span class="line">	//格式化输入，%d/%d/%d这样才可以 </span><br><span class="line">	while(~scanf(&quot;%d/%d/%d&quot;,&amp;y,&amp;m,&amp;d))&#123;</span><br><span class="line">		//~scanf(&quot;%d%c%d%c%d&quot;,&amp;y,&amp;ch,&amp;m,&amp;ch,&amp;d)这种方法也是可以的 </span><br><span class="line">		tianshu=0; //在这地方一定要重新初始化，不然tianshu会加上上一次运算的值 </span><br><span class="line">		if(isLeapYear(y))&#123;</span><br><span class="line">			for(int i=1;i&lt;m;i++)&#123;  //从1月加到第m-1个月 </span><br><span class="line">				tianshu +=rn[i];</span><br><span class="line">			&#125;</span><br><span class="line">			tianshu+=d;</span><br><span class="line">		&#125; else&#123;</span><br><span class="line">			for(int j=1;j&lt;m;j++)&#123;</span><br><span class="line">				tianshu +=pn[j];</span><br><span class="line">			&#125;</span><br><span class="line">			tianshu+=d;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;tianshu&lt;&lt;endl;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>H - 平方和与立方和（给定一段连续的整数，求出他们中所有偶数的平方和以及所有奇数的立方和。 ）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int m,n,jishu,oshu;</span><br><span class="line">	while((cin&gt;&gt;m&gt;&gt;n))&#123;</span><br><span class="line">		jishu=0;oshu=0;</span><br><span class="line">		if(n&lt;m)&#123;</span><br><span class="line">			//可以用swap(n,m)来交换n和m的值 </span><br><span class="line">			for(int i=n;i&lt;=m;i++)</span><br><span class="line">				if(i&amp;1==1)&#123;//是奇数</span><br><span class="line">					jishu+=i*i*i;		</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">					oshu+=i*i;</span><br><span class="line">				&#125;	</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			for(int i=m;i&lt;=n;i++)</span><br><span class="line">				if(i&amp;1==1)&#123;//是奇数</span><br><span class="line">					jishu+=i*i*i;		</span><br><span class="line">				&#125;else&#123;</span><br><span class="line">					oshu+=i*i;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;oshu&lt;&lt;&quot; &quot;&lt;&lt;jishu&lt;&lt;endl; </span><br><span class="line">			</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>I - 数值统计(统计给定的n个数中，负数、零和正数的个数。 )</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">double shu[101];</span><br><span class="line">int ling,zhengshu,fushu;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//输入n并且！0时的语句为下面的这条语句 </span><br><span class="line">	while(cin&gt;&gt;n,n!=0)&#123;</span><br><span class="line">		ling=zhengshu=fushu=0; </span><br><span class="line">		for(int i=0;i&lt;n;i++)cin&gt;&gt;shu[i];</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			if(shu[i]&gt;0)zhengshu++;</span><br><span class="line">			else if(shu[i]&lt;0)fushu++;</span><br><span class="line">			else ling++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;fushu&lt;&lt;&quot; &quot;&lt;&lt;ling&lt;&lt;&quot; &quot;&lt;&lt;zhengshu&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>J - 求数列的和(数列的第一项为n，以后各项为前一项的平方根，求数列的前m项的和。 )</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include &lt;iomanip&gt; </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	double sum=0,tmp;</span><br><span class="line">	while(cin&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">		sum=0;</span><br><span class="line">		if(m==1)&#123;</span><br><span class="line">			cout&lt;&lt;setprecision(2)&lt;&lt;fixed&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			sum+=n;</span><br><span class="line">			tmp=n;</span><br><span class="line">			for(int i=1;i&lt;m;i++)&#123;//m-1项 </span><br><span class="line">				sum+=sqrt(tmp);</span><br><span class="line">				tmp=sqrt(tmp);</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;setprecision(2)&lt;&lt;fixed&lt;&lt;sum&lt;&lt;endl;	</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>K - 水仙花数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int shiwei(int shu)&#123;</span><br><span class="line">	return ((shu/10)%10); </span><br><span class="line">&#125;</span><br><span class="line">int baiwei(int shu)&#123;</span><br><span class="line">	return ((shu/100)%10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int xia;</span><br><span class="line">	int m,n;</span><br><span class="line">	int a[1000];</span><br><span class="line">	int flag;</span><br><span class="line">	while(cin&gt;&gt;m&gt;&gt;n)&#123;</span><br><span class="line">		memset(a,0,sizeof(a));</span><br><span class="line">		xia=0;</span><br><span class="line">		flag=0;//这地方以为内下一次循环要用到这些变量，</span><br><span class="line">		//所以要对一些变量初始化才可以不会出错 </span><br><span class="line">		for(int i=m;i&lt;=n;i++)&#123;</span><br><span class="line">			if(i==((i%10)*(i%10)*(i%10)+shiwei(i)*shiwei(i)*shiwei(i)+baiwei(i)*baiwei(i)*baiwei(i)))</span><br><span class="line">			&#123;</span><br><span class="line">				flag=1;</span><br><span class="line">				xia++;</span><br><span class="line">				a[xia]=i;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if(flag==0)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;</span><br><span class="line">			</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			for(int i=1;i&lt;=xia;i++)&#123;</span><br><span class="line">				if(i==xia)cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">				else&#123;</span><br><span class="line">					cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">				</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>L - 多项式求和 (1 - 1&#x2F;2 + 1&#x2F;3 - 1&#x2F;4 + 1&#x2F;5 - 1&#x2F;6 + …现在请你求出该多项式的前n项的和。 )</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include &lt;iomanip&gt; </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double duo(int n)&#123;</span><br><span class="line">	double sum=0.00;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(i%2==1)sum=sum+1.0/i;</span><br><span class="line">		else sum=sum-1.0/i;</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	</span><br><span class="line">	int m;</span><br><span class="line">	int a[110];//不能在cin&gt;&gt;m之后写a[m] </span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;m;i++)cin&gt;&gt;a[i]; </span><br><span class="line">	for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">		printf(&quot;%.2lf\n&quot;,duo(a[i]) );</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>M - 素数判定(对于表达式n^2+n+41，当n在（x,y）范围内取整数值时（包括x,y）(-39&lt;&#x3D;x&lt;y&lt;&#x3D;50)，判定该表达式的值是否都为素数。 )</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string.h&gt; </span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn=20000;</span><br><span class="line">int prime[maxn];</span><br><span class="line">bool isPrime[maxn];</span><br><span class="line">bool noPrime[maxn];</span><br><span class="line">//2591</span><br><span class="line">//1523</span><br><span class="line">int eulerSieve_1(int n)&#123;</span><br><span class="line">	int num=0;</span><br><span class="line">	memset(isPrime,true,sizeof(isPrime));</span><br><span class="line">	isPrime[0]=isPrime[1]=false;</span><br><span class="line">	for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">		//这个从prime的0下标开始存素数 </span><br><span class="line">		if(isPrime[i])prime[num++]=i;</span><br><span class="line">		//第一次执行num++，prime[0]存入i，之后num为1，那么下面这个for中num为1 </span><br><span class="line">		for(int j=0;j&lt;num&amp;&amp;i*prime[j]&lt;=n;j++)&#123;</span><br><span class="line">			//这个从j开始到num，遍历一遍prime数组，所以遍历的次数为数组个数 </span><br><span class="line">			isPrime[i*prime[j]]=false;</span><br><span class="line">			if(i%prime[j]==0)break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return num;</span><br><span class="line">&#125;</span><br><span class="line">int sieve(int n)&#123;</span><br><span class="line">	int num=0;</span><br><span class="line">	memset(isPrime,true,sizeof(isPrime));</span><br><span class="line">	isPrime[0]=isPrime[1]=false;</span><br><span class="line">	for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">		if(isPrime[i])&#123;</span><br><span class="line">			prime[num++]=i;</span><br><span class="line">			for(int j=2;j*i&lt;=n;j++)&#123;</span><br><span class="line">				isPrime[j*i]=false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int eulerSieve_3(int n)&#123;</span><br><span class="line">	int num=0;</span><br><span class="line">	memset(prime,0,sizeof(prime));</span><br><span class="line">	memset(noPrime,false,sizeof(noPrime));</span><br><span class="line">	noPrime[0]=noPrime[1]=true;</span><br><span class="line">	for(int i=2;i&lt;=n;++i)&#123;</span><br><span class="line">		if(noPrime[i]==false)prime[++num]=i;</span><br><span class="line">		//从1开始存素数 </span><br><span class="line">		for(int j=1;j&lt;=num&amp;&amp;i*prime[j]&lt;=n;++j)&#123;</span><br><span class="line">			noPrime[i*prime[j]]=true;</span><br><span class="line">			if(i%prime[j] ==0)break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int x,y,flag=0;</span><br><span class="line">	int tmp;</span><br><span class="line">	sieve(20000);</span><br><span class="line">	//for(int i=0;i&lt;100;i++) cout&lt;&lt;prime[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	while(cin&gt;&gt;x&gt;&gt;y)&#123;</span><br><span class="line">		if(x==0&amp;&amp;y==0)break;</span><br><span class="line">		flag=0;</span><br><span class="line">		for(int i=x;i&lt;=y;i++)&#123;</span><br><span class="line">			tmp=i*i+i+41;</span><br><span class="line">			if(noPrime[tmp]==true)&#123;</span><br><span class="line">				//但是这一句写为了isPrime[tmp]==false就会出现错误，不知道为什么 </span><br><span class="line">				flag=1;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag==0)cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl;</span><br><span class="line">		else cout&lt;&lt;&quot;Sorry&quot;&lt;&lt;endl;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>N - 蟠桃记 (第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？ )</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int digui(int n)&#123;</span><br><span class="line">	if(n==1)return 1;</span><br><span class="line">	else return  2*(digui(n-1)+1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">//一定要把main写对了，写成mian就会出现id已存在的错误 </span><br><span class="line">	int n;</span><br><span class="line">    while(cin&gt;&gt;n)&#123;</span><br><span class="line">    	cout&lt;&lt;digui(n)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>O - 青年歌手大奖赛_评委会打分</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn=110;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	double sum;</span><br><span class="line">	int a[maxn];</span><br><span class="line">    while(cin&gt;&gt;n)&#123;</span><br><span class="line">    	sum=0;</span><br><span class="line">    	for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    	sort(a,a+n);</span><br><span class="line">    	for(int i=1;i&lt;n-1;i++)sum+=a[i];</span><br><span class="line">    	printf(&quot;%.2lf\n&quot;,sum/(n-2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>P-Best Cow Line (字典序问题）<br>可以用cin.getline();但是时间慢，           也可以用 scanf(“%s”, tmp);s[i] &#x3D; tmp[0];</li>
</ul>
<p>参考了网上的思路发现，还可以用scanf(“ %c”, &amp;ch)；</p>
<p>在格式串中，空格的意思是匹配输入中的所有换行、TAB、空格，所以加上一个空格，就可以屏蔽掉在输入中的所有的不愉快的因素了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char s[2002];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			scanf(&quot; %c&quot;,&amp;s[i]);	//前面的空格用来匹配空白符号 </span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		int a=0,b=n-1;</span><br><span class="line">		int ans=0;</span><br><span class="line">		while(a&lt;=b)&#123;</span><br><span class="line">			bool left=false;		</span><br><span class="line">			for(int i=0;a+i&lt;=b;i++)&#123;		//字符串反转比较， </span><br><span class="line">				if(s[a+i]&lt;s[b-i])&#123;</span><br><span class="line">					left=true;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				else if(s[a+i]&gt;s[b-i])&#123;</span><br><span class="line">					left=false;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if(left)  putchar(s[a++]);</span><br><span class="line">			else putchar(s[b--]);   //如果相等就返回字符串右边的</span><br><span class="line">			ans++;</span><br><span class="line">			if(ans==80)&#123;</span><br><span class="line">				printf(&quot;\n&quot;);</span><br><span class="line">				ans=0;</span><br><span class="line">			&#125; 	</span><br><span class="line">		&#125;	</span><br><span class="line">		  printf(&quot;\n&quot;);	</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>Q Saruman’s Army<br>　　题意：在一条直线上，有n个点。从这n个点中选择若干个，给他们加上标记。对于每一个点，其距离为R以内的区域里必须有一个被标记的点。问至少要有多少点被加上标记。<br>　　题解：我们从最左边的开始考虑。对于这个点，到距其R以内的区域必须要有带有标记的点。带有标记的点一定在其右侧（包含这个点本身）。给从最左边开始，距离为R以内的最远的点加上标记，尽可能的覆盖更靠右边的点。对于添加了标记的点右侧相距超过R的下一个点，采用同样的方法找到最右侧R距离以内最远的点添加标记。在所有点都被覆盖之前不断重复这一过程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[1010];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,R,i,ans;</span><br><span class="line">	while(scanf(&quot;%d%d&quot;,&amp;R,&amp;n)&amp;&amp;R!=-1||n!=-1)</span><br><span class="line">	&#123;</span><br><span class="line">		for(i=0;i&lt;n;++i)</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">		sort(a,a+n);</span><br><span class="line">		i=0;ans=0;</span><br><span class="line">		while(i&lt;n)</span><br><span class="line">		&#123;</span><br><span class="line">			int s=a[i++];//s表示没有被覆盖的最左边的点 </span><br><span class="line">			while(i&lt;n&amp;&amp;a[i]&lt;=s+R)//一直向右前进直到距s的距离大于R的点 </span><br><span class="line">				i++;</span><br><span class="line">			int p=a[i-1];//被标记的点 </span><br><span class="line">			while(i&lt;n&amp;&amp;a[i]&lt;=p+R)//一直向右前进直到距p的距离大于R的点 </span><br><span class="line">				i++;</span><br><span class="line">			ans++;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>R - Fence Repair<br>每次都要先从大长木板上切下要分割的木板中的较大的小木板，这样才能最后切割的费用最小。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	priority_queue&lt;long long,vector&lt;long long int&gt;,greater&lt;long long int&gt; &gt;p;</span><br><span class="line">//逆着来，就找两个最小的，然后压进去，倒这来求</span><br><span class="line">	long long int i,n,a,s,x,y;</span><br><span class="line">	scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">		s=0;</span><br><span class="line">	   for(i=0;i&lt;n;i++)</span><br><span class="line">	   &#123;</span><br><span class="line">		   scanf(&quot;%lld&quot;,&amp;a);</span><br><span class="line">		   p.push(a);</span><br><span class="line">	   &#125;</span><br><span class="line">	   while(p.size()&gt;1)</span><br><span class="line">	   &#123;</span><br><span class="line">	    	x=p.top();</span><br><span class="line">		    p.pop();</span><br><span class="line">		    y=p.top();</span><br><span class="line">		    p.pop();</span><br><span class="line">		    s=s+x+y;</span><br><span class="line">		   </span><br><span class="line">		    p.push(x+y);</span><br><span class="line">	    &#125;</span><br><span class="line">	    printf(&quot;%lld\n&quot;,s);</span><br><span class="line">	   </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>S - Cleaning Shifts<br> 题意：给出区间[ 1,T ]和N个小区间，要求用尽可能少的小区间覆盖区间[ 1,T ]，输出最少的小区间数量；若不能覆盖，输出-1。</li>
</ul>
<p>思路：贪心。</p>
<p>具体：令begin为当前未被覆盖的区间起点。</p>
<pre><code>        贪心策略：选取包含点begin的区间中右端点最大的那个；若不存在包含begin的区间，输出-1。
</code></pre>
<p>证明：因为begin为未被覆盖的区间起点，所以begin一定要被小区间覆盖，将最优解中覆盖begin的小区间命名为区间X。</p>
<pre><code>        以下使用剪贴技术证明。

        若存在包含begin的小区间Y( Y != X )使最终所需的小区间数少于原最优解，那么Y一定包含了X之后的某些小区间，

        即Y的右端点大于X的右端点，与贪心策略矛盾，得证。
        
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=25010;</span><br><span class="line">int n, T, sum, start=1, end;</span><br><span class="line">struct node&#123; int s, e; &#125;cow[N];</span><br><span class="line"> </span><br><span class="line">bool cmp( node a, node b ) &#123;</span><br><span class="line">	return a.s&lt;b.s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">	scanf( &quot;%d%d&quot;, &amp;n, &amp;T );</span><br><span class="line">	for( int i=1; i&lt;=n; i++ ) &#123;</span><br><span class="line">		scanf( &quot;%d%d&quot;, &amp;cow[i].s, &amp;cow[i].e );</span><br><span class="line">		end=max( end, cow[i].e );</span><br><span class="line">		cow[i].e++;</span><br><span class="line">	&#125;</span><br><span class="line">	sort( cow+1, cow+n+1, cmp );</span><br><span class="line">	if( 1&lt;cow[1].s || end&lt;T )&#123; printf( &quot;-1\n&quot; ); return 0; &#125;</span><br><span class="line">	end=0;</span><br><span class="line">	for( int i=1; i&lt;=n; ) &#123;</span><br><span class="line">		bool flg=0;</span><br><span class="line">		while( i&lt;=n &amp;&amp; cow[i].s&lt;=start ) &#123;</span><br><span class="line">			end=max( end, cow[i].e );</span><br><span class="line">			i++; flg=1;</span><br><span class="line">		&#125;</span><br><span class="line">		if( !flg )&#123; printf( &quot;-1\n&quot; ); return 0; &#125;</span><br><span class="line">		sum++;</span><br><span class="line">		if( end&gt;T ) break;</span><br><span class="line">		start=end;</span><br><span class="line">	&#125;</span><br><span class="line">	printf( &quot;%d\n&quot;, sum );</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>T poj3190Stall Reservations(贪心+优先队列)<br>思路：<br>首先根据挤奶时间的先后顺序排序。。。然后将第一头牛加入优先队列。。然后就是加入优先队列的牛应该根据越早结束挤奶那么优先级更高，如果时间结束点相等，那么开始时间早的优先级高。。。<br>然后从前向后枚举。如果碰到有牛的挤奶时间的开始值大于优先队列的首部的结束值，那么说明这两头牛可以一起公用一个挤奶房。。然后从优先队列中删除这头牛。。那么这个问题就得到解决了。。。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;limits.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1000000+10;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int st,ed;</span><br><span class="line">    int pos;//pos记录是第几个奶牛</span><br><span class="line">    bool operator&lt;(const node &amp;a)const</span><br><span class="line">    &#123;</span><br><span class="line">        if(ed==a.ed)</span><br><span class="line">           return st&gt;a.st;</span><br><span class="line">        return ed&gt;a.ed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line">int used[maxn];//used记录奶牛挤奶的位置=。=</span><br><span class="line">int cmp(node l1,node l2)</span><br><span class="line">&#123;</span><br><span class="line">    if(l1.st==l2.st)</span><br><span class="line">        return l1.ed&lt;l2.ed;</span><br><span class="line">    return l1.st&lt;l2.st;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while(~scanf(&quot;%d&quot;,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        priority_queue&lt;node&gt;q;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;,&amp;a[i].st,&amp;a[i].ed);</span><br><span class="line">            a[i].pos=i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a+1,a+n+1,cmp);</span><br><span class="line">        q.push(a[1]);</span><br><span class="line">        int ans=1;</span><br><span class="line">        used[a[1].pos]=1;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!q.empty()&amp;&amp;q.top().ed&lt;a[i].st)//判定是否符合条件</span><br><span class="line">            &#123;</span><br><span class="line">                used[a[i].pos]=used[q.top().pos];</span><br><span class="line">                q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            else//不符合条件槽的数量加一，同时这个奶牛应该在新加的槽</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                used[a[i].pos]=ans;</span><br><span class="line">            &#125;</span><br><span class="line">            q.push(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            printf(&quot;%d\n&quot;,used[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>U POJ 1017 Packets(贪心</li>
</ul>
<p>题意：工厂出售边长分别为1,2,3,4,5,6的正方形板子，但工厂只有6<em>6的板子，其他的板子都是从这种板子上裁剪而来的。现在给出分别这些板子的需求量，问最少需要多少块6</em>6的板子。</p>
<p>题解：从面积大的开始取，一块6<em>6的板子可以去一块5</em>5的板子剩下11个 1<em>1的板子。取一块4</em>4的板子剩下5个2<em>2的板子。 6</em>6的板子可以取四块3<em>3的板子，在一块6</em>6板子上取3<em>3的板子数目为  1  2  3  4  的时候剩下 2</em>2的板子分别为  5  3  1  0，剩余部分还可以去1<em>1的板子。 若2</em>2的板子有剩余，还可以分割成1*1的板子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">int dir[4]=&#123;0,5,3,1&#125;;</span><br><span class="line">int a[10];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int i,sum,ans;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		sum=0;</span><br><span class="line">		for(i=1;i&lt;7;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">			sum+=a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		if(!sum)</span><br><span class="line">			break;</span><br><span class="line">		ans=a[6]+a[5]+a[4]+(a[3]+3)/4;//计算边长为3 4 5 6的板子消耗量 </span><br><span class="line">		int cnt_2=a[4]*5+dir[a[3]%4];</span><br><span class="line">		if(a[2]&gt;cnt_2)</span><br><span class="line">			ans+=(a[2]-cnt_2+8)/9;//当上面剩余的2*2板子量不足时，需要消耗新的板子 </span><br><span class="line">		int cnt_1=ans*36-a[6]*36-a[5]*25-a[4]*16-a[3]*9-a[2]*4;</span><br><span class="line">		if(a[1]&gt;cnt_1)//当上面剩余的1*1板子量不足时，需要消耗新的板子 </span><br><span class="line">			ans+=(a[1]-cnt_1+35)/36;</span><br><span class="line">		printf(&quot;%d\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>V    Stripies （和R题Fence Repair是一样一样的）<br>题意：介绍了一大堆，全废话。 题目就是说有n个物品，每个物品重w_i，对于两个物品他们合并时重量就会变成<br>w &#x3D; 2 * sqrt(w_a * w_b)。 问当n个物品合成一个时，最小重量是多少？<br>题解：贪心啊，不过要用到一点数学知识，在n个物品中取两个物品合并，要想最后总重最小，要每次取两个重量最大的物品。关于这个结论，下面给出证明：<br>设：n&#x3D;3，三个物品的重量分比为：a，b，c， 合并之后最小重量为w。<br>则w &#x3D; 2 * sqrt( a* 2 * sqrt(b * c) )<br>化简后的 w^2&#x2F;8 &#x3D; sqrt( a<em>a</em>b*c )， 此式可得 a 取最小时 w 的值最小。<br>归纳总结，n个物品每次取最大的两个合并，总重最小。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	double num;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		priority_queue&lt;double&gt;q;</span><br><span class="line">		while(n--)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(&quot;%lf&quot;,&amp;num);</span><br><span class="line">			q.push(num);</span><br><span class="line">		&#125;</span><br><span class="line">		double ans=q.top();//注意n为1的情况 </span><br><span class="line">		while(q.size()&gt;1)</span><br><span class="line">		&#123;</span><br><span class="line">			double a=q.top();</span><br><span class="line">			q.pop();</span><br><span class="line">			double b=q.top();</span><br><span class="line">			q.pop();</span><br><span class="line">			ans=2*sqrt(a*b);</span><br><span class="line">			q.push(ans);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;%.3f\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<ul>
<li>W-Protecting the Flowers</li>
</ul>
<p>题解：因为农夫每抱走一头牛，剩下的n-1头牛的问题还是和上面的问题一致。故要想使最终结果最优，所以必须要求当前最优解，所以可以判定是贪心问题。<br>刚开始，以为先优先d值大的，d值相等时优先t值小的。 WA了，应该优先 t&#x2F;d 小的。<br>若先取走a牛，则食花量为 2 * t_a * d_b ；<br>若先取走b牛，则食花量为 2 * t_b * d_a ；<br>两式分别除以 d_a * d_b ；分别为 2 * t_a &#x2F; d_a         2 * t_b &#x2F; d_b<br>所以要优先 t&#x2F;d 值小的。</p>
<p>对于贪心问题n与n-1的策略是相同的，所以由n&#x3D;2的情况推广到任意n的情况。</p>
<p>注意：O(n^2)算法是会超时的，除去排序情况，其他部分可以优化到O(n)的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#define ll __int64</span><br><span class="line">using namespace std;</span><br><span class="line">ll sum[100010];</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">	ll t,d; </span><br><span class="line">&#125;cow[100010];</span><br><span class="line"> </span><br><span class="line">int cmp(node a,node b)</span><br><span class="line">&#123;</span><br><span class="line">	return (a.t*1.0/a.d)&lt;(b.t*1.0/b.d);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,i,j;</span><br><span class="line">	ll ans;</span><br><span class="line">	while(scanf(&quot;%d&quot;,&amp;n)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		for(i=0;i&lt;n;++i)</span><br><span class="line">			scanf(&quot;%I64d%I64d&quot;,&amp;cow[i].t,&amp;cow[i].d);</span><br><span class="line">		sort(cow,cow+n,cmp);</span><br><span class="line">		sum[n-1]=0;//最后一头牛的消耗为0</span><br><span class="line">		for(i=n-2;i&gt;=0;i--)//其余每头牛的消耗为上一头牛的消耗+本头牛去的时候的消耗</span><br><span class="line">			sum[i]=sum[i+1]+cow[i+1].d;</span><br><span class="line">		ans=0;</span><br><span class="line">		for(i=0;i&lt;n;++i)</span><br><span class="line">			ans+=2*cow[i].t*sum[i]; //遍历一遍得到总的消耗</span><br><span class="line">		printf(&quot;%I64d\n&quot;,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>X-The Dragon of Loowater<br>题意<br>有n头龙🐉和m个骑士，需要让这些骑士杀掉所有的龙，骑士能杀死龙的条件是骑士的身高比龙头的直径要高，每个骑士只能被雇用一次，且雇佣的费用是骑士的身高，求杀死所有龙所需要的最少费用 如果不能杀死所有的龙输出 Loowater is doomed!<br>思路<br>把龙头的直径和骑士的身高从小到大排序，从第一头龙开始找，然后从所有的骑士里面找能杀死他的，如果找到一个肯定是最小的，然后把他标记上（代表不能再雇佣他了） 如果可以杀死所有的龙🐉，那么输出答案，否则输出 Loowater is doomed!</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 20000+100;</span><br><span class="line">int a[maxn],b[maxn];//数组a代表龙首的个数，b代表骑士身高 </span><br><span class="line">bool bk[maxn];//记录该龙是否被杀死 </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);</span><br><span class="line">    int n,m;//n为龙的个数，m为骑士人数 </span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        if(m==0 &amp;&amp; n==0)</span><br><span class="line">            break;</span><br><span class="line">        memset(bk,false,sizeof(bk));</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">            cin&gt;&gt;b[i];</span><br><span class="line">        sort(a,a+n);</span><br><span class="line">        sort(b,b+m);</span><br><span class="line"></span><br><span class="line">        int sum=0,cnt=0;</span><br><span class="line">		//sum计数需要的金币数，cnt计数可以被杀死龙的头数 </span><br><span class="line">        for(int i=0;i&lt;m;i++)</span><br><span class="line">        for(int j=0;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(!bk[j] &amp;&amp; b[i]&gt;=a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                sum+=b[i];</span><br><span class="line">                bk[j]=true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cnt==n )</span><br><span class="line">            cout&lt;&lt;sum&lt;&lt;&quot;\n&quot;;</span><br><span class="line">        else</span><br><span class="line">            cout&lt;&lt;&quot;Loowater is doomed! \n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Y  <a target="_blank" rel="noopener" href="https://vjudge.net/problem/UVA-11729">Commando War 突击队战争</a></li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-186.png" alt="upload successful"><br> 调度问题，直接贪心出完成任务需要的时间最长的那个人排序，就行了。</p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-187.png" alt="upload successful"></p>
<p><strong>一种贪心的证明思路是：先假设找到了一种最优解，然后看我们贪心的方法是否会改变这个最优解，如果改变不了，那么说明我们的方法一定是没有问题的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;map&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#define ll long long</span><br><span class="line">#define pb push_back</span><br><span class="line">#define pm make_pair</span><br><span class="line">#define fi first</span><br><span class="line">#define se second</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAX = 2e5 + 5;</span><br><span class="line">struct Node &#123;</span><br><span class="line">	int a,b;</span><br><span class="line">&#125; node[MAX];</span><br><span class="line">bool cmp(Node a,Node b) &#123;</span><br><span class="line">	return a.b&gt;b.b;  //让执行时间长的排在前面</span><br><span class="line">&#125;</span><br><span class="line">int n;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int iCase = 0;</span><br><span class="line">	while(~scanf(&quot;%d&quot;,&amp;n)) &#123;</span><br><span class="line">		if(n == 0) break;</span><br><span class="line">		for(int i = 1; i&lt;=n; i++) scanf(&quot;%d%d&quot;,&amp;node[i].a,&amp;node[i].b);</span><br><span class="line">		int ans = 0,tmp=0;</span><br><span class="line">		sort(node+1,node+n+1,cmp);</span><br><span class="line">		for(int i = 1; i&lt;=n; i++) &#123;</span><br><span class="line">			tmp += node[i].a;</span><br><span class="line">			ans = max(ans,tmp + node[i].b);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Case %d: %d\n&quot;,++iCase,ans);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>Z - Children’s Game  （字典序问题）<br>题意<br>让你从给定的n个字符串中组成一个字典序最大的字符串<br>思路<br>如果是9 和 90 两个字符串，如果按照字典序排序的话是909 但是990比它要大，要重载运算符符&lt;，定义a+b &gt; b+a为less真，按字典序从大到小的顺序来排列， 这样排完之后就是字典序最大的字符串了.<br>不能挨个位数的比较，要找到好的比较方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">string num[55];</span><br><span class="line"> </span><br><span class="line">bool cmp(string a, string b)</span><br><span class="line">&#123;//要转换方法为这样，而不是单纯的比较每位数字的大小（要找到好的排序方法） </span><br><span class="line">	return a+b &gt; b+a;     //‘+’表示a和b的连接 </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n;</span><br><span class="line">	while(scanf(&quot;%d&quot;, &amp;n), n)</span><br><span class="line">	&#123;</span><br><span class="line">		for(int i=0; i&lt;n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; num[i];</span><br><span class="line">		&#125;</span><br><span class="line">		sort(num, num+n, cmp);</span><br><span class="line">		for(int i=0; i&lt;n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; num[i];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">新生训练</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/myblog/categories/ACM//" class="article-tag-list-link color4">ACM</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/myblog/2019/10/23/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83class-1-%E7%86%9F%E6%82%89oj%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E8%B4%AA%E5%BF%83/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-杭电那10道题" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/myblog/2019/10/12/%E6%9D%AD%E7%94%B5%E9%82%A310%E9%81%93%E9%A2%98/">杭电那10道题</a>
    </h1>
  

        
        <a href="/myblog/2019/10/12/%E6%9D%AD%E7%94%B5%E9%82%A310%E9%81%93%E9%A2%98/" class="archive-article-date">
  	<time datetime="2019-10-12T07:23:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-10-12</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">杭电</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/myblog/categories/编程刷题//" class="article-tag-list-link color5">编程刷题</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/myblog/2019/10/12/%E6%9D%AD%E7%94%B5%E9%82%A310%E9%81%93%E9%A2%98/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-最小生成树，最短路径，哈夫曼编码" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/myblog/2019/10/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/">最小生成树，最短路径，哈夫曼编码</a>
    </h1>
  

        
        <a href="/myblog/2019/10/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/" class="archive-article-date">
  	<time datetime="2019-10-10T11:36:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-10-10</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="最小生成树（趣学算法2-7-沟通无限校园网）"><a href="#最小生成树（趣学算法2-7-沟通无限校园网）" class="headerlink" title="最小生成树（趣学算法2.7 沟通无限校园网）"></a>最小生成树（趣学算法2.7 沟通无限校园网）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int INF =0x3fffffff;</span><br><span class="line">const int  N=100;</span><br><span class="line">bool s[N];</span><br><span class="line">int closest[N];</span><br><span class="line">int lowcost[N];</span><br><span class="line">void Prim(int n,int u0,int c[N][N])&#123;</span><br><span class="line">	s[u0]=true;</span><br><span class="line">	int i;</span><br><span class="line">	int j;</span><br><span class="line">	for(int i=1;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		if(i!=u0)&#123;</span><br><span class="line">			lowcost[i]=c[u0][i];</span><br><span class="line">			closest[i]=u0;</span><br><span class="line">			s[i]=false;</span><br><span class="line">		&#125;</span><br><span class="line">		//这就是那个u0的情况 </span><br><span class="line">		else lowcost[i]=0;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		int temp=INF;</span><br><span class="line">		int t=u0;</span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			if((!s[j])&amp;&amp;lowcost[j]&lt;temp)&#123;</span><br><span class="line">				t=j;</span><br><span class="line">				temp=lowcost[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if(t==u0)break;</span><br><span class="line">		s[t]=true;	//把t加进来 </span><br><span class="line">		for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">			if((!s[j])&amp;&amp;(c[t][j]&lt;lowcost[j]))</span><br><span class="line">			&#123;</span><br><span class="line">				lowcost[j]=c[t][j];</span><br><span class="line">				closest[j]=t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line">	int main()&#123;</span><br><span class="line">		int n,c[N][N],m,u,v,w;</span><br><span class="line">		int u0 ;</span><br><span class="line">		cout&lt;&lt;&quot;shuru jiedianshu n and bianshu m&quot;&lt;&lt;endl;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		int sumcost=0;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">			for(int j=1;j&lt;=n;j++)</span><br><span class="line">				c[i][j]=INF;</span><br><span class="line">		cout&lt;&lt;&quot;shuru jiedianshu n v de bianzhi w&quot;&lt;&lt;endl;</span><br><span class="line">		for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">			cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">			c[u][v]=c[v][u]=w;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;&quot;shuru renyijiedian u0&quot;&lt;&lt;endl;</span><br><span class="line">		cin&gt;&gt;u0;</span><br><span class="line">		Prim(n,u0,c);</span><br><span class="line">		cout&lt;&lt;&quot;数组lowcost的内容为：&quot;&lt;&lt;endl;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">			cout&lt;&lt;lowcost[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		for(int i=1;i&lt;=n;i++)</span><br><span class="line">			sumcost+=lowcost[i];</span><br><span class="line">		cout&lt;&lt;&quot; 最小花费是：&quot;&lt;&lt;sumcost&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">		return 0; </span><br><span class="line">		</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">还有优化，p93</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">最小生成树</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">最短路径</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">哈夫曼编码</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/myblog/categories/编程刷题//" class="article-tag-list-link color5">编程刷题</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/myblog/2019/10/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-qlu-acm个人赛第一场" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/myblog/2019/10/09/qlu-acm%E4%B8%AA%E4%BA%BA%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA/">qlu_acm个人赛第一场</a>
    </h1>
  

        
        <a href="/myblog/2019/10/09/qlu-acm%E4%B8%AA%E4%BA%BA%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA/" class="archive-article-date">
  	<time datetime="2019-10-09T12:41:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-10-09</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1101/problem/A">A. Minimum Integer</a><br>求某一范围之外的最小能整除某个数的数是多少</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef  long long ll;</span><br><span class="line">int q;</span><br><span class="line">ll l,r,d;</span><br><span class="line">int main() &#123;</span><br><span class="line">    ios::sync_with_stdio(0);</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    while (q--) &#123;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;</span><br><span class="line">        ll L, R;</span><br><span class="line">        //分L，R能否被d取余得0来分类求解</span><br><span class="line">        if (l%d != 0) &#123;</span><br><span class="line">            L = (l / d);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (l%d == 0)L = l / d - 1;</span><br><span class="line">        </span><br><span class="line">        if (r%d == 0)R = r / d + 1;</span><br><span class="line">        else if (r%d != 0)R = r / d + 1;</span><br><span class="line">        //最后由L的值来决定输出的结果</span><br><span class="line">        if (L == 0) &#123;</span><br><span class="line">            cout &lt;&lt; d * R &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            cout &lt;&lt; 1 * d &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1101/problem/B">B. Accordion</a><br>题意：左边是[:中间可以有|，右边是:]；问最长的串；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int l,r,d;</span><br><span class="line"></span><br><span class="line">char a[500005];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%s&quot;,a);</span><br><span class="line">    int l=strlen(a);</span><br><span class="line">    int left=0,right=0;</span><br><span class="line">    int i,j;</span><br><span class="line">    //从左右搜索[::]这几个字符，其中[和：要用一个变量连续搜索 </span><br><span class="line">    for(i=0;i&lt;l;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]==&#x27;[&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            ++left;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(;i&lt;l;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i]==&#x27;:&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            ++left;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(j=l-1;j&gt;i;--j)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[j]==&#x27;]&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            ++right;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    for(;j&gt;i;--j)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[j]==&#x27;:&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            ++right;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int num=0;</span><br><span class="line">    </span><br><span class="line">    if(left!=right)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;-1\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        for(int kk=i+1;kk&lt;j;++kk)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[kk]==&#x27;|&#x27;)</span><br><span class="line">                ++num;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,num+4);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1101/problem/D">D. GCD Counting</a></p>
<ul>
<li>洛谷讲解dp问题<br><a target="_blank" rel="noopener" href="https://www.luogu.org/problemnew/solution/CF1101D">https://www.luogu.org/problemnew/solution/CF1101D</a></li>
</ul>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color3">训练</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/myblog/categories/ACM//" class="article-tag-list-link color4">ACM</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/myblog/2019/10/09/qlu-acm%E4%B8%AA%E4%BA%BA%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-最长连续递增字序列问题" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/myblog/2019/10/06/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%97%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/"> Longest Increasing Subsequence</a>
    </h1>
  

        
        <a href="/myblog/2019/10/06/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%97%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/" class="archive-article-date">
  	<time datetime="2019-10-06T04:06:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-10-06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/winner647520/article/details/80514947">https://blog.csdn.net/winner647520/article/details/80514947</a><br>这一题的代码没看懂</p>
<p>快排三指针？？？</p>
<h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h4><p>问题描述:给出一个序列a1,a2,a3,a4,a5,a6,a7….an,求它的一个子序列（设为s1,s2,…sn），使得这个子序列满足这样的性质，s1&lt;s2&lt;s3&lt;…&lt;sn并且这个子序列的长度最长。输出这个最长的长度。</p>
<p>O(n^2)算法：<br>我们依次遍历整个序列，每一次求出从第一个数到当前这个数的最长上升子序列，直至遍历到最后一个数字为止，然后再取dp数组里最大的那个即为整个序列的最长上升子序列。我们用dp[i]来存放序列下标0到i-1中最长上升子序列的长度，那么dp[i]&#x3D;max(dp[j])+1,(j∈[0, i-1]); 显然dp[i]&#x3D;1,我们从i&#x3D;0开始遍历后面的元素即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const int MAXN = 100005;</span><br><span class="line">int a[MAXN], dp[MAXN];</span><br><span class="line"></span><br><span class="line">//最长上升子序列</span><br><span class="line">int LIS(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = 1;</span><br><span class="line">        for(int j = 0; j &lt; i; ++j)</span><br><span class="line">            if(a[j] &lt; a[i]) dp[i] = max(dp[i], dp[j]+1);</span><br><span class="line">        res = max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DP之最长上升子序列O-n-logn-算法"><a href="#DP之最长上升子序列O-n-logn-算法" class="headerlink" title="DP之最长上升子序列O(n*logn)算法"></a>DP之最长上升子序列O(n*logn)算法</h4><p> 假设一个序列d[1..9] &#x3D; 2 1 5 3 6 4 8 9 7，可以看出来它的LIS长度为5.下面慢慢的一步一步的找出它的LIS.</p>
<p>我们定义一个了序列为B,然后用i从1到9慢慢的考察。另外再定义一个len来记录当前的最长序列的长度</p>
<p>首先，把d[1]有序地放到B里，令B[1] &#x3D; 2，就是说当只有一个数字为2的时候，长度为1的LIS的最小末尾是2，这时Len&#x3D;1，</p>
<p>然后，把d[2]有序地放到B里，令B[1] &#x3D; 1，就是说长度为1的LIS的最小末尾是1，d[1]&#x3D;2已经没用了，很容易理解，是吧。这时Len&#x3D;1。接着，d[3] &#x3D; 5，d[3]&gt;B[1]，所以令B[1+1]&#x3D;B[2]&#x3D;d[3]&#x3D;5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候B[1..2] &#x3D; 1, 5，Len＝2。再来，d[4] &#x3D; 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] &#x3D; 1, 3，Len &#x3D; 2。继续，</p>
<p>d[5] &#x3D; 6，它在3后面，因为B[2] &#x3D; 3, 而6在3后面，于是很容易可以推知B[3] &#x3D; 6, 这时B[1..3] &#x3D; 1, 3, 6，还是很容易理解吧？ Len &#x3D; 3 了。</p>
<p>第6个, d[6] &#x3D; 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] &#x3D; 4。B[1..3] &#x3D; 1, 3, 4， Len继续等于3.</p>
<p>第7个, d[7] &#x3D; 8，它很大，比4大，嗯。于是B[4] &#x3D; 8。Len变成4了</p>
<p>第8个, d[8] &#x3D; 9，得到B[5] &#x3D; 9，嗯。Len继续增大，到5了。</p>
<p>最后一个, d[9] &#x3D; 7，它在B[3] &#x3D; 4和B[4] &#x3D; 8之间，所以我们知道，最新的B[4] &#x3D;7，B[1..5] &#x3D; 1, 3, 4, 7, 9，Len &#x3D; 5。</p>
<p>于是我们知道了LIS的长度为5。</p>
<p>!!!!! 注意。这个1,3,4,7,9不是LIS，它只是存储的对应长度LIS的最小末尾。有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] &#x3D; 7更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到d[5], 9更新到d[6]，得出LIS的长度为6。</p>
<p>然后应该发现一件事情了：在B中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到O(logN)   于是算法的时间复杂度就降低到了O(NlogN)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int find(int *a,int len,int n)</span><br><span class="line">&#123;</span><br><span class="line">	int left=0,right=len,mid=(right+left)/2;</span><br><span class="line">	while(left&lt;=right)</span><br><span class="line">	&#123;</span><br><span class="line">		if(n&gt;a[mid])</span><br><span class="line">			left=mid+1;</span><br><span class="line">		else if(n&lt;a[mid])</span><br><span class="line">			right=mid-1;</span><br><span class="line">		else</span><br><span class="line">			return mid;</span><br><span class="line">		mid=(right+left)/2;</span><br><span class="line">	&#125;</span><br><span class="line">	return left;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int c[100],i,j,len;</span><br><span class="line">	int a[9]=&#123;2 ,1 ,5 ,3 ,6 ,4 ,8 ,9 ,7&#125;;</span><br><span class="line">	c[0]=-1;</span><br><span class="line">	c[1]=a[0];</span><br><span class="line">	len=1;</span><br><span class="line">	for(i=0;i&lt;9;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		j=find(c,len,a[i]);</span><br><span class="line">		c[j]=a[i];</span><br><span class="line">		if(j&gt;len)</span><br><span class="line">			len=j;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h4 id="最长下降子序列"><a href="#最长下降子序列" class="headerlink" title="最长下降子序列"></a>最长下降子序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//最长下降子序列</span><br><span class="line">int LDS(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = 1;</span><br><span class="line">        for(int j = 0; j &lt; i; ++j)</span><br><span class="line">            if(a[j] &gt; a[i]) dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">        res = max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/myblog/categories/ACM//" class="article-tag-list-link color4">ACM</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/myblog/2019/10/06/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%97%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-数据结构" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/myblog/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构上机实验</a>
    </h1>
  

        
        <a href="/myblog/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="archive-article-date">
  	<time datetime="2019-10-03T12:36:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-10-03</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="对分易作业：表的操作"><a href="#对分易作业：表的操作" class="headerlink" title="对分易作业：表的操作"></a>对分易作业：表的操作</h4><p>算法设计作业内容：所有操作的函数头已经给出，分别写出函数体。<br>1）已知单链表L，设计算法求单链表的表长。 int ListLength ( LinkList L )<br>2）设计一个算法，求顺序表中值最大的结点的值。  int Max (SqList L )<br>3)设计一个算法，求单链表中值最大的结点的值。  int Max (LinkList L )<br>4）设计一个算法，删除数组s中的最大元素。  void DeleteMax (int s[], int n)<br>5）设计一个算法，删除单链表中值最大的结点。  void DeleteMax (LinkList L )<br>6）设计算法删除单链表L中所有值为x的结点。   void DeleteX (LinkList L, int x )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef struct LNode&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct LNode *next;</span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line">//后插法 顺序相同 </span><br><span class="line">void CreateList_R(LinkList &amp;L,int n)&#123;</span><br><span class="line">	L=new LNode;    //头结点 </span><br><span class="line">	L-&gt;next=NULL;</span><br><span class="line">	LinkList r=L;	//r为尾指针 </span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		LinkList p=new LNode;</span><br><span class="line">		cin&gt;&gt;p-&gt;data;</span><br><span class="line">		p-&gt;next=NULL;</span><br><span class="line">		r-&gt;next=p;</span><br><span class="line">		r=p;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">//第一题 求表长度 </span><br><span class="line">int ListLength(LinkList L)&#123;</span><br><span class="line">	int len=0;</span><br><span class="line">	LinkList p=L-&gt;next;</span><br><span class="line">	while(p)&#123;</span><br><span class="line">		len++;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三题 求表中最大的节点的值 </span><br><span class="line">int Max(LinkList L)&#123;</span><br><span class="line">	LinkList p=L-&gt;next;</span><br><span class="line">	int maxnum=L-&gt;data;</span><br><span class="line">	while(p)&#123;</span><br><span class="line">		if(p-&gt;data&gt;maxnum)</span><br><span class="line">			maxnum=p-&gt;data;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	return maxnum;</span><br><span class="line">&#125; </span><br><span class="line">//第四题 删除数组中最大元素 </span><br><span class="line">void DeleteMax(int s[],int n)&#123;</span><br><span class="line">	int maxid=0;</span><br><span class="line">	int maxnum=s[0];</span><br><span class="line">	//假设s[0]是最小的那个元素 </span><br><span class="line">	for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">		if(s[i]&gt;maxnum)&#123; </span><br><span class="line">			maxid=i;</span><br><span class="line">			maxnum=s[i];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;for(int i=maxid;i&lt;n-1;i++)&#123;</span><br><span class="line">		//注意这时候这个i到n-1，因为那个数组的最大下标是i-1 </span><br><span class="line">		s[i]=s[i+1];</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br><span class="line">//第五题 删单链表中值最大的节点 </span><br><span class="line">void DeleteMax( LinkList L)&#123;</span><br><span class="line">	LinkList p=L-&gt;next;</span><br><span class="line">	int maxx=p-&gt;data;</span><br><span class="line">	while(p)&#123;</span><br><span class="line">		if(p-&gt;data&gt;maxx)</span><br><span class="line">			maxx=p-&gt;data;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	p=L;</span><br><span class="line">	while(p-&gt;next)&#123;</span><br><span class="line">		bool flag=false;</span><br><span class="line">		if(p-&gt;next-&gt;data==maxx)&#123;</span><br><span class="line">			flag=true;</span><br><span class="line">			LinkList q=p-&gt;next;</span><br><span class="line">			p-&gt;next=q-&gt;next;</span><br><span class="line">			delete q;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag)continue;</span><br><span class="line">		else p=p-&gt;next;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//第六题 删除单链表中所有值为x的节点 </span><br><span class="line">void DeleteX(LinkList L,int x)&#123;</span><br><span class="line">	LinkList p=L;</span><br><span class="line">	while(p-&gt;next)&#123;</span><br><span class="line">		bool flag=false;</span><br><span class="line">		if(p-&gt;next-&gt;data==x)&#123;</span><br><span class="line">			flag=true;</span><br><span class="line">			LinkList q=p-&gt;next;</span><br><span class="line">			p-&gt;next=q-&gt;next;</span><br><span class="line">			delete q;</span><br><span class="line">		&#125;</span><br><span class="line">		if(flag)continue;</span><br><span class="line">		else p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	LinkList L;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	CreateList_R(L,n);</span><br><span class="line">	//测试第一题 </span><br><span class="line">	cout&lt;&lt;ListLength(L)&lt;&lt;endl; </span><br><span class="line">	//测试第三题 </span><br><span class="line">	cout&lt;&lt;MAX(L)&lt;&lt;endl; </span><br><span class="line">	//测试第五题 </span><br><span class="line">	DeleteMax(L);</span><br><span class="line">	//输出链表的内容 </span><br><span class="line">	LinkList p=L-&gt;next;</span><br><span class="line">while(p)&#123;</span><br><span class="line">		cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">		p=p-&gt;next; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	//测试第六题 </span><br><span class="line">	DeleteX(L,4);</span><br><span class="line">	p=L-&gt;next;</span><br><span class="line">	while(p)&#123;</span><br><span class="line">		cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;;</span><br><span class="line">		p=p-&gt;next; </span><br><span class="line">	&#125;</span><br><span class="line">/*测试第四题 </span><br><span class="line">	int s[4];</span><br><span class="line">	for(int i=0;i&lt;4;i++)&#123;</span><br><span class="line">		cin&gt;&gt;s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	DeleteMax(s,4);</span><br><span class="line">	for(int i=0;i&lt;3;i++)cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//顺序表的后插法 顺序相同 </span><br><span class="line">void CreateList_R(LinkList &amp;L,int n)&#123;</span><br><span class="line">	L=new LNode;    //头结点 </span><br><span class="line">	L-&gt;next=NULL;</span><br><span class="line">	LinkList r;	//r为尾指针 </span><br><span class="line">	int len=ListLength(L);</span><br><span class="line">	cin&gt;&gt;r.data;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		if(p)</span><br><span class="line">	&#125; </span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		LinkList p=new LNode;</span><br><span class="line">		cin&gt;&gt;p-&gt;data;</span><br><span class="line">		p-&gt;next=NULL;</span><br><span class="line">		r-&gt;next=p;</span><br><span class="line">		r=p;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//前插法 顺序相反 </span><br><span class="line">void CreateList_H(LinkList &amp;L,int n)&#123;</span><br><span class="line">	L=new LNode;</span><br><span class="line">	L-&gt;next=NULL;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		LinkList p=new LNode ;</span><br><span class="line">		cin&gt;&gt;p-&gt;data;</span><br><span class="line">		p-&gt;next=L-&gt;next;</span><br><span class="line">		L-&gt;next=p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LNode *locateElem(LinkList L,int e)&#123;</span><br><span class="line">	LinkList p=L-&gt;next;</span><br><span class="line">	while(p&amp;&amp;p-&gt;data!=e)</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">还有一部分作业就是顺序表那部分：</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;fstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">#define OVERFLOW 0</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	int *elem;</span><br><span class="line">	int length;</span><br><span class="line">&#125;SQList;</span><br><span class="line">void InitList(SQList &amp;L)&#123;</span><br><span class="line">	L.elem=new int[MAXSIZE];</span><br><span class="line">	if(!L.elem)exit(OVERFLOW);</span><br><span class="line">	L.length=0;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">/*产生一个顺序表，先输入n，在输入n个数据，</span><br><span class="line">思想就是先输入n，在输入一个数存到L.elem[0],然后比较一下顺序表中元素的</span><br><span class="line">值，然后插入元素 </span><br><span class="line">*/ </span><br><span class="line">void CreatList(SQList &amp;L)&#123;</span><br><span class="line">	int n,num;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cin&gt;&gt;L.elem[0];</span><br><span class="line">	L.length=1;</span><br><span class="line">	for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;num;</span><br><span class="line">		int j;</span><br><span class="line">		for(j=1;j&lt;L.length;j++)&#123;</span><br><span class="line">			if(num&lt;L.elem[j])&#123;</span><br><span class="line">			break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">			for(int k=L.length-1;k&gt;=j-1;k--)&#123;</span><br><span class="line">					L.elem[k+1]=L.elem[k];</span><br><span class="line">			&#125;</span><br><span class="line">			++L.length;</span><br><span class="line">			L.elem[j]=num;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">//第二题 求顺序表中值最大的节点的值 </span><br><span class="line">int MAX(SQList L)&#123;</span><br><span class="line">	int maxx=L.elem[0];</span><br><span class="line">	int maxid;</span><br><span class="line">	for(int i=1;i&lt;L.length;i++)&#123;</span><br><span class="line">		if(L.elem[i]&gt;maxx)&#123;</span><br><span class="line">			maxid=i;</span><br><span class="line">			maxx=L.elem[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return maxid;</span><br><span class="line">&#125;</span><br><span class="line">//测试函数 </span><br><span class="line">int main()&#123;</span><br><span class="line">	SQList L;</span><br><span class="line">	InitList(L);</span><br><span class="line">	CreatList(L);</span><br><span class="line">	for(int i=0;i&lt;L.length;i++)&#123;</span><br><span class="line">		cout&lt;&lt;L.elem[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;L.elem[MAX(L)];</span><br><span class="line">&#125;</span><br><span class="line">int MAX_1(SQList L,int e)&#123;</span><br><span class="line">	int maxx=e;</span><br><span class="line">	int maxid;</span><br><span class="line">	for(int i=0;i&lt;L.length;i++)&#123;</span><br><span class="line">		if(L.elem[i]&gt;maxx)&#123;</span><br><span class="line">			maxid=i;</span><br><span class="line">			maxx=L.elem[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return maxid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ListInsert(SQList &amp;L,int i,int e)&#123;</span><br><span class="line">	if((i&lt;1)||(i&gt;L.length+1)) return error;</span><br><span class="line">	if(L.length==MAXSIZE) return error;</span><br><span class="line">	for(int j=L.length-1;j&gt;=i-1;j--)</span><br><span class="line">		L.elem[j+1]=L.elem[j];</span><br><span class="line">	L.elem[i-1]=e;</span><br><span class="line">	++L.length;</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="上机实验1（字符串链表的插入，删除，查找）"><a href="#上机实验1（字符串链表的插入，删除，查找）" class="headerlink" title="上机实验1（字符串链表的插入，删除，查找）"></a>上机实验1（字符串链表的插入，删除，查找）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line">#include&quot;string.h&quot;</span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line">#include&quot;ctype.h&quot;</span><br><span class="line">typedef struct node //定义结点</span><br><span class="line">&#123;</span><br><span class="line">	char data[10]; //结点的数据域为字符串</span><br><span class="line">	struct node *next; //结点的指针域</span><br><span class="line">&#125;ListNode;</span><br><span class="line">typedef ListNode * LinkList; // 自定义 LinkList 单链表类型</span><br><span class="line">LinkList CreatListR1(); //函数，用尾插入法建立带头结点的单链表</span><br><span class="line">LinkList CreatList(void); //函数，用头插入法建立带头结点的单链表</span><br><span class="line">ListNode *LocateNode(); //函数，按值查找结点</span><br><span class="line">void DeleteList(); //函数，删除指定值的结点</span><br><span class="line">void printlist(); //函数，打印链表中的所有值</span><br><span class="line">void DeleteAll(); //函数，删除所有结点，释放内存</span><br><span class="line">ListNode * AddNode(); //修改程序：增加节点。用头插法，返回头指针</span><br><span class="line">//==========主函数==============</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	char ch[10], num[5];</span><br><span class="line">	LinkList head;</span><br><span class="line">	head = CreatList(); //用头插入法建立单链表，返回头指针</span><br><span class="line">	printlist(head); //遍历链表输出其值</span><br><span class="line">	printf(&quot; Delete node (y/n):&quot;); //输入&quot;y&quot;或&quot;n&quot;去选择是否删除结点</span><br><span class="line">	scanf(&quot;%s&quot;, num);</span><br><span class="line">	if (strcmp(num, &quot;y&quot;) == 0 || strcmp(num, &quot;Y&quot;) == 0) &#123;</span><br><span class="line">		printf(&quot;Please input Delete_data:&quot;);</span><br><span class="line">		scanf(&quot;%s&quot;, ch); //输入要删除的字符串</span><br><span class="line">		DeleteList(head, ch);</span><br><span class="line">		printlist(head);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot; Add node ? (y/n):&quot;); //输入&quot;y&quot;或&quot;n&quot;去选择是否增加结点</span><br><span class="line">	scanf(&quot;%s&quot;, num);</span><br><span class="line">	if (strcmp(num, &quot;y&quot;) == 0 || strcmp(num, &quot;Y&quot;) == 0)</span><br><span class="line">	&#123;</span><br><span class="line">		head = AddNode(head);</span><br><span class="line">	&#125;</span><br><span class="line">	printlist(head);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	DeleteAll(head); //删除所有结点，释放内存</span><br><span class="line">&#125;</span><br><span class="line">////==========用尾插入法建立带头结点的单链表===========</span><br><span class="line">//LinkList CreatListR1(void)</span><br><span class="line">//&#123;</span><br><span class="line">//	char ch[10];</span><br><span class="line">//	LinkList head = (LinkList)malloc(sizeof(ListNode)); //生成头结点</span><br><span class="line">//	ListNode *s, *r, *pp;</span><br><span class="line">//	r = head;</span><br><span class="line">//	r-&gt;next = NULL;</span><br><span class="line">//	printf(&quot;Input # to end &quot;); //输入&quot;#&quot;代表输入结束</span><br><span class="line">//	printf(&quot;\nPlease input Node_data:&quot;);</span><br><span class="line">//	scanf(&quot;%s&quot;, ch); //输入各结点的字符串</span><br><span class="line">//	while (strcmp(ch, &quot;#&quot;) != 0) &#123;</span><br><span class="line">//		pp = LocateNode(head, ch); //按值查找结点，返回结点指针</span><br><span class="line">//		if (pp == NULL) &#123; //没有重复的字符串，插入到链表中</span><br><span class="line">//			s = (ListNode *)malloc(sizeof(ListNode));</span><br><span class="line">//			strcpy(s-&gt;data, ch);</span><br><span class="line">//			r-&gt;next = s;</span><br><span class="line">//			r = s;</span><br><span class="line">//			r-&gt;next = NULL;</span><br><span class="line">//		&#125;</span><br><span class="line">//		printf(&quot;Input # to end &quot;);</span><br><span class="line">//		printf(&quot;Please input Node_data:&quot;);</span><br><span class="line">//		scanf(&quot;%s&quot;, ch);</span><br><span class="line">//	&#125;</span><br><span class="line">//	return head; //返回头指针</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">//==========用头插入法建立带头结点的单链表===========</span><br><span class="line">LinkList CreatList(void)</span><br><span class="line">&#123;</span><br><span class="line">	char ch[100];</span><br><span class="line">	LinkList head, p;</span><br><span class="line">	head = (LinkList)malloc(sizeof(ListNode));//只声明一个数据空间 </span><br><span class="line">	head-&gt;next = NULL;</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Input # to end &quot;);</span><br><span class="line">		printf(&quot;Please input Node_data:&quot;);</span><br><span class="line">		scanf(&quot;%s&quot;, ch);</span><br><span class="line">		if (strcmp(ch, &quot;#&quot;))</span><br><span class="line">		&#123;</span><br><span class="line">			if (LocateNode(head, ch) == NULL)//只有一个字符串 </span><br><span class="line">			&#123;</span><br><span class="line">				strcpy(head-&gt;data, ch);</span><br><span class="line">				p = (LinkList)malloc(sizeof(ListNode));</span><br><span class="line">				p-&gt;next = head;</span><br><span class="line">				head = p;//p只是一个临时的节点，并没有存到LinkList中 </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br><span class="line">//==========按值查找结点，找到则返回该结点的位置，否则返回 NULL==========</span><br><span class="line">ListNode *LocateNode(LinkList head, char *key)</span><br><span class="line">&#123;</span><br><span class="line">	ListNode *p = head-&gt;next; //从开始结点比较</span><br><span class="line">	while (p != NULL &amp;&amp; strcmp(p-&gt;data, key) != 0) //直到 p 为 NULL 或 p-&gt;data 为 key 止</span><br><span class="line">		p = p-&gt;next; //扫描下一个结点</span><br><span class="line">	return p; //若 p=NULL 则查找失败，否则 p 指向找到的值为 key 的结点</span><br><span class="line">&#125;</span><br><span class="line">//==========修改程序：增加节点=======</span><br><span class="line">ListNode * AddNode(LinkList head)</span><br><span class="line">&#123;</span><br><span class="line">	char ch[10];int pos; int i;</span><br><span class="line">	ListNode *s, *pp,*p;</span><br><span class="line">	printf(&quot;\nPlease input Insert_data:&quot;);</span><br><span class="line">	scanf(&quot;%s&quot;, ch); //输入各结点的字符串</span><br><span class="line">	printf(&quot;\nposition:&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;pos); //c语言的scanf中一定要加&amp;，上面那个赋值给ch不用加，因为ch本身就是地质 </span><br><span class="line">	pp = LocateNode(head, ch); //按值查找结点，返回结点指针</span><br><span class="line">//	p = (ListNode *)malloc(sizeof(ListNode));</span><br><span class="line">	p=head-&gt;next;</span><br><span class="line">	</span><br><span class="line">	if (pp == NULL) &#123; //没有重复的字符串，插入到链表中</span><br><span class="line">	</span><br><span class="line">		s = (ListNode *)malloc(sizeof(ListNode));</span><br><span class="line">		</span><br><span class="line">		strcpy(s-&gt;data, ch);</span><br><span class="line">		for(i=1;i&lt;pos-1;i++)p=p-&gt;next;</span><br><span class="line">		</span><br><span class="line">		s-&gt;next = p-&gt;next;</span><br><span class="line">		p-&gt;next = s;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return head;</span><br><span class="line">&#125;</span><br><span class="line">//==========删除带头结点的单链表中的指定结点=======</span><br><span class="line">void DeleteList(LinkList head, char *key)</span><br><span class="line">&#123;</span><br><span class="line">	ListNode *p, *r, *q = head;</span><br><span class="line">	p = LocateNode(head, key); //按 key 值查找结点的</span><br><span class="line">	if (p == NULL) &#123; //若没有找到结点，退出</span><br><span class="line">		printf(&quot;position error&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	while (q-&gt;next != p) //p 为要删除的结点，q 为 p 的前结点</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	r = q-&gt;next;</span><br><span class="line">	q-&gt;next = r-&gt;next;</span><br><span class="line">	free(r); //释放结点</span><br><span class="line">&#125;</span><br><span class="line">//===========打印链表=======</span><br><span class="line">void printlist(LinkList head)</span><br><span class="line">&#123;</span><br><span class="line">	ListNode *p = head-&gt;next; //从开始结点打印</span><br><span class="line">	while (p) &#123;</span><br><span class="line">		if(p-&gt;next==NULL)printf(&quot;%s&quot;, p-&gt;data);</span><br><span class="line">		else printf(&quot;%s, &quot;, p-&gt;data);</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//==========删除所有结点，释放空间===========</span><br><span class="line">void DeleteAll(LinkList head)</span><br><span class="line">&#123;</span><br><span class="line">	ListNode *p = head, *r;</span><br><span class="line">	while (p-&gt;next) &#123;</span><br><span class="line">		r = p-&gt;next;</span><br><span class="line">		free(p);</span><br><span class="line">		p = r;</span><br><span class="line">	&#125;</span><br><span class="line">	free(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*1,首先明白了头插法和尾插法的区别：头插法是从一个表开始，重复读入数据，</span><br><span class="line">生成新节点，将读入数据存放到新节点的数据域中，</span><br><span class="line">然后将新节点插入到当前链表的头结点之后，直至读入结束标志为止。</span><br><span class="line">其插入的顺序和存储的逻辑顺序相反，而尾插法相同。</span><br><span class="line">2，在按值查找这个函数中，要返回指定值的节点，</span><br><span class="line">可以这么写：while (p != NULL &amp;&amp; strcmp(p-&gt;data, key) != 0)p = p-&gt;next;</span><br><span class="line">这样的话，当程序跳出while循环之后，p就只要求的节点（p为NULL说明链表中没有该值的节点）。</span><br><span class="line">3，在打印链表的时候while（）中要写p而不是p-&gt;next,</span><br><span class="line">否则的话最后一个节点就打印不出来了；</span><br><span class="line">在删除所有节点的函数中，while函数中写的是p-&gt;next,而不是p，</span><br><span class="line">这样的话，p走到最后一个节点的时候就不会进入while循环了，</span><br><span class="line">那么在while循环外面还要写free(p)来删除最后那个节点</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="上机实验二-实验二：顺序表的基本操作"><a href="#上机实验二-实验二：顺序表的基本操作" class="headerlink" title="上机实验二 实验二：顺序表的基本操作"></a><strong>上机实验二 实验二：顺序表的基本操作</strong></h4><p>实验目的：<br>1、理解什么是顺序表；<br>2、掌握顺序表的基本操作，如建立、查找、插入和删除等。<br>实验内容：<br>定义一个包含学生信息（学号，姓名，成绩）的顺序表，使其具有如下功能：<br>(1) 根据指定学生个数，逐个输入学生信息；<br>(2) 逐个显示学生表中所有学生的相关信息；<br>(3) 根据姓名进行查找，返回此学生的学号和成绩；<br>(4) 根据指定的位置可返回相应的学生信息（学号，姓名，成绩）；<br>(5) 给定一个学生信息，插入到表中指定的位置；<br>(6) 删除指定位置的学生记录；<br>(7) 统计表中学生个数。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;  </span><br><span class="line">#include&lt;malloc.h&gt;  </span><br><span class="line">#include&lt;stdlib.h&gt;  </span><br><span class="line">#include&lt;string.h&gt;  </span><br><span class="line">#define OK 1  </span><br><span class="line">#define ERROR 0  </span><br><span class="line">#define OVERFLOW -2  </span><br><span class="line">#define MAXSIZE 100  </span><br><span class="line">  </span><br><span class="line">typedef int Status; // 定义函数返回值类型  </span><br><span class="line">  </span><br><span class="line">typedef struct  </span><br><span class="line">&#123;  </span><br><span class="line">    char num[10]; // 学号  </span><br><span class="line">    char name[20]; // 姓名  </span><br><span class="line">    double grade; // 成绩   </span><br><span class="line">&#125;student;  </span><br><span class="line">  </span><br><span class="line">typedef student ElemType;  </span><br><span class="line">  </span><br><span class="line">typedef struct  </span><br><span class="line">&#123;  </span><br><span class="line">    ElemType *elem; // 存储空间的基地址   </span><br><span class="line">    int length; // 当前长度   </span><br><span class="line">&#125;SqList;  </span><br><span class="line">  </span><br><span class="line">Status InitList(SqList *L) // 构造空的顺序表 L   </span><br><span class="line">&#123;     </span><br><span class="line">    L-&gt;elem=(ElemType *)malloc(sizeof(ElemType)*MAXSIZE);  </span><br><span class="line">    if(!L-&gt;elem)  exit(OVERFLOW);  </span><br><span class="line">    L-&gt;length=0;  </span><br><span class="line">    return OK;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">ElemType GetElem(SqList &amp;L,int i) // 访问顺序表，找到 i位置，返回给 e  </span><br><span class="line">&#123;  </span><br><span class="line">    return L.elem[i];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int Search(SqList &amp;L,char str[]) // 根据名字查找，返回该同学在顺序表中的编号   </span><br><span class="line">&#123;  </span><br><span class="line">    for(int i=1;i&lt;=L.length;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(strcmp(L.elem[i].name,str)==0)  </span><br><span class="line">            return i;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">Status ListInsert(SqList &amp;L,int i,ElemType e) // 在 i位置插入某个学生的信息   </span><br><span class="line">&#123;  </span><br><span class="line">    if((i&lt;1)||(i&gt;L.length+1)) return ERROR;  </span><br><span class="line">    if(L.length==MAXSIZE)   return ERROR;  </span><br><span class="line">    for(int j=L.length;j&gt;=i;j--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        L.elem[j+1]=L.elem[j];  </span><br><span class="line">    &#125;  </span><br><span class="line">    L.elem[i]=e;  </span><br><span class="line">    ++L.length;  </span><br><span class="line">    return OK;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">Status ListDelete(SqList &amp;L,int i) // 在顺序表中删除 i位置的学生信息   </span><br><span class="line">&#123;  </span><br><span class="line">    if((i&lt;1)||(i&gt;L.length))   return ERROR;  </span><br><span class="line">    for(int j=i;j&lt;=L.length;j++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        L.elem[j]=L.elem[j+1];  </span><br><span class="line">    &#125;  </span><br><span class="line">    --L.length;  </span><br><span class="line">    return OK;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void Input(ElemType *e)  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;姓名:&quot;);  scanf(&quot;%s&quot;,e-&gt;name);  </span><br><span class="line">    printf(&quot;学号:&quot;);  scanf(&quot;%s&quot;,e-&gt;num);  </span><br><span class="line">    printf(&quot;成绩:&quot;);  scanf(&quot;%lf&quot;,&amp;e-&gt;grade);  </span><br><span class="line">    printf(&quot;输入完成\n\n&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void Output(ElemType *e)  </span><br><span class="line">&#123;  </span><br><span class="line"></span><br><span class="line">	printf(&quot;\t%s\t%s\t%f\n&quot;,e-&gt;name,e-&gt;num,e-&gt;grade);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    SqList L;  </span><br><span class="line">    ElemType a,b,c,d;  </span><br><span class="line">    printf(&quot;\n********************************\n\n&quot;);  </span><br><span class="line">    puts(&quot;1. 构造顺序表&quot;);   </span><br><span class="line">    puts(&quot;2. 录入学生信息&quot;);  </span><br><span class="line">    puts(&quot;3. 显示学生信息&quot;);  </span><br><span class="line">    puts(&quot;4. 输入姓名，查找该学生&quot;);  </span><br><span class="line">    puts(&quot;5. 显示某位置该学生信息&quot;);   </span><br><span class="line">    puts(&quot;6. 在指定位置插入学生信息&quot;);  </span><br><span class="line">    puts(&quot;7. 在指定位置删除学生信息&quot;);  </span><br><span class="line">    puts(&quot;8. 统计学生个数&quot;);  </span><br><span class="line">    puts(&quot;0. 退出&quot;);  </span><br><span class="line">    printf(&quot;\n********************************\n\n&quot;);  </span><br><span class="line">    int x,choose;  </span><br><span class="line">    while(1)  </span><br><span class="line">    &#123;  </span><br><span class="line">        puts(&quot;请选择:&quot;);  </span><br><span class="line">        scanf(&quot;%d&quot;,&amp;choose);  </span><br><span class="line">        if(choose==0)   break;  </span><br><span class="line">        switch(choose)  </span><br><span class="line">        &#123;  </span><br><span class="line">            case 1:  </span><br><span class="line">                    if(InitList(&amp;L))  </span><br><span class="line">                        printf(&quot;成功建立顺序表\n\n&quot;);  </span><br><span class="line">                    else  </span><br><span class="line">                        printf(&quot;顺序表建立失败\n\n&quot;);  </span><br><span class="line">                    break;  </span><br><span class="line">            case 2:  </span><br><span class="line">                    printf(&quot;请输入要录入学生的人数（小于100）:&quot;);  </span><br><span class="line">                    scanf(&quot;%d&quot;,&amp;x);  </span><br><span class="line">                    for(int i=1;i&lt;=x;i++)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        printf(&quot;第%d个学生:\n&quot;,i);  </span><br><span class="line">                        Input(&amp;L.elem[i]);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    L.length=x;  </span><br><span class="line">                    puts(&quot;&quot;);  </span><br><span class="line">                    break;  </span><br><span class="line">            case 3:  </span><br><span class="line">                    printf(&quot;\t姓名\t学号\t成绩\n&quot;);</span><br><span class="line">				    for(int i=1;i&lt;=x;i++)  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        a=GetElem(L,i);  </span><br><span class="line">                        Output(&amp;a);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    break;  </span><br><span class="line">            case 4:  </span><br><span class="line">                    char s[20];  </span><br><span class="line">                    printf(&quot;请输入要查找的学生姓名:&quot;);  </span><br><span class="line">                    scanf(&quot;%s&quot;,s);  </span><br><span class="line">                    if(Search(L,s))  </span><br><span class="line">                        Output(&amp;L.elem[Search(L,s)]);  </span><br><span class="line">                    else  </span><br><span class="line">                        puts(&quot;对不起，查无此人&quot;);  </span><br><span class="line">                    puts(&quot;&quot;);  </span><br><span class="line">                    break;  </span><br><span class="line">			case 5:  </span><br><span class="line">				printf(&quot;请输入要查询的位置:&quot;);    </span><br><span class="line">				int id1;                   </span><br><span class="line">				scanf(&quot;%d&quot;,&amp;id1);  </span><br><span class="line">				if((id1&lt;1)||(id1&gt;L.length+1)) &#123;</span><br><span class="line">					puts(&quot;要查询的位置不合法&quot;);</span><br><span class="line">					continue;</span><br><span class="line">				&#125;   </span><br><span class="line">				b=GetElem(L,id1);           </span><br><span class="line">				Output(&amp;b);       </span><br><span class="line">				break;</span><br><span class="line">            case 6:  </span><br><span class="line">                    printf (&quot;请输入要插入的位置:&quot;);  </span><br><span class="line">                    int id2;  </span><br><span class="line">                    scanf(&quot;%d&quot;,&amp;id2);  </span><br><span class="line">                    printf(&quot;请输入学生信息:\n&quot;);  </span><br><span class="line">                    Input(&amp;c);  </span><br><span class="line">                    if(ListInsert(L,id2,c))  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        x++;  </span><br><span class="line">                        puts(&quot;插入成功&quot;);  </span><br><span class="line">                        puts(&quot;&quot;);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    else  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        puts(&quot;插入失败&quot;);  </span><br><span class="line">                        puts(&quot;&quot;);     </span><br><span class="line">                    &#125;  </span><br><span class="line">                    break;  </span><br><span class="line">            case 7:  </span><br><span class="line">                    printf(&quot;请输入要删除的位置:&quot;);  </span><br><span class="line">                    int id3;  </span><br><span class="line">                    scanf(&quot;%d&quot;,&amp;id3);  </span><br><span class="line">                    if(ListDelete(L,id3))  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        x--;  </span><br><span class="line">                        puts(&quot;删除成功&quot;);  </span><br><span class="line">                        puts(&quot;&quot;);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    else  </span><br><span class="line">                    &#123;  </span><br><span class="line">                        puts(&quot;删除失败&quot;);  </span><br><span class="line">                        puts(&quot;&quot;);     </span><br><span class="line">                    &#125;  </span><br><span class="line">                    break;  </span><br><span class="line">            case 8:  </span><br><span class="line">                    printf(&quot;已录入的学生个数为:%d\n\n&quot;,L.length);  </span><br><span class="line">                    break;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    printf(&quot;\n\n谢谢您的使用，请按任意键退出\n\n\n&quot;);  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">预习报告</span><br><span class="line">1.	按学生的姓名来查找学生信息时，声明一个sceach的函数判断一下顺序表中</span><br><span class="line">是否有该同学，如果存在，那么返回该同学在顺序表中的位置k，然后output函数返</span><br><span class="line">回第k个位置的学生信息；如果不存在，就输出信息提示没有该同学。</span><br><span class="line"></span><br><span class="line">预习报告代码：</span><br><span class="line">int Search(SqList &amp;L,char str[]) // 根据名字查找，返回该同学在顺序表中的编号   </span><br><span class="line">&#123;  </span><br><span class="line">    for(int i=1;i&lt;=L.length;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(strcmp(L.elem[i].name,str)==0)  </span><br><span class="line">            return i;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line">2.	删除的顺序应该先声明一个用来计数的变量，该变量的值从第i个元素开始，</span><br><span class="line">依次加1，直到j大于表长度，让每个变量对应存储的值向前移动，实现删除第i个元素的功能 </span><br><span class="line">实现for循环</span><br><span class="line"> for(int j=i;j&lt;=L.length;j++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        L.elem[j]=L.elem[j+1];  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">3.在指定位置插入元素，实现ListInsert函数，把顺序表，id2（要插入的位置），</span><br><span class="line">c（包含一个学生的信息的student类型的结构体变量），该函数应该判断插入的位置id2是否合法，</span><br><span class="line">然后在id2以后的所有已经存在的结构题变量往后一一个位置，</span><br><span class="line">空出要插入的位置，插入要插入的位置，表长加1。如果插入成功返回1，否则放那会0.</span><br><span class="line"></span><br><span class="line">4.要查询指定位置的学生信息时，首先把顺序表和指定位置i当作参数，实现GetElem的方法，</span><br><span class="line">让该方法返回指定位置的学生信息。</span><br><span class="line"></span><br><span class="line">实验心得</span><br><span class="line">1.	程序的健壮性是指程序能对输入的非法数据进行处理，并不会因为输入非法数据导致程序的崩溃。</span><br><span class="line">写程序要考虑程序的健壮性，比如本次实验在ListDelete这个方法中要对传进来的参数i（要插入的位置）进行判断，</span><br><span class="line">如果插入的位置小于1或者大于表长度+1，就提示输入数据有误。</span><br><span class="line">2.	为了方便阅读，书写程序要有层次的缩进，这样一眼就能看出来每个语句块的内容，方便理解 </span><br><span class="line">3.	Input函数中，那个向传过来的参数e赋值grade语句时，一定要加&amp;，因为name和num都是引用型数据，</span><br><span class="line">可以不加&amp;。</span><br><span class="line">4.	switch语句，要在每个case语句中加入break语句，否则的话，执行完一条case语句，</span><br><span class="line">就会接着执行下一跳语句。可以在if语句之后写continue和break，但满足if条件时，就执行该语句，跳过循环或者退出循环 </span><br><span class="line"></span><br><span class="line">5.	删除指定位置的元素时，该方法首先要判断删除的位置是否合法，</span><br><span class="line">然后从第i个位置到最后一个元素依次往前移动，覆盖要删除的位置，表长减1.</span><br><span class="line"></span><br><span class="line">6.	Output(&amp;a);这一条语句调用output函数要加&amp;来运行，因为原函数当中是ElemType *e当作形参的，</span><br><span class="line">那个a是student类型的，&amp;a就代表这个参数为指向student类型的地址。</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="上机实验三-栈"><a href="#上机实验三-栈" class="headerlink" title="上机实验三 栈"></a><strong>上机实验三 栈</strong></h4><p>一、实验目的<br>熟悉栈的顺序表示与实现。<br>熟悉栈的应用。<br>理解并掌握递归函数的设计与实现。<br>二、实验内容<br>1  问题描述：利用栈实现十进制数n转化为d（分别是2,8,16）进制数<br>要求：<br>输入一个n和d，打印输出d进制数序列。<br>利用顺序栈来实现十进制数n转化为其他d进制数。此时，需要同时实现初始化空栈、入栈、出栈、判栈空等辅助功能。<br>测试数据：<br>8进制：输入n:1348       输出：2504<br>2进制：输入n:1348        输出：101 0100 0100‬<br>16进制：输入n:1348        输出：544  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">#include&lt;stdlib.h&gt; </span><br><span class="line">#define STACK_INIT_SIZE 10 /* 存储空间初始分配量 */ </span><br><span class="line">#define STACK_INCREMENT 2 /* 存储空间分配增量 */ </span><br><span class="line">#define TRUE 1 </span><br><span class="line">#define FALSE 0 </span><br><span class="line">#define OK 1 </span><br><span class="line">#define ERROR 0 </span><br><span class="line">#define OVERFLOW 0 </span><br><span class="line">typedef struct SqStack &#123;</span><br><span class="line"> 	int *base; </span><br><span class="line"> 	/* 在栈构造之前和销毁之后，base 的值为 NULL */ </span><br><span class="line">	int *top; /* 栈顶指针 */ </span><br><span class="line"> 	int stacksize; /* 当前已分配的存储空间，以元素为单位 */ </span><br><span class="line"> 	//整个sqStack的大小是24，所以base，top和stacksize各为8 </span><br><span class="line"> &#125;SqStack; /* 顺序栈 */ </span><br><span class="line"> </span><br><span class="line"> void InitStack(SqStack *s) &#123; </span><br><span class="line"> /* 构造一个空栈 S */ </span><br><span class="line"> 	s-&gt;base=(int *)malloc(STACK_INIT_SIZE*sizeof(int)); </span><br><span class="line"> 	if(!s-&gt;base) exit(OVERFLOW); /* 存储分配失败 */ </span><br><span class="line">	s-&gt;top=s-&gt;base; </span><br><span class="line"> 	s-&gt;stacksize=STACK_INIT_SIZE; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> int StackEmpty(SqStack s) &#123; </span><br><span class="line"> /* 若栈 S 为空栈，则返回 TRUE，否则返回 FALSE */ </span><br><span class="line">	 if(s.top==s.base) return TRUE; </span><br><span class="line">	 else return FALSE; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> int StackLength(SqStack s) &#123; </span><br><span class="line"> </span><br><span class="line">	 /* 返回 S 的元素个数，即栈的长度 */ </span><br><span class="line"> 	return s.top-s.base; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> void Push(SqStack *s,int e) &#123; </span><br><span class="line"> /* 插入元素 e 为新的栈顶元素 */ </span><br><span class="line">	 if(s-&gt;top-s-&gt;base&gt;=s-&gt;stacksize) //这两个相等的时候重新分配内存 </span><br><span class="line"> /* 栈满，追加存储空间 */ </span><br><span class="line"> 	&#123; </span><br><span class="line"> 		s-&gt;base=(int *)realloc(s-&gt;base,(s-&gt;stacksize+STACK_INCREMENT)*sizeof(int)); </span><br><span class="line"> 		//每次开辟两个空间，下一次让top指针指向刚stacksisze的位置，然后s-&gt;top++之后也不会溢出 </span><br><span class="line">		 if(!s-&gt;base) exit(1); </span><br><span class="line"> /* 存储分配失败 */ </span><br><span class="line"> 		s-&gt;top=s-&gt;base+s-&gt;stacksize; //s-&gt;stacksize这个是原来没改变之前的那个</span><br><span class="line">		 //是为了让top指针指向刚刚大一size之后的第一个位置; </span><br><span class="line">		s-&gt;stacksize+=STACK_INCREMENT; </span><br><span class="line">	&#125; </span><br><span class="line">	*(s-&gt;top)++=e;   //这是数值和数值的赋值，*(s-&gt;top)是指向这个地址的数值 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int Pop(SqStack *s,int *e) &#123; </span><br><span class="line">/* 若栈不空，则删除 S 的栈顶元素，用 e 返回其值，并返回 OK；否则 返回 ERROR */ </span><br><span class="line">	if(s-&gt;top==s-&gt;base) return ERROR; </span><br><span class="line">	*e=*--s-&gt;top; </span><br><span class="line">	return OK;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> void conversion_16() &#123; </span><br><span class="line"> /* 对于输入的任意一个非负 10 进制整数，打印输出与其等值的 16 进制数 */ </span><br><span class="line"> 	SqStack s; int n; /* 非负整数 */ </span><br><span class="line"> 	int e; InitStack(&amp;s); /* 初始化栈 */ </span><br><span class="line"> 	printf(&quot;将 10 进制整数 n 转换为 16 进制数\n 请输入 n( &gt;0 )：&quot;); </span><br><span class="line"> 	scanf(&quot;%d&quot;,&amp;n); /* 输入非负十进制整数 n */ </span><br><span class="line"> 	while(n)&#123;/* 当 n 不等于 0 */</span><br><span class="line"> 		 Push(&amp;s,n%16); /* 入栈 n 除以 16 的余数(16 进制的低位) */ </span><br><span class="line"> 		 n=n/16; </span><br><span class="line">	  &#125; </span><br><span class="line">  	while(!StackEmpty(s)) /* 当栈不空 */ </span><br><span class="line">  	&#123; </span><br><span class="line">  		Pop(&amp;s,&amp;e); /* 弹出栈顶元素且赋值给 e */ </span><br><span class="line"> 		 if(e&lt;=9) printf(&quot;%d&quot;,e); </span><br><span class="line"> 		 else printf(&quot;%c&quot;,e+55); /* 大于 9 的余数，输出相应的字符*/ </span><br><span class="line"> 	 &#125; </span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> void conversion_8() &#123; </span><br><span class="line"> /* 对于输入的任意一个非负 10 进制整数，打印输出与其等值的 8 进制数 */ </span><br><span class="line"> 	SqStack s; int n; /* 非负整数 */ </span><br><span class="line"> 	int e; InitStack(&amp;s); /* 初始化栈 */ </span><br><span class="line"> 	printf(&quot;将 10 进制整数 n 转换为 8 进制数\n 请输入 n( &gt;0 )：&quot;); </span><br><span class="line"> 	scanf(&quot;%d&quot;,&amp;n); /* 输入非负十进制整数 n */ </span><br><span class="line"> 	while(n)&#123;/* 当 n 不等于 0 */</span><br><span class="line"> 		 Push(&amp;s,n%8); /* 入栈 n 除以 8 的余数(8 进制的低位) */ </span><br><span class="line"> 		 n=n/8; </span><br><span class="line">	  &#125; </span><br><span class="line">  	while(!StackEmpty(s)) /* 当栈不空 */ </span><br><span class="line">  	&#123; </span><br><span class="line">  		Pop(&amp;s,&amp;e); /* 弹出栈顶元素且赋值给 e */ </span><br><span class="line"> 		 printf(&quot;%d&quot;,e);</span><br><span class="line"> 	 &#125; </span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void conversion_2() &#123; </span><br><span class="line"> /* 对于输入的任意一个非负 10 进制整数，打印输出与其等值的 2进制数 */ </span><br><span class="line"> 	SqStack s; int n; /* 非负整数 */ </span><br><span class="line"> 	int e; InitStack(&amp;s); /* 初始化栈 */ </span><br><span class="line"> 	printf(&quot;将 10 进制整数 n 转换为 2 进制数\n 请输入 n( &gt;0 )：&quot;); </span><br><span class="line"> 	scanf(&quot;%d&quot;,&amp;n); /* 输入非负十进制整数 n */ </span><br><span class="line"> 	while(n)&#123;/* 当 n 不等于 0 */</span><br><span class="line"> 		 Push(&amp;s,n%2); /* 入栈 n 除以 2 的余数(2 进制的低位) */ </span><br><span class="line"> 		 n=n/2; </span><br><span class="line">	  &#125; </span><br><span class="line">  	while(!StackEmpty(s)) /* 当栈不空 */ </span><br><span class="line">  	&#123; </span><br><span class="line">  		Pop(&amp;s,&amp;e); /* 弹出栈顶元素且赋值给 e */ </span><br><span class="line"> 		 printf(&quot;%d&quot;,e);</span><br><span class="line"> 	 &#125; </span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 	 </span><br><span class="line">  int main() &#123; </span><br><span class="line">  </span><br><span class="line">  SqStack s; int n; /* 非负整数 */ </span><br><span class="line"> 	int e; InitStack(&amp;s); /* 初始化栈 */ </span><br><span class="line">// 	Push(&amp;s,3);</span><br><span class="line">// 	Push(&amp;s,4);	Push(&amp;s,4);</span><br><span class="line"> 	printf(&quot;%d&quot;,s.stacksize); //ans是10</span><br><span class="line">	 	printf(&quot;%d&quot;,sizeof(s));  //ans24</span><br><span class="line"> 	</span><br><span class="line"> 	</span><br><span class="line"> 	</span><br><span class="line"> 	</span><br><span class="line"> 	</span><br><span class="line">//  int choice;</span><br><span class="line">//   printf(&quot;%s&quot;,&quot;1.十进制转二进制\n&quot;);</span><br><span class="line">//  	  printf(&quot;%s&quot;,&quot;2.十进制转八进制\n&quot;);</span><br><span class="line">//  	  printf(&quot;%s&quot;,&quot;3.十进制转十六进制\n&quot;);</span><br><span class="line">//  while(1)&#123;</span><br><span class="line">//  	 </span><br><span class="line">//  	  printf(&quot;%s&quot;,&quot;请输入序号：&quot;);</span><br><span class="line">//	  scanf(&quot;%d&quot;,&amp;choice);</span><br><span class="line">//	  switch(choice)&#123;</span><br><span class="line">//	  	case 1: conversion_2(); break;</span><br><span class="line">//	  	case 2: conversion_8();break;</span><br><span class="line">//	  	case 3: conversion_16();break;</span><br><span class="line">//	  	default: return 0;</span><br><span class="line">//	  &#125; </span><br><span class="line">// 	 &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  /* </span><br><span class="line">  	预习报告 </span><br><span class="line">  	1.进制转换可以使用顺序栈这种数据结构，SqStack 结构包括两个int</span><br><span class="line">	类型的指针，top和base，还保存着顺序栈的存储空间的大小。</span><br><span class="line">其结构体定义如下： </span><br><span class="line">	typedef struct SqStack &#123;</span><br><span class="line"> 		int *base; </span><br><span class="line">		int *top; </span><br><span class="line"> 		int stacksize;  </span><br><span class="line"> 	&#125;SqStack; </span><br><span class="line">  		2.栈是一种只在表尾进行插入或者删除的操作的线性表，表尾</span><br><span class="line">	  叫栈顶（本题中的top指针），表头端称为栈底（本题中的base指针）；栈的修改是按照后进先出的原则</span><br><span class="line">	  进行的。本题目正好符合进制转换中先得到的余数后输出，即先得到的余数</span><br><span class="line">	  是低位，可以用栈这种数据结构来实现。 </span><br><span class="line">  	3.ASCII表中A对应的十进制数为65，9对应的十进制数为57，若对</span><br><span class="line">	  16取余的余数大于9，则可用余数+55得到其相应字母对应的10进制数</span><br><span class="line">	  然后将该十进制数转换为相应的字符，这种方法实现了10进制转换为相应的16进制数。</span><br><span class="line">	4.5.八进制转换 </span><br><span class="line"> 	 void conversion_8() &#123; </span><br><span class="line"> 	/* 对于输入的任意一个非负 10 进制整数，打印输出与其等值的 8 进制数 */ </span><br><span class="line">// 	SqStack s; int n; /* 非负整数 */ </span><br><span class="line">// 	int e; InitStack(&amp;s); /* 初始化栈 */ </span><br><span class="line">// 	printf(&quot;将 10 进制整数 n 转换为 8 进制数\n 请输入 n( &gt;0 )：&quot;); </span><br><span class="line">// 	scanf(&quot;%d&quot;,&amp;n); /* 输入非负十进制整数 n */ </span><br><span class="line">// 	while(n)&#123;/* 当 n 不等于 0 */</span><br><span class="line">// 		 Push(&amp;s,n%8); /* 入栈 n 除以 8 的余数(8 进制的低位) */ </span><br><span class="line">// 		 n=n/8; </span><br><span class="line">//	  &#125; </span><br><span class="line">//  	while(!StackEmpty(s)) /* 当栈不空 */ </span><br><span class="line">//  	&#123; </span><br><span class="line">//  		Pop(&amp;s,&amp;e); /* 弹出栈顶元素且赋值给 e */ </span><br><span class="line">// 		 printf(&quot;%d&quot;,e);</span><br><span class="line">// 	 &#125; </span><br><span class="line">//	printf(&quot;\n&quot;);</span><br><span class="line">//&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	/* </span><br><span class="line">	心得 </span><br><span class="line">		1.对于输入一个任意的非负十进制整数n，对n除以16结果为a，余数为b，</span><br><span class="line">	将余数b压入顺序栈，继续对a进行此操作，直至a为0；</span><br><span class="line">	当栈不为空时，弹出相应的数输出即可；对于16进制输出，首先判断弹出的元素e</span><br><span class="line">	是否小于9，若大于9输出（e+55）对应的字符即可 。 </span><br><span class="line">	</span><br><span class="line">	2. 根据问题的要求，利用顺序栈实现将十进制数n转换为 16,2,8进制数， </span><br><span class="line">	此时 同时要实现初始化空栈，入栈，出栈，判栈空，栈的长度等功能。</span><br><span class="line">	其中：判断栈空的条件是栈顶指针和栈底指针相等。栈的长度是 栈顶指针和栈底指针的差值</span><br><span class="line">	。</span><br><span class="line">	 </span><br><span class="line">	3.在栈顶插入元素，即入栈操作 ，首先是先判断栈是否已满，如果栈满就realloc</span><br><span class="line">	函数重新为栈分配新的空间， 初始化栈顶到没扩展之前的base+stacksize的位置 </span><br><span class="line">	</span><br><span class="line">  */</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="上机实验四-实验题目：循环队列基本操作-循环队列基本操作"><a href="#上机实验四-实验题目：循环队列基本操作-循环队列基本操作" class="headerlink" title="上机实验四  实验题目：循环队列基本操作 循环队列基本操作"></a><strong>上机实验四  实验题目：循环队列基本操作 循环队列基本操作</strong></h4><p>【 实验目的 】<br>1、 掌握用 VC 工具上机调试循环队列的基本方法；<br>2、 掌握循环队列的基本操作，循环队列初始化、入队、出队、判断队空、判断队满<br>以及求队列长度操作；<br>3、 掌握队列的先进先出运算规则及其在病人看病模拟程序中的应用，理解队列在运算过程<br>中状态的变化。<br>【 实验要求 】  </p>
<ol>
<li>循环队列的初始化、入队、出队、判断是否为空、求队列长度及队列输出操作的实现；  </li>
<li>编写程序模拟实现病人看病排队。<br>【 需求分析 】<br>1、 程序应该达到的功能：<br>在病人排队看医生的过程中，主要重复两件事：<br>（1） 病人到达诊室，将病历本交给护士，排到等待队列中候诊；<br>（2） 护士从等待队列中取出下一位病人的病历，该病人进入诊室就诊。<br>要求程序能够模拟病人等待就诊这一过程，因此程序应采取菜单方式，且各选项的功能<br>如下：<br>（1） 排队——输入排队病人的病历号，加入病人排队队列中；<br>（2） 就诊——病人排队队列中最前面的病人就诊，并将其从队列中删除；<br>（3） 查看队列——从队首到队尾依次列出所有的排队病人的病历号；<br>（4） 不再接受排队，队列中现有病人依次就诊。<br>（5） 下班——退出系统。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef int ElementType;</span><br><span class="line">#define MaxSize 5</span><br><span class="line">// 队列结构体定义</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	ElementType patient[MaxSize];</span><br><span class="line">	int front, rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line">// 排队(入队)</span><br><span class="line">void AddQ(Queue *PtrQ) &#123;</span><br><span class="line">	int flag = 0, i, item;</span><br><span class="line">	i = PtrQ-&gt;front;//第一次加的时候，i指向front初始值为0 </span><br><span class="line">	if( (PtrQ-&gt;rear+1)%MaxSize == PtrQ-&gt;front ) &#123;//判断队满了没有 </span><br><span class="line">		printf(&quot; &gt;&gt;排队人数已超出范围, 请先诊断病人.\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	do &#123;</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;item);</span><br><span class="line">		while((i++)%MaxSize != PtrQ-&gt;rear ) &#123;</span><br><span class="line">			//如果只有两个的话，++i之后就会直接不运行下面这个while了 </span><br><span class="line">		//这地方不能改为++i，为什么呀，font队头本身就不用判断呀，因为有时候要 </span><br><span class="line">			if(item == PtrQ-&gt;patient[i%MaxSize]) &#123;//i修改为i%MaxSize，因为i++之后有可能会跳过一些数 </span><br><span class="line">				</span><br><span class="line">				flag = 1;</span><br><span class="line">				break;</span><br><span class="line">			&#125; else</span><br><span class="line">				flag = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		if( flag == 1 ) &#123;</span><br><span class="line">			printf(&quot; &gt;&gt;病历号重复, 请重新输入:&quot;);</span><br><span class="line">			i = PtrQ-&gt;front;//重新跟新一下i，新加上的 </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; while( flag );</span><br><span class="line">	PtrQ-&gt;rear = (PtrQ-&gt;rear+1) % MaxSize;</span><br><span class="line">	PtrQ-&gt;patient[PtrQ-&gt;rear] = item;//没与下一行调换顺序 ，为了让在0的位置存一下数据 ？？ </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">// 就诊(出队)</span><br><span class="line">void Treatment(Queue *PtrQ) &#123;</span><br><span class="line">	int patient;</span><br><span class="line">	if( PtrQ-&gt;front == PtrQ-&gt;rear ) &#123;//不要+1 ，相等就是队满了 </span><br><span class="line">		printf(&quot; &gt;&gt;没人在排队看病.\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		</span><br><span class="line">		 </span><br><span class="line">		PtrQ-&gt;front = (PtrQ-&gt;front+1) % MaxSize;</span><br><span class="line">		patient = PtrQ-&gt;patient[PtrQ-&gt;front];</span><br><span class="line">		printf(&quot; &gt;&gt;病人%d 就诊\n&quot;, patient);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 查看排队情况(遍历循环队列)</span><br><span class="line">void print(Queue *PtrQ) &#123;</span><br><span class="line">	int i = PtrQ-&gt;front;//头部指向数据的前一个没有数据的节点 </span><br><span class="line">	if( PtrQ-&gt;front == PtrQ-&gt;rear ) &#123;</span><br><span class="line">		printf(&quot; &gt;&gt;没有人在排队.\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		printf(&quot; &gt;&gt;排队的人有:&quot;);</span><br><span class="line">		while( (i % MaxSize) != PtrQ-&gt;rear) &#123;</span><br><span class="line">		//while中i修改为(i % MaxSize)  </span><br><span class="line">		//如果i是队尾了，就不用输出了，因为队尾在上一次就已经输出来了 </span><br><span class="line">			printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]);//i+1修改为 (i+1)%MaxSize</span><br><span class="line">			//最开始的时候从下标为1的头开始读取 </span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line">// 余下依次就诊，不再排队(遍历队列)</span><br><span class="line">void NoMoreQueue(Queue *PtrQ) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	if(PtrQ-&gt;front == PtrQ-&gt;rear) &#123;</span><br><span class="line">		printf(&quot; &gt;&gt;没有排队的人.\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		i = PtrQ-&gt;front;</span><br><span class="line">		printf(&quot; &gt;&gt;病人按以下顺序就诊:&quot;);</span><br><span class="line">		while( i%MaxSize != PtrQ-&gt;rear ) &#123;</span><br><span class="line">			printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]);</span><br><span class="line">			//第一次就输出队头的下一个元素 ，i+1修改为 (i+1)%MaxSize </span><br><span class="line">			</span><br><span class="line">			i++;</span><br><span class="line">			PtrQ-&gt;front = (PtrQ-&gt;front+1) % MaxSize;</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int flag = 1, sel;</span><br><span class="line">	Queue *p;</span><br><span class="line">	p = (Queue *)malloc(sizeof(Queue));</span><br><span class="line">	p-&gt;front = 0;</span><br><span class="line">	p-&gt;rear = 0;</span><br><span class="line">	while( flag ) &#123;</span><br><span class="line">		printf(&quot;1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:&quot;);</span><br><span class="line">		scanf(&quot;%d&quot;, &amp;sel);</span><br><span class="line">		switch( sel ) &#123;</span><br><span class="line">			case 1 :</span><br><span class="line">				printf(&quot; &gt;&gt;请输入病历号:&quot;);</span><br><span class="line">				AddQ( p );</span><br><span class="line">				break;</span><br><span class="line">			case 2 :</span><br><span class="line">				Treatment( p );</span><br><span class="line">				break;</span><br><span class="line">			case 3 :</span><br><span class="line">				print( p );</span><br><span class="line">				break;</span><br><span class="line">			case 4 :</span><br><span class="line">				NoMoreQueue( p );</span><br><span class="line">				break;</span><br><span class="line">			case 5 :</span><br><span class="line">				if(p-&gt;front != p-&gt;rear )</span><br><span class="line">					printf(&quot; &gt;&gt;请排队的病人明天就医!现在要下班了\n&quot;);</span><br><span class="line">				else</span><br><span class="line">					printf(&quot; &gt;&gt;已经没有排队的病人,现在准备下班!\n&quot;);</span><br><span class="line">				flag = 0;</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*1:</span><br><span class="line"></span><br><span class="line">bug1:那个不再排队直接一次就诊之后还要不要能看那个查看排队</span><br><span class="line">bug2：为什么在排队时第一次输入一个重复的病历单后，之后输入</span><br><span class="line">不同的病历单也会出现病历单重复的信息，而且程序会直接会崩 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 预习报告：</span><br><span class="line"> 1.余下的一次就诊的方法设计思路：首先是判断一下队列的头指针和尾指针是否相同，相同的话队列</span><br><span class="line">为空，就显示没有正在排队的人，否则，声明一个临时变量i，让它指向队列的头部， printf(&quot;%d &quot;, PtrQ-&gt;patient[i+1]);</span><br><span class="line">因为i+1 有可能比5要大，不对 MaxSize取模的话就会出现显示未知数据的情况，所以应该这样写:printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]);</span><br><span class="line"> 并且应该在i++之后写PtrQ-&gt;front = (PtrQ-&gt;front+1) % MaxSize;，这样的话每一个病人就诊完后，头指针+1(将该病人从队列中删除)，</span><br><span class="line"> 这样的话选择4之后就还可以选择1，再添加病人。 </span><br><span class="line"> </span><br><span class="line"> 2. 入队操作的设计思路，应该先判断队列是否已满，已满的话就提示信息；否则获取要排队的</span><br><span class="line"> 序号，与此同时对队列中已有的序号与输入的序号进行比较，如果相同就提示再次输入</span><br><span class="line"> ，然后队列尾指针向后移动一位，在尾指针处存入相应的数据，头部指针是不存储数据的。</span><br><span class="line"> </span><br><span class="line"> 实验心得： </span><br><span class="line">1. 在AddQ方法中判断输入的序号是否出现时，while(i++!=PtrQ-&gt;rear) </span><br><span class="line">该条语句应该改为 while((i++)%MaxSize != PtrQ-&gt;rear )</span><br><span class="line">并且本条语句if(item == PtrQ-&gt;patient[i]) 也应该 改为if(item == PtrQ-&gt;patient[i%MaxSize]) </span><br><span class="line">否则会因为在while语句中i++后i的值比原来增加1，少比较一些值，会出现在队列中加入</span><br><span class="line">与原来相同的序号</span><br><span class="line">2.在NoMoreQueue方法中，printf(&quot;%d &quot;, PtrQ-&gt;patient[i+1]);也会出现显示相同序号的问题，</span><br><span class="line">printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]);</span><br><span class="line">	同样在print方法中， printf(&quot;%d &quot;, PtrQ-&gt;patient[i+1]);该条语句的后果可能会出现</span><br><span class="line">	两个相同的序号，但是在选择2挨个就诊的时候并不会出现两个相同的序号 ，所以该条语句应改为</span><br><span class="line">printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">实验结果	</span><br><span class="line">	1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1</span><br><span class="line"> &gt;&gt;请输入病历号:1</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1</span><br><span class="line"> &gt;&gt;请输入病历号:2</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1</span><br><span class="line"> &gt;&gt;请输入病历号:3</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1</span><br><span class="line"> &gt;&gt;请输入病历号:4</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:3</span><br><span class="line"> &gt;&gt;排队的人有:1 2 3 4</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:2</span><br><span class="line"> &gt;&gt;病人1 就诊</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:2</span><br><span class="line"> &gt;&gt;病人2 就诊</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1</span><br><span class="line"> &gt;&gt;请输入病历号:1</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:4</span><br><span class="line"> &gt;&gt;病人按以下顺序就诊:3 4 1</span><br><span class="line">1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:5</span><br><span class="line"> &gt;&gt;已经没有排队的病人,现在准备下班!</span><br><span class="line"></span><br><span class="line"> */ </span><br></pre></td></tr></table></figure>

<h4 id="上机实验五-二叉树"><a href="#上机实验五-二叉树" class="headerlink" title="上机实验五  二叉树"></a><strong>上机实验五  二叉树</strong></h4><p>一、实验目的<br>　　　1．掌握二叉树树的结构及非线性特点，递归特点和动态性。<br>　　　2．巩固对指针的使用和二叉树的三种遍历方法、建立方法。<br>二、实验内容<br>　　　二叉树的实现和运算    </p>
<p>预习报告：    </p>
<ol>
<li><p>首先是树的节点的声明<br>typedef struct BitNode {<br> &#x2F;&#x2F;节点存放char类型的数据<br> char data;<br> &#x2F;&#x2F;声明两个节点类型的左指针和右指针<br> struct BitNode *lchild,*rchild;<br>}*BitTree;  </p>
</li>
<li><p>先序建立二叉树BinTreeCreat的方法，首先本算法要在叶子结点下<br>输入#来代表下面没有节点了，所以先获取输入节点的值，如果该节点<br>的值为#，那么该节点的子树为空，如果该节点的值不为#，那么<br>递归的建立左子树右子树。</p>
</li>
<li><p>先序遍历二叉树BinTraverse方法，首先应该判断输入的树是否为<br>不为空就输出该节点的值，递归的输出左子树和右子树的值  </p>
</li>
<li><p>求二叉树的深度BinTreeDepth函数的设计思路为：首先声明一个<br>int类型的变量depthval，判断二叉树是否为空，不为空就<br>递归的调用该方法求左子树右子树的深度，求完的时候还要<br>在 depthLeft和depthRight中求最大值还要+1，该结果就是<br>二叉树的深度。   </p>
</li>
<li><p>求二叉树中所有结点数的BinTreeCount方法，首先要声明int<br>类型的变量node，和求二叉树的深度的函数的设计方法相似，<br>判断二叉树是否为空，不为空就递归的调用该方法求左子树右<br>子树的节点，最后总的节点数为左子树+右子树+1。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">实验代码：</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef char DataType;</span><br><span class="line">typedef struct BitNode &#123;</span><br><span class="line">	DataType data;</span><br><span class="line">	struct BitNode *lchild,*rchild;</span><br><span class="line">&#125;*BitTree;</span><br><span class="line">void BinTreeInit(BitTree &amp;BT) &#123; // 初始化二叉树，即把树根指针置空</span><br><span class="line">	BT=(BitTree)malloc(sizeof(BitNode));</span><br><span class="line">	BT-&gt;data=NULL;</span><br><span class="line">	cout&lt;&lt;&quot; 二叉树初始化成功 !&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int BinTreeCreat(BitTree &amp;BT) &#123; // 按先序次序建立一个二叉树</span><br><span class="line">	char ch;</span><br><span class="line">	cin&gt;&gt;ch;</span><br><span class="line">	if(ch==&#x27;#&#x27;) BT=NULL;</span><br><span class="line">	else &#123;</span><br><span class="line">		if(!(BT=(BitTree)malloc(sizeof(BitNode))))</span><br><span class="line">			exit(0);</span><br><span class="line">		BT-&gt;data=ch;</span><br><span class="line">		BinTreeCreat(BT-&gt;lchild);</span><br><span class="line">		BinTreeCreat(BT-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">void BinTreeEmpty(BitTree &amp;BT) &#123; // 检查二叉树是否为空</span><br><span class="line">	if(BT-&gt;data==NULL)</span><br><span class="line">		cout&lt;&lt;&quot; 是空二叉树 !&quot;&lt;&lt;endl;</span><br><span class="line">	else</span><br><span class="line">		cout&lt;&lt;&quot; 不是空二叉树 !&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void BinTraverse(BitTree &amp;BT) &#123; // 先序序列遍历二叉树</span><br><span class="line">	if(BT!=NULL) &#123;</span><br><span class="line">		cout&lt;&lt;BT-&gt;data;</span><br><span class="line">		BinTraverse(BT-&gt;lchild);</span><br><span class="line">		BinTraverse(BT-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int BinTreeDepth(BitTree BT) &#123; // 求二叉树的深度</span><br><span class="line">	int depthval;</span><br><span class="line">	if(BT)&#123;</span><br><span class="line">		int depthLeft=BinTreeDepth(BT-&gt;lchild);</span><br><span class="line">		int depthRight=BinTreeDepth(BT-&gt;rchild);</span><br><span class="line">		depthval = 1+(depthLeft&gt;depthRight?depthLeft:depthRight);</span><br><span class="line">	&#125; else depthval=0;</span><br><span class="line">	return depthval;</span><br><span class="line">&#125;</span><br><span class="line">int BinTreeCount(BitTree BT) &#123; // 求二叉树中所有结点数</span><br><span class="line">	int node;</span><br><span class="line">	if(BT) &#123;</span><br><span class="line">		int lchild=BinTreeCount(BT-&gt;lchild);</span><br><span class="line">		int rchild=BinTreeCount(BT-&gt;rchild);</span><br><span class="line">		node=lchild+rchild+1;</span><br><span class="line">	&#125; else node= 0;</span><br><span class="line">	return node;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int i;</span><br><span class="line">	BitTree BT;</span><br><span class="line">	cout&lt;&lt;&quot;1 、初始化二叉树 :&quot;&lt;&lt;&quot;\n2 、按先序序列建立二叉树 &quot;&lt;&lt;&quot;\n3 、判断二叉树是否为空 :&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;\n4 、先序序列遍历二叉树 &quot;&lt;&lt;&quot;\n5 、求二叉树的深度 &quot;&lt;&lt;&quot;\n6 、求二叉树节点的个数 &quot;&lt;&lt;endl;</span><br><span class="line">	for(;;) &#123;</span><br><span class="line">		cout&lt;&lt;&quot; 输出你所需的操作 :&quot;;</span><br><span class="line">		cin&gt;&gt;i;</span><br><span class="line">		if(i==1)</span><br><span class="line">			BinTreeInit(BT);</span><br><span class="line">		else if(i==2) &#123;</span><br><span class="line">			cout&lt;&lt;&quot; 输入你要建立的二叉树 :&quot;&lt;&lt;endl;</span><br><span class="line">			BinTreeCreat(BT);</span><br><span class="line">		&#125; else if(i==3)</span><br><span class="line">			BinTreeEmpty(BT);</span><br><span class="line">		else if(i==4)</span><br><span class="line">			BinTraverse(BT);</span><br><span class="line">		else if(i==5)</span><br><span class="line">			cout&lt;&lt;&quot; 二叉树的深度 :&quot;&lt;&lt;BinTreeDepth(BT)&lt;&lt;endl;</span><br><span class="line">		else if(i==6)</span><br><span class="line">			cout&lt;&lt;&quot; 二叉树的节点数 &quot;&lt;&lt;BinTreeCount(BT)&lt;&lt;endl;</span><br><span class="line">		else</span><br><span class="line">			return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">实验结果：</span><br><span class="line">1 、初始化二叉树 :</span><br><span class="line">2 、按先序序列建立二叉树</span><br><span class="line">3 、判断二叉树是否为空 :</span><br><span class="line">4 、先序序列遍历二叉树</span><br><span class="line">5 、求二叉树的深度</span><br><span class="line">6 、求二叉树节点的个数</span><br><span class="line"> 输出你所需的操作 :1</span><br><span class="line"> 二叉树初始化成功 !</span><br><span class="line"> 输出你所需的操作 :2</span><br><span class="line"> 输入你要建立的二叉树 :</span><br><span class="line">1 2 4 # # 5 # # 3 # 6 # #</span><br><span class="line"> 输出你所需的操作 :3</span><br><span class="line"> 不是空二叉树 !</span><br><span class="line"> 输出你所需的操作 :4</span><br><span class="line">124536 输出你所需的操作 :5</span><br><span class="line"> 二叉树的深度 :3</span><br><span class="line"> 输出你所需的操作 :6</span><br><span class="line"> 二叉树的节点数 6 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="上机实验六-实验题目-：-图的-存储与遍历"><a href="#上机实验六-实验题目-：-图的-存储与遍历" class="headerlink" title="上机实验六 实验题目 ： 图的 存储与遍历"></a><strong>上机实验六 实验题目 ： 图的 存储与遍历</strong></h4><p>实验目的 ：<br>掌握有向图和无向图的概念；掌握邻接矩阵和邻接链表建立图的存储结构；掌握 DFS 及<br>BFS 对图的遍历操作。<br>实验要求：<br>采用邻接矩阵作为图的存储结构，完成有向图和无向图的 DFS 和 BFS 操作。<br>实验主要步骤：<br>设计一个有向图和一个无向图，任选一种存储结构，完成有向图和无向图的 DFS（深度优<br>先遍历）和 BFS（广度优先遍历）的操作。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">#include&quot;stdio.h&quot;</span><br><span class="line">#include&quot;stdlib.h&quot;</span><br><span class="line">#define MaxVertexNum 100</span><br><span class="line">//定义最大顶点数</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	char vexs[MaxVertexNum];</span><br><span class="line">	//顶点表</span><br><span class="line">	int edges[MaxVertexNum][MaxVertexNum];</span><br><span class="line">	//邻接矩阵，可看作边表</span><br><span class="line">	int n,e;</span><br><span class="line">	//图中的顶点数 n 和边数 e</span><br><span class="line"></span><br><span class="line">&#125; MGraph;</span><br><span class="line"></span><br><span class="line">//用邻接矩阵表示的图的类型</span><br><span class="line">//=========建立邻接矩阵=======</span><br><span class="line">void CreatMGraph(MGraph *G) &#123;</span><br><span class="line">	int i,j,k;</span><br><span class="line">	char a;</span><br><span class="line">	printf(&quot;Input VertexNum(n) and EdgesNum(e): &quot;);</span><br><span class="line">	scanf(&quot;%d,%d&quot;,&amp;G-&gt;n,&amp;G-&gt;e);</span><br><span class="line">	//输入顶点数和边数</span><br><span class="line">	scanf(&quot;%c&quot;,&amp;a);</span><br><span class="line"></span><br><span class="line">	printf(&quot;Input Vertex string:&quot;);</span><br><span class="line"></span><br><span class="line">	for(i=0; i&lt;G-&gt;n; i++)         &#123;</span><br><span class="line">		scanf(&quot;%c&quot;,&amp;a);</span><br><span class="line">		G-&gt;vexs[i]=a;</span><br><span class="line">		//读入顶点信息，建立顶点表</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	for(i=0; i&lt;G-&gt;n; i++)</span><br><span class="line">		for(j=0; j&lt;G-&gt;n; j++)</span><br><span class="line">			G-&gt;edges[i][j]=0;</span><br><span class="line">	//初始化邻接矩阵</span><br><span class="line">	printf(&quot;Input edges,Creat Adjacency Matrix\n&quot;);</span><br><span class="line">	for(k=0; k&lt;G-&gt;e; k++) &#123;</span><br><span class="line">		//读入 e 条边，建立邻接矩阵</span><br><span class="line">		scanf(&quot;%d%d&quot;,&amp;i,&amp;j);</span><br><span class="line">		//输入边（Vi，Vj）的顶点序号</span><br><span class="line">		G-&gt;edges[i][j]=1;</span><br><span class="line"></span><br><span class="line">		G-&gt;edges[j][i]=1;</span><br><span class="line">		//若为无向图，矩阵为对称矩阵；若建立有向图，去掉该条语句</span><br><span class="line">	&#125;</span><br><span class="line">&#125; //=========定义标志向量，为全局变量=======</span><br><span class="line">typedef enum &#123;FALSE,TRUE&#125; Boolean;</span><br><span class="line"></span><br><span class="line">Boolean visited[MaxVertexNum];</span><br><span class="line">//========DFS：深度优先遍历的递归算法======</span><br><span class="line">void DFSM(MGraph *G,int i) &#123;</span><br><span class="line">//以 Vi 为出发点对邻接矩阵表示的图 G 进行 DFS 搜索，邻接矩阵是 0，1 矩阵</span><br><span class="line">	int j;</span><br><span class="line">	printf(&quot;%c&quot;,G-&gt;vexs[i]);</span><br><span class="line">	//访问顶点 Vi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	visited[i]=TRUE;</span><br><span class="line">	//置已访问标志</span><br><span class="line">	for(j=0; j&lt;G-&gt;n; j++)</span><br><span class="line">		//依次搜索 Vi 的邻接点</span><br><span class="line">		if(G-&gt;edges[i][j]==1 &amp;&amp; ! visited[j])      DFSM(G,j);</span><br><span class="line">	//（Vi，Vj）∈E，且 Vj 未访问过，故 Vj 为新出发点</span><br><span class="line">&#125;</span><br><span class="line">void DFS(MGraph *G) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=0; i&lt;G-&gt;n; i++)</span><br><span class="line">		visited[i]=FALSE;</span><br><span class="line">	//标志向量初始化</span><br><span class="line">	for(i=0; i&lt;G-&gt;n; i++)  if(!visited[i])</span><br><span class="line">			//Vi 未访问过</span><br><span class="line"></span><br><span class="line">			DFSM(G,i);</span><br><span class="line">	//以 Vi 为源点开始 DFS 搜索</span><br><span class="line">&#125;</span><br><span class="line">//===========BFS：广度优先遍历=======</span><br><span class="line">void BFS(MGraph *G,int k) &#123;</span><br><span class="line">	//以 Vk 为源点对用邻接矩阵表示的图 G 进行广度优先搜索</span><br><span class="line">	int i,j,f=0,r=0;</span><br><span class="line">	int cq[MaxVertexNum];</span><br><span class="line">	//定义队列</span><br><span class="line"></span><br><span class="line">	for(i=0; i&lt;G-&gt;n; i++)  visited[i]=FALSE;</span><br><span class="line">	//标志向量初始化</span><br><span class="line"></span><br><span class="line">	for(i=0; i&lt;G-&gt;n; i++)  cq[i]=-1;</span><br><span class="line">	//队列初始化</span><br><span class="line">	printf(&quot;%c&quot;,G-&gt;vexs[k]);</span><br><span class="line">	//访问源点 Vk</span><br><span class="line">	visited[k]=TRUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	cq[r]=k;</span><br><span class="line">	//Vk 已访问，将其入队。注意，实际上是将其序号入队</span><br><span class="line">	while(cq[f]!=-1) &#123;</span><br><span class="line">		//队非空则执行</span><br><span class="line">		i=cq[f];</span><br><span class="line">		f=f+1;             //Vf 出队</span><br><span class="line">		for(j=0; j&lt;G-&gt;n; j++)       //依次 Vi 的邻接点 Vj</span><br><span class="line">			if(G-&gt;edges[i][j]==1 &amp;&amp; !visited[j]) &#123;  //Vj 未访问</span><br><span class="line">				printf(&quot;%c&quot;,G-&gt;vexs[j]);         //访问 Vj</span><br><span class="line">				visited[j]=TRUE;</span><br><span class="line">				r=r+1;</span><br><span class="line">				cq[r]=j;</span><br><span class="line">				//访问过 Vj 入队</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; //==========main=====</span><br><span class="line">int main() &#123;</span><br><span class="line">	int i;</span><br><span class="line">	MGraph *G;</span><br><span class="line">	G=(MGraph *)malloc(sizeof(MGraph));</span><br><span class="line">	//为图 G 申请内存空间</span><br><span class="line"></span><br><span class="line">	CreatMGraph(G);</span><br><span class="line">	//建立邻接矩阵</span><br><span class="line">	printf(&quot;Print Graph DFS: &quot;);</span><br><span class="line">	DFS(G);</span><br><span class="line">	//深度优先遍历</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;Print Graph BFS: &quot;);</span><br><span class="line">	BFS(G,3);</span><br><span class="line">	//以序号为 3 的顶点开始广度优先遍历</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	system(&quot;pause&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">/* </span><br><span class="line">实验结果： </span><br><span class="line">Input VertexNum(n) and EdgesNum(e): 8,9</span><br><span class="line">Input Vertex string:01234567</span><br><span class="line">Input edges,Creat Adjacency Matrix</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">4 7</span><br><span class="line">5 6</span><br><span class="line">Print Graph DFS: 01374256</span><br><span class="line">Print Graph BFS: 31704256</span><br><span class="line"> </span><br><span class="line"> 预习报告：</span><br><span class="line"> 	1,在树形结构中，数据元素之间有着明显的层次关系，并且每一层</span><br><span class="line">	 中和上一层中的元素可能和下一层中的多个元素相关；而在图的</span><br><span class="line">	 结构中，节点之间的关系可以是任意的，图中任意两个数据元素之间</span><br><span class="line">	 都有可能相关。</span><br><span class="line">	2. 关于图的一些基本术语，邻接点：对于无向图G，如果图的边(v,v&#x27;)</span><br><span class="line">	 属于E，那么顶点v,v&#x27;互为邻接点。</span><br><span class="line">	 路径：从一个顶点到另一个顶点的顶点序列叫做路径。</span><br><span class="line">	 路径长度：是一条路径上经过的边或弧的数目。</span><br><span class="line">	 连通：在无向图中，两个顶点之间存在路径，就说这两个顶点是连通的。</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">实验心得：</span><br><span class="line">	1.深度优先搜索遍历类似于数的先序遍历，是树的先序遍历的推广。	  </span><br><span class="line">	本实验中：首先进行标志向量初始化，对没有访问过的节点进行</span><br><span class="line">	DFS搜索，对于顶点vi进行搜索时，先输出本节点的值，在输出与本节点</span><br><span class="line">	的邻接点。这样就对整个图进行了搜索。</span><br><span class="line">	2.广度优先搜索遍历类似于数的按层次遍历的过程，设x和y是来给你个相继</span><br><span class="line">	被访问的顶点，若当前是以x为出发点进行搜索，则在访问x的所有未曾访问</span><br><span class="line">	过的领节点之后，紧接着是以y为出发点进行横向搜索；</span><br><span class="line">	3.本此实验中用到的是邻接矩阵，骑士表示是顶点之间相邻关系的矩阵，</span><br><span class="line">	用他表示图，可以很容易的通过邻接矩阵的值来判断两个顶点之间是否有边</span><br><span class="line">	也很容易的计算各个顶点的度。 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="上机实验七-题目：-顺序查找与二分查找"><a href="#上机实验七-题目：-顺序查找与二分查找" class="headerlink" title="上机实验七 题目： 顺序查找与二分查找"></a>上机实验七 题目： 顺序查找与二分查找</h4><p>【 实验目的 】<br>本次实习的主要目的在于熟悉顺序表和有序表的查找方法和特点。其中以熟悉各种顺序表的<br>操作为侧重点。通过本次实习还可帮助读者复习高级语言的使用方法。<br>【实验要求】<br>【问题描述】<br>①建立一个查找表，使用顺序查找算法对其元素进行查找，并输出查找时比较的元素和最<br>终的比较的次数。如果没有找到，则把该元素插入到该查找表中。<br>②建立一个有序查找表，使用二分查找算法对其元素进行查找，并输出查找时比较的元素<br>和最终的比较的次数；如果没有找到，则把该元素插入到该查找表中。<br>【基本要求】<br>查找过程中，同时输出查找时比较的元素和最终的比较的次数，当没有找到元素时输出<br>“没有此元素”，然后把该元素插入到该查找表中；否则输出此元素在查找表中的位置。<br>【测试数据】<br>1、查找表中的元素{1，5，7，2，8，9，6，0，4，3}，查找元素为 8，查找元素 10。<br>2、查找表中的元素{0，1，2，3，4，5，6，7，8，9}，查找元素为 8，查找元素 10。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include&lt;process.h&gt; 		// exit()函数包含在此头文件中 </span><br><span class="line">#define LIST_INIT_SIZE 100 // 初始化大小</span><br><span class="line">#define LISTINCREMENT 15</span><br><span class="line">#define EQ(a,b) ((a)==(b))</span><br><span class="line">#define LT(a,b) ((a)&lt;(b))</span><br><span class="line">#define LQ(a,b) ((a)&lt;=(b))</span><br><span class="line">#define MT(a,b) ((a)&gt;(b))</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define OVERFLOW 0</span><br><span class="line">typedef int ElemType;	 // 基本(元素)类型</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	ElemType * elem;</span><br><span class="line">	int length;</span><br><span class="line">	int listsize;</span><br><span class="line">&#125; SSTable;</span><br><span class="line">int InitTable(SSTable *L)</span><br><span class="line">// 操作结果：构造一个空的顺序线性表</span><br><span class="line">&#123;</span><br><span class="line">	(*L).elem=(ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType));</span><br><span class="line">	if(!(*L).elem) // 存储分配失败</span><br><span class="line">		exit(OVERFLOW);</span><br><span class="line">	(*L).length=0; // 空表长度为 0</span><br><span class="line">	(*L).listsize=LIST_INIT_SIZE; // 初始存储容量</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line">int TableInsert(SSTable *L,int i,ElemType e)</span><br><span class="line">// 初始条件：顺序线性表 L 已存在，1≤i≤ListLength(L)+1 。操作结果：在 L 中第 i 个位置</span><br><span class="line">//之前插入新的数据元素 e，L 的长度加 1</span><br><span class="line">&#123;</span><br><span class="line">	ElemType *newbase,*q,*p;</span><br><span class="line">	if(i&lt;1||i&gt;(*L).length+1) // i 值不合法</span><br><span class="line">		return ERROR;</span><br><span class="line">	if((*L).length&gt;=(*L).listsize) &#123; // 当前存储空间已满，增加分配</span><br><span class="line">		newbase=(ElemType</span><br><span class="line">		         *)realloc((*L).elem,((*L).listsize+LISTINCREMENT)*sizeof(ElemType));</span><br><span class="line">		if(!newbase) // 存储分配失败</span><br><span class="line">			exit(OVERFLOW);</span><br><span class="line">		(*L).elem=newbase; // 新基址</span><br><span class="line">		(*L).listsize+=LISTINCREMENT; // 增加存储容量</span><br><span class="line">	&#125;</span><br><span class="line">	q=(*L).elem+i-1; // q 为插入位置</span><br><span class="line">	for(p=(*L).elem+(*L).length-1; p&gt;=q; --p) // 插入位置及之后的元素右移</span><br><span class="line">		*(p+1)=*p;</span><br><span class="line">	*q=e; // 插入 e</span><br><span class="line">	++(*L).length; // 表长增 1</span><br><span class="line">	return OK;</span><br><span class="line">&#125;</span><br><span class="line">int Search_Seq(SSTable ST,ElemType key) &#123;</span><br><span class="line">//在顺序表 ST 中顺序查找其关键字等于 key 的数据元素。若找到，则函数值为该元素</span><br><span class="line">	//在表中的位置，否则为 0。</span><br><span class="line">	int i,j,k=0;</span><br><span class="line">	for(i=ST.length-1; !EQ(ST.elem[i],key)&amp;&amp;i&gt;=0; --i) &#123; //从后往前找，因为啥？？不从头忘后找呀</span><br><span class="line">		k++;</span><br><span class="line">		printf(&quot;比较的元素为：%d\n&quot;,ST.elem[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	if(!EQ(ST.elem[i],key)) &#123;</span><br><span class="line">		//这句话就是在for循环比较完了之后在判断</span><br><span class="line">		//一下，如果表中没有这个key就添加进去，</span><br><span class="line">		//否则就输出比较的次数</span><br><span class="line">		printf(&quot;查找该元素，比较的次数为：%d\n&quot;,k);</span><br><span class="line">		j=TableInsert(&amp;ST,ST.length+1,key);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		k++;</span><br><span class="line">		printf(&quot;比较的元素为：%d\n&quot;,ST.elem[i]);</span><br><span class="line">		printf(&quot;查找该元素，比较的次数为：%d\n&quot;,k);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int Search_Bin(SSTable ST,ElemType key) &#123;</span><br><span class="line">//在有序表 ST 中折半查找其他关键字等于 key 的数据元素。若找到，则函数值为该元</span><br><span class="line">	//素在表中的位置，否则为 0。</span><br><span class="line">	int low,high,mid,j,k=0;</span><br><span class="line">	low=0;</span><br><span class="line">	high=ST.length-1; //置区间初值</span><br><span class="line">	while(low&lt;=high) &#123;</span><br><span class="line">		mid=(low+high)/2;</span><br><span class="line">		if(EQ(key,ST.elem[mid])) &#123;</span><br><span class="line">			k++;</span><br><span class="line">			printf(&quot;比较的元素为：%d\n&quot;,ST.elem[mid]);</span><br><span class="line">			printf(&quot;查找该元素，比较的次数为：%d\n&quot;,k); //找到待查元素</span><br><span class="line">			return 0;</span><br><span class="line">		&#125; else if(LT(key,ST.elem[mid])) &#123;</span><br><span class="line">			k++;</span><br><span class="line">			printf(&quot;比较的元素为：%d\n&quot;,ST.elem[mid]);</span><br><span class="line">			high=mid-1; //继续在前半区间进行查找</span><br><span class="line">		&#125; else if(MT(key,ST.elem[mid])) &#123;</span><br><span class="line">			k++;</span><br><span class="line">			printf(&quot;比较的元素为：%d\n&quot;,ST.elem[mid]);</span><br><span class="line">			low=mid+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(!EQ(key,ST.elem[mid])) &#123;</span><br><span class="line">		printf(&quot;查找该元素，比较的次数为：%d\n&quot;,k);//没有找到待查元素</span><br><span class="line">		if(LT(key,ST.elem[mid]))</span><br><span class="line">			j=TableInsert(&amp;ST,mid+1,key);</span><br><span class="line">		else if(MT(key,ST.elem[mid]))</span><br><span class="line">			j=TableInsert(&amp;ST,ST.length+1,key);</span><br><span class="line">	&#125;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br><span class="line">int Menu() &#123;</span><br><span class="line">	int choice;</span><br><span class="line">	printf(&quot;************************\n&quot;);</span><br><span class="line">	printf(&quot; 1.新建静态查找表\n&quot;);</span><br><span class="line">	printf(&quot; 2.输出静态查找表\n&quot;);</span><br><span class="line">	printf(&quot; 3.顺序查找\n&quot;);</span><br><span class="line">	printf(&quot; 4.二分查找查找\n&quot;);</span><br><span class="line">	printf(&quot; 5.退出\n&quot;);</span><br><span class="line">	printf(&quot;============================\n&quot;);</span><br><span class="line">	printf(&quot;请选择：&quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;choice);</span><br><span class="line">	return choice;</span><br><span class="line">&#125;</span><br><span class="line">void print(ElemType *c) &#123;</span><br><span class="line">	printf(&quot;%d &quot;,*c);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	SSTable L;</span><br><span class="line">	int i,j,k,m,n,ch;</span><br><span class="line">	while (ch!=5) &#123;</span><br><span class="line">		ch=Menu();</span><br><span class="line">		switch(ch) &#123;</span><br><span class="line">			case 1:</span><br><span class="line">				printf(&quot;请输入表 L 的元素个数 n 的值：&quot;);</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">				InitTable(&amp;L); // 创建空表 L 成功</span><br><span class="line">				printf(&quot;请输入顺序表 L 的%d 个元素（格式为：元素 1 元素 2）：\n&quot;,n);</span><br><span class="line">				for(j=1; j&lt;=n; j++) &#123; // 在表 L 中插入 n 个元素</span><br><span class="line">					scanf(&quot;%d&quot;,&amp;k);</span><br><span class="line">					i=TableInsert(&amp;L,j,k);</span><br><span class="line">				&#125;</span><br><span class="line">				break;</span><br><span class="line">			case 2:</span><br><span class="line">				printf(&quot;顺序表 L 的元素分别为：&quot;); // 输出表 L 的内容</span><br><span class="line">				for(i=0; i&lt;L.length; i++)</span><br><span class="line">					print(&amp;L.elem[i]);</span><br><span class="line">				printf(&quot;\n&quot;);</span><br><span class="line">				break;</span><br><span class="line">			case 3:</span><br><span class="line">				printf(&quot;请输入查找的元素的值 m(顺序查找)：&quot;);</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">				if(Search_Seq(L,m))</span><br><span class="line">					L.length=L.length+1;</span><br><span class="line">				break;</span><br><span class="line">			case 4:</span><br><span class="line">				printf(&quot;请输入查找的元素的值 m(折半查找)：&quot;);</span><br><span class="line">				scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">				if(Search_Bin(L,m))</span><br><span class="line">					L.length=L.length+1;</span><br><span class="line">				break;</span><br><span class="line">			case 5:</span><br><span class="line">				printf(&quot;结束程序。\n&quot;);</span><br><span class="line">				return 0;</span><br><span class="line">				break;</span><br><span class="line">			default:</span><br><span class="line">				printf(&quot;输入错误！请重新输入！\n\n&quot;);</span><br><span class="line">				break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*  测试数据1：</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：1</span><br><span class="line">请输入表 L 的元素个数 n 的值：10</span><br><span class="line">请输入顺序表 L 的10 个元素（格式为：元素 1 元素 2）：</span><br><span class="line">1 5 7 2 8 9 6 0 4 3</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：2</span><br><span class="line">顺序表 L 的元素分别为：1 5 7 2 8 9 6 0 4 3</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：3</span><br><span class="line">请输入查找的元素的值 m(顺序查找)：8</span><br><span class="line">比较的元素为：3</span><br><span class="line">比较的元素为：4</span><br><span class="line">比较的元素为：0</span><br><span class="line">比较的元素为：6</span><br><span class="line">比较的元素为：9</span><br><span class="line">比较的元素为：8</span><br><span class="line">查找该元素，比较的次数为：6     (因为是从后往前比较的)</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：4</span><br><span class="line">请输入查找的元素的值 m(折半查找)：10</span><br><span class="line">比较的元素为：8</span><br><span class="line">比较的元素为：0</span><br><span class="line">比较的元素为：4</span><br><span class="line">比较的元素为：3</span><br><span class="line">查找该元素，比较的次数为：4</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：5</span><br><span class="line">结束程序。</span><br><span class="line"></span><br><span class="line">测试数据 2：</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：1</span><br><span class="line">请输入表 L 的元素个数 n 的值：10</span><br><span class="line">请输入顺序表 L 的10 个元素（格式为：元素 1 元素 2）：</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：2</span><br><span class="line">顺序表 L 的元素分别为：0 1 2 3 4 5 6 7 8 9</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：3</span><br><span class="line">请输入查找的元素的值 m(顺序查找)：8</span><br><span class="line">比较的元素为：9</span><br><span class="line">比较的元素为：8</span><br><span class="line">查找该元素，比较的次数为：2</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：4</span><br><span class="line">请输入查找的元素的值 m(折半查找)：10</span><br><span class="line">比较的元素为：4</span><br><span class="line">比较的元素为：7</span><br><span class="line">比较的元素为：8</span><br><span class="line">比较的元素为：9</span><br><span class="line">查找该元素，比较的次数为：4</span><br><span class="line">************************</span><br><span class="line"> 1.新建静态查找表</span><br><span class="line"> 2.输出静态查找表</span><br><span class="line"> 3.顺序查找</span><br><span class="line"> 4.二分查找查找</span><br><span class="line"> 5.退出</span><br><span class="line">============================</span><br><span class="line">请选择：5</span><br><span class="line">结束程序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">预习报告：</span><br><span class="line">1.顺序查找定义：从线性表中的第一个（或最后一个）</span><br><span class="line"> 数据元素开始，逐个进行数据元素关键字和给定值的比</span><br><span class="line"> 较，若某个数据元素的关键字和给定值相等则查找成功；</span><br><span class="line"> 如果直到最后一个（或第一个）</span><br><span class="line"> 数据元素，其关键字和给定值都不等时，则查找失败。</span><br><span class="line"> 若有n个数据，其查找次数为（n+1）/2；</span><br><span class="line">2.折半查找：先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或找不到记录为止。</span><br><span class="line"></span><br><span class="line">基本思想：</span><br><span class="line">首先将查找表进行排序；</span><br><span class="line">取中间数据元素进行比较；</span><br><span class="line">    当给定值与中间数据元素的关键字相等时，查找成功；</span><br><span class="line">    当给定值小于中间元素时，在中间元素左区间进行二分查找；</span><br><span class="line">    当给定值大于中间元素时，在中间元素右区间进行二分查找；</span><br><span class="line">当任意区间均无记录时，查找失败。</span><br><span class="line">其时间复杂度是O(log2 n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">实验心得：</span><br><span class="line">1. TableInsert方法： 顺序线性表 L 已存在，1≤i≤List</span><br><span class="line">Length(L)+1 。操作结果：在 L 中第 i 个位置</span><br><span class="line">之前插入新的数据元素 e，L 的长度加 1 。</span><br><span class="line"> 其中一个重要的思想就是在插入位置之后的元素要</span><br><span class="line"> 从最后一个元素开始位往后移。并且表长+1</span><br><span class="line">2. Search_Seq方法的目的是在顺序表 ST 中顺序查</span><br><span class="line">找其关键字等于 key 的数据元素。若找到，则函数值为该元素</span><br><span class="line"> 在表中的位置，否则为 0。</span><br><span class="line"> 在for循环比较完了之后在判断一下，如果表中没有这个key就添加进去，</span><br><span class="line">否则就输出比较的次数。</span><br><span class="line"></span><br><span class="line">其中for循环这样设计会减少判断是否到达表尾的次数</span><br><span class="line">从而一定程度上加快程序执行的速度。</span><br><span class="line"></span><br><span class="line">3.Search_Bin方法 的执行结果是有序表 ST 中折半查找其他关键字等于</span><br><span class="line">key 的数据元素。若找到，则函数值为该元</span><br><span class="line">素在表中的位置，否则为 0。</span><br><span class="line">在这个方法中用到了折半查找的思维，</span><br><span class="line"> 首先将查找的整个区间的左端点置为0，右端点</span><br><span class="line"> 置为表长-1；然后进行while语句，其中while的</span><br><span class="line"> 判断条件是low&lt;=high;因为当退出本循环的时候</span><br><span class="line"> 双指针会交错；如果key和mid的值相等就输出该比较的</span><br><span class="line"> 元素，如果key小于mid就对左半区间查找，若果key</span><br><span class="line"> 大于mid就对右半区间查找。</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="实验题目：-内部排序"><a href="#实验题目：-内部排序" class="headerlink" title="实验题目： 内部排序"></a>实验题目： 内部排序</h4><p>【 实验目的 】<br>１． 掌握常见的排序算法的思想及其适用条件。<br>２． 掌握常见的排序算法的程序实现。<br>【实验要求】<br>输入一组关键字序列分别实现下列排序: :   </p>
<ol>
<li><ol>
<li>实现直接插入排序、折半插入排序和希尔排序算法。 实现直接插入排序、折半插入排序和希尔排序算法。</li>
</ol>
</li>
<li><ol start="2">
<li>实现 实现 快速排序算法。</li>
</ol>
</li>
<li><ol start="3">
<li>实现归并排序算法。 实现归并排序算法。</li>
</ol>
</li>
<li><ol start="4">
<li>在主函数中设计一个简单的菜单，分别测试上述算法。 在主函数中设计一个简单的菜单，分别测试上述算法。</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;ctype.h&gt;</span><br><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">//函数结果状态代码</span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define INFEASIBLE -1</span><br><span class="line">typedef int Status;</span><br><span class="line">typedef int Boolean;</span><br><span class="line">//对两个数值型关键字的比较</span><br><span class="line">#define EQ(a,b) ((a)==(b))</span><br><span class="line">#define LT(a,b) ((a)&lt;(b))</span><br><span class="line">#define LQ(a,b) ((a)&lt;=(b))</span><br><span class="line">//待排记录的数据类型</span><br><span class="line">#define MAXSIZE 20 //一个用作示例的小顺序表的最大长度</span><br><span class="line">typedef int KeyType; //定义关键字类型为整型</span><br><span class="line">typedef int InfoType; //定义其它数据项的类型</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	KeyType key; //关键字项</span><br><span class="line">	InfoType otherinfo;//其他数据项</span><br><span class="line">&#125; RedType; //记录类型</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	RedType r[MAXSIZE+1];//r[0]闲置或用作哨兵单元</span><br><span class="line">	int length;//顺序表长度</span><br><span class="line">&#125; SqList; //顺序表类型</span><br><span class="line">typedef SqList HeapType; // 堆采用顺序表存储表示</span><br><span class="line">//顺序表插入排序的函数</span><br><span class="line">void InsertSort(SqList &amp;L);</span><br><span class="line">void BInsertSort(SqList &amp;L);</span><br><span class="line">void ShellInsert(SqList &amp;L,int dk);</span><br><span class="line">void ShellSort(SqList &amp;L,int dlta[],int t);</span><br><span class="line">//快速排序</span><br><span class="line">int Partition(SqList &amp;L,int low,int high);</span><br><span class="line">void QSort(SqList &amp;L,int low,int high);</span><br><span class="line">void QuickSort(SqList &amp;L);</span><br><span class="line">//归并排序</span><br><span class="line">void Merge(RedType SR[],RedType TR[],int i,int m,int n);</span><br><span class="line">void MSort(RedType SR[],RedType TR1[],int s, int t);</span><br><span class="line">void MergeSort(SqList &amp;L);</span><br><span class="line">//输出函数</span><br><span class="line">void print(SqList L);</span><br><span class="line">#define N 8</span><br><span class="line">#define T 3</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">	RedType d[N]= &#123;&#123;20,6&#125;,&#123;52,1&#125;,&#123;65,3&#125;,&#123;88,9&#125;,&#123;47,8&#125;,&#123;22,4&#125;,&#123;39,5&#125;,&#123;74,7&#125;&#125;;</span><br><span class="line">	int i;</span><br><span class="line">	SqList LL;</span><br><span class="line">	int dt[T]= &#123;5,3,1&#125;; // 增量序列数组</span><br><span class="line">	int choice;</span><br><span class="line">s123:</span><br><span class="line">	cout&lt;&lt;&quot;请选择要使用的排序算法：\n0..............退出\n&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;1..............插入排序\n2..............交换排序\n&quot;;</span><br><span class="line">	cout&lt;&lt;&quot;3..............归并排序\n&quot;;</span><br><span class="line">	cin&gt;&gt;choice;</span><br><span class="line">	switch(choice) &#123;</span><br><span class="line">		case 0:</span><br><span class="line">			break;</span><br><span class="line">		case 1: //插入排序</span><br><span class="line">			for(i=0; i&lt;N; i++) //给 LL.r 赋值</span><br><span class="line">				LL.r[i+1]=d[i];</span><br><span class="line">			LL.length=N;</span><br><span class="line">			printf(&quot;直接插入排序前:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			InsertSort(LL);</span><br><span class="line">			printf(&quot;直接插入排序后:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			for(i=0; i&lt;N; i++)</span><br><span class="line">				LL.r[i+1]=d[i];</span><br><span class="line">			LL.length=N;</span><br><span class="line">			printf(&quot;\n 折半插入排序前:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			BInsertSort(LL);</span><br><span class="line">			printf(&quot;折半插入排序后:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			for(i=0; i&lt;N; i++)</span><br><span class="line">				LL.r[i+1]=d[i];</span><br><span class="line">			LL.length=N;</span><br><span class="line">			printf(&quot;\n 希尔排序前: \n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			ShellSort(LL,dt,T);</span><br><span class="line">			printf(&quot;希尔排序后: \n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			goto s123;</span><br><span class="line">		case 2: //交换排序</span><br><span class="line">			for(i=0; i&lt;N; i++)</span><br><span class="line">				LL.r[i+1]=d[i];</span><br><span class="line">			LL.length=N;</span><br><span class="line">			printf(&quot;快速排序前:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			QuickSort(LL);</span><br><span class="line">			printf(&quot;快速排序后:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			goto s123;</span><br><span class="line">		case 3: //归并排序</span><br><span class="line">			for(i=0; i&lt;N; i++)</span><br><span class="line">				LL.r[i+1]=d[i];</span><br><span class="line">			LL.length=N;</span><br><span class="line">			printf(&quot;归并排序前:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			MergeSort(LL);</span><br><span class="line">			printf(&quot;归并排序后:\n&quot;);</span><br><span class="line">			print(LL);</span><br><span class="line">			goto s123;</span><br><span class="line">		default:</span><br><span class="line">			cout&lt;&lt;&quot;输入有误，请输入正确的选项！\n&quot;;</span><br><span class="line">			goto s123;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//顺序表插入排序的函数(3 个)</span><br><span class="line">//InsertSort</span><br><span class="line">void InsertSort(SqList &amp;L) &#123;</span><br><span class="line">	// 对顺序表 L 作直接插入排序。</span><br><span class="line">	int i,j;</span><br><span class="line">	for(i=2; i&lt;=L.length; ++i)</span><br><span class="line">		if(LT(L.r[i].key,L.r[i-1].key)) &#123;</span><br><span class="line">			L.r[0]=L.r[i];</span><br><span class="line">			L.r[i]=L.r[i-1];</span><br><span class="line">			for(j=i-2; LT(L.r[0].key,L.r[j].key); --j)</span><br><span class="line">				L.r[j+1]=L.r[j];</span><br><span class="line">			L.r[j+1]=L.r[0];</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BInsertSort</span><br><span class="line">void BInsertSort(SqList &amp;L) &#123;</span><br><span class="line">	//对顺序表 L 作折半插入排序。</span><br><span class="line">	int low,high,m;</span><br><span class="line">	for(int i=2; i&lt;=L.length; ++i) &#123;</span><br><span class="line">		L.r[0]=L.r[i];</span><br><span class="line">		low=1;</span><br><span class="line">		high=i-1;</span><br><span class="line">		while(low&lt;=high) &#123;</span><br><span class="line">			m=(low+high)/2;</span><br><span class="line">			if(LT(L.r[0].key,L.r[m].key))</span><br><span class="line">				high=m-1;</span><br><span class="line">			else</span><br><span class="line">				low=m+1;</span><br><span class="line">		&#125;//while</span><br><span class="line">		for(int j=i-1; j&gt;=high+1; --j)</span><br><span class="line">			L.r[j+1]=L.r[j];</span><br><span class="line">		L.r[high+1]=L.r[0];</span><br><span class="line">	&#125;//for</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//希尔排序 </span><br><span class="line">void ShellInsert(SqList &amp;L,int dk) &#123;</span><br><span class="line">	//对顺序表 L 作一趟希尔插入排序。本算法是和一趟直接插入排序相比，作了以下修改：</span><br><span class="line">// 1.前后记录位置的增量是 dk,而不是 1;</span><br><span class="line">// 2.r[0]只是暂存单元,不是哨兵。当 j&lt;=0 时,插入位置已找到。</span><br><span class="line">	int i,j;</span><br><span class="line">	for(i=dk+1; i&lt;=L.length; ++i)</span><br><span class="line">		if LT(L.r[i].key,L.r[i-dk].key) &#123;</span><br><span class="line">			//需将 L.r[i]插入有序增量子表</span><br><span class="line">			L.r[0]=L.r[i]; //暂存在 L.r[0]</span><br><span class="line">			for(j=i-dk; j&gt;0&amp;&amp;LT(L.r[0].key,L.r[j].key); j-=dk)</span><br><span class="line">				L.r[j+dk]=L.r[j]; //记录后移，查找插入位置</span><br><span class="line">			L.r[j+dk]=L.r[0]; //插入</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">void ShellSort(SqList &amp;L,int dlta[],int t) &#123;</span><br><span class="line">	//按增量序列 dlta[0..t-1]对顺序表 L 作希尔排序。</span><br><span class="line">	int k;</span><br><span class="line">	for(k=0; k&lt;t; ++k) &#123;</span><br><span class="line">		ShellInsert(L,dlta[k]); //一趟增量为 dlta[k]的插入排序</span><br><span class="line">		printf(&quot;第%d 趟排序结果: \n&quot;,k+1);</span><br><span class="line">		print(L);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//QuickSort</span><br><span class="line">int Partition(SqList &amp;L,int low,int high) &#123;</span><br><span class="line">	//交换顺序表 L 中子表 r[low..high]的记录，枢轴记录到位，并返回其</span><br><span class="line">//所在位置，此时在它之前（后）的记录均不大（小）于它。</span><br><span class="line">	KeyType pivotkey;</span><br><span class="line">	L.r[0]=L.r[low]; //用子表的第一个记录作枢轴记录</span><br><span class="line">	pivotkey=L.r[low].key; //枢轴记录关键字</span><br><span class="line">	while(low&lt; high) &#123;</span><br><span class="line">		//从表的两端交替地向中间扫描</span><br><span class="line">		while(low&lt;high&amp;&amp;L.r[high].key&gt;=pivotkey)</span><br><span class="line">			--high;</span><br><span class="line">		L.r[low]=L.r[high]; //将比枢轴记录小的记录移到低端</span><br><span class="line">		while(low&lt;high&amp;&amp;L.r[low].key&lt;=pivotkey)</span><br><span class="line">			++low;</span><br><span class="line">		L.r[high]=L.r[low]; //将比枢轴记录大的记录移到高端</span><br><span class="line">	&#125;</span><br><span class="line">	L.r[low]=L.r[0]; //枢轴记录到位</span><br><span class="line">	return low; //返回枢轴位置</span><br><span class="line">&#125;</span><br><span class="line">void QSort(SqList &amp;L,int low,int high) &#123;</span><br><span class="line">	//对顺序表 L 中的子序列 L.r[low..high]作快速排序。</span><br><span class="line">	if(low&lt;high) &#123;</span><br><span class="line">		int pivotloc;</span><br><span class="line">		pivotloc=Partition(L,low,high);</span><br><span class="line">		QSort(L,low,pivotloc-1);</span><br><span class="line">		QSort(L,pivotloc+1,high);</span><br><span class="line">	&#125;//if</span><br><span class="line">&#125;//QSort</span><br><span class="line">void QuickSort(SqList &amp;L) &#123;</span><br><span class="line">	//对顺序表 L 作快速排序。</span><br><span class="line">	QSort(L,1,L.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//归并排序 </span><br><span class="line">void Merge(RedType SR[],RedType TR[],int i,int m,int n) &#123;</span><br><span class="line">	//将有序的 SR[i..m]和 SR[m+1..n]归并为有序的 TR[i..n]</span><br><span class="line">	int j,k,l;</span><br><span class="line">	for(j=m+1,k=i; i&lt;=m&amp;&amp;j&lt;=n; ++k) //将 SR 中记录由小到大地并入 TR</span><br><span class="line">		if LQ(SR[i].key,SR[j].key)</span><br><span class="line">			TR[k]=SR[i++];</span><br><span class="line">		else</span><br><span class="line">			TR[k]=SR[j++];</span><br><span class="line">	if(i&lt;=m)</span><br><span class="line">		for(l=0; l&lt;=m-i; l++)</span><br><span class="line">			TR[k+l]=SR[i+l]; //将剩余的 SR[i..m]复制到 TR</span><br><span class="line">	if(j&lt;=n)</span><br><span class="line">		for(l=0; l&lt;=n-j; l++)</span><br><span class="line">			TR[k+l]=SR[j+l]; //将剩余的 SR[j..n]复制到 TR</span><br><span class="line">&#125;</span><br><span class="line">void MSort(RedType SR[],RedType TR1[],int s, int t) &#123;</span><br><span class="line">	//将 SR[s..t]归并排序为 TR1[s..t]。</span><br><span class="line">	RedType TR2[MAXSIZE];</span><br><span class="line">	if(s==t)</span><br><span class="line">		TR1[s]=SR[s];</span><br><span class="line">	else &#123;</span><br><span class="line">		int m=(s+t)/2;</span><br><span class="line">		MSort(SR,TR2,s,m);</span><br><span class="line">		MSort(SR,TR2,m+1,t);</span><br><span class="line">		Merge(TR2,TR1,s,m,t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void MergeSort(SqList &amp;L) &#123;</span><br><span class="line">	//对顺序表 L 作归并排序。</span><br><span class="line">	MSort(L.r,L.r,1,L.length);</span><br><span class="line">&#125;</span><br><span class="line">void print(SqList L) &#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=1; i&lt;=L.length; i++)</span><br><span class="line">		printf(&quot; (%d,%d) &quot;,L.r[i].key,L.r[i].otherinfo);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">实验结果：</span><br><span class="line"> </span><br><span class="line">请选择要使用的排序算法：</span><br><span class="line">0..............退出</span><br><span class="line">1..............插入排序</span><br><span class="line">2..............交换排序</span><br><span class="line">3..............归并排序</span><br><span class="line">1</span><br><span class="line">直接插入排序前:</span><br><span class="line"> (20,6)  (52,1)  (65,3)  (88,9)  (47,8)  (22,4)  (39,5)  (74,7)</span><br><span class="line">直接插入排序后:</span><br><span class="line"> (20,6)  (22,4)  (39,5)  (47,8)  (52,1)  (65,3)  (74,7)  (88,9)</span><br><span class="line"></span><br><span class="line"> 折半插入排序前:</span><br><span class="line"> (20,6)  (52,1)  (65,3)  (88,9)  (47,8)  (22,4)  (39,5)  (74,7)</span><br><span class="line">折半插入排序后:</span><br><span class="line"> (20,6)  (22,4)  (39,5)  (47,8)  (52,1)  (65,3)  (74,7)  (88,9)</span><br><span class="line"></span><br><span class="line"> 希尔排序前:</span><br><span class="line"> (20,6)  (52,1)  (65,3)  (88,9)  (47,8)  (22,4)  (39,5)  (74,7)</span><br><span class="line">第1 趟排序结果:</span><br><span class="line"> (20,6)  (39,5)  (65,3)  (88,9)  (47,8)  (22,4)  (52,1)  (74,7)</span><br><span class="line">第2 趟排序结果:</span><br><span class="line"> (20,6)  (39,5)  (22,4)  (52,1)  (47,8)  (65,3)  (88,9)  (74,7)</span><br><span class="line">第3 趟排序结果:</span><br><span class="line"> (20,6)  (22,4)  (39,5)  (47,8)  (52,1)  (65,3)  (74,7)  (88,9)</span><br><span class="line">希尔排序后:</span><br><span class="line"> (20,6)  (22,4)  (39,5)  (47,8)  (52,1)  (65,3)  (74,7)  (88,9)</span><br><span class="line">请选择要使用的排序算法：</span><br><span class="line">0..............退出</span><br><span class="line">1..............插入排序</span><br><span class="line">2..............交换排序</span><br><span class="line">3..............归并排序</span><br><span class="line">2</span><br><span class="line">快速排序前:</span><br><span class="line"> (20,6)  (52,1)  (65,3)  (88,9)  (47,8)  (22,4)  (39,5)  (74,7)</span><br><span class="line">快速排序后:</span><br><span class="line"> (20,6)  (22,4)  (39,5)  (47,8)  (52,1)  (65,3)  (74,7)  (88,9)</span><br><span class="line">请选择要使用的排序算法：</span><br><span class="line">0..............退出</span><br><span class="line">1..............插入排序</span><br><span class="line">2..............交换排序</span><br><span class="line">3..............归并排序</span><br><span class="line">3</span><br><span class="line">归并排序前:</span><br><span class="line"> (20,6)  (52,1)  (65,3)  (88,9)  (47,8)  (22,4)  (39,5)  (74,7)</span><br><span class="line">归并排序后:</span><br><span class="line"> (20,6)  (22,4)  (39,5)  (47,8)  (52,1)  (65,3)  (74,7)  (88,9)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 预习报告： </span><br><span class="line"> 1.直接插入排序的核心思想就是：将数组中的所</span><br><span class="line"> 有元素依次跟前面已经排好的元素相比较，如果</span><br><span class="line"> 选择的元素比已排序的元素小，则交换，直到全</span><br><span class="line"> 部元素都比较过。</span><br><span class="line"> </span><br><span class="line"> 2.尔排序的算法思想：将待排序数组按照步长gap</span><br><span class="line"> 进行分组，然后将每组的元素利用直接插入排序的</span><br><span class="line"> 方法进行排序；每次将增量折半减小，循环上述操作</span><br><span class="line"> ；当增量=1时，利用直接插入，完成排序。</span><br><span class="line"> 3.堆的概念</span><br><span class="line">堆：本质是一种数组对象。特别重要的一点性质：</span><br><span class="line">任意的叶子节点小于（或大于）它所有的父节</span><br><span class="line">点。对此，又分为大顶堆和小顶堆，大顶堆</span><br><span class="line">要求节点的元素都要大于其孩子，小顶堆要求节</span><br><span class="line">点元素都小于其左右孩子，两者对左右孩子的大小</span><br><span class="line">关系不做任何要求。</span><br><span class="line">利用堆排序，就是基于大顶堆或者小顶堆的一种</span><br><span class="line">排序方法。下面，我们通过大顶堆来实现。</span><br><span class="line"> </span><br><span class="line"> 实验心得： </span><br><span class="line"> 1.在写冒泡排序的时候因为没有想到因为第一个位置</span><br><span class="line"> 空闲不用，而导致写错了，是每次都把最小的冒到最上面</span><br><span class="line"> 然后最大的就沉到最下面，从上向下就成了有序的。</span><br><span class="line"> 所以冒泡排序思路为：</span><br><span class="line">    将序列当中的左右元素，依次比较，保证右边的元素始终大于左边的元素；</span><br><span class="line">    （ 第一轮结束后，序列最后一个元素一定是当前序列的最大值；）</span><br><span class="line">    对序列当中剩下的n-1个元素再次执行步骤1。</span><br><span class="line">    对于长度为n的序列，一共需要执行n-1轮比较</span><br><span class="line">    （利用while循环可以减少执行次数）</span><br><span class="line"> 2.快速排序的基本思想：挖坑填数+分治法</span><br><span class="line">    从序列当中选择一个基准数(pivot)</span><br><span class="line">    在这里我们选择序列当中第一个数最为基准数</span><br><span class="line">    将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧</span><br><span class="line">    重复步骤1.2，直到所有子集当中只有一个元素为止。</span><br><span class="line">    用伪代码描述如下：</span><br><span class="line">    1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。</span><br><span class="line">    2．j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</span><br><span class="line">    3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</span><br><span class="line">    4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中</span><br><span class="line">3.基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</span><br><span class="line">分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</span><br><span class="line">收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[ ]</span><br><span class="line">对新形成的序列L[]重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束</span><br><span class="line"> </span><br><span class="line"> */ </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">数据结构</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/myblog/categories/数据结构//" class="article-tag-list-link color5">数据结构</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/myblog/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-排序算法" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/myblog/2019/10/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a>
    </h1>
  

        
        <a href="/myblog/2019/10/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="archive-article-date">
  	<time datetime="2019-10-01T01:25:00.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2019-10-01</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="冒泡排序和选择排序"><a href="#冒泡排序和选择排序" class="headerlink" title="冒泡排序和选择排序"></a>冒泡排序和选择排序</h5><ul>
<li>冒泡排序的本质就是交换，选择排序的本质就是求最大最小，</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int g;</span><br><span class="line">	void bubblesort(int a[],int g);</span><br><span class="line">	void selectsort(int a[],int g) ;</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		if((cin&gt;&gt;g)==0)break;</span><br><span class="line">		int a[g];</span><br><span class="line">		for(int i=0;i&lt;g;i++) cin&gt;&gt;a[i];</span><br><span class="line">	    //selectsort(a,g);</span><br><span class="line">	    bubblesort(a,g);</span><br><span class="line">		for(int i=0;i&lt;g;i++)&#123;</span><br><span class="line">			if(i==g-1) cout&lt;&lt;a[i]&lt;&lt;endl;</span><br><span class="line">			else cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//冒泡排序 </span><br><span class="line">void bubblesort(int a[],int n) &#123;</span><br><span class="line">	//把最大的冒到最后一个，倒数第二个，依次进行 </span><br><span class="line">	int temp;</span><br><span class="line">	for(int i=0;i&lt;=n-1;i++)  		//n-1是小一位数 ,因为外循环要比n-1次，如三次比两次就好了 </span><br><span class="line">		for(int j=0;j&lt;=n-i-1;j++)   //不能j=i+1</span><br><span class="line">		/*也可以这样写 </span><br><span class="line">		for(int i=1;i&lt;n;i++)</span><br><span class="line">		for(int j=0;j&lt;n-i;j++)    //1  n  0  n-i </span><br><span class="line">		*/</span><br><span class="line">			if(a[j]&gt;a[j+1])&#123;</span><br><span class="line">				temp=a[j];</span><br><span class="line">				a[j]=a[j+1];</span><br><span class="line">				a[j+1]=temp;</span><br><span class="line">			//a[j+1]=temp;这行是a[j+1]而不是 a[j] </span><br><span class="line">			//或者  swap(a[j],a[j+1]);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    //选择排序</span><br><span class="line">void selectsort(int a[],int n) &#123;</span><br><span class="line">	//if(a[j]&lt;a[index]) index=j;  index存放最小值（最大值）的下标</span><br><span class="line">	//就是把最小的换到第一个位置 ，第二小的换到第二位置，依次排列 </span><br><span class="line">	int temp,index;</span><br><span class="line">	    for(int i=0;i&lt;n-1;i++)&#123;    //比较n-1次就行了   0  n-1  i+1  n</span><br><span class="line">		index=i; 				  //假设i=0为最小值（最大值）的下标 </span><br><span class="line">		for(int j=i+1;j&lt;n;j++)    //是j&lt;n而不是n-1 </span><br><span class="line">			if(a[j]&lt;a[index]) index=j;  </span><br><span class="line">		temp=a[index];    //最小值（最大值）与下标为i的换 </span><br><span class="line">		a[index]=a[i];</span><br><span class="line">		a[i]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="插入排序（挪动数组）"><a href="#插入排序（挪动数组）" class="headerlink" title="插入排序（挪动数组）"></a>插入排序（挪动数组）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//插入排序实现从小到大排列（若果想从大到小排列，那么改为if（a[k-1）&lt;x） a[k]=a[k-1],这样的话就是当前位置的数比x小就往后移。</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">    #include&lt;cstdio&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    #define N 5</span><br><span class="line">    int a[N];//有序数组</span><br><span class="line">    int main ( ) &#123;</span><br><span class="line">    	int i, k, x;</span><br><span class="line">    	printf(&quot;Please input %d numbers:\n&quot;,N);   </span><br><span class="line">    	for (i=0; i&lt;N; i++) &#123;</span><br><span class="line">    		scanf (&quot;%d&quot;, &amp;x);</span><br><span class="line">    		for ( k=i; k&gt;0; k-- ) &#123;	        /* 从后向前比较 */</span><br><span class="line">    			if ( a[k-1] &gt; x )    //x前面的数比它大</span><br><span class="line">    				a[k]=a[k-1];         /* 将大数向后移动*/</span><br><span class="line">    			else      break; /* 找到插入的位置，退出 */</span><br><span class="line">    		&#125;</span><br><span class="line">    		a[k] = x;  /* 完成插入操作 */</span><br><span class="line">    	&#125;</span><br><span class="line">    </span><br><span class="line">    	for (i=0; i&lt;N; i++)</span><br><span class="line">    		printf(&quot;%d &quot;, a[i]);</span><br><span class="line">    	return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="快速排序（分治法的一个体现）"><a href="#快速排序（分治法的一个体现）" class="headerlink" title="快速排序（分治法的一个体现）"></a>快速排序（分治法的一个体现）</h5><p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-101.png" alt="upload successful"></p>
<ul>
<li>快排之单向扫描分区法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//快速排序单向扫描分区法 </span><br><span class="line">void swap(int A[],int p,int r)&#123;</span><br><span class="line">	//交换数组A下标为p和r的值 </span><br><span class="line">	int tmp=A[p];</span><br><span class="line">	A[p]=A[r];</span><br><span class="line">	A[r]=tmp;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">int partition(int A[],int p,int r)&#123;</span><br><span class="line">	int pivot=A[p];//初始化pivot(主元)指向A[p],就是最靠左的位置 </span><br><span class="line">	int sp=p+1;  //扫描指针 </span><br><span class="line">	int bigger=r; //右侧指针 </span><br><span class="line">	while(sp&lt;=bigger)&#123;  //bigger指向的 </span><br><span class="line">		if(A[sp]&lt;=pivot) //扫描元素小于主元，右指针向右移 </span><br><span class="line">			sp++;</span><br><span class="line">		else&#123;</span><br><span class="line">			swap(A,sp,bigger);//扫描元素大于主元，二指针的元素互换，右指针左移 </span><br><span class="line">			bigger--;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	swap(A,p,bigger);</span><br><span class="line">	return bigger;</span><br><span class="line">&#125;</span><br><span class="line">void quickSort(int A[],int p,int r)&#123;</span><br><span class="line">	if(p&lt;r)&#123;</span><br><span class="line">		int q=partition(A,p,r);</span><br><span class="line">		quickSort(A,p,q-1);</span><br><span class="line">		quickSort(A,q+1,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int a[]=&#123;11,9,2,9,4,6&#125;;</span><br><span class="line">	quickSort(a,0,5);//因为从0开始存的，所以此时的右侧指针为下标5</span><br><span class="line">	for(int i=0;i&lt;6;i++)</span><br><span class="line">	cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>双向扫描法<br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-103.png" alt="upload successful"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//快速排序双向扫描分区法 </span><br><span class="line">//void swap(int A[],int p,int r)&#123;</span><br><span class="line">//	//交换数组A下标为p和r的值 </span><br><span class="line">//	int tmp=A[p];</span><br><span class="line">//	A[p]=A[r];</span><br><span class="line">//	A[r]=tmp;</span><br><span class="line">//	可以用stl中的swap函数来交换两个数或数组的值 </span><br><span class="line">//&#125;</span><br><span class="line">int partition2(int A[],int p,int r)&#123;</span><br><span class="line">	int pivot=A[p];//初始化pivot(主元)指向A[p],就是最靠左的位置 </span><br><span class="line">	int left=p+1;  //左侧指针 </span><br><span class="line">	int right=r; //右侧指针 </span><br><span class="line">	while(left&lt;=right)&#123;  </span><br><span class="line">	//left不停的往右走，直到遇到大于主元的元素 </span><br><span class="line">		while(left&lt;=right&amp;&amp;A[left]&lt;=pivot)left++;</span><br><span class="line">		//上面这个循环退出时，left一定是指向第一个大于主元的位置 </span><br><span class="line">		while(left&lt;=right&amp;&amp;A[right]&gt;pivot)right--;</span><br><span class="line">		//上面这个循环退出时，right一定是指向最后一个小于或等于主元的位置 </span><br><span class="line">		if(left&lt;right)</span><br><span class="line">			swap(A[left],A[right]);</span><br><span class="line">	&#125;</span><br><span class="line">	//while退出时，两者相错，且right指向的是最后一个小于等于主元的位置，也就是主元应该待的位置 </span><br><span class="line">	swap(A[p],A[right]);</span><br><span class="line">	return right;</span><br><span class="line">&#125;</span><br><span class="line">void quickSort(int A[],int p,int r)&#123;</span><br><span class="line">	if(p&lt;r)&#123;</span><br><span class="line">		int q=partition2(A,p,r);</span><br><span class="line">		quickSort(A,p,q-1);</span><br><span class="line">		quickSort(A,q+1,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int a[]=&#123;11,9,2,9,4,6&#125;;</span><br><span class="line">	quickSort(a,0,5);</span><br><span class="line">	for(int i=0;i&lt;6;i++)</span><br><span class="line">	cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>三指针分区法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">void quickSort(int a[], int low, int high)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (low &lt;= high)</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    int i = low;</span><br><span class="line"></span><br><span class="line">    int j = high;</span><br><span class="line"></span><br><span class="line">    int key = a[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while (i &lt; j)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        while (i &lt; j &amp;&amp; a[j] &gt;= key)</span><br><span class="line"></span><br><span class="line">            --j;</span><br><span class="line"></span><br><span class="line">        a[i] = a[j];</span><br><span class="line"></span><br><span class="line">        while (i &lt; j &amp;&amp; a[i] &lt;= key)</span><br><span class="line"></span><br><span class="line">            ++i;</span><br><span class="line"></span><br><span class="line">        a[j] = a[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    a[i] = key;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    quickSort(a, low, i - 1);</span><br><span class="line"></span><br><span class="line">    quickSort(a, i + 1, high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>3.6 快排在工程实践中的优化</li>
</ul>
<hr>
<h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-121.png" alt="upload successful"></p>
<ul>
<li>希尔排序的过程   <ul>
<li>希尔排序在排序前：将一个序列分成了好几个序列  </li>
<li>在第一趟排序时：将这几个序列做插入排序。  </li>
<li>在第二趟排序时：将这个序列又分了好几个序列做插入排序。  </li>
<li>…………….  </li>
<li>在第n趟排序时：将原序列进行插入排序，从宏观上看，此序列就基本是有序的了。这时就用简单插入排序将数列直至已序</li>
</ul>
</li>
</ul>
<p> <strong>从直观上看希尔排序：<br>    就是把数列进行分组(不停使用插入排序)，直至从宏观上看起来有序，最后插入排序起来就容易了(无须多次移位或交换)。就是increase后面的第一个分组中的元素和数列的第一个分组比较，然后后面第二个分组和数列的第二个分组比较．．．．</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//希尔排序的ｊａｖａ实现数组从小到大排列</span><br><span class="line">public static void shellSort(int[] nums)&#123;</span><br><span class="line">    for(int increase = nums.length/2;increase &gt; 0;increase/=2)&#123;//increase为希尔排序增量</span><br><span class="line">        //对每一个增量序列进行插入排序</span><br><span class="line">        for(int i = increase;i&lt;nums.length;i++)&#123;</span><br><span class="line">            int target = nums[i];</span><br><span class="line">            int j = i - increase;</span><br><span class="line">            while(j&gt;=0 &amp;&amp; target&lt;nums[j])&#123;</span><br><span class="line">                nums[j+increase] = nums[j];</span><br><span class="line">                j = j - increase;　　//进行下一组的排序</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j+increase] = target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c++的实现</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">template &lt;typename T&gt; void ShellSort(T *array, const int length)</span><br><span class="line">&#123;</span><br><span class="line">    int gap = length/2;</span><br><span class="line">    do&#123;//第一次因为length不为0，所以肯定能执行一次while语句 </span><br><span class="line">        T tmp;</span><br><span class="line">        for(int i=gap; i&lt;length; ++i)&#123;</span><br><span class="line">            tmp = array[i];</span><br><span class="line">            int j = i;</span><br><span class="line">            while(j&gt;=gap &amp;&amp; tmp&lt;array[j-gap])&#123;</span><br><span class="line">                array[j] = array[j-gap];</span><br><span class="line">                j-=gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        gap/=2;</span><br><span class="line">    &#125;while(gap);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int a[5]=&#123;12,1,6,3,2&#125;;</span><br><span class="line">	ShellSort(a,5);</span><br><span class="line">	for(int i=0;i&lt;5;i++)cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-132.png" alt="upload successful"></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-133.png" alt="upload successful"></p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
 
//归并过程
void merge(int arr[], int l, int mid, int r)&#123;
    int help[r-l+1];//辅助数组
    int i = 0;
    int lIndex = l;
    int rIndex = mid+1;
    while(lIndex &lt;= mid &amp;&amp; rIndex &lt;= r)&#123;
        help[i++] = arr[lIndex] &lt; arr[rIndex] ? arr[lIndex++]:arr[rIndex++];    
    &#125;
    //左边和右边肯定有一边到头了，不可能同时，因为每次只移动一边
    while(lIndex &lt;= mid)&#123;
        help[i++] = arr[lIndex++];
    &#125; 
    while(rIndex &lt;= r)&#123;
        help[i++] = arr[rIndex++];
    &#125;
    //将排好序的辅助数组赋值给原始数组，不需要返回值
    for(i = 0; i &lt; r-l+1; i++)&#123;
        arr[l+i] = help[i];
    &#125;
&#125;
 
//递归
static void mergeSort(int arr[], int l, int r)&#123;
    if(l == r)&#123;
        return;
    &#125;
    int mid = (l + r) / 2;
    //左半部分归并排序
    mergeSort(arr, l, mid);
    //右半部分归并排序
    mergeSort(arr, mid+1, r);
    //左右部分归并
    merge(arr, l, mid, r);
&#125;
 
//归并排序整个数组
void mergeSort(int arr[], int n)&#123;
    //如果数组为空或只有一个元素，不需要排序
    if(arr == NULL || n &lt; 2)&#123;
        return;
    &#125;
    mergeSort(arr,0,n-1);
&#125;
 
 
int main()&#123;
    int n; 
    while(cin &gt;&gt; n)&#123;
        int arr[n];
        for(int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i];
 
        mergeSort(arr, n);
 
        for(int i = 0; i &lt; n; i++)&#123;
            cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
        &#125; 
        cout &lt;&lt; endl;
    &#125;
    return 0;
&#125; 
</code></pre>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">堆排序</span><br><span class="line">最差时间复杂度：O(nlogn)</span><br><span class="line">最优时间复杂度：O(nlogn)</span><br><span class="line">平均时间复杂度：O(nlogn)</span><br><span class="line">稳定性：不稳定</span><br><span class="line">堆排序，利用堆这种数据结构设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足性质：即子节点的键值或索引总是小于（或者大于）它的父节点。</span><br><span class="line">通常堆是通过一维数组来实现的，在起始数组为0的情形中，对于节点i：</span><br><span class="line">其左子节点的下标为 (2*i+1)；</span><br><span class="line">其右子节点的下标为 (2*i+2)；</span><br><span class="line">其父节点的下标为 floor((i-1)/2)。</span><br><span class="line">在堆的数据结构中，堆中的最大值总是位于根节点。堆中定义一下三个操作：</span><br><span class="line">1.最大堆调整（Max Heapify）：在假定节点i的左右子节点为根的两棵二叉树都是最大堆的前提下，确保父节点大于子节点，否则下降原父节点，最终使以i为根的子树成为最大堆。</span><br><span class="line">2.创建最大堆（Build Max Heap）：将堆所有数据重新排序，对所有非叶子节点调用一次Max Heapify。</span><br><span class="line">3.堆排序（Heap Sort）：首先创建最大堆，然后依次将堆的根节点与末节点交换、剔除末节点、对根节点进行最大堆调整，直到堆中的节点数为1，排序结束。</span><br><span class="line">*/</span><br><span class="line">template &lt;typename T&gt; void MaxHeapify(T *array, int i, int heapSize)</span><br><span class="line">&#123;</span><br><span class="line">    int l = 2*i+1;</span><br><span class="line">    int r = 2*i+2;</span><br><span class="line">    int tmp = i;</span><br><span class="line">    if(l&lt;=heapSize &amp;&amp; array[l]&gt;array[i])&#123;</span><br><span class="line">        tmp = l;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        tmp = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(r&lt;=heapSize &amp;&amp; array[r]&gt;array[tmp])&#123;</span><br><span class="line">        tmp = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(tmp != i)&#123;</span><br><span class="line">        swap(array[i], array[tmp]);</span><br><span class="line">        MaxHeapify(array, tmp, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">template &lt;typename T&gt; void HeapSort(T *array, const int length)</span><br><span class="line">&#123;</span><br><span class="line">    if(array == NULL)&#123; </span><br><span class="line">        throw invalid_argument(&quot;Array must not be empty&quot;);</span><br><span class="line">    &#125;   </span><br><span class="line">    if(length&lt;=0) </span><br><span class="line">        return;</span><br><span class="line">    for(auto i = length/2; i&gt;=0; --i)&#123; //构建最大堆</span><br><span class="line">        MaxHeapify(array, i, length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(auto i = length-1; i&gt;=0; --i)&#123;</span><br><span class="line">        swap(array[0], array[i]);</span><br><span class="line">        MaxHeapify(array, 0, i-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>sort函数的时间复杂度为 O(N log(N))</p>
<p>这篇将排序将的很好<br><a target="_blank" rel="noopener" href="https://www.imooc.com/article/9429">https://www.imooc.com/article/9429</a></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-201.png" alt="upload successful"></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">排序算法</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/myblog/categories/ACM//" class="article-tag-list-link color4">ACM</a>
        		</li>
      		
		</ul>
	</div>


      
        <p class="article-more-link">
          <a class="article-more-a" href="/myblog/2019/10/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/myblog/page/21/">&amp;laquo; Prev</a><a class="page-number" href="/myblog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/myblog/page/20/">20</a><a class="page-number" href="/myblog/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/myblog/page/23/">23</a><a class="page-number" href="/myblog/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/myblog/page/27/">27</a><a class="extend next" rel="next" href="/myblog/page/23/">Next &amp;raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2022 zouqingzhi
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/myblog/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/myblog/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/myblog/slider.e37972.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 100%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">C++字符串处理</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">c#</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">c</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">c++</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">c语言小知识</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">DP</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">DFS</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">BFS</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">图</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">FFT</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">html</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">KMP</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">CF</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">comparable and comparator</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">qluoj</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">stl</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">web</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">sql</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">英文单词</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">iis配置</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">java se</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">素数</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">param</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">java</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">java 深浅拷贝</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">小游戏</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">五子棋</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">贪吃蛇</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">java算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">java网络编程</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">聊天室</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">DOM</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">js</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">linux教程</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">数据库</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">mysql</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">crypto</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">隐写</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">训练</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">新生训练</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">2019校赛</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">二分法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">动态规划</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">背包问题</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">单调栈</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">单调队列</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">博弈论</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">哲学</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">国王挖金子</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">最小生成树</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">大数运算</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">山理工</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">快速幂</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">排序算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">新生训练_02</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">数据结构</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">牛客</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">codeforce</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">最短路径</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">哈夫曼编码</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">杭电</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">棋盘覆盖</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">栈</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">队列</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">递归</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">  </a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">boos</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">递归与分治</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">模板</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">蓝桥杯算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">蓝桥省赛</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">蓝桥杯</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">计网笔记</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">图论</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">联盟周赛</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">贪心</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">面试</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    

    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>