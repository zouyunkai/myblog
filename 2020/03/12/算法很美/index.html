<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>算法很美 | Sweet@</title>
  <meta name="description" content="1 位运算的奇巧淫技 2 查找与排序（上）  3 查找与排序（下） 4 多维数组和矩阵  5 字符串专题  6 数学问题  7 递归，DFS，剪枝，回溯等问题  8 贪心策略与动态规划      **位运算的奇巧淫技 **   1.2如何找数组中唯一成对的那个数  详见C++语言零碎知识点汇总这篇文章中的&amp;和|的那一节  例如： 1&lt;&lt;n&#x3D;2^n  ； n&lt;&amp;l">
<meta property="og:type" content="article">
<meta property="og:title" content="算法很美">
<meta property="og:url" content="https://zouyunkai.github.io/myblog/2020/03/12/%E7%AE%97%E6%B3%95%E5%BE%88%E7%BE%8E/index.html">
<meta property="og:site_name" content="Sweet@">
<meta property="og:description" content="1 位运算的奇巧淫技 2 查找与排序（上）  3 查找与排序（下） 4 多维数组和矩阵  5 字符串专题  6 数学问题  7 递归，DFS，剪枝，回溯等问题  8 贪心策略与动态规划      **位运算的奇巧淫技 **   1.2如何找数组中唯一成对的那个数  详见C++语言零碎知识点汇总这篇文章中的&amp;和|的那一节  例如： 1&lt;&lt;n&#x3D;2^n  ； n&lt;&amp;l">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-166.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-167.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-168.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-169.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-170.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-117.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-122.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-123.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-124.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-125.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-127.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-128.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-129.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-131.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-130.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-138.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-135.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-136.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-137.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-140.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-143.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-142.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-147.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-144.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-148.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-149.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-152.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-157.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-155.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-176.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-171.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-177.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-172.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-173.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-174.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-178.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-179.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-181.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-180.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-182.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-233.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-234.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-227.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-232.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-235.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-236.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-240.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-237.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5C202002022111.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5C202002021950.png">
<meta property="article:published_time" content="2020-03-12T13:37:35.000Z">
<meta property="article:modified_time" content="2022-02-26T03:52:52.601Z">
<meta property="article:author" content="zouqingzhi">
<meta property="article:tag" content="蓝桥杯算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-166.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://zouyunkai.github.io/myblog/2020/03/12/%E7%AE%97%E6%B3%95%E5%BE%88%E7%BE%8E/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Sweet@" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/myblog/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.0.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/zouyunkai" target="_blank">
          <img class="img-circle img-rotate" src="/myblog/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">云开</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Stay Hungry , Stay Foolish.</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/myblog/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/myblog/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/myblog/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/myblog/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/myblog/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/myblog/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/zouyunkai" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/zouyunkai" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/zouyunkai" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/zouyunkai" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/myblog/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E9%9D%A2%E8%AF%95/">面试</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/02/24/%E7%AE%80%E5%8E%86/" class="title">个人简历</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-24T13:46:00.000Z" itemprop="datePublished">2022-02-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E6%9D%82%E8%AE%B0/">杂记</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/01/25/%E5%85%B3%E4%BA%8E%E5%A4%87%E8%80%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/" class="title">关于备考的方法</a>
              </p>
              <p class="item-date">
                <time datetime="2022-01-25T13:29:00.000Z" itemprop="datePublished">2022-01-25</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/">所长的跨学科工具箱</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/01/19/01%E6%A8%A1%E6%9D%BF/" class="title">脑科学重要模型</a>
              </p>
              <p class="item-date">
                <time datetime="2022-01-19T13:29:00.000Z" itemprop="datePublished">2022-01-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/">所长的跨学科工具箱</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/01/19/01%E7%86%B5%E4%B8%8E%E7%83%AD%E5%8A%9B%E5%AD%A6%E9%87%8D%E8%A6%81%E6%A8%A1%E5%9E%8B/" class="title">熵增定理-世界演化之道</a>
              </p>
              <p class="item-date">
                <time datetime="2022-01-19T13:29:00.000Z" itemprop="datePublished">2022-01-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/">所长的跨学科工具箱</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/01/19/02%E7%B3%BB%E7%BB%9F%E8%AE%BA%E9%87%8D%E8%A6%81%E6%A8%A1%E5%9E%8B/" class="title">系统思维 - 深刻认识世界</a>
              </p>
              <p class="item-date">
                <time datetime="2022-01-19T13:29:00.000Z" itemprop="datePublished">2022-01-19</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/myblog/tags/" style="font-size: 13px;">  </a> <a href="/myblog/tags/2019%E6%A0%A1%E8%B5%9B/" style="font-size: 13px;">2019校赛</a> <a href="/myblog/tags/BFS/" style="font-size: 13.2px;">BFS</a> <a href="/myblog/tags/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/" style="font-size: 13px;">C++字符串处理</a> <a href="/myblog/tags/CF/" style="font-size: 13px;">CF</a> <a href="/myblog/tags/DFS/" style="font-size: 13.2px;">DFS</a> <a href="/myblog/tags/DOM/" style="font-size: 13px;">DOM</a> <a href="/myblog/tags/DP/" style="font-size: 13px;">DP</a> <a href="/myblog/tags/FFT/" style="font-size: 13px;">FFT</a> <a href="/myblog/tags/KMP/" style="font-size: 13px;">KMP</a> <a href="/myblog/tags/boos/" style="font-size: 13px;">boos</a> <a href="/myblog/tags/c/" style="font-size: 13px;">c</a> <a href="/myblog/tags/c/" style="font-size: 13px;">c#</a> <a href="/myblog/tags/c/" style="font-size: 13.4px;">c++</a> <a href="/myblog/tags/codeforce/" style="font-size: 13.2px;">codeforce</a> <a href="/myblog/tags/comparable-and-comparator/" style="font-size: 13px;">comparable and comparator</a> <a href="/myblog/tags/crypto/" style="font-size: 13px;">crypto</a> <a href="/myblog/tags/c%E8%AF%AD%E8%A8%80%E5%B0%8F%E7%9F%A5%E8%AF%86/" style="font-size: 13px;">c语言小知识</a> <a href="/myblog/tags/git/" style="font-size: 13px;">git</a> <a href="/myblog/tags/html/" style="font-size: 13px;">html</a> <a href="/myblog/tags/iis%E9%85%8D%E7%BD%AE/" style="font-size: 13px;">iis配置</a> <a href="/myblog/tags/java/" style="font-size: 13.2px;">java</a> <a href="/myblog/tags/java-se/" style="font-size: 13.2px;">java se</a> <a href="/myblog/tags/java-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" style="font-size: 13px;">java 深浅拷贝</a> <a href="/myblog/tags/java%E7%AE%97%E6%B3%95/" style="font-size: 13px;">java算法</a> <a href="/myblog/tags/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 13px;">java网络编程</a> <a href="/myblog/tags/js/" style="font-size: 13px;">js</a> <a href="/myblog/tags/linux%E6%95%99%E7%A8%8B/" style="font-size: 13px;">linux教程</a> <a href="/myblog/tags/mysql/" style="font-size: 13px;">mysql</a> <a href="/myblog/tags/param/" style="font-size: 13px;">param</a> <a href="/myblog/tags/qluoj/" style="font-size: 13px;">qluoj</a> <a href="/myblog/tags/sql/" style="font-size: 13px;">sql</a> <a href="/myblog/tags/stl/" style="font-size: 13px;">stl</a> <a href="/myblog/tags/web/" style="font-size: 13.2px;">web</a> <a href="/myblog/tags/%E4%BA%8C%E5%88%86%E6%B3%95/" style="font-size: 13px;">二分法</a> <a href="/myblog/tags/%E4%BA%94%E5%AD%90%E6%A3%8B/" style="font-size: 13px;">五子棋</a> <a href="/myblog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 13.2px;">动态规划</a> <a href="/myblog/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 13px;">单调栈</a> <a href="/myblog/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" style="font-size: 13px;">单调队列</a> <a href="/myblog/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" style="font-size: 13px;">博弈论</a> <a href="/myblog/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/" style="font-size: 13px;">哈夫曼编码</a> <a href="/myblog/tags/%E5%93%B2%E5%AD%A6/" style="font-size: 13px;">哲学</a> <a href="/myblog/tags/%E5%9B%BD%E7%8E%8B%E6%8C%96%E9%87%91%E5%AD%90/" style="font-size: 13px;">国王挖金子</a> <a href="/myblog/tags/%E5%9B%BE/" style="font-size: 13.2px;">图</a> <a href="/myblog/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 13px;">图论</a> <a href="/myblog/tags/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/" style="font-size: 13px;">大数运算</a> <a href="/myblog/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/" style="font-size: 13.2px;">小游戏</a> <a href="/myblog/tags/%E5%B1%B1%E7%90%86%E5%B7%A5/" style="font-size: 13px;">山理工</a> <a href="/myblog/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/" style="font-size: 13px;">快速幂</a> <a href="/myblog/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 13px;">排序算法</a> <a href="/myblog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 13.4px;">数据库</a> <a href="/myblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13px;">数据结构</a> <a href="/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/" style="font-size: 14px;">新生训练</a> <a href="/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83-02/" style="font-size: 13px;">新生训练_02</a> <a href="/myblog/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 13.2px;">最小生成树</a> <a href="/myblog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" style="font-size: 13.2px;">最短路径</a> <a href="/myblog/tags/%E6%9D%AD%E7%94%B5/" style="font-size: 13px;">杭电</a> <a href="/myblog/tags/%E6%A0%88/" style="font-size: 13px;">栈</a> <a href="/myblog/tags/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96/" style="font-size: 13px;">棋盘覆盖</a> <a href="/myblog/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 13px;">模板</a> <a href="/myblog/tags/%E7%89%9B%E5%AE%A2/" style="font-size: 13.8px;">牛客</a> <a href="/myblog/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.2px;">算法</a> <a href="/myblog/tags/%E7%B4%A0%E6%95%B0/" style="font-size: 13px;">素数</a> <a href="/myblog/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/" style="font-size: 13px;">聊天室</a> <a href="/myblog/tags/%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9B/" style="font-size: 13px;">联盟周赛</a> <a href="/myblog/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" style="font-size: 13px;">背包问题</a> <a href="/myblog/tags/%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D/" style="font-size: 13px;">英文单词</a> <a href="/myblog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" style="font-size: 13px;">蓝桥杯</a> <a href="/myblog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%97%E6%B3%95/" style="font-size: 13px;">蓝桥杯算法</a> <a href="/myblog/tags/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B/" style="font-size: 13.6px;">蓝桥省赛</a> <a href="/myblog/tags/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/" style="font-size: 13px;">计网笔记</a> <a href="/myblog/tags/%E8%AE%AD%E7%BB%83/" style="font-size: 13.6px;">训练</a> <a href="/myblog/tags/%E8%B4%AA%E5%90%83%E8%9B%87/" style="font-size: 13px;">贪吃蛇</a> <a href="/myblog/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 13px;">贪心</a> <a href="/myblog/tags/%E9%80%92%E5%BD%92/" style="font-size: 13.4px;">递归</a> <a href="/myblog/tags/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/" style="font-size: 13px;">递归与分治</a> <a href="/myblog/tags/%E9%98%9F%E5%88%97/" style="font-size: 13px;">队列</a> <a href="/myblog/tags/%E9%9A%90%E5%86%99/" style="font-size: 13px;">隐写</a> <a href="/myblog/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13px;">面试</a>
    </div>
  </div>

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-算法很美" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      算法很美
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/myblog/2020/03/12/%E7%AE%97%E6%B3%95%E5%BE%88%E7%BE%8E/" class="article-date">
	  <time datetime="2020-03-12T13:37:35.000Z" itemprop="datePublished">2020-03-12</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/myblog/categories/ACM/">ACM</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/myblog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%97%E6%B3%95/" rel="tag">蓝桥杯算法</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/myblog/2020/03/12/%E7%AE%97%E6%B3%95%E5%BE%88%E7%BE%8E/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p><a href="#1">1 位运算的奇巧淫技 </a><br><a href="#2">2 查找与排序（上）  </a><br><a href="#3">3 查找与排序（下） </a><br><a href="#4">4 多维数组和矩阵  </a><br><a href="#5">5 字符串专题  </a><br><a href="#6">6 数学问题  </a><br><a href="#7">7 递归，DFS，剪枝，回溯等问题  </a><br><a href="#8">8 贪心策略与动态规划   </a>  </p>
<p><strong><p id="1"><p></strong><br>**位运算的奇巧淫技 ** </p>
<ul>
<li>1.2如何找数组中唯一成对的那个数<br>  详见C++语言零碎知识点汇总这篇文章中的&amp;和|的那一节</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-166.png" alt="upload successful"><br>例如： 1&lt;&lt;n&#x3D;2^n  ； n&lt;&lt;1&#x3D;2*n   ；左移一位就相当于乘2；<br>右移一位相当于除2  。   </p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-167.png" alt="upload successful"></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-168.png" alt="upload successful">  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=11;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//method1：利用^运算 </span><br><span class="line">	int a[N];</span><br><span class="line">	for(int i=1;i&lt;N;i++)a[i]=N-i;</span><br><span class="line">	a[0]=rand()%10;  //定义重复的那个数 </span><br><span class="line">	int x=0;</span><br><span class="line">	for(int i=1;i&lt;=N-1;i++)x=(x^i);</span><br><span class="line">	//^优先级高于=，所以不知道优先级的时候就加（） </span><br><span class="line">	for(int i=0;i&lt;N;i++)x=x^a[i];</span><br><span class="line">	cout&lt;&lt;&quot;a数组为：&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">		cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;结果为：&quot;&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	//method2：利用辅助空 </span><br><span class="line">	cout&lt;&lt;&quot;method2：利用辅助空&quot;&lt;&lt;endl;</span><br><span class="line">	int helper[N];</span><br><span class="line">	memset(helper,0,sizeof(helper));</span><br><span class="line">	//注意最后一个参数不是N，而是N*4(因为一个int类型的数占4个字节) </span><br><span class="line">	//其中helper数组放在main函数里面一定要初始化为0</span><br><span class="line">    </span><br><span class="line">	for(int i=0;i&lt;N;i++)helper[a[i]]++;</span><br><span class="line">    // helper[a[i]]++;记住还有这种用法</span><br><span class="line">	cout&lt;&lt;&quot;helper数组为：&quot;&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">		cout&lt;&lt;helper[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">		 if(helper[i]==2)&#123;</span><br><span class="line">			cout&lt;&lt;&quot;结果为：&quot;&lt;&lt;i;</span><br><span class="line">			break; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125; </span><br><span class="line">/*</span><br><span class="line">例如：随机生成10个0~100各不相同的数：</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">#define random(x) (rand()%x)</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">     srand((int)time(0));</span><br><span class="line">     for(int x=0;x&lt;10;x++)</span><br><span class="line">           printf(&quot;%d/n&quot;,random(100));</span><br><span class="line">&#125;</span><br><span class="line">*/	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>1.4 计算一个二进制数中1的个数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//method：移动1中1的位置，与要比较的数进行比较 </span><br><span class="line">	int n=5;</span><br><span class="line">	int count=0;</span><br><span class="line">	for(int i=0;i&lt;32;i++)&#123;</span><br><span class="line">		if((n&amp;(1&lt;&lt;i))==(1&lt;&lt;i))count++;</span><br><span class="line">        //if(n&amp;(1&lt;&lt;i)==(1&lt;&lt;i)) 要是这样写就错了，==优先级比^要高</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">	</span><br><span class="line">	//method 2:移动要比较的数，向右移与1比较 </span><br><span class="line">	int count1=0;</span><br><span class="line">	unsigned int n1=5;</span><br><span class="line">	for(unsigned int i=0;i&lt;32;i++)&#123;</span><br><span class="line">		//if(((n1&gt;&gt;&gt;i)&amp;1)==1)count1++;  为什么写&gt;&gt;&gt;不行 ，因为&gt;&gt;&gt;是带符号的，有可能不等于1</span><br><span class="line">		if(((n1&gt;&gt;i)&amp;1)==1)count1++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;count1&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">	//method3: 一个数减1之后与原来的自己进行与运算，</span><br><span class="line">	//就会把减掉的那个1的位之后的数全变为0 </span><br><span class="line">	int count2=0;</span><br><span class="line">	int n2=5;</span><br><span class="line">	while(n2!=0)&#123;</span><br><span class="line">		n2=((n2-1)&amp;n2);</span><br><span class="line">		count2++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;count2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>1.5 判断整数是不是2的整数次方</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-169.png" alt="upload successful"></p>
<ul>
<li>1.6 将整数的奇偶位互换</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int m(int i)&#123;</span><br><span class="line">	int ou=i&amp;0xaaaaaaaa;  //和1010 1010 1010...做与运算出偶数位 </span><br><span class="line">	int ji=i&amp;0x55555555;  //和0101 0101 0101...做与运算出奇数</span><br><span class="line">	return (ou&gt;&gt;1)^(ji&lt;&lt;1); //连起来 </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int a=9;</span><br><span class="line">	int a1=0b01000000_00000000_00000000_00000000; </span><br><span class="line">	int b=m(9);  //结果应该为6 </span><br><span class="line">	int b1=0b10000000_00000000_00000000_00000000;</span><br><span class="line">	//其中a1奇偶互换之后应该为b1 </span><br><span class="line">	cout&lt;&lt;b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>1.7 浮点数的二进制表示</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-170.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	double num=0.625;</span><br><span class="line">	string sb=&quot;0.&quot;;</span><br><span class="line">	while(num&gt;0)&#123;</span><br><span class="line">	double r=num*2;</span><br><span class="line">	//判断整数部分</span><br><span class="line">		if(r&gt;=1)&#123;</span><br><span class="line">			sb.append(&quot;1&quot;);</span><br><span class="line">			num=r-1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			sb.append(&quot;0&quot;);</span><br><span class="line">			num=r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	if(sb.length()&gt;34)&#123;</span><br><span class="line">	 	cout&lt;&lt;&quot;error&quot;;</span><br><span class="line">	 	return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;sb&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>1.8 出现k次与出现1次</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	//方法一：在multiset中找到出现一次的数 </span><br><span class="line">	multiset&lt;int&gt; s;</span><br><span class="line">	int a[16]=&#123;2,2,2,9,7,7,7,3,3,3,6,6,6,0,0,0&#125;;</span><br><span class="line">	s.insert(a,a+16);</span><br><span class="line">	if(s.find(2)!=s.end())cout&lt;&lt;&quot; 2 is existent&quot;&lt;&lt;endl&lt;&lt;s.count(2)&lt;&lt;endl; </span><br><span class="line">	for(multiset&lt;int&gt;::iterator it=s.begin(); it != s.end(); it++)&#123;</span><br><span class="line">		if(s.count(*it)==1)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	//方法二： 将所有数转为k进制，然后相应的位做不进位加法，</span><br><span class="line">	//最后得到的数就是出现一次的那个数 （因为k个k进制的数做不进位加法，结果为0） </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong><p id="2"><p></strong><br><strong>查找与排序（上）</strong></p>
<ul>
<li>详见这篇文章 递归 recursive functions<ul>
<li>2.1 什么是递归</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">找重复：</span><br><span class="line">	1，找到一种划分方法</span><br><span class="line">    2，找到递推公式或者等价代换</span><br><span class="line">找变化的量：</span><br><span class="line">	变化的量通常作为参数（如果递归起来比较费劲，或者难想，那么有可能是该参数找的不对）</span><br><span class="line">找出口：</span><br><span class="line">	依照边界，找到问题的出口</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">f1(n):求n的阶乘</span><br><span class="line">*找重复：n*(n-1)的阶乘，求n-1的阶乘是原问题的重复(规模更小)，即子问题</span><br><span class="line">*找变化：变化的量应该作为参数</span><br><span class="line">*找边界：根据参数的变化趋势，对边界进行控制，适时终止递归 </span><br><span class="line">*/</span><br><span class="line">int f1(int n)&#123;</span><br><span class="line">	if(n==1)return 1;</span><br><span class="line">	return n*f1(n-1);</span><br><span class="line">&#125;</span><br><span class="line">//打印i到j之间的值 </span><br><span class="line">void f2(int i,int j)&#123;</span><br><span class="line">	if(i&gt;j)</span><br><span class="line">		return ;</span><br><span class="line">	cout&lt;&lt;i;</span><br><span class="line">	f2(i+1,j);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li><p>2.3 斐波那锲是把问题划分为多个子问题（此时是看那个有没有递推公式，或者等价转换等），这多个子问题之间还是有包含关系的，这与前面的切蛋糕思维不一样（自己解决一小部分，然后剩下的看成一个小问题）。</p>
</li>
<li><p>2.4 递推求最大公约数</p>
</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-117.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int gcd(int m,int n)&#123;</span><br><span class="line">	if(n==0) return m;</span><br><span class="line">		return gcd(n,m%n);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int m=5;int n=10;</span><br><span class="line">	cout&lt;&lt;gcd(m,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2.7 二分查找的递归解法<br>首先切蛋糕思维是单分支，而斐波那锲和汉诺塔是双分支，而二分查找是类似于双分支的单分支（剪枝），其每次只会选择一条路径走下去。  <ul>
<li>全范围内二分查找<br>  等价于三个问题：左边找（递归）,中间比,右边找（递归）<br>  注意：左查找和右查找只选其一</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//二分查找的非递归形式</span><br><span class="line">int binSearch(int nums[],int k)&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">//j是数组最后一个下标的位置，如int a[5]，j最大为4（因为没有a[5]这个值</span><br><span class="line">	int j = sizeof(nums) / sizeof(nums[0])-1;</span><br><span class="line">	int mid;</span><br><span class="line">	while(i&lt;=j)&#123;</span><br><span class="line">		mid = i+((j-i)&gt;&gt;1);//防止溢出,而且使用位运算更加高效//mid = ((i+j)&gt;&gt;&gt;1);</span><br><span class="line">		if(nums[mid]==k)&#123;</span><br><span class="line">			return mid;</span><br><span class="line">		&#125;else if(nums[mid]&gt;k)&#123;</span><br><span class="line">			j = mid-1;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			i = mid+1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br><span class="line">//二分查找的递归形式，其中k，i，j参数是必要的，不然的话怎么调用传值</span><br><span class="line">int binSearch_1(int nums[],int k,int i,int j)&#123;</span><br><span class="line">//其中nums是有序数组，k为要查找的值，i为要查找的数组的起始下标，j为终点下标</span><br><span class="line">	if(i&gt;j) return -1;</span><br><span class="line">	int mid =i+((j-i)&gt;&gt;1);</span><br><span class="line">	if(nums[mid]==k)&#123;</span><br><span class="line">		return mid;</span><br><span class="line">	&#125;else if(nums[mid]&gt;k) &#123;</span><br><span class="line">		return binSearch_1(nums,k,i,mid-1);</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		return binSearch_1(nums,k,mid+1,j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int a[]=&#123;1,2,3,4,5&#125;;</span><br><span class="line">	cout&lt;&lt;binSearch_1(a,5,0,4); //结果为4，即数组下表的最后一个，a[4]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2.10常见函数的复杂度计算<br>首先现在的计算机的计算速度是1s计算10^8</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-122.png" alt="upload successful"></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-123.png" alt="upload successful"></p>
<ul>
<li>2.13 三种典型递归形式的算法的性能分析</li>
</ul>
<p>递归求阶乘的算法分析<br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-124.png" alt="upload successful"></p>
<p>斐波那锲算法复杂度为o（2^n）（八皇后问题那种就是8^n）<br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-125.png" alt="upload successful"></p>
<p>求最大公约数的复杂度为o（2lgn）<br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-127.png" alt="upload successful"></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-128.png" alt="upload successful"></p>
<ul>
<li>2.16 小白上楼梯</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-129.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int f(int n)&#123;</span><br><span class="line">	if(n==0)return 1;</span><br><span class="line">//这地方要return 1，因为最后一次调用f(n-1)的时候要返回1</span><br><span class="line">	if(n==1)return 1;</span><br><span class="line">	if(n==2)return 2;</span><br><span class="line">	return f(n-1)+f(n-2)+f(n-3);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cout&lt;&lt;f(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2.17 旋转数组的最小数字</li>
</ul>
<p>从中间插入刀，那么就会一边有序，一边无序；而且如果begin的值小于end的值，说明数组本身没有旋转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class 旋转数组的最小数字 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    int []arr = &#123;5,1,2,3,4&#125;;</span><br><span class="line">    System.out.println(&quot;最小数字为&quot;+min(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  活用二分查找</span><br><span class="line"> * @param arr</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">static int min(int arr[])&#123;</span><br><span class="line">    int begin = 0;</span><br><span class="line">    int end = arr.length - 1;</span><br><span class="line">    // 考虑没有旋转这种特殊的旋转</span><br><span class="line">    if (arr[begin] &lt; arr[end]) return arr[begin];</span><br><span class="line"></span><br><span class="line">    while(begin+1&lt;end)&#123;</span><br><span class="line">        int mid = begin + ((end-begin)&gt;&gt;1);</span><br><span class="line">        // 要么左侧有序，要么右侧有序</span><br><span class="line">        //  下面这行代码有个bug 假如数组为 1 1 1 0 1 这种数组应该在程序的入口检测一下</span><br><span class="line">        // 假如左侧和中间相等了  那么就应该用顺序查找最小值了。</span><br><span class="line">        if (arr[mid] &gt;= arr[begin]) &#123;   // 左侧有序</span><br><span class="line">            begin = mid;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr[end];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><p id="3">查找与排序（下）<p></strong></p>
<ul>
<li>3.1 分治法的介绍</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-131.png" alt="upload successful"><br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-130.png" alt="upload successful"></p>
<ul>
<li>3.8 _调整数组顺序-奇数在左偶数在右</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">法一：模式匹配：归并排序：</span><br><span class="line">奇数放左边，偶数放右边。需另外开辟空间。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void mergeSortOddEven(int arr[],int low, int high)&#123;</span><br><span class="line">	int length=high-low+1;</span><br><span class="line">	int ref[length];</span><br><span class="line"></span><br><span class="line">	int left=low;</span><br><span class="line">	int right=high;</span><br><span class="line">	int current=low;</span><br><span class="line"></span><br><span class="line">//Copy到ref数组 </span><br><span class="line">for(int i=0;i&lt;length;i++)&#123;</span><br><span class="line">    ref[i]=arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(current&lt;length)&#123;</span><br><span class="line">    if(ref[current]%2==0)&#123;</span><br><span class="line">        arr[right--]=ref[current++];</span><br><span class="line">    &#125;</span><br><span class="line">    if((ref[current]%2)!=0)&#123;</span><br><span class="line">        arr[left++]=ref[current++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int arr[]=&#123;2,4,6,1,7,2,8,3,7,3,6&#125;;</span><br><span class="line"></span><br><span class="line">mergeSortOddEven(arr,0,10);</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;11;i++)&#123;</span><br><span class="line">    cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">法二：模式匹配：快速排序：</span><br><span class="line">左右两指针，不满足则交换元素。</span><br><span class="line"></span><br><span class="line">#include</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void quickSortOddEven(int arr[],int low, int high)&#123;</span><br><span class="line">	int length=high-low+1;</span><br><span class="line"></span><br><span class="line">	int left=low;</span><br><span class="line">	int right=high;</span><br><span class="line"></span><br><span class="line">	while(left&lt;right)&#123;</span><br><span class="line">    while(arr[left]%2==1)&#123;</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    while(arr[right]%2==0)&#123;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    if(left&lt;right)&#123;</span><br><span class="line">        swap(arr[left],arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int arr[]=&#123;2,4,6,1,7,2,8,3,7,3,6&#125;;</span><br><span class="line"></span><br><span class="line">quickSortOddEven(arr,0,10);</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;11;i++)&#123;</span><br><span class="line">    cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.9 最快效率求出乱序数组中第k小的数</li>
</ul>
<p>第k个元素：以尽量高的效率，求出一个乱序数组中按数值顺序的第k个元素值。<br>时间复杂度： 平均：O（n）；最差：O（n²）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//三点中值法</span><br><span class="line">int partition(int A[],int p,int r)&#123;</span><br><span class="line"></span><br><span class="line">//优化： 在p、r、mid之间，选一个中间值作为主元</span><br><span class="line">int midIndex=p+((r-p)&gt;&gt;1); //中间下标</span><br><span class="line">int midValueIndex=-1; //中值的下标</span><br><span class="line">if(A[p]&lt;=A[midIndex]&amp;&amp;A[p]&gt;=A[r])&#123;</span><br><span class="line">    midValueIndex=p;</span><br><span class="line">&#125; </span><br><span class="line">else if(A[r]&lt;=A[midIndex]&amp;&amp;A[r]&gt;=A[p])&#123;</span><br><span class="line">    midValueIndex=r;</span><br><span class="line">&#125; </span><br><span class="line"> else&#123;</span><br><span class="line">     midValueIndex=midIndex;</span><br><span class="line"> &#125;</span><br><span class="line">swap(A[p],A[midValueIndex]);</span><br><span class="line">int pivot=A[p];</span><br><span class="line"></span><br><span class="line">int left=p+1;//扫描指针 </span><br><span class="line">int right=r; //右侧指针 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while(left&lt;=right)&#123;</span><br><span class="line">    //left不停往右走，直到遇到大于主元的元素</span><br><span class="line">    while(A[left]&lt;=pivot) left++;   //循环退出时，left一定是指向第一个大于主元的位置 </span><br><span class="line">    while(A[right]&gt;pivot) right--;   //循环退出时，right一定是指向最后一个小于等于主元的位置 </span><br><span class="line">    if(left&lt;right)&#123;</span><br><span class="line">        swap(A[right],A[left]);    </span><br><span class="line">    &#125;            </span><br><span class="line">&#125; </span><br><span class="line">//while退出时，两者交错，且right指向的是最后一个小于等于主元的位置，也就是主元应该待的位置 </span><br><span class="line">swap(A[p],A[right]);</span><br><span class="line"></span><br><span class="line">return right;        //返回主元在交换完成后的下标</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int selectK(int A[],int p,int r,int k)&#123;</span><br><span class="line">	int q=partition(A,p,r); //主元下标</span><br><span class="line">	int qK=q-p+1; //主元是第几个元素(排好序后)</span><br><span class="line">	if(qK==k)&#123;</span><br><span class="line">		return A[q];</span><br><span class="line">	&#125;</span><br><span class="line">	else if(qK&gt;k)&#123;</span><br><span class="line">		return selectK(A,p,q-1,k);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">	return selectK(A,q+1,r,k-qK);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int arr[]=&#123;2,4,6,1,7,2,8,3,7,3,6&#125;;</span><br><span class="line">	cout&lt;&lt;selectK(arr,0,10,5);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>发帖水王（一个数组中某个元素出现的个数大于等于数组个数的一半）</li>
</ul>
<p>两种解法：<br>法一（消除法，两个不同的数就互相消除,这种方法是第一个和第二个比，第三个和第四个比，…）：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">public class MoreThanHalf &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    f(new int[]&#123;5,6,6,6,2,3,6&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不同的数，进行消除，O(N)</span><br><span class="line">public static void f(int arr[])&#123;</span><br><span class="line">    //候选数  先定位第一个元素</span><br><span class="line">    int candidate = arr[0];</span><br><span class="line">    // 出现的次数</span><br><span class="line">    int nTimes = 1;</span><br><span class="line">    // 扫描数组</span><br><span class="line">    for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        // 两两消减为0，应该把现在的元素作为候选值</span><br><span class="line">        if (nTimes==0 ) &#123;</span><br><span class="line">            candidate = arr[i];</span><br><span class="line">            nTimes = 1;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果遇到和候选值相同的，次数加一</span><br><span class="line">        if (arr[i]==candidate) &#123;</span><br><span class="line">            nTimes++;</span><br><span class="line">            // 不同的数，进行消减</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            nTimes--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //System.out.println(nTimes);</span><br><span class="line">    if (nTimes==0) &#123;</span><br><span class="line">        System.out.println(-1);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        System.out.println(candidate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">加强版水王（出现个数等于数组个数的一半）</span><br><span class="line"></span><br><span class="line">public class MoreThanHalf &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //进行测试数据要满足测试条件 不然结果会错误</span><br><span class="line">    f(new int[]&#123;6,6,6,5,6,1,2,3,4,6&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不同的数，进行消除，O(N)</span><br><span class="line">public static void f(int arr[])&#123;</span><br><span class="line">    //候选数  先定位第一个元素</span><br><span class="line">    int candidate = arr[0];</span><br><span class="line">    // 出现的次数</span><br><span class="line">    int nTimes = 1;</span><br><span class="line">    int countOfLast = 1;  // 统计这个元素出现的次数</span><br><span class="line">    // 扫描数组</span><br><span class="line">    for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i-1]==arr[arr.length-1]) &#123;</span><br><span class="line">            countOfLast++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 两两消减为0，应该把现在的元素作为候选值</span><br><span class="line">        if (nTimes==0 ) &#123;</span><br><span class="line">            candidate = arr[i];</span><br><span class="line">            nTimes = 1;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果遇到和候选值相同的，次数加一</span><br><span class="line">        if (arr[i]==candidate) &#123;</span><br><span class="line">            nTimes++;</span><br><span class="line">            // 不同的数，进行消减</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            nTimes--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //System.out.println(nTimes);</span><br><span class="line">    if (countOfLast==arr.length/2) &#123;</span><br><span class="line">        System.out.println(arr[arr.length-1]);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        System.out.println(candidate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">法二（这个与上面那个不同的就是i--，还有那个大的if-else语句，这种方法是第一个和第二个比，第二个和第三个比，第三个和第四个比....）：</span><br><span class="line"></span><br><span class="line">（https://www.jianshu.com/p/79bca265f7b2）</span><br><span class="line">int findK(int* arr,int arrLen)&#123;</span><br><span class="line">int value=arr[0];</span><br><span class="line">int count=1;</span><br><span class="line">for(int i=1;i&lt;arrLen;i++)&#123;</span><br><span class="line"></span><br><span class="line">    if(count==0)&#123;</span><br><span class="line">        i--;//避免value的赋值跳过那个使count等于0的与value比较的数组元素 ,网上其它人的代码就是少了这条语句</span><br><span class="line">        value=arr[i];</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else&#123;</span><br><span class="line">        if(value==arr[i])//count!=0 &amp;&amp; value==arr[i] </span><br><span class="line">            count++;</span><br><span class="line">        else//count!=0&amp;value!=arr[i]</span><br><span class="line">            count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">加强版水王问题（出现的次数正好是数组个数的一半）：</span><br><span class="line">int findK(int* arr,int arrLen)&#123;</span><br><span class="line">int value=arr[0];</span><br><span class="line">int count=1;</span><br><span class="line">int countOfLast=0;//统计最后的元素arr[n-1]出现的个数</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;arrLen;i++)&#123;</span><br><span class="line"></span><br><span class="line">    //增加最后一个元素的计数步骤</span><br><span class="line">    if(arr[i]==arr[arrLen-1]) </span><br><span class="line">        countOfLast++;</span><br><span class="line"></span><br><span class="line">    if(count==0)&#123;</span><br><span class="line">        i--;//避免value的赋值跳过那个使count等于0的与value比较的数组元素 </span><br><span class="line">        value=arr[i];</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else&#123;</span><br><span class="line">        if(value==arr[i])//count!=0 &amp;&amp; value==arr[i] </span><br><span class="line">            count++;</span><br><span class="line">        else//count!=0&amp;value!=arr[i]</span><br><span class="line">            count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//增加最后一个元素的计数步骤</span><br><span class="line">if(arr[0]=arr[arrLen-1])</span><br><span class="line">    countOfLast++;</span><br><span class="line">//如果最后一个元素出现次数是n/2,则这个元素就是要找的数 </span><br><span class="line">if(countOfLast==arrLen/2)</span><br><span class="line">    return arr[arrLen-1];</span><br><span class="line">else</span><br><span class="line">    return value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><p id="4">多维数组和矩阵<p></strong></p>
<ul>
<li>4.1  基础题：顺时针打印二维数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void print(int matrix[][5],int rowlength,int collength) &#123;</span><br><span class="line">//二维数组传参数一定要知道一维的下标是多少</span><br><span class="line">	int leftUpRow = 0, leftUpCol = 0, rightDownRow = rowlength - 1, 		rightDownCol = collength - 1;</span><br><span class="line">	while (leftUpRow &lt;= rightDownRow &amp;&amp; leftUpCol &lt;= rightDownCol) &#123;</span><br><span class="line">		int r = leftUpRow, c = leftUpCol;</span><br><span class="line">		//上面一条边</span><br><span class="line">	while (c &lt;= rightDownCol) &#123;</span><br><span class="line">		cout&lt;&lt;matrix[r][c++]&lt;&lt;” “;</span><br><span class="line">	&#125;</span><br><span class="line">	//恢复</span><br><span class="line">	c = rightDownCol;</span><br><span class="line">	r++;</span><br><span class="line">	//右边的一条边</span><br><span class="line">	while (r &lt;= rightDownRow) &#123;</span><br><span class="line">		cout&lt;&lt;matrix[r++][c]&lt;&lt;” “;</span><br><span class="line">	&#125;</span><br><span class="line">	//恢复</span><br><span class="line">	r = rightDownRow;</span><br><span class="line">	c–;</span><br><span class="line">	//下面一条边</span><br><span class="line">	while (c &gt;= leftUpCol) &#123;</span><br><span class="line">		cout&lt;&lt;matrix[r][c–]&lt;&lt;” “;</span><br><span class="line">	&#125;</span><br><span class="line">	// 恢复</span><br><span class="line">	c = leftUpCol;</span><br><span class="line">	r–;</span><br><span class="line">	while (r &gt; leftUpRow) &#123;</span><br><span class="line">		cout&lt;&lt;matrix[r–][c]&lt;&lt;” “;</span><br><span class="line">	&#125;</span><br><span class="line">	leftUpRow++;</span><br><span class="line">	leftUpCol++;</span><br><span class="line">	rightDownRow–;</span><br><span class="line">	rightDownCol–;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int matrix[5][5] = &#123;</span><br><span class="line">		&#123;1, 2, 3, 4, 100&#125;,</span><br><span class="line">		&#123;5, 6, 7, 8, 101&#125;,</span><br><span class="line">		&#123;9, 10, 11, 12, 102&#125;,</span><br><span class="line">		&#123;13, 14, 15, 16, 103&#125;,</span><br><span class="line">		&#123;104, 105, 106, 107, 103&#125;,</span><br><span class="line">	&#125;;</span><br><span class="line">	print(matrix,5,5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>4.2 基础题：将0所在的行列清零<br>这样的话，不能扫一下行，如果有0的话就把这一行置为0，这样的方法会使全部的矩阵置为0<br>应该开另一个数组存行出现0的下标，另一个数组存列开出现0的下标，然后在这样扫一遍把原来数组的行或列置为0</p>
</li>
<li><p>4.3 Z型打印矩阵</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void print(int matrix[4][4],int rlen,int clen)&#123;</span><br><span class="line">	int r=0,m=rlen;</span><br><span class="line">	int c=0,n=clen;</span><br><span class="line">	bool l2r=true;//从左到右</span><br><span class="line">	while(r&lt;m&amp;&amp;c&lt;n)&#123;</span><br><span class="line">	//从左下到右上的斜线</span><br><span class="line">		if(l2r)&#123;</span><br><span class="line">			cout&lt;&lt;matrix[r][c]&lt;&lt;” “;</span><br><span class="line">	//现在在第一行，列未到边界，这是只能向右走</span><br><span class="line">		if(r==0&amp;&amp;n-1)&#123;</span><br><span class="line">			l2r=!l2r;</span><br><span class="line">			c++;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;else if(r&gt;0&amp;&amp;c==n-1)&#123;</span><br><span class="line">			//现在在最后一列，只能向下走</span><br><span class="line">			l2r=!l2r;</span><br><span class="line">			r++;</span><br><span class="line">			continue;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			//继续走上坡</span><br><span class="line">			r–;</span><br><span class="line">			c++;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;else&#123;//反，走下坡</span><br><span class="line">			cout&lt;&lt;matrix[r][c]&lt;&lt;” “;</span><br><span class="line">		//走到第一列，只能往下走</span><br><span class="line">			if(c==0&amp;&amp;r&lt;m-1)&#123;</span><br><span class="line">				l2r=!l2r;</span><br><span class="line">				r++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;else if(r==m-1)&#123;</span><br><span class="line">			//到最后一行，只能往右走</span><br><span class="line">				l2r=!l2r;</span><br><span class="line">				c++;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				r++;</span><br><span class="line">				c–;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int matrix[3][4] = &#123;</span><br><span class="line">&#123;1, 2, 3, 4&#125;,</span><br><span class="line">&#123;5, 6, 7, 8&#125;,</span><br><span class="line">&#123;9, 10, 11, 12&#125;,</span><br><span class="line">// &#123;13, 14, 15, 16&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">print(matrix,3,4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>4.4 求边界为1的最大子方阵</li>
</ul>
<p>优化前O(n^4)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int solve(int A[3][3],int length)&#123;</span><br><span class="line">int N=length;</span><br><span class="line">int n=length;//n为最大子方阵的值</span><br><span class="line">while (n &gt; 0) &#123;</span><br><span class="line">//最上面那一行顶点</span><br><span class="line">for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">if (i + n &gt; N) break;</span><br><span class="line">for (int j = 0; j &lt; N; j++) &#123;</span><br><span class="line"></span><br><span class="line">      if (j + n &gt; N) break;</span><br><span class="line"></span><br><span class="line">       //检查四个边</span><br><span class="line">       int r = i, c = j;</span><br><span class="line">       while (c &lt; j + n) &#123;</span><br><span class="line">         if (A[r][c++] == 0) goto l3;</span><br><span class="line">       &#125;</span><br><span class="line">       c--;//恢复，不然的话会越界 </span><br><span class="line">       while (r &lt; i + n) &#123;</span><br><span class="line">         if (A[r++][c] == 0)</span><br><span class="line">           goto l3;</span><br><span class="line">       &#125;</span><br><span class="line">       r--;</span><br><span class="line">       while (c &gt;= j) &#123;</span><br><span class="line">         if (A[r][c--] == 0)</span><br><span class="line">           goto l3;</span><br><span class="line">       &#125;</span><br><span class="line">       c++;</span><br><span class="line">       while (r &gt;= i) &#123;</span><br><span class="line">         if (A[r--][c] == 0)</span><br><span class="line">           goto l3;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return n;</span><br><span class="line">      l3: continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125; </span><br><span class="line">  n--;</span><br><span class="line">&#125;</span><br><span class="line">return 0; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a[3][3] = &#123;</span><br><span class="line">&#123;0, 1, 1&#125;,</span><br><span class="line">&#123;0, 1, 1&#125;,</span><br><span class="line">&#123;0, 1, 0&#125;</span><br><span class="line">&#125;;</span><br><span class="line">cout&lt;&lt;solve(a,3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">优化之后O(n^3)</span><br><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int l=100;</span><br><span class="line">int rec[l][l][2];</span><br><span class="line">void generatehelpRec(int A[l][l],int length)&#123;</span><br><span class="line">//产生一个rec数组，其存放右和下方元素个数为1的个数，这样就产生了一个表，然后</span><br><span class="line">//能产生那个方阵的条件在 check中判断，这样时间复杂度就是o(n^3)</span><br><span class="line">	int N=length;</span><br><span class="line">	int row=N-1;</span><br><span class="line">	//初始化rec的最后一行</span><br><span class="line">	for(int j=N-1;j&gt;=0;j–)&#123;</span><br><span class="line">		int value=A[row][j];</span><br><span class="line">		if(value==1)&#123;</span><br><span class="line">			if(j==N-1)&#123;</span><br><span class="line">				rec[row][j][0]=1;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				rec[row][j][0]=rec[row][j+1][0]+1;</span><br><span class="line">			&#125;</span><br><span class="line">			rec[row][j][1]=1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	row–;</span><br><span class="line">	for(int i=row;i&gt;=0;i–)&#123;</span><br><span class="line">		//因为row–，此时是倒数第二行 ，初始化rec剩下的数组</span><br><span class="line">	for(int j=N-1;j&gt;=0;j–)&#123;</span><br><span class="line">		int value=A[i][j];</span><br><span class="line">		if(value==1)&#123;</span><br><span class="line">			if(j==N-1)&#123;</span><br><span class="line">				rec[i][j][0]=1;</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				rec[i][j][0]=rec[i][j+1][0]+1;</span><br><span class="line">			&#125;</span><br><span class="line">			rec[i][j][1]=rec[i+1][j][1]+1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//以常数阶判断是否能组成方阵</span><br><span class="line">int check(int i,int j,int n)&#123;</span><br><span class="line">	if(rec[i][j][0]&gt;=n&amp;&amp;rec[i][j][1]&gt;=n&amp;&amp;rec[i][j+n-1][1]&gt;=n&amp;&amp;rec[i+n-1][j][0]&gt;=n)&#123;</span><br><span class="line">	return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">//n从N到0判断最大子方阵的阶数</span><br><span class="line">int solve(int A[l][l],int length)&#123;</span><br><span class="line">int N=length;</span><br><span class="line">int n=N;</span><br><span class="line">	while(n&gt;0)&#123;</span><br><span class="line">		for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">			if(i+n&gt;N)break;//判断一下边界，能优化一点</span><br><span class="line">			for(int j=0;j&lt;N;j++)&#123;</span><br><span class="line">				if(j+n&gt;N)break;</span><br><span class="line">			if(check(i,j,n))</span><br><span class="line">			return n;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		n–;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int a[l][l];</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;//n阶方阵</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">generatehelpRec(a,n);</span><br><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;n;j++)</span><br><span class="line">cout&lt;&lt;rec[i][j][0]&lt;&lt;” “&lt;&lt;rec[i][j][1]&lt;&lt;” “;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;solve(a,n);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.7 子数组的最大累加和</li>
</ul>
<p>为什么那暴力有时回比递推法多1那？？？？？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//个数最多为n*(n+1)/2</span><br><span class="line">void findByForce(int arr[],int length)&#123;</span><br><span class="line">int maxSum=arr[0];</span><br><span class="line">for(int j=0;j&lt;length;j++)&#123;</span><br><span class="line">//控制子数组的最大长度</span><br><span class="line">	int sum=arr[0];//为第i项的和</span><br><span class="line">	int maxOfJ=sum;//从第j项起和的最大值</span><br><span class="line">	for(int i=j+1;i&lt;length;i++)&#123;</span><br><span class="line">		//数组的尾指针，后移实现遍历最长数组中的不同子数组</span><br><span class="line">		sum+=arr[i];</span><br><span class="line">		if(sum&gt;maxOfJ)&#123;//第一次就是第j+1和第j项相比</span><br><span class="line">			maxOfJ=sum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    //单独比较一下每个元素的值和maxSum的值的大小 </span><br><span class="line">    if(maxOfJ&gt;maxSum)&#123;</span><br><span class="line">        maxSum=maxOfJ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;maxSum&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//递推法O(n)</span><br><span class="line">int left;</span><br><span class="line">int right;</span><br><span class="line">int findByDp(int arr[],int length)&#123;</span><br><span class="line">	if(length==0)return 0;</span><br><span class="line">	int sumJ=arr[0];//前j个元素的最大贡献</span><br><span class="line">	int max=sumJ;</span><br><span class="line">	int right=0,left=0;//left为最大子序列的左端点,right为右端点</span><br><span class="line">	for(int j=1;j&lt;length;j++)&#123;</span><br><span class="line">		if(sumJ&gt;=0)&#123;</span><br><span class="line">			sumJ+=arr[j];</span><br><span class="line">		&#125; else&#123;</span><br><span class="line">			sumJ=arr[j];</span><br><span class="line">			left=j;//更新一下left</span><br><span class="line">		&#125;</span><br><span class="line">		if(sumJ&gt;max)&#123;</span><br><span class="line">			max=sumJ;</span><br><span class="line">			right=j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int arr[]=&#123;1,-3,5,5,-2,-1,0,0&#125;;</span><br><span class="line">int arr1[]=&#123;0,0,1&#125;;</span><br><span class="line">cout&lt;&lt;”暴力破解”&lt;&lt;endl;</span><br><span class="line">findByForce(arr,8);</span><br><span class="line">cout&lt;&lt;”递推法”&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;findByDp(arr,8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.8求解矩阵的子矩阵的最大累加和</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int ll=100;</span><br><span class="line">int findByDp(int arr[],int length)&#123;</span><br><span class="line">	if(length==0)return 0;</span><br><span class="line">	int sumJ=arr[0];//前j个元素的最大贡献</span><br><span class="line">	int max=sumJ;</span><br><span class="line">	int right=0,left=0;//left为最大子序列的左端点,right为右端点</span><br><span class="line">	for(int j=1;j&lt;length;j++)&#123;</span><br><span class="line">		if(sumJ&gt;=0)&#123;</span><br><span class="line">			sumJ+=arr[j];</span><br><span class="line">		&#125; else&#123;</span><br><span class="line">			sumJ=arr[j];</span><br><span class="line">		&#125;</span><br><span class="line">		if(sumJ&gt;max)&#123;</span><br><span class="line">			max=sumJ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return max;</span><br><span class="line">&#125;</span><br><span class="line">//就是把每一列的和当做一维数组来处理</span><br><span class="line">int maxSum(int matrix[ll][ll],int m,int n)&#123;</span><br><span class="line">int beginRow=0;</span><br><span class="line">int sums[n];</span><br><span class="line">int max=0;</span><br><span class="line">while(beginRow&lt;m)&#123;</span><br><span class="line">		//从起始行到第n行</span><br><span class="line">		for(int i=beginRow;i&lt;n;i++)&#123;</span><br><span class="line">		//按列累加</span><br><span class="line">			for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">				sums[j]+=matrix[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		//这地方就是用了上一题中思想，把二维数组转化为一位数组求解</span><br><span class="line">			int t=findByDp(sums,n); //这地方找前n个位置的对吗</span><br><span class="line">			if(t&gt;max)max=t;</span><br><span class="line">		&#125;</span><br><span class="line">	// memset(sums,0,sizeof(sums)); 为什么写memset不可以那</span><br><span class="line">		for(int k=0;k&lt;n;k++)&#123;</span><br><span class="line">			sums[k]=0;&#125;</span><br><span class="line">		beginRow++;</span><br><span class="line">		&#125;</span><br><span class="line">	return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int a[ll][ll];</span><br><span class="line">int m,n;</span><br><span class="line">cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">	for(int j=0;j&lt;n;j++)</span><br><span class="line">		cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">	cout&lt;&lt;maxSum(a,m,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>4.9 矩阵的运算<br>矩阵的乘法不满足交换律</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100;</span><br><span class="line">int a[N][N];</span><br><span class="line">int b[N][N];</span><br><span class="line">int c[N][N];</span><br><span class="line">void multi(int a[][N],int b[][N],int a_row,int b_col,int n)</span><br><span class="line">&#123;</span><br><span class="line">//普通的三层for循环实现矩阵乘法，第二三层for循环可颠倒</span><br><span class="line">	for(int i=1;i&lt;=a_row;i++) //矩阵ab，遍历a的第i行</span><br><span class="line">		for(int k=1;k&lt;=n;k++) //遍历a的第j列,b的第j行</span><br><span class="line">			for(int j=1;j&lt;=b_col;j++)//n为a的列或者b的行数</span><br><span class="line">				c[i][j]+=a[i][k]*b[k][j];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a_row,b_col,n;</span><br><span class="line">cin&gt;&gt;a_row&gt;&gt;b_col&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=a_row;i++)&#123;</span><br><span class="line">    for(int k=1;k&lt;=n;k++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">    for(int k=1;k&lt;=b_col;k++)&#123;</span><br><span class="line">        cin&gt;&gt;b[i][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> multi(a,b,a_row,b_col,n);</span><br><span class="line">     for(int i=1;i&lt;=a_row;i++)&#123;</span><br><span class="line">    for(int k=1;k&lt;=b_col;k++)&#123;</span><br><span class="line">        cout&lt;&lt;c[i][k];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.9 矩阵快速幂的问题</li>
</ul>
<p><strong><p id="5">字符串专题<p></strong></p>
<p>－　5.1判断两个字符串是否有重复的字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=256;</span><br><span class="line">int help[N];</span><br><span class="line">//这种思想要知道，就是扫描一遍，然后在辅助的数组中存放数据</span><br><span class="line">//在辅助数组的数据中找到问题的答案</span><br><span class="line">int main()&#123;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">bool flag=true;</span><br><span class="line">int k;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;sizeof(s);i++)&#123;</span><br><span class="line">    k=s[i]-&#x27;0&#x27;;</span><br><span class="line">    help[k]++;</span><br><span class="line">    if(help[k]==2)&#123;   //可以在这里判断，直接找到问题的答案</span><br><span class="line">        flag=false;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">if(flag==false)cout&lt;&lt;&quot;有重复&quot;;</span><br><span class="line">else cout&lt;&lt;&quot;无重复&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-5.2字符串翻转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">对于char []类型的数据：</span><br><span class="line"></span><br><span class="line">#include</span><br><span class="line"></span><br><span class="line">#include</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char s[]=”123456”;//不能是string类型；</span><br><span class="line">	strrev(s);</span><br><span class="line">	cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对于string类型的数据：</span><br><span class="line"></span><br><span class="line">#include</span><br><span class="line"></span><br><span class="line">#include</span><br><span class="line"></span><br><span class="line">#include</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string s[]=”123456”;</span><br><span class="line">reverse(s.begin(),s.end());</span><br><span class="line">cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>5.3 走出思维误区：变形词问题</li>
</ul>
<p>解法1：这种题可以先对字符串排序之后，判断两个字符串是否相等；<br>解法2：声明一个help数组（ascii码），然后扫描s1，扫描到一个字符，在相应的位置+1，然后扫s2，扫到一个字符在相应的位置-1，最后如果help数组中有不是0的位置，那么就返回false，否则返回true。  </p>
<p>这道题的一个变形题是：判断两个串是否属于一个字符集<br>解法1：是用一个help，并全初始化为0， s1中出现的一个字符，就在help相应的位置变为1,；  然后扫s2，若扫描到的字符对应的help中相应的位置为0，则返回false，否则返回true；<br>解法2：就是用一下map，map相应的操作和help相同。  </p>
<ul>
<li><p>5.5 压缩字符串<br>？？？</p>
</li>
<li><p>5.6 旋转词<br>解法<br>1、判断s1和s2是否等长<br>2、如果不等长，建一个s1 + s1的字符串<br>3、判断s2 是否在s1 + s1中。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">bool solution(string s1, string s2)&#123;</span><br><span class="line">	if(s1.length() != s2.length())&#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int len = s1.length();</span><br><span class="line">string ds1 = s1 + s1;</span><br><span class="line">	for (int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">		if (ds1.substr(i, i + len)==s2)</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	string s1,s2;</span><br><span class="line">	cin&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">	cout&lt;&lt;solution(s1,s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>-5.8 将字符串按单词进行翻转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">	string s1,s2,s3;</span><br><span class="line">	// s1=”xiao liu z x”;</span><br><span class="line">	getline(cin,s1);</span><br><span class="line">	//注意cin和scanf都不能输入带空格的字符串</span><br><span class="line">	//可以使用getline(cin,str)或者scanf(“%[^\n]]”,str)或者gets(字符数组名);</span><br><span class="line">	stringstream ss;</span><br><span class="line">	ss&lt;&lt;s1;</span><br><span class="line">	int count=0;</span><br><span class="line">	while(ss&gt;&gt;s2)&#123;</span><br><span class="line">		reverse(s2.begin(),s2.end());</span><br><span class="line">		if(count==0)s3.append(s2);</span><br><span class="line">		else s3.append(“ “+s2);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>5.11最短摘要的生成</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pangxiaodong/archive/2011/09/08/2171551.html">https://www.cnblogs.com/pangxiaodong/archive/2011/09/08/2171551.html</a></p>
<p><strong><p id="6">数学问题<p></strong></p>
<ul>
<li>6.1 巧用进制解决天平称重问题<br> 二进制可以代表取和不取，如每一位上为1就代表取相应的2^n个相应的砝码<br> 本体思想就是三进制0代表不取这个砝码，1代表取这个砝码，2可以+1转换为进位和-1，其中-1代表放天平的另一边。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string i2s(int num)&#123; //int类型转字符串</span><br><span class="line">string a;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss&lt;&lt;num;</span><br><span class="line">ss&gt;&gt;a;</span><br><span class="line">return a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">string zhuanhuan(long long num,int base)&#123;//进制转换</span><br><span class="line">	string ans=””;</span><br><span class="line">	do&#123;</span><br><span class="line">		int i=num%base;</span><br><span class="line">		if(i&gt;=0&amp;&amp;i&lt;=9)ans+=i+’0’;</span><br><span class="line">		else ans+=i-10+’a’;</span><br><span class="line">		num/=base;</span><br><span class="line">	&#125;while(num!=0); </span><br><span class="line">		//reverse(ans.begin(),ans.end());</span><br><span class="line">	return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">long long num;</span><br><span class="line">cin&gt;&gt;num;</span><br><span class="line">string san=zhuanhuan(num,3);</span><br><span class="line">string ans=””;</span><br><span class="line">vector v;</span><br><span class="line">std::vector::iterator it=v.begin();</span><br><span class="line">for(int i=0;i&lt;san.length();i++)&#123;</span><br><span class="line">//因为没有反转，此时从低位往高位走</span><br><span class="line">	if(san[i]==’2’)&#123;</span><br><span class="line">			v.push_back(-1);</span><br><span class="line">		if(i==san.length()-1)&#123;</span><br><span class="line">			v.push_back(1);</span><br><span class="line">		&#125; else&#123;</span><br><span class="line">			++san[i+1];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else if(san[i]==’3’)&#123;</span><br><span class="line">		v.push_back(0);</span><br><span class="line">		if(i==san.length()-1)&#123;</span><br><span class="line">			v.push_back(1);</span><br><span class="line">		&#125; else&#123;</span><br><span class="line">			++san[i+1];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		v.push_back(san[i]-‘0’);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">reverse(v.begin(),v.end());</span><br><span class="line">	for(int i=0;i&lt;v.size();i++)&#123;</span><br><span class="line">		if(v[i]==1)&#123;</span><br><span class="line">			ans.append(“+”).append(i2s(pow(3,v.size()-i-1)));</span><br><span class="line">		&#125;</span><br><span class="line">		if(v[i]==-1)&#123;</span><br><span class="line">			ans.append(“-“).append(i2s(pow(3,v.size()-i-1)));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(ans[0]==’+’)ans.erase(0,1);</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>6.2 nim游戏</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41958841/article/details/82807985">洛谷取火柴棒问题</a></p>
<p>1、桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。你们是聪明人，每一步都是最优解。<br>这样的游戏有一个结论：如果石子的数量为4的倍数，一定是对手赢，否则，就是先手赢。  </p>
<p>结论：一个Nim游戏中的状态是必败状态当且仅当每个子游戏的异或和为0，否则是必胜态。通过必胜态一定可以通过一步操作变成必败状态。  </p>
<p>2、桌子上有一堆石头，两人对战，从任意一堆石子中取出任意数量的石子，至少取一颗，至多取这堆石子中剩下的个数。 拿掉最后一块石头的人就是获胜者。你作为先手。<br>（这一题也是那个异或来求，因为你是先手，所以你面对着异或之后为0的情况就能赢；这题与洛谷上的那个取火柴棒的问题是有点不同的）  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool solve(int a[],int length)&#123;</span><br><span class="line">	int res=0;</span><br><span class="line">	for(int i=0;i&lt;length;i++)&#123;</span><br><span class="line">		res^=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">//因为先手面对着0的情况，则一定会赢;面对非零情况，则会输，所以要返回res！=0；</span><br><span class="line">	return res!=0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int a[]=&#123;3,10,15&#125;;</span><br><span class="line">	bool res=solve(a,3);</span><br><span class="line">	cout&lt;&lt;res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>6.3 解题nim问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N=100;</span><br><span class="line">int data[N][N];</span><br><span class="line">int caseNum,length;</span><br><span class="line"></span><br><span class="line">string deal(int A[],int length)&#123;</span><br><span class="line">	int len=sizeof(A)/sizeof(A[0]); //求数组长度的做法</span><br><span class="line">	sort(A,A+len); //因为测试数据有可能是乱序的</span><br><span class="line">	int res=0;</span><br><span class="line">	if((len&amp;1)==1)&#123;//当len为奇数时就把第一个看为一份，为偶数就两两一份来当做nim问题异或</span><br><span class="line">		for (int i = 0; i &lt; len; i += 2) &#123;</span><br><span class="line">			res ^= (i == 0) ? (A[0] - 1) : (A[i] - A[i - 1] - 1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		for (int i = 1; i &lt; len; i += 2) &#123;</span><br><span class="line">			res ^= (A[i] - A[i - 1] - 1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	if (res == 0) &#123;</span><br><span class="line">		return “Bob will win\n”;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">	return “Georgia will win\n”;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;caseNum;</span><br><span class="line">for(int i=0;i&lt;caseNum;i++)&#123;</span><br><span class="line">    int k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    for(int j=0;j&lt;k;j++)</span><br><span class="line">        cin&gt;&gt;data[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(int l=0;l&lt;caseNum;l++)&#123;</span><br><span class="line">    string res=deal(data[l],length);</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>结论的应用很重要</p>
<ul>
<li>6.4 必备的求和公式</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-138.png" alt="upload successful"><br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-135.png" alt="upload successful"></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-136.png" alt="upload successful"></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-137.png" alt="upload successful"></p>
<ul>
<li>6.5 欧几里得算法</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-140.png" alt="upload successful"></p>
<ul>
<li>6.6 扩展欧几里得算法</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-143.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">扩展欧几里得</span><br><span class="line">gcd(a,b)</span><br><span class="line">return b==0?a</span><br><span class="line">我们观察到：欧几里德算法停止的状态是： a’= gcd ， b’ = 0 ，(a’,b’是递归最后一层时参数的值)那么，这是否能给我们求解 x y 提供一种思路呢？</span><br><span class="line">a’x + b’y = gcd 此时x=1,y为任意数</span><br><span class="line">因为，这时候，只要 a = gcd 的系数是 1 ，那么只要 b 的系数是 0 或者其他值</span><br><span class="line">（无所谓是多少，反正任何数乘以 0 都等于 0 但是a 的系数一定要是 1），这时，我们就会有： a’1 + b’0 = gcd</span><br><span class="line"></span><br><span class="line">当然这是最终状态，但是我们是否可以从最终状态反推到最初的状态呢？</span><br><span class="line"></span><br><span class="line">假设当前我们要处理的是求出 a 和 b的最大公约数，并求出 x 和 y 使得 a*x + b*y= gcd    ……(1式)，---&gt;要求的</span><br><span class="line">而我们已经求出了下一个状态：b 和 a%b 的最大公约数，并且求出了一组x1 和y1 使得： b*x1 + (a%b)*y1 = gcd (2式) ，--&gt;下一个状态</span><br><span class="line">那么这两个相邻的状态之间是否存在一种关系呢？</span><br><span class="line"></span><br><span class="line">a%b = k  ==&gt;  a = b*(a/b) +k  &quot;/&quot;舍掉余数的除法 ==&gt; k=a-(a/b)*b</span><br><span class="line">我们知道： a%b = a - (a/b)*b（这里的 “/” 指的是整除，例如 5/2=2 , 1/3=0），那么，我们可以进一步得到：</span><br><span class="line"></span><br><span class="line">    gcd = b*x1 + (a-(a/b)*b)*y1</span><br><span class="line"></span><br><span class="line">        = b*x1 + a*y1 – (a/b)*b*y1</span><br><span class="line"></span><br><span class="line">        = a*y1 + b*(x1 – a/b*y1)        ……(3式)</span><br><span class="line"></span><br><span class="line">对比之前我们的状态,式(3)和式(1)：求一组 x 和 y 使得：a*x + b*y = gcd ，是否发现了什么？</span><br><span class="line"></span><br><span class="line">这里：</span><br><span class="line"></span><br><span class="line">    x = y1</span><br><span class="line"></span><br><span class="line">    y = x1 – a/b*y1</span><br><span class="line"></span><br><span class="line">这就是递推式,注意x,y是递归过程中的上一层,x1,y1是下一层(下一个状态)得到的值</span><br></pre></td></tr></table></figure>

<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-142.png" alt="upload successful"></p>
<ul>
<li>6.6 扩展欧几里得算法求贝祖等式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">ll x,y;</span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line">    扩展欧几里得</span><br><span class="line">    传入a，b调用完成后x，y是ax+by=gcd(a,b)的解/</span><br><span class="line">    ll exgcd(ll a,ll b)&#123;</span><br><span class="line">    if(b==0)&#123;</span><br><span class="line">    x=1;</span><br><span class="line">    y=0;</span><br><span class="line">    return a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res=exgcd(b,a%b);</span><br><span class="line">    //x,y已经被下一层递归更新了,ppt中所说的x0和y0</span><br><span class="line">    ll x1=x; //备份x</span><br><span class="line">    x=y; //更新x</span><br><span class="line">    y=x1-a/by; //更新y</span><br><span class="line">    return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/exgcd模板</span><br><span class="line">void exgcd(int a,int b,int&amp; d,int&amp; x,int&amp; y)&#123;</span><br><span class="line">	if(!b)&#123;d=a,x=1,y=0;return;&#125;</span><br><span class="line">	exgcd(b,a%b,d,y,x);</span><br><span class="line">    y-=x(a/b);</span><br><span class="line">&#125;</span><br><span class="line">/</span><br><span class="line">ll linerEquation(ll a,ll b,ll m)&#123;</span><br><span class="line">ll d=exgcd(a,b);</span><br><span class="line">	if(m%d!=0)&#123;</span><br><span class="line">		cout&lt;&lt;” no ans”;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		long n=m/d;</span><br><span class="line">		x=n;</span><br><span class="line">		y*=n;</span><br><span class="line">	return d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	ll a,b,m; //求解ax+by=m</span><br><span class="line">	cin&gt;&gt;a&gt;&gt;b&gt;&gt;m;</span><br><span class="line">	linerEquation(a,b,m);</span><br><span class="line">	cout&lt;&lt;x&lt;&lt;” “&lt;&lt;y;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>6.8 求解同余方程</li>
</ul>
<p>模可以看为一个圈，就比如</p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-147.png" alt="upload successful"></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-144.png" alt="upload successful"></p>
<ul>
<li>poj1061 <a target="_blank" rel="noopener" href="http://poj.org/problem?id=1061">青蛙的约会（同余方程的求解）</a></li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-148.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include</span><br><span class="line"></span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define ll long long</span><br><span class="line"></span><br><span class="line">int flag=0;</span><br><span class="line">void exgcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)&#123;</span><br><span class="line">	if(!b)&#123;</span><br><span class="line">		d=a,x=1,y=0;return;</span><br><span class="line">	&#125;</span><br><span class="line">	exgcd(b,a%b,d,y,x);y-=x*(a/b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linearEquation (ll d,ll m,ll &amp;x,ll &amp;y)&#123;</span><br><span class="line">	if(m%d!=0)&#123;</span><br><span class="line">		flag=1;</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		x=(m/d);</span><br><span class="line">		y=(m/d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	ll x,y,m,n,l;//m，n为青蛙a，b一次跳的距离</span><br><span class="line">	cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;l;</span><br><span class="line">	ll a=m-n;</span><br><span class="line">	long b=l;</span><br><span class="line">	m=y-x; //此时的m是ax+by=m中的m</span><br><span class="line">	ll d=0;//d=gcd（a，b）</span><br><span class="line">	exgcd(a,b,d,x,y);</span><br><span class="line">	linearEquation(d,m,x,y);</span><br><span class="line">	b/=d; b=abs(b);//运算之后b就是那个要x要变为最小的正解的最小正倍数</span><br><span class="line">	x=(x%b+b)%b; //让x变为那个最小的正解</span><br><span class="line">	if(flag==1)cout&lt;&lt;”Impossible”&lt;&lt;endl;</span><br><span class="line">	else cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>模的逆元</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-149.png" alt="upload successful"></p>
<p>1.乘法逆元（在维基百科中也叫倒数，当然是 mod p后的,其实就是倒数不是吗？）:<br><strong>如果ax≡1 (mod p),且gcd(a,p)&#x3D;1（a与p互质），则称a关于模p的乘法逆元为x。</strong><br><em>为什么可以用扩展欧几里得求得逆元？  *<br>我们都知道模就是余数，比如12%5&#x3D;12-5</em>2&#x3D;2，18%4&#x3D;18-4*4&#x3D;2。（&#x2F;是程序运算中的除）<br>那么ax≡1 (mod p)即ax-yp&#x3D;1.把y写成+的形式就是ax+py&#x3D;1，为方便理解下面我们把p写成b就是ax+by&#x3D;1。<br>就表示x是a的模b乘法逆元，y是b的模a乘法逆元。然后就可以用扩展欧几里得求了。<br>知道.逆元怎么算之后，那么乘法逆元有什么用呢？<br><strong>做题时如果结果过大一般都会让你模一个数，确保结果不是很大，而这个数一般是1e9+7，而且这个数又是个素数，<br>加减乘与模运算的顺序交换不会影响结果，但是除法不行。有的题目要求结果mod一个大质数，如果原本的结果中有除法，比如除以a,那就可以乘以a的逆元替代。<br>（除一个数等于乘它的倒数，虽然这里的逆元不完全是倒数，但可以这么理解，毕竟乘法逆元就是倒数的扩展）。</strong></p>
<ul>
<li>模的运算规则</li>
</ul>
<p>%运算法则 </p>
<ol>
<li><p>乘法的,因为( a%p) <em>(b%p)这个有可能会大于p，所以对总结果再%p<br>(a</em>b) %p&#x3D; （ ( a%p) *(b%p) ）%p   </p>
</li>
<li><p>除法的  （b^(-1）表示b的逆元)<br>(a&#x2F;b) %p&#x3D;（ ( a *b^(-1)%p) ）%p  </p>
</li>
<li><p>乘方<br>(a^b) % p &#x3D; ((a % p)^b) % p</p>
</li>
</ol>
<ul>
<li>6.11 同余方程组</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-152.png" alt="upload successful"></p>
<ul>
<li><p>6.12　　？？</p>
</li>
<li><p>6.13  　？？</p>
</li>
<li><p>6.14　快速幂运算</p>
<p>  －　其中矩阵和斐波那锲是有关系的</p>
</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-157.png" alt="upload successful"><br>即：</p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-155.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const int N=10;</span><br><span class="line">int tmp[N][N];</span><br><span class="line">void multi(int a[][N],int b[][N],int n)</span><br><span class="line">&#123;</span><br><span class="line">	memset(tmp,0,sizeof tmp);</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">		for(int j=0;j&lt;n;j++)</span><br><span class="line">			for(int k=0;k&lt;n;k++)</span><br><span class="line">				tmp[i][j]+=a[i][k]b[k][j];</span><br><span class="line">	for(int i=0;i&lt;n;i++)</span><br><span class="line">		for(int j=0;j&lt;n;j++)</span><br><span class="line">		a[i][j]=tmp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">int res[N][N];</span><br><span class="line">void Pow(int a[][N],int n)</span><br><span class="line">&#123;</span><br><span class="line">	memset(res,0,sizeof res);//n是幂，N是矩阵大小</span><br><span class="line">	for(int i=0;i&lt;N;i++) res[i][i]=1;</span><br><span class="line">		while(n)</span><br><span class="line">		&#123;</span><br><span class="line">			if(n&amp;1)</span><br><span class="line">			multi(res,a,N);//res=resa;复制直接在multi里面实现了；</span><br><span class="line">			multi(a,a,N);//a=a*a</span><br><span class="line">			n&gt;&gt;=1;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><p id="7"><p></strong><br>递归，DFS，剪枝，回溯等问题</p>
<ul>
<li><p>7.1 递归（本质上是数学归纳，可以从简单的例子，一步一步的递推，直到找到问题的答案）：<br>  递推就是一种由少到多，递推可以分为递归（由少到多，由简到繁，归一）和迭代两种表现形式，递归比迭代有更强的表达能力，其中有记忆性的递归就叫动态规划。</p>
</li>
<li><p>7.2 双管齐下的解决递归问题：</p>
</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-176.png" alt="upload successful"><br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-171.png" alt="upload successful"></p>
<ul>
<li>7.3 机器人走方格</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-177.png" alt="upload successful"><br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-172.png" alt="upload successful"></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-173.png" alt="upload successful"></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-174.png" alt="upload successful"></p>
<ul>
<li>7.5 硬币表示某个面值</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-178.png" alt="upload successful"><br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-179.png" alt="upload successful"></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-181.png" alt="upload successful"><br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-180.png" alt="upload successful"></p>
<ul>
<li><p>其中走楼梯，机器人走格子，硬币表示某个面值这三题都是逐步生成结果类问题之数值型</p>
</li>
<li><p>7.6 合法括号（逐步生成结果之非数值型）<br>其中每种每个类型都能分解成另三种情况，但是有重复的，所以就可以用set集合来去重。<br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-182.png" alt="upload successful"></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//迭代形式</span><br><span class="line">set&lt;string&gt; parenthesis1(int n)&#123;</span><br><span class="line">	set&lt;string&gt;res;</span><br><span class="line">	res.insert(&quot;()&quot;);</span><br><span class="line">	if(n==1)&#123;</span><br><span class="line">		return res;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">		set&lt;string&gt;res_new;</span><br><span class="line">		for(set&lt;string&gt;::iterator it=res.begin();it!=res.end();it++)&#123;</span><br><span class="line">			res_new.insert(*it+&quot;()&quot;);</span><br><span class="line">			res_new.insert(&quot;()&quot;+*it);</span><br><span class="line">			res_new.insert(&quot;(&quot;+*it+&quot;)&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		res=res_new;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//递归公式求解 </span><br><span class="line">set&lt;string&gt; parenthesis(int n)&#123;</span><br><span class="line">	set&lt;string&gt;s_n;</span><br><span class="line">	if(n==1)&#123;</span><br><span class="line">		s_n.insert(&quot;()&quot;);</span><br><span class="line">		return s_n;</span><br><span class="line">	&#125;</span><br><span class="line">	set&lt;string&gt;s_n_1=parenthesis(n-1);</span><br><span class="line">	for(set&lt;string&gt;::iterator it=s_n_1.begin();it!=s_n_1.end();it++)&#123;</span><br><span class="line">		s_n.insert(&quot;()&quot;+*it);</span><br><span class="line">		s_n.insert(*it+&quot;()&quot;);</span><br><span class="line">		s_n.insert(&quot;(&quot;+*it+&quot;)&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return s_n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	set&lt;string&gt;s;</span><br><span class="line">	s=parenthesis(n); //s=parenthesis1(n);</span><br><span class="line">	for(set&lt;string&gt;::iterator it=s.begin();it!=s.end();it++)&#123;</span><br><span class="line">		cout&lt;&lt;*it&lt;&lt;&quot; &quot;;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-7.6 子集的生成<br>子集就是一个选和不选的问题，括号是加左加右还是加中间的问题。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34248487/article/details/93388816">c++实现生成子集</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*算法思想 </span><br><span class="line">	例如求4个元素 3 2 1 0 的子集。</span><br><span class="line">	那么用二进制的1代表每一位是否选中。</span><br><span class="line">十进制	二进制 </span><br><span class="line">0	 	0000  代表空集</span><br><span class="line">1	 	0001  代表&#123;0&#125;</span><br><span class="line">2	 	0010  代表&#123;1&#125;</span><br><span class="line">3	 	0011  代表&#123;0,1&#125;</span><br><span class="line">4	 	0100  代表&#123;2&#125;</span><br><span class="line">		 ...</span><br><span class="line">15	 	1110  代表&#123;3,2,1&#125;</span><br><span class="line">16	 	1111  代表&#123;3,2,1,0&#125; </span><br><span class="line">如果n很大的话可以用字符串模拟二进制 </span><br><span class="line">*/</span><br><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line"># include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//二进制法求子集 </span><br><span class="line">void print_subset(int n,int s)&#123;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		if(s &amp; (1&lt;&lt;i)) //1左移i位，监测s的哪一位为1，为1的话输出 </span><br><span class="line">			printf(&quot;%d &quot;,i);</span><br><span class="line">	&#125; </span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">&#125; </span><br><span class="line">int main() &#123;</span><br><span class="line">	int n=3;</span><br><span class="line">	for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123;//1左移n位等价于2^n-1.因为子集个数2^n-1 </span><br><span class="line">		print_subset(n,i);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如有一个集合{0,1,2…n-1}<br>那么我们可以进行如下操作：   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">空集.............................0</span><br><span class="line">只含有第i个元素的集合&#123;i&#125;............1&lt;&lt;i</span><br><span class="line">含有全部n个元素的集合&#123;0,1...n-1&#125;....(1&lt;&lt;n)-1//含有n个元素的全集</span><br><span class="line">判断第i个元素是否属于集合S...........if(S&gt;&gt;i&amp;1)</span><br><span class="line">向集合中加入第i个元素S∪&#123;i&#125;..........s|1&lt;&lt;i</span><br><span class="line">从集合中取出第i个元素...............s&amp;~(1&lt;&lt;i)</span><br><span class="line">集合S和T的并集S∪T.................S|T</span><br><span class="line">集合S和T的交集S∩T.................S&amp;T</span><br></pre></td></tr></table></figure>

<p>比如 只含有第i个元素的集合为什么可以表示成1&lt;&lt;i</p>
<p>举个例子 比如只含有第2个元素的集合 那么 1&lt;&lt;2&#x3D;2^2 二进制表示就是100   第0个元素没有 因为在第0位置为0 第1个元素没有因为在第1位置为0 第2个元素为1 表示有第二个元素 所以就这样表示（它是倒着来的）。</p>
<p>比如  含有全部n个元素的集合{0,1…n-1}….(1&lt;&lt;n)-1&#x2F;&#x2F;含有n个元素的全集   </p>
<p>举个例子 含有全部3个元素的集合 {0，1，2}   那么(1&lt;&lt;3)-1 &#x3D; 7&#x3D;111(二进制)    是不是对应二进制位置都为1  </p>
<p>比如 判断第i个元素是否属于集合S………..if(S&gt;&gt;i&amp;1)  </p>
<p>举个例子 比如一个集合s{1 2 3}  判断它的第2个元素是否属于s 将它的二进制111 右移2位得到001 与1位与 得到1 说明第二个元素属于集合s。</p>
<p><strong>这第0个元素也代表一个确切的元素，而不一定就是为0，没有东西（空集），比如上面那个s集合，第0个元素,111（代表全集）右移0位和1与运算，得到1，代表1在集合内</strong></p>
<h4 id="贪心策略与动态规划"><a href="#贪心策略与动态规划" class="headerlink" title="贪心策略与动态规划"></a><strong>贪心策略与动态规划</strong></h4><ul>
<li>8.1快速渡河问题</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-233.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//#include&lt;iostream&gt;</span><br><span class="line">//#include&lt;algorithm&gt;</span><br><span class="line">//using namespace std;</span><br><span class="line"></span><br><span class="line">int speed[1010];</span><br><span class="line">输入后，按从小到大排序 </span><br><span class="line">void f(int n) &#123;</span><br><span class="line">    int left = n;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    while (left &gt; 0) &#123;</span><br><span class="line">      if (left == 1) &#123;//只有1人</span><br><span class="line">        ans += speed[0];</span><br><span class="line">        break;</span><br><span class="line">      &#125; else if (left == 2) &#123;//只有两人</span><br><span class="line">        ans += speed[1];</span><br><span class="line">        break;</span><br><span class="line">      &#125; else if (left == 3) &#123;//有三人</span><br><span class="line">        ans += speed[2] + speed[0] + speed[1];</span><br><span class="line">        break;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        //1，2出发，1返回，最后两名出发，2返回</span><br><span class="line">        int s1 = speed[1] + speed[0] + speed[left - 1] + speed[1];</span><br><span class="line">        //1，3出发，1返回，1，4出发，1返回，1，2过河</span><br><span class="line">        int s2 = speed[left - 1] + speed[left - 2] + 2 * speed[0];</span><br><span class="line">        //其中s1和s2中都少写一个b，是因为在left==2的时候加上了 </span><br><span class="line">		ans += min(s1, s2);</span><br><span class="line">        left -= 2;//左侧是渡河的起点，left代表左侧的剩余人数</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<ul>
<li>8.2 区间调度问题<br>有n项工作,每项工作分别在si时间开始,在ti时间结束.<br>对于每项工作,你都可以选择参与与否.如果选择了参与,那么自始至终都必须全程参与.<br>此外,参与工作的时间段不能重复(即使是开始的瞬间  和结束的瞬间的重叠也是不允许的).<br>你的目标是参与尽可能多的工作,那么最多能参与多少项工作呢?<br>1≤n≤100000<br>1≤si≤ti≤10^9</li>
</ul>
<p>输入:<br>第一行:n<br>第二行:n个整数空格隔开,代表n个工作的开始时间<br>第三行:n个整数空格隔开,代表n个工作的结束时间   </p>
<p>样例输入:<br>5<br>1 3 1 6 8<br>3 5 2 9 10<br>样例输出:<br>3   </p>
<p>说明:选取工作1,3,5    </p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-234.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">//方法二：按左端点从大到小来排列 </span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=110;</span><br><span class="line">struct Inteval&#123;</span><br><span class="line">	int x,y;//开区间的左右端点 </span><br><span class="line">&#125;I[maxn];</span><br><span class="line">bool cmp(Inteval a,Inteval b)&#123;</span><br><span class="line">	if(a.x!=b.x)return a.x&gt;b.x;//先按左端点从大到小排</span><br><span class="line">	else return a.y&lt;b.y;//左端点相同按右端点从小到大排列 </span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int n;</span><br><span class="line">	while(cin&gt;&gt;n&amp;&amp;n!=0)&#123;</span><br><span class="line">		for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">			cin&gt;&gt;I[i].x&gt;&gt;I[i].y;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(I,I+n,cmp);//把区间排序</span><br><span class="line">		int ans=1;int lastX=I[0].x;</span><br><span class="line">		for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">			id(I[i].y&lt;=lastX)&#123;//若果该区间右端点在lastX的左边 </span><br><span class="line">				lastX=I[i].x;//以I[i]作为新选中的区间 </span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">方法一java实现的：</span><br><span class="line">private static int f(int n, Job[] jobs) &#123;</span><br><span class="line">    int cnt = 1;</span><br><span class="line">    int y = jobs[0].t;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">      if (jobs[i].s &gt; y) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        y = jobs[i].t;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">  &#125; </span><br><span class="line">*/ </span><br></pre></td></tr></table></figure>

<ul>
<li>8.3 区间选点问题-POJ1201<br>数轴上有n个闭区间[ai,bi]。取尽量少的点，使得每个区间内都至少有一个点（不同区间内含的点可以是同一个）。</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-227.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">//用树状数组才可以不超时</span><br><span class="line">public class Case04_区间选点问题II &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Scanner sc = new Scanner(System.in);</span><br><span class="line">    int n = sc.nextInt();</span><br><span class="line">    Interval[] intervals = new Interval[n];</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">      intervals[i] = new Interval(sc.nextInt(), sc.nextInt(), sc.nextInt());</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(intervals);//按区间右端点排序</span><br><span class="line"></span><br><span class="line">    int max = intervals[n - 1].t;//右端最大值</span><br><span class="line">    int[] axis = new int[max + 1];</span><br><span class="line">    int[] c = new int[max + 2];</span><br><span class="line">    // int[] sums = new int[max + 1];</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">      //1.查阅区间中有多少个点</span><br><span class="line">      int s = intervals[i].s;//起点</span><br><span class="line">      int t = intervals[i].t;//终点</span><br><span class="line">      int cnt = sum(t + 1, c, max + 1) - sum(s, c, max + 1);//sum(axis,s,t);//sums[t] - sums[s - 1];//效率低</span><br><span class="line">      //  2.如果不够，从区间右端开始标记，遇标记过的就跳过</span><br><span class="line">      intervals[i].c -= cnt;</span><br><span class="line">      while (intervals[i].c &gt; 0) &#123;</span><br><span class="line">        if (axis[t] == 0) &#123;</span><br><span class="line">          axis[t] = 1;</span><br><span class="line">          update(t + 1, 1, c, max + 1);</span><br><span class="line">          intervals[i].c--;</span><br><span class="line">          t--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          t--;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum(max + 2, c, max + 1));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 更新树状数组c，注意i是项数，不是下标，而是下标+1*/</span><br><span class="line">  private static void update(int i, int delta, int[] c, int n) &#123;</span><br><span class="line">    for (; i &lt;= n; i += lowbit(i)) &#123;</span><br><span class="line">      c[i] += delta;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 前i项和，注意：i不是下标</span><br><span class="line">   * @param i</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  private static int sum(int i, int[] c, int n) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    if (i &gt; n)</span><br><span class="line">      i = n;</span><br><span class="line">    for (; i &gt; 0; i -= lowbit(i)) &#123;</span><br><span class="line">      sum += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 它通过公式来得出k，其中k就是该值从末尾开始1的位置。</span><br><span class="line">   * 然后将其得出的结果加上x自身就可以得出当前节点的父亲节点的位置</span><br><span class="line">   * 或者是x减去其结果就可以得出上一个父亲节点的位置。</span><br><span class="line">   * 比如当前是6，二进制就是0110，k为2，那么6+2=8，C(8)则是C(6)的父亲节点的位置；</span><br><span class="line">   * 相反，6-2=4，则是C(6)的上一个父亲节点的位置。*/</span><br><span class="line">  static int lowbit(int x) &#123;</span><br><span class="line">    return x - (x &amp; (x - 1));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static class Interval implements Comparable&lt;Interval&gt; &#123;</span><br><span class="line">    int s;</span><br><span class="line">    int t;</span><br><span class="line">    int c;</span><br><span class="line"></span><br><span class="line">    public Interval(int s, int t, int c) &#123;</span><br><span class="line">      this.s = s;</span><br><span class="line">      this.t = t;</span><br><span class="line">      this.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Interval other) &#123;</span><br><span class="line">      int x = this.t - other.t;</span><br><span class="line">      if (x == 0)</span><br><span class="line">        return this.s - other.s;</span><br><span class="line">      else</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>8.4 区间覆盖问题 -poj2376<br>选最少的区间片段覆盖这一整个区域，问最少的区间数是多少？<br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-232.png" alt="upload successful"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class Case05_区间覆盖问题 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Scanner sc = new Scanner(System.in);</span><br><span class="line">    int N = sc.nextInt();</span><br><span class="line">    int T = sc.nextInt();</span><br><span class="line">    Job[] jobs = new Job[N];</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">      jobs[i] = new Job(sc.nextInt(), sc.nextInt());</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(jobs);</span><br><span class="line">    int start = 1;//要覆盖的目标点，end覆盖该点的所有区间中右端点最右</span><br><span class="line">    int end = 1;</span><br><span class="line">    int ans = 1;</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line"></span><br><span class="line">      int s = jobs[i].s;</span><br><span class="line">      int t = jobs[i].t;</span><br><span class="line"></span><br><span class="line">      if (i == 0 &amp;&amp; s &gt; 1) break;</span><br><span class="line"></span><br><span class="line">      if (s &lt;= start) &#123;//当前区间有可能覆盖start</span><br><span class="line">        end = max(t, end);//更新更右的端点</span><br><span class="line">      &#125; else &#123;//开始下一个区间</span><br><span class="line">        ans++;//上一个目标覆盖已经达成，计数加1</span><br><span class="line">        start = end + 1;//更新起点，设置一个新的覆盖目标</span><br><span class="line">        if (s &lt;= start) &#123;</span><br><span class="line">          end = max(t, end);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (end &gt;= T) &#123;//当前的end超越了线段的右侧</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if (end &lt; T)</span><br><span class="line">      System.out.println(-1);</span><br><span class="line">    else</span><br><span class="line">      System.out.println(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static class Job implements Comparable&lt;Job&gt; &#123;</span><br><span class="line">    int s;</span><br><span class="line">    int t;</span><br><span class="line"></span><br><span class="line">    public Job(int s, int t) &#123;</span><br><span class="line">      this.s = s;</span><br><span class="line">      this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**按照区间起点排序*/</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Job other) &#123;</span><br><span class="line">      int x = this.s - other.s;</span><br><span class="line">      if (x == 0)</span><br><span class="line">        return this.t - other.t;</span><br><span class="line">      else</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字典序最小的问题（POJ-3617）"><a href="#字典序最小的问题（POJ-3617）" class="headerlink" title="字典序最小的问题（POJ - 3617）"></a>字典序最小的问题（POJ - 3617）</h4><p>字典序最小问题<br>给一个定长为N的字符串S,构造一个字符串T,长度也为N。<br>起初，T是一个空串，随后反复进行下列任意操作   </p>
<ol>
<li>从S的头部删除一个字符，加到T的尾部     </li>
<li>从S的尾部删除一个字符，加到T的尾部<br>目标是最后生成的字符串T的字典序尽可能小<br>1≤N≤2000<br>字符串S只包含大写英文字母<br>输入：字符串S<br>输出：字符串T<br> 要求每80个字符换行输出</li>
</ol>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-235.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Case06_字典序最小问题 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Scanner sc = new Scanner(System.in);</span><br><span class="line">    int N = sc.nextInt();</span><br><span class="line">    StringBuilder ss = new StringBuilder();</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">      ss.append(sc.next());</span><br><span class="line">    &#125;</span><br><span class="line">    // String s = sc.nextLine();</span><br><span class="line">    f(ss.toString());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static void f(String s) &#123;</span><br><span class="line">    String s1 = new StringBuilder(s).reverse().toString();</span><br><span class="line">    int N = s.length();</span><br><span class="line">    StringBuilder rs = new StringBuilder();</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    while (rs.length() &lt; N) &#123;</span><br><span class="line">      if (s.compareTo(s1) &lt;= 0) &#123;</span><br><span class="line">        rs.append(s.charAt(0));</span><br><span class="line">        s = s.substring(1);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        rs.append(s1.charAt(0));</span><br><span class="line">        s1 = s1.substring(1);</span><br><span class="line">      &#125;</span><br><span class="line">      //字符满80个就换行</span><br><span class="line">      if (rs.length() % 80 == 0) &#123;</span><br><span class="line">        System.out.println(rs.substring(cnt * 80, (cnt + 1) * 80));</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //余数部分</span><br><span class="line">    if (rs.length() &gt; cnt * 80) &#123;</span><br><span class="line">      System.out.println(rs.substring(cnt * 80));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h4><ul>
<li>背包问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 给出n个物体，第i个物体重量为wi。选择尽量多的物体，不能取一部分，使得总重量不超过C。</span><br><span class="line"> * 01背包</span><br><span class="line"> */</span><br><span class="line">public class Case07_最优装载问题 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Scanner sc = new Scanner(System.in);</span><br><span class="line">    int n = sc.nextInt();</span><br><span class="line">    int[] w = new int[n];</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">      w[i] = sc.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">    int C = sc.nextInt();</span><br><span class="line"></span><br><span class="line">    Arrays.sort(w);</span><br><span class="line">    int ans = f(n, w, C);</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static int f(int n, int[] w, int c) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">      sum += w[i];</span><br><span class="line">      if (sum &lt;= c) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return cnt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>部分背包（部分指的是一个物体可以取一部分）</li>
</ul>
<p>有n个物体，第i个物体的重量为wi，价值为vi。在总重量不超过C的情况下让总价值尽量高。<br> 每一个物体都可以只取走一部分，价值和重量按比例计算。<br> 求最大总价值<br> 注意：每个物体可以只拿一部分，因此一定可以让总重量恰好为C。   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class Case08_部分背包问题 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    int[] w = &#123;1, 2, 3, 4, 5&#125;;//背包中物体的重量</span><br><span class="line">    int[] v = &#123;3, 4, 3, 1, 4&#125;;//物体的价值</span><br><span class="line">    int n = w.length;</span><br><span class="line">    double C = 10;//背包的容量</span><br><span class="line">    Obj[] objs = new Obj[n];</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">      objs[i] = new Obj(w[i], v[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(objs);</span><br><span class="line">    double c = C;</span><br><span class="line">    double maxValue = 0;</span><br><span class="line">    for (int i = n - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">      if (objs[i].w &lt;= c) &#123;//每一次判断一下当前背包的容量是否还可以继续装一个物体</span><br><span class="line">        maxValue += objs[i].v;</span><br><span class="line">        c -= objs[i].w;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        maxValue += objs[i].v * (c / objs[i].w);//取全部的会超重，所以只取一部分</span><br><span class="line">        break;//取完这一部分，就装满了</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(maxValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private static class Obj implements Comparable&lt;Obj&gt; &#123;</span><br><span class="line">    int w;</span><br><span class="line">    int v;</span><br><span class="line"></span><br><span class="line">    public Obj(int w, int v) &#123;</span><br><span class="line">      this.w = w;</span><br><span class="line">      this.v = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice() &#123;</span><br><span class="line">      return v / (double) w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int compareTo(Obj o) &#123;</span><br><span class="line">      if (this.getPrice() == o.getPrice()) return 0;</span><br><span class="line">      else if (this.getPrice() &lt; o.getPrice()) return -1;</span><br><span class="line">      else return 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="乘船问题"><a href="#乘船问题" class="headerlink" title="乘船问题"></a>乘船问题</h4><p>有n个人，第i个人重量为wi。每艘船的最大载重量均为C，且最多只能乘两个人。用最少的船装载所有人。 求需要船的数量   </p>
<p> 贪心策略：考虑最轻的人i，如果每个人都无法和他一起坐船（重量和超过C），则唯一的方案是每个人坐一艘<br> 否则，他应该选择能和他一起坐船的人中最重的一个j     </p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> public class Case09_乘船问题 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    int[] w = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;</span><br><span class="line">    int n = w.length;</span><br><span class="line">    int c = 10;</span><br><span class="line"></span><br><span class="line">    Arrays.sort(w);</span><br><span class="line">    int cntOfPerson = n;</span><br><span class="line">    int cntOfBoat = 0;</span><br><span class="line">    int p1 = 0;//两个指针分别指向头和尾</span><br><span class="line">    int p2 = n - 1;</span><br><span class="line">    while (cntOfPerson &gt; 0) &#123;</span><br><span class="line">      if (p1 + p2 &gt; c) &#123;</span><br><span class="line">        p2--;//如果两个人的重量大于c，那么只能中的那个人自己走  </span><br><span class="line">        cntOfPerson--;</span><br><span class="line">        cntOfBoat++;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        p1++;</span><br><span class="line">        p2--;</span><br><span class="line">        cntOfPerson -= 2;</span><br><span class="line">        cntOfBoat++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(cntOfBoat);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="以上贪心策略的总结"><a href="#以上贪心策略的总结" class="headerlink" title="以上贪心策略的总结"></a>以上贪心策略的总结</h4><p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-236.png" alt="upload successful"></p>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><ul>
<li>什么是动态规划</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-240.png" alt="upload successful"></p>
<ul>
<li>01背包问题的三种解法：<br>其中dp解法的图表为：</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-237.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">有n个重量和价值分别为wi，vi的物品，从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。</span><br><span class="line">    1≤n≤100</span><br><span class="line">    1≤wi，vi≤100</span><br><span class="line">    1≤W≤10000</span><br><span class="line">输入：</span><br><span class="line">    n=4</span><br><span class="line">    (w,v)=&#123;(2,3),(1,2),(3,4),(2,2)&#125;</span><br><span class="line">    W=5</span><br><span class="line">输出：</span><br><span class="line">    7（选择第0，1，3号物品）</span><br><span class="line"></span><br><span class="line">因为对每个物品只有选和不选两种情况，所以这个问题称为01背包。</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line">public class Case10_01背包问题 &#123;</span><br><span class="line">  static int[] w = &#123;2, 1, 3, 2&#125;;//重量表</span><br><span class="line">  static int[] v = &#123;3, 2, 4, 2&#125;;//价值表</span><br><span class="line">  static int n = 4;//物品数量</span><br><span class="line">  static int W = 5;//背包的承重极限</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    int ww = W;</span><br><span class="line">    int ans = dfs(0, ww);</span><br><span class="line">    System.out.println(&quot;方法一:&quot;+ans);</span><br><span class="line"></span><br><span class="line">    rec = new int[n][W + 1];</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">      Arrays.fill(rec[i], -1);</span><br><span class="line">    &#125;</span><br><span class="line">    ww = W;</span><br><span class="line">    ans = m(0, ww);</span><br><span class="line">    System.out.println(&quot;方法二:&quot;+ans);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;方法三:&quot;+dp());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**方法一：dfs</span><br><span class="line">   * 2^n的复杂度</span><br><span class="line">   */</span><br><span class="line">  static int dfs(int i, int ww) &#123;//深搜的做法，每一个递归树都找一下</span><br><span class="line">    if (ww &lt;= 0) return 0;//装不进去</span><br><span class="line">    if (i == n) return 0;//没东西可选了</span><br><span class="line"></span><br><span class="line">    int v2 = dfs(i + 1, ww);//不选择当前物品</span><br><span class="line">    if (ww &gt;= w[i]) &#123;</span><br><span class="line">      int v1 = v[i] + dfs(i + 1, ww - w[i]);//选择当前物品</span><br><span class="line">      return max(v1, v2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return v2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  /**方法二：</span><br><span class="line">   * 记忆型递归</span><br><span class="line">   */</span><br><span class="line">  static int[][] rec;//记录的是递归树中某个节点的值</span><br><span class="line">  static int m(int i, int ww) &#123;</span><br><span class="line">    if (ww &lt;= 0) return 0;</span><br><span class="line">    if (i == n) return 0;</span><br><span class="line">    //1.计算之前先查询</span><br><span class="line">    if (rec[i][ww] &gt;= 0)</span><br><span class="line">      return rec[i][ww];</span><br><span class="line"></span><br><span class="line">    int v2 = m(i + 1, ww);//不选择当前物品</span><br><span class="line">    int ans;</span><br><span class="line">    if (ww &gt;= w[i]) &#123;</span><br><span class="line">      int v1 = v[i] + m(i + 1, ww - w[i]);//选择当前物品</span><br><span class="line">      ans = max(v1, v2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ans = v2;</span><br><span class="line">    &#125;</span><br><span class="line">    //2.计算之后做保存</span><br><span class="line">    rec[i][ww] = ans;</span><br><span class="line">    return ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  //方法三：dp</span><br><span class="line">  static int dp() &#123;</span><br><span class="line">    int[][] dp = new int[n][W + 1];</span><br><span class="line">    //初始化dp表的第一行</span><br><span class="line">    for (int i = 0; i &lt; W + 1; i++) &#123;//i为每一列的值，就是容量的大小</span><br><span class="line">      if (i &gt;= w[0]) &#123;// 每种容量-0号物品，大于0就表示要的起</span><br><span class="line">        dp[0][i] = v[0];</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        dp[0][i] = 0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //  其他行，下面的for中i为行号</span><br><span class="line">    for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">      // j是列，也是背包的剩余容量</span><br><span class="line">      for (int j = 0; j &lt; W + 1; j++) &#123;</span><br><span class="line">        if (j &gt;= w[i]) &#123;//要得起</span><br><span class="line">          int i1 = v[i] + dp[i - 1][j - w[i]];//选择当前物品即i号物品的价值+上一步剩余容量所能达到的最大价值</span><br><span class="line">          int i2 = dp[i - 1][j];//不选本件物品所能达到的最大价值</span><br><span class="line">          dp[i][j] = max(i1, i2);//取两者的最大值</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          dp[i][j] = dp[i - 1][j];//要不起，就直接赋值为j所能取得最大价值</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n - 1][W];//最后一个单元格的值就是最终结果</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h4 id="钢条切割问题-算法导论"><a href="#钢条切割问题-算法导论" class="headerlink" title="钢条切割问题 算法导论"></a>钢条切割问题 算法导论</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Serling公司购买长钢条，将其切割为短钢条出售。切割工序本身没有成本支出。公司管理层希望知道最佳的切割方案。</span><br><span class="line">假定我们知道Serling公司出售一段长为i英寸的钢条的价格为pi(i=1,2,…，单位为美元)。钢条的长度均为整英寸。</span><br><span class="line"></span><br><span class="line">| 长度i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |</span><br><span class="line">| - | - | - | - | - | - | - | - | - | - |</span><br><span class="line">价格pi | 1 | 5 | 8 | 16 | 10 | 17 | 17 | 20 | 24 | 30 |</span><br><span class="line"></span><br><span class="line">钢条切割问题是这样的：给定一段长度为n英寸的钢条和一个价格表pi(i=1,2,…n)，求切割钢条方案，使得销售收益rn最大。</span><br><span class="line">注意，如果长度为n英寸的钢条的价格pn足够大，最优解可能就是完全不需要切割。</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line">public class Case11_钢条切割 &#123;</span><br><span class="line">  static int n = 10;</span><br><span class="line">  static int[] p = &#123;1, 5, 8, 16, 10, 17, 17, 20, 24, 30&#125;;</span><br><span class="line"></span><br><span class="line">  static int[] vs = new int[n + 1];</span><br><span class="line"></span><br><span class="line">  /**记忆性递归</span><br><span class="line">   * @param x 钢条的长度</span><br><span class="line">   */</span><br><span class="line">  static int r(int x) &#123;</span><br><span class="line">    if (x == 0) &#123;</span><br><span class="line">      return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt;= x; i++) &#123;</span><br><span class="line">      if (vs[x - i] == -1)//先查，没有的话再递归</span><br><span class="line">        vs[x - i] = r(x - i);</span><br><span class="line">     </span><br><span class="line">      int v = p[i - 1] + vs[x - i];//保留一段为整段，然后剩下的进行递归来求解，很巧妙</span><br><span class="line">      ans = max(v, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    vs[x] = ans;//递归之后，赋值</span><br><span class="line">    return ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static int dp() &#123;</span><br><span class="line">    vs[0] = 0;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++) &#123;//拥有的钢条长度</span><br><span class="line">      for (int j = 1; j &lt;= i; j++) &#123;//保留j为整段</span><br><span class="line">        vs[i] = max(p[j - 1] + vs[i - j], vs[i]);</span><br><span class="line">      &#125; //区别01背包中只有取和不取两种状态，而这个里为取一段和剩下一段来递归的两种分解方式</span><br><span class="line">    &#125;</span><br><span class="line">    return vs[n];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Arrays.fill(vs, -1);</span><br><span class="line">    int ans = r(n);</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">    Arrays.fill(vs, 0);</span><br><span class="line"></span><br><span class="line">    ans = dp();</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h4><p>可以把一个二维数组简化为一个一维数组，因为上面这一个值的大小不取决于它的左侧，所以<br>覆盖了没有影响，这就是滚动数组。<br>其中数字三角形是位置在改变，而钢条切割是长度在变，01背包是容量在变</p>
<p><img src="/myblog/%5Caoyue%5Cimages%5C202002022111.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 数字三角形(POJ1163)&lt;br&gt;</span><br><span class="line"> *</span><br><span class="line"> * 在数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。&lt;br&gt;</span><br><span class="line"> * 路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。&lt;br&gt;</span><br><span class="line"> * 三角形的行数大于1小于等于100，数字为 0 - 99&lt;br&gt;</span><br><span class="line"> * 输入格式：&lt;br&gt;</span><br><span class="line"> * 5 //表示三角形的行数 接下来输入三角形&lt;br&gt;</span><br><span class="line"> *      7&lt;br&gt;</span><br><span class="line"> *     3 8&lt;br&gt;</span><br><span class="line"> *    8 1 0&lt;br&gt;</span><br><span class="line"> *   2 7 4 4&lt;br&gt;</span><br><span class="line"> *  4 5 2 6 5&lt;br&gt;</span><br><span class="line"> * 要求输出最大和&lt;br&gt;</span><br><span class="line"> *</span><br><span class="line"> * @author zhengwei</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Case12_POJ1163_数字三角形 &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    // int[][] triangle = &#123;</span><br><span class="line">    //     &#123;7&#125;,</span><br><span class="line">    //     &#123;3, 8&#125;,</span><br><span class="line">    //     &#123;8, 1, 0&#125;,</span><br><span class="line">    //     &#123;2, 7, 4, 4&#125;,</span><br><span class="line">    //     &#123;4, 5, 2, 6, 5&#125;,</span><br><span class="line">    //     &#123;4, 5, 2, 6, 5, 7&#125;,</span><br><span class="line">    //     &#123;4, 13, 12, 88, 6, 6, 5&#125;,</span><br><span class="line">    //     &#123;3, 8, 7, 11, 9, 22, 66, 3&#125;,</span><br><span class="line">    // &#125;;</span><br><span class="line">    // Instant now = Instant.now();</span><br><span class="line">    // System.out.println(maxSumUsingRecursive(triangle, 0, 0));</span><br><span class="line">    // System.out.println(&quot;持续时间为：&quot; + Duration.ofMillis(Instant.now().toEpochMilli() - now.toEpochMilli()).getSeconds());</span><br><span class="line">    // now = Instant.now();</span><br><span class="line">    // System.out.println(maxSumUsingMemory(triangle, 0, 0, new int[8][8]));</span><br><span class="line">    // System.out.println(&quot;持续时间为：&quot; + Duration.ofMillis(Instant.now().toEpochMilli() - now.toEpochMilli()).getSeconds());</span><br><span class="line">    Scanner sc = new Scanner(System.in);</span><br><span class="line">    int n = sc.nextInt();</span><br><span class="line">    int[][] triangle = new int[n][];</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">      triangle[i] = new int[i + 1];</span><br><span class="line">      for (int j = 0; j &lt; i + 1; j++) &#123;</span><br><span class="line">        triangle[i][j] = sc.nextInt();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(maxSumUsingDp(triangle, 0, 0));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   *</span><br><span class="line">   * @param triangle</span><br><span class="line">   *          数字三角形</span><br><span class="line">   * @param i</span><br><span class="line">   *          起点行号</span><br><span class="line">   * @param j</span><br><span class="line">   *          起点列号</span><br><span class="line">   * @return 计算出的最大和</span><br><span class="line">   */</span><br><span class="line">  public static int maxSumUsingRecursive(int[][] triangle, int i, int j) &#123;</span><br><span class="line">    int rowIndex = triangle.length;</span><br><span class="line">    if (i == rowIndex - 1) &#123;</span><br><span class="line">      return triangle[i][j];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //顶点的值+max(左侧支线的最大值，右侧支路的最大值)</span><br><span class="line">      return triangle[i][j]</span><br><span class="line">          + max(maxSumUsingRecursive(triangle, i + 1, j),</span><br><span class="line">          maxSumUsingRecursive(triangle, i + 1, j + 1));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 记忆型递归</span><br><span class="line">   * @param triangle</span><br><span class="line">   * @param i</span><br><span class="line">   * @param j</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  public static int maxSumUsingMemory(int[][] triangle, int i, int j, int[][] map) &#123;</span><br><span class="line">    int rowIndex = triangle.length;</span><br><span class="line">    int value = triangle[i][j];</span><br><span class="line">    if (i == rowIndex - 1) &#123;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //缓存有值，便不递归</span><br><span class="line">      int v1 = map[i + 1][j];</span><br><span class="line">      if (v1 == 0) &#123;</span><br><span class="line">        v1 = maxSumUsingMemory(triangle, i + 1, j, map);</span><br><span class="line">      &#125;</span><br><span class="line">      //缓存有值，便不递归</span><br><span class="line">      int v2 = map[i + 1][j + 1];</span><br><span class="line">      if (v2 == 0) &#123;</span><br><span class="line">        v2 = maxSumUsingMemory(triangle, i + 1, j + 1, map);</span><br><span class="line">      &#125;</span><br><span class="line">      value = value</span><br><span class="line">          + max(v1, v2);</span><br><span class="line">    &#125;</span><br><span class="line">    //放入缓存</span><br><span class="line">    map[i][j] = value;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  public static int maxSumUsingDp(int[][] triangle, int i, int j) &#123;</span><br><span class="line">    int rowCount = triangle.length;//行数</span><br><span class="line">    int columnCount = triangle[rowCount - 1].length;//最后一行的列数</span><br><span class="line">    int[] dp = new int[columnCount];//利用滚动数组来做</span><br><span class="line">    for (int k = 0; k &lt; columnCount; k++) &#123;</span><br><span class="line">      dp[k] = triangle[rowCount - 1][k];//初始化最后一行</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int k = rowCount - 2; k &gt;= 0; k--) &#123;</span><br><span class="line">      for (int l = 0; l &lt;= k; l++) &#123;</span><br><span class="line">        dp[l] = triangle[k][l] + max(dp[l], dp[l + 1]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[0];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最长间断子序列"><a href="#最长间断子序列" class="headerlink" title="最长间断子序列"></a>最长间断子序列</h4><p><img src="/myblog/%5Caoyue%5Cimages%5C202002021950.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 求最大公共子序列问题</span><br><span class="line"> * AB34C</span><br><span class="line"> * A1BC2 结果为 ABC</span><br><span class="line"> * 更多案例请看测试用例</span><br><span class="line"> * */</span><br><span class="line">public class Case13_LCS &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Case13_LCS obj = new Case13_LCS();</span><br><span class="line">    // System.out.println(obj.solution(&quot;AB34C&quot;, &quot;A1BC2&quot;));</span><br><span class="line">    // Assertions.assertThat(obj.solution(&quot;3563243&quot;, &quot;513141&quot;)).isEqualTo(&quot;534&quot;);</span><br><span class="line">    // Assertions.assertThat(obj.solution(&quot;3069248&quot;, &quot;513164318&quot;)).isEqualTo(&quot;3648&quot;);//断言</span><br><span class="line">    ArrayList ans = obj.dfs(&quot;AB34C&quot;, &quot;A1BC2&quot;);</span><br><span class="line">    System.out.println(ans);</span><br><span class="line">    System.out.println(obj.dfs(&quot;3563243&quot;, &quot;513141&quot;));</span><br><span class="line">    System.out.println(obj.dfs(&quot;3069248&quot;, &quot;513164318&quot;));</span><br><span class="line">    System.out.println(obj.dfs(&quot;123&quot;, &quot;456&quot;));</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  //用dfs来暴力求解</span><br><span class="line">  ArrayList&lt;Character&gt; dfs(String s1, String s2) &#123;</span><br><span class="line">    int len1 = s1.length();</span><br><span class="line">    int len2 = s2.length();</span><br><span class="line">    ArrayList&lt;Character&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; len1; i++) &#123;</span><br><span class="line">      //求以i字符开头的公共子序列</span><br><span class="line">      ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">      //和s2的每个字符比较</span><br><span class="line">      for (int j = 0; j &lt; len2; j++) &#123;</span><br><span class="line">        if (s1.charAt(i) == s2.charAt(j)) &#123;//如果相同</span><br><span class="line">          list.add(s1.charAt(i));</span><br><span class="line">          list.addAll(dfs(s1.substring(i + 1), s2.substring(j + 1)));</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (list.size() &gt; ans.size()) &#123;</span><br><span class="line">        ans = list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * 生成动规表</span><br><span class="line">   * @param s1</span><br><span class="line">   * @param s2</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  String solution(String s1, String s2) &#123;</span><br><span class="line">    int len1 = s1.length();</span><br><span class="line">    int len2 = s2.length();</span><br><span class="line">    int[][] dp = new int[len1 + 1][len2 + 1]; // 动规数组</span><br><span class="line">    int flag = 0;</span><br><span class="line">    // 初始化第一列</span><br><span class="line">    //O(M)</span><br><span class="line">    for (int i = 1; i &lt;= len1; i++) &#123;</span><br><span class="line">      if (flag == 1) &#123;//如果历史上有过1或者比较的两者相等的时候就为1</span><br><span class="line">        dp[i][1] = 1;</span><br><span class="line">      &#125; else if (s1.charAt(i - 1) == s2.charAt(0)) &#123;</span><br><span class="line">        dp[i][1] = 1;</span><br><span class="line">        flag = 1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        dp[i][1] = 0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flag = 0;</span><br><span class="line">    //初始化第一行</span><br><span class="line">    //O(N)</span><br><span class="line">    for (int j = 1; j &lt;= len2; j++) &#123;</span><br><span class="line">      if (flag == 1) &#123;</span><br><span class="line">        dp[1][j] = 1;</span><br><span class="line">      &#125; else if (s2.charAt(j - 1) == s1.charAt(0)) &#123;</span><br><span class="line">        dp[1][j] = 1;</span><br><span class="line">        flag = 1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        dp[1][j] = 0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //O(M*N)</span><br><span class="line">    for (int i = 2; i &lt;= len1; i++) &#123;  // M</span><br><span class="line">      for (int j = 2; j &lt;= len2; j++) &#123;  // N</span><br><span class="line">        int maxOfLeftAndUp = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">        if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123;</span><br><span class="line">          // dp[i][j] = Math.max(maxOfLeftAndUp, dp[i - 1][j - 1] + 1);</span><br><span class="line">          dp[i][j] = dp[i - 1][j - 1] + 1;//若果比较的两个字符相等，那么等于左上角的数值+1</span><br><span class="line">        &#125; else &#123;//如果比较的不相等，那么等于上，左上，左三者的最大值</span><br><span class="line">          dp[i][j] = maxOfLeftAndUp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // Util.printMatrix(dp);</span><br><span class="line">    return parseDp(dp, s1, s2);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 解析动态规划表，得到最长公共子序列</span><br><span class="line">   * @param dp</span><br><span class="line">   * @param s1</span><br><span class="line">   * @param s2</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  private String parseDp(int[][] dp, String s1, String s2) &#123;</span><br><span class="line">    int M = s1.length();</span><br><span class="line">    int N = s2.length();</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    while (M &gt; 0 &amp;&amp; N &gt; 0) &#123;</span><br><span class="line">      // 比左和上大，一定是当前位置的字符相等</span><br><span class="line">      if (dp[M][N] &gt; Math.max(dp[M - 1][N], dp[M][N - 1])) &#123;</span><br><span class="line">        sb.insert(0, s1.charAt(M - 1));</span><br><span class="line">        M--;</span><br><span class="line">        N--;</span><br><span class="line">      &#125; else &#123;  // 一定选择的是左边和上边的大者，因为比较的两者不相同的时候贡献来自左上角</span><br><span class="line">        if (dp[M - 1][N] &gt; dp[M][N - 1]) &#123;</span><br><span class="line">          M--;  //往上移</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          N--; // 往左移</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return sb.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 物品数量无限</span><br><span class="line"> * 完全背包问题</span><br><span class="line"> * 首先在初始化最后一行的时候有所不同：初始化时，当只考虑一件物品a时，state[row][j] = values[row]*j/weight[row]</span><br><span class="line"> * 然后在递推的时候有些不同：state[row][j] = max&#123;state[row+1][j],state[row][j-weight[row]]+values[row]&#125;，即不抓时用现在的容量去匹配下面行</span><br><span class="line"> * 要抓的时候，先抓到这个物品的价值，然后用剩下的容量去匹配同一行，为什么匹配同一行，这是因为剩下的容量可以重复抓当前物品（不限数量）</span><br><span class="line"> *</span><br><span class="line"> * 同时必须理解，抓一个之后用剩余的容量重新考虑当前可选的所有物品其实包含了抓2个甚至更多的情况！！！</span><br><span class="line"> * @author zhengwei</span><br><span class="line"> */</span><br><span class="line">public class Case14_完全背包问题 &#123;</span><br><span class="line"></span><br><span class="line">  static int[] values = &#123;9, 5, 3, 1&#125;;</span><br><span class="line">  static int[] weights = &#123;7, 4, 3, 2&#125;;</span><br><span class="line">  static int n = 4;</span><br><span class="line">  static int total = 10;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    dp();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  static int[][] state = new int[n][total + 1];//不同的物品范围下不同的容量能装出来的最大价值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /***</span><br><span class="line">   * 递推</span><br><span class="line">   */</span><br><span class="line">  static void dp() &#123;</span><br><span class="line">    // row 行号</span><br><span class="line">    int row = n - 1;//此数组从下往上进行赋值的，从上往下也是一样的</span><br><span class="line">    //v是容量</span><br><span class="line">    int v = 1;</span><br><span class="line">    int w = weights[row];</span><br><span class="line">    for (; v &lt; total + 1; v++) &#123;</span><br><span class="line">      state[row][v] = values[row] * v / w;//dp数组的含义为当前当前这么大的容量所能取物品的最大价值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int r = row - 1; r &gt;= 0; r--) &#123;</span><br><span class="line">      //r 当前处理的行，也是当前处理的物品</span><br><span class="line">      w = weights[r];</span><br><span class="line">      for (int c = 1; c &lt; total + 1; c++) &#123;</span><br><span class="line">        //c 当前处理的容量</span><br><span class="line">        //背包的容量还足以取本物品时</span><br><span class="line">        if (c &gt;= w) &#123;</span><br><span class="line">          //  要要取本物品</span><br><span class="line">          int v1 = values[r] + state[r][c - w];//其实这个state[r][c - w]就包括了取一次，取两次</span><br><span class="line">          // 不取本物品</span><br><span class="line">          int v2 = state[r + 1][c];</span><br><span class="line">          state[r][c] = Math.max(v1, v2);</span><br><span class="line">        &#125; else &#123; // 不能抓</span><br><span class="line">          state[r][c] = state[r + 1][c];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(state[0][total]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://zouyunkai.github.io/myblog/2020/03/12/%E7%AE%97%E6%B3%95%E5%BE%88%E7%BE%8E/" title="算法很美" target="_blank" rel="external">https://zouyunkai.github.io/myblog/2020/03/12/算法很美/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/zouyunkai" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/myblog/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/zouyunkai" target="_blank"><span class="text-dark">云开</span><small class="ml-1x">Stay Hungry , Stay Foolish.</small></a></h3>
        <div>Stay Hungry , Stay Foolish.</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/myblog/2020/03/13/asp%E5%AE%9E%E9%AA%8C%E4%BA%8C/" title="asp实验二"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/myblog/2020/03/12/%E5%8F%8D%E6%B1%87%E7%BC%96/" title="反汇编"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/myblog/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/myblog/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/zouyunkai" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/zouyunkai" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/zouyunkai" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/zouyunkai" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/myblog/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/myblog/js/plugin.min.js"></script>


<script src="/myblog/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/myblog/',
        CONTENT_URL: '/myblog/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/myblog/js/insight.js"></script>



    <script>
(function ($) {
    $('.search-form').on('submit', function (e) {
        var keyword = $('.search-form-input[name="wd"]').val();
        window.location = 'https://www.baidu.com/s?wd=site:zouyunkai.github.io/myblog ' + keyword;
        return false;
    });
})(jQuery);
</script>




   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '9f5iImvmYajPaJ79pRkbVNU9-gzGzoHsz',
    appKey: 'n3qUzkAGTOqjKi9k5LKGLfgV',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>