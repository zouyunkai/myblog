<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>剑指offer-第五章-优化时间和空间效率 | Sweet@</title>
  <meta name="description" content="5.1 面试官谈效率5.2 时间效率 剑指Offer（39）：数组中出现次数超过一半的数字题目  数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。    思路 数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer-第五章-优化时间和空间效率">
<meta property="og:url" content="https://zouyunkai.github.io/myblog/2020/04/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87/index.html">
<meta property="og:site_name" content="Sweet@">
<meta property="og:description" content="5.1 面试官谈效率5.2 时间效率 剑指Offer（39）：数组中出现次数超过一半的数字题目  数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。    思路 数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1084.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1085.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1086.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1087.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1089.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1090.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1102.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1101.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1103.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1104.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1117.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1118.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1119.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1123.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1124.png">
<meta property="og:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1130.png">
<meta property="article:published_time" content="2020-04-13T03:50:00.000Z">
<meta property="article:modified_time" content="2022-02-26T03:52:51.859Z">
<meta property="article:author" content="zouqingzhi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zouyunkai.github.io/myblog/%5Caoyue%5Cimages%5Cpasted-1084.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://zouyunkai.github.io/myblog/2020/04/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Sweet@" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/myblog/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.0.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/zouyunkai" target="_blank">
          <img class="img-circle img-rotate" src="/myblog/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">云开</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Stay Hungry , Stay Foolish.</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/myblog/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/myblog/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/myblog/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/myblog/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/myblog/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/myblog/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/zouyunkai" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/zouyunkai" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/zouyunkai" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/zouyunkai" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/myblog/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E9%9D%A2%E8%AF%95/">面试</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/02/24/%E7%AE%80%E5%8E%86/" class="title">个人简历</a>
              </p>
              <p class="item-date">
                <time datetime="2022-02-24T13:46:00.000Z" itemprop="datePublished">2022-02-24</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E6%9D%82%E8%AE%B0/">杂记</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/01/25/%E5%85%B3%E4%BA%8E%E5%A4%87%E8%80%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/" class="title">关于备考的方法</a>
              </p>
              <p class="item-date">
                <time datetime="2022-01-25T13:29:00.000Z" itemprop="datePublished">2022-01-25</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/">所长的跨学科工具箱</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/01/19/01%E6%A8%A1%E6%9D%BF/" class="title">脑科学重要模型</a>
              </p>
              <p class="item-date">
                <time datetime="2022-01-19T13:29:00.000Z" itemprop="datePublished">2022-01-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/">所长的跨学科工具箱</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/01/19/01%E7%86%B5%E4%B8%8E%E7%83%AD%E5%8A%9B%E5%AD%A6%E9%87%8D%E8%A6%81%E6%A8%A1%E5%9E%8B/" class="title">熵增定理-世界演化之道</a>
              </p>
              <p class="item-date">
                <time datetime="2022-01-19T13:29:00.000Z" itemprop="datePublished">2022-01-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/">所长的跨学科工具箱</a>
              </p>
              <p class="item-title">
                <a href="/myblog/2022/01/19/02%E7%B3%BB%E7%BB%9F%E8%AE%BA%E9%87%8D%E8%A6%81%E6%A8%A1%E5%9E%8B/" class="title">系统思维 - 深刻认识世界</a>
              </p>
              <p class="item-date">
                <time datetime="2022-01-19T13:29:00.000Z" itemprop="datePublished">2022-01-19</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/myblog/tags/" style="font-size: 13px;">  </a> <a href="/myblog/tags/2019%E6%A0%A1%E8%B5%9B/" style="font-size: 13px;">2019校赛</a> <a href="/myblog/tags/BFS/" style="font-size: 13.2px;">BFS</a> <a href="/myblog/tags/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/" style="font-size: 13px;">C++字符串处理</a> <a href="/myblog/tags/CF/" style="font-size: 13px;">CF</a> <a href="/myblog/tags/DFS/" style="font-size: 13.2px;">DFS</a> <a href="/myblog/tags/DOM/" style="font-size: 13px;">DOM</a> <a href="/myblog/tags/DP/" style="font-size: 13px;">DP</a> <a href="/myblog/tags/FFT/" style="font-size: 13px;">FFT</a> <a href="/myblog/tags/KMP/" style="font-size: 13px;">KMP</a> <a href="/myblog/tags/boos/" style="font-size: 13px;">boos</a> <a href="/myblog/tags/c/" style="font-size: 13px;">c</a> <a href="/myblog/tags/c/" style="font-size: 13px;">c#</a> <a href="/myblog/tags/c/" style="font-size: 13.4px;">c++</a> <a href="/myblog/tags/codeforce/" style="font-size: 13.2px;">codeforce</a> <a href="/myblog/tags/comparable-and-comparator/" style="font-size: 13px;">comparable and comparator</a> <a href="/myblog/tags/crypto/" style="font-size: 13px;">crypto</a> <a href="/myblog/tags/c%E8%AF%AD%E8%A8%80%E5%B0%8F%E7%9F%A5%E8%AF%86/" style="font-size: 13px;">c语言小知识</a> <a href="/myblog/tags/git/" style="font-size: 13px;">git</a> <a href="/myblog/tags/html/" style="font-size: 13px;">html</a> <a href="/myblog/tags/iis%E9%85%8D%E7%BD%AE/" style="font-size: 13px;">iis配置</a> <a href="/myblog/tags/java/" style="font-size: 13.2px;">java</a> <a href="/myblog/tags/java-se/" style="font-size: 13.2px;">java se</a> <a href="/myblog/tags/java-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/" style="font-size: 13px;">java 深浅拷贝</a> <a href="/myblog/tags/java%E7%AE%97%E6%B3%95/" style="font-size: 13px;">java算法</a> <a href="/myblog/tags/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 13px;">java网络编程</a> <a href="/myblog/tags/js/" style="font-size: 13px;">js</a> <a href="/myblog/tags/linux%E6%95%99%E7%A8%8B/" style="font-size: 13px;">linux教程</a> <a href="/myblog/tags/mysql/" style="font-size: 13px;">mysql</a> <a href="/myblog/tags/param/" style="font-size: 13px;">param</a> <a href="/myblog/tags/qluoj/" style="font-size: 13px;">qluoj</a> <a href="/myblog/tags/sql/" style="font-size: 13px;">sql</a> <a href="/myblog/tags/stl/" style="font-size: 13px;">stl</a> <a href="/myblog/tags/web/" style="font-size: 13.2px;">web</a> <a href="/myblog/tags/%E4%BA%8C%E5%88%86%E6%B3%95/" style="font-size: 13px;">二分法</a> <a href="/myblog/tags/%E4%BA%94%E5%AD%90%E6%A3%8B/" style="font-size: 13px;">五子棋</a> <a href="/myblog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 13.2px;">动态规划</a> <a href="/myblog/tags/%E5%8D%95%E8%B0%83%E6%A0%88/" style="font-size: 13px;">单调栈</a> <a href="/myblog/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/" style="font-size: 13px;">单调队列</a> <a href="/myblog/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/" style="font-size: 13px;">博弈论</a> <a href="/myblog/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/" style="font-size: 13px;">哈夫曼编码</a> <a href="/myblog/tags/%E5%93%B2%E5%AD%A6/" style="font-size: 13px;">哲学</a> <a href="/myblog/tags/%E5%9B%BD%E7%8E%8B%E6%8C%96%E9%87%91%E5%AD%90/" style="font-size: 13px;">国王挖金子</a> <a href="/myblog/tags/%E5%9B%BE/" style="font-size: 13.2px;">图</a> <a href="/myblog/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 13px;">图论</a> <a href="/myblog/tags/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/" style="font-size: 13px;">大数运算</a> <a href="/myblog/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/" style="font-size: 13.2px;">小游戏</a> <a href="/myblog/tags/%E5%B1%B1%E7%90%86%E5%B7%A5/" style="font-size: 13px;">山理工</a> <a href="/myblog/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/" style="font-size: 13px;">快速幂</a> <a href="/myblog/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 13px;">排序算法</a> <a href="/myblog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 13.4px;">数据库</a> <a href="/myblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13px;">数据结构</a> <a href="/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/" style="font-size: 14px;">新生训练</a> <a href="/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83-02/" style="font-size: 13px;">新生训练_02</a> <a href="/myblog/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" style="font-size: 13.2px;">最小生成树</a> <a href="/myblog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" style="font-size: 13.2px;">最短路径</a> <a href="/myblog/tags/%E6%9D%AD%E7%94%B5/" style="font-size: 13px;">杭电</a> <a href="/myblog/tags/%E6%A0%88/" style="font-size: 13px;">栈</a> <a href="/myblog/tags/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96/" style="font-size: 13px;">棋盘覆盖</a> <a href="/myblog/tags/%E6%A8%A1%E6%9D%BF/" style="font-size: 13px;">模板</a> <a href="/myblog/tags/%E7%89%9B%E5%AE%A2/" style="font-size: 13.8px;">牛客</a> <a href="/myblog/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.2px;">算法</a> <a href="/myblog/tags/%E7%B4%A0%E6%95%B0/" style="font-size: 13px;">素数</a> <a href="/myblog/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/" style="font-size: 13px;">聊天室</a> <a href="/myblog/tags/%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9B/" style="font-size: 13px;">联盟周赛</a> <a href="/myblog/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" style="font-size: 13px;">背包问题</a> <a href="/myblog/tags/%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D/" style="font-size: 13px;">英文单词</a> <a href="/myblog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" style="font-size: 13px;">蓝桥杯</a> <a href="/myblog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%97%E6%B3%95/" style="font-size: 13px;">蓝桥杯算法</a> <a href="/myblog/tags/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B/" style="font-size: 13.6px;">蓝桥省赛</a> <a href="/myblog/tags/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/" style="font-size: 13px;">计网笔记</a> <a href="/myblog/tags/%E8%AE%AD%E7%BB%83/" style="font-size: 13.6px;">训练</a> <a href="/myblog/tags/%E8%B4%AA%E5%90%83%E8%9B%87/" style="font-size: 13px;">贪吃蛇</a> <a href="/myblog/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 13px;">贪心</a> <a href="/myblog/tags/%E9%80%92%E5%BD%92/" style="font-size: 13.4px;">递归</a> <a href="/myblog/tags/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/" style="font-size: 13px;">递归与分治</a> <a href="/myblog/tags/%E9%98%9F%E5%88%97/" style="font-size: 13px;">队列</a> <a href="/myblog/tags/%E9%9A%90%E5%86%99/" style="font-size: 13px;">隐写</a> <a href="/myblog/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 13px;">面试</a>
    </div>
  </div>

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-剑指offer-第五章-优化时间和空间效率" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      剑指offer-第五章-优化时间和空间效率
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/myblog/2020/04/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87/" class="article-date">
	  <time datetime="2020-04-13T03:50:00.000Z" itemprop="datePublished">2020-04-13</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/myblog/categories/%E5%89%91%E6%8C%87offer/">剑指offer</a>
  </span>

        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/myblog/2020/04/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h4 id="5-1-面试官谈效率"><a href="#5-1-面试官谈效率" class="headerlink" title="5.1 面试官谈效率"></a>5.1 面试官谈效率</h4><h4 id="5-2-时间效率"><a href="#5-2-时间效率" class="headerlink" title="5.2 时间效率"></a>5.2 时间效率</h4><ul>
<li>剑指Offer（39）：数组中出现次数超过一半的数字<br>题目</li>
</ul>
<p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。   </p>
<p>思路</p>
<p>数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现次数的和还要多。因此我们可以考虑在遍历数组的时候保存两个值：一个是数组的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，我们需要保存下一个数字，并把次数设为1。由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时对应的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        if(numbers.empty())&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历每个元素，并记录次数；若与前一个元素相同，则次数加1，否则次数减1</span><br><span class="line">        int result = numbers[0];</span><br><span class="line">        int times = 1;</span><br><span class="line">        for(int i = 1; i &lt; numbers.size(); ++i)&#123;</span><br><span class="line">            if(times == 0)&#123;</span><br><span class="line">                // 更新result的值为当前元素，并置次数为1</span><br><span class="line">                result = numbers[i];</span><br><span class="line">                times = 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(numbers[i] == result)&#123;</span><br><span class="line">                times++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                times--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断result是否符合条件，即出现次数大于数组长度的一半</span><br><span class="line">        times = 0;</span><br><span class="line">        for(int i = 0; i &lt; numbers.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(numbers[i] == result)&#123;</span><br><span class="line">                times++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (times &gt; (numbers.size() &gt;&gt; 1)) ? result : 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：基于partation函数的设计</p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1084.png" alt="upload successful"></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1085.png" alt="upload successful"></p>
<ul>
<li>剑指Offer（40） 求最小的k个数<br>最大堆O(nlogk)</li>
</ul>
<ol>
<li><p>首先选取前K个数建立最大堆（根结点值大于左右结点值）。</p>
</li>
<li><p>此后，每次从原数组中取一个元素与根进行比较，如果大于根结点的元素，忽视之，取下一个数组元素继续该过程；如果小于根结点的元素，则将其加入最大堆，并进行堆调整，将根元素移动到最后再删除，即保证最大堆中的元素仍然是排名前K的数，且根元素仍然最大。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        int sz = input.size();</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        if (sz == 0 || k &lt;= 0 || sz &lt; k)</span><br><span class="line">            return vec;</span><br><span class="line">        for (int i = 0; i &lt; k; ++i)</span><br><span class="line">            vec.push_back(input[i]);</span><br><span class="line">        // 以数组前k个元素建立初始的最大堆</span><br><span class="line">        make_heap(vec.begin(), vec.end(), less&lt;int&gt;());</span><br><span class="line">        for (int i = k; i &lt; sz; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (input[i] &gt; vec.front()) // 如果接下来的元素比堆顶元素大，直接跳过</span><br><span class="line">                continue;</span><br><span class="line">            else // 如果接下来的元素比堆顶元素小，则调整堆</span><br><span class="line">            &#123;</span><br><span class="line">                vec.push_back(input[i]);</span><br><span class="line">                // 添加新元素调整堆</span><br><span class="line">                push_heap(vec.begin(), vec.end());</span><br><span class="line">                // 将堆顶元素调整到最后</span><br><span class="line">                pop_heap(vec.begin(), vec.end());</span><br><span class="line">                // 删除最后那个元素</span><br><span class="line">                vec.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 以上方法得到的只是求了TopK，但是并未排序，所以使用sort_heap排序一下</span><br><span class="line">        sort_heap(vec.begin(), vec.end());</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【该算法有两个明显的优点】：<br> 没有修改输入的数据（代码中的变量data）。我们每次只是从data中读入数字，所有的写操作都是在容器leastNumbers中进行的。<br> 该算法适合海量数据的输入，不需要将数据一次性全部载入内存。</p>
<ul>
<li>方法二：<br>基于快排的算法O(n)</li>
</ul>
<ol>
<li><p>利用快速排序划分的思想，每一次划分就会有一个数字位于以数组从小到达排列的的最终位置location（假设下标从1开始）；</p>
</li>
<li><p>位于index左边的数字都小于location对应的值，右边都大于location指向的值；所以，当location&gt; k时，表示k个最小数字一定在location的左边，此时，只需要对location的左边进行划分即可；</p>
</li>
<li><p>当location&lt; k 时，说明location及location左边数字还没能满足k个数字，需要继续对location右边进行划分。</p>
</li>
<li><p>当index &#x3D; k 时，说明已划分完。</p>
</li>
</ol>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1086.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int partition(vector&lt;int&gt;&amp; arr, int low, int high)</span><br><span class="line">    &#123;</span><br><span class="line">        int pivot = arr[high]; // 选最后一个元素作为枢纽元</span><br><span class="line">        int location = low; // location放置的是最新的比枢纽元小的元素</span><br><span class="line">        for (int i = low; i &lt; high; i++) // 比枢纽元小的元素依次放在前半部分</span><br><span class="line">            if (arr[i] &lt; pivot)</span><br><span class="line">                swap(arr[i], arr[location++]); // 移动location</span><br><span class="line">        swap(arr[high], arr[location]); // 最后交换的是arr[high]，不是pivot</span><br><span class="line">        return location;</span><br><span class="line">    &#125;</span><br><span class="line">    void quick_sort(vector&lt;int&gt;&amp; arr, int low, int high, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        if (low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            int middle = partition(arr, low, high);</span><br><span class="line">            // 如果middle大于k-1，则说明arr[middle]右边的元素都大于k，于是只递归arr[low, middle-1]即可</span><br><span class="line">            if (middle &gt; k - 1)</span><br><span class="line">                quick_sort(arr, low, middle-1, k);</span><br><span class="line">            // 如果middle小于k-1，则说明arr[middle]左边的元素都小于k，于是只递归arr[middle+1, high]即可</span><br><span class="line">            if (middle &lt; k - 1)</span><br><span class="line">                quick_sort(arr, middle+1, high, k);</span><br><span class="line">            // 如果middle等于k-1说明前k个元素已经找到</span><br><span class="line">            if (middle == k - 1)</span><br><span class="line">                return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123;</span><br><span class="line">        int sz = input.size();</span><br><span class="line">        vector&lt;int&gt; vec;</span><br><span class="line">        if (sz == 0 || k &lt;= 0 || sz &lt; k)</span><br><span class="line">            return vec;</span><br><span class="line">        quick_sort(input, 0, input.size() - 1, k);</span><br><span class="line">        for (int i = 0; i &lt; k; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>快排的另外一种写法：</p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1087.png" alt="upload successful"></p>
<ul>
<li>剑指Offer（41）：数据流中的中位数</li>
</ul>
<p>题目</p>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。<br>1、思路</p>
<p>这道题的解法有很多，文本使用最大堆和最小堆实现。</p>
<p>主要思想：</p>
<p>最大堆 | 最小堆</p>
<p>我们将数据分为两部分，位于左边最大堆的数据比右边最小堆的数据要小，左、右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得到中位数。</p>
<p>接下来考虑用最大堆和最小堆实现的一些细节。</p>
<p>首先要保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过1.为了实现平均分配，可以在数据的总数目是偶数时把新数据插入到最小堆中，否则插入到最大堆中。</p>
<p>此外，还要保证最大堆中所有数据小于最小堆中数据。所以，新传入的数据需要先和最大堆的最大值或者最小堆中的最小值进行比较。以总数目为偶数为例，按照我们制定的规则，新的数据会被插入到最小堆中，但是在这之前，我们需要判断这个数据和最大堆中的最大值谁更大，如果最大堆中的数据比较大，那么我们就需要把当前数据插入最大堆，然后弹出新的最大值，再插入到最小堆中。由于最终插入到最小堆的数字是原最大堆中最大的数字，这样就保证了最小堆中所有数字都大于最大堆的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void Insert(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果已有数据为偶数，则放入最小堆</span><br><span class="line">        if(((max.size() + min.size()) &amp; 1) == 0)&#123;</span><br><span class="line">            // 如果插入的数字小于最大堆里的最大的数，则将数字插入最大堆</span><br><span class="line">            // 并将最大堆中的最大的数字插入到最小堆</span><br><span class="line">            if(max.size() &gt; 0 &amp;&amp; num &lt; max[0])&#123;</span><br><span class="line">                // 插入数据插入到最大堆数组</span><br><span class="line">                max.push_back(num);</span><br><span class="line">                // 调整最大堆</span><br><span class="line">                push_heap(max.begin(), max.end(), less&lt;int&gt;());</span><br><span class="line">                // 拿出最大堆中的最大数</span><br><span class="line">                num = max[0];</span><br><span class="line">                // 删除最大堆的栈顶元素</span><br><span class="line">                pop_heap(max.begin(), max.end(), less&lt;int&gt;());</span><br><span class="line">                max.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            // 将数据插入最小堆数组</span><br><span class="line">            min.push_back(num);</span><br><span class="line">            // 调整最小堆</span><br><span class="line">            push_heap(min.begin(), min.end(), greater&lt;int&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        // 已有数据为奇数，则放入最大堆</span><br><span class="line">        else&#123;</span><br><span class="line">            if(min.size() &gt; 0 &amp;&amp; num &gt; min[0])&#123;</span><br><span class="line">                // 将数据插入最小堆</span><br><span class="line">                min.push_back(num);</span><br><span class="line">                // 调整最小堆</span><br><span class="line">                push_heap(min.begin(), min.end(), greater&lt;int&gt;());</span><br><span class="line">                // 拿出最小堆的最小数</span><br><span class="line">                num = min[0];</span><br><span class="line">                // 删除最小堆的栈顶元素</span><br><span class="line">                pop_heap(min.begin(), min.end(), greater&lt;int&gt;());</span><br><span class="line">                min.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            // 将数据插入最大堆  </span><br><span class="line">            //pop_heap()把堆顶元素放到了最后一位，然后对它前面的数字重建了堆。</span><br><span class="line">            //这样一来只要再使用pop_back()把最后一位元素删除，就得到了新的堆</span><br><span class="line">            max.push_back(num);</span><br><span class="line">            push_heap(max.begin(), max.end(), less&lt;int&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    double GetMedian()</span><br><span class="line">    &#123;</span><br><span class="line">        // 统计数据大小</span><br><span class="line">        int size = min.size() + max.size();</span><br><span class="line">        if(size == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果数据为偶数</span><br><span class="line">        if((size &amp; 1) == 0)&#123;</span><br><span class="line">            return (min[0] + max[0]) / 2.0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 奇数</span><br><span class="line">        else&#123;</span><br><span class="line">            return min[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    // 使用vector建立最大堆和最小堆,min是最小堆数组,max是最大堆数组</span><br><span class="line">    vector&lt;int&gt; min;</span><br><span class="line">    vector&lt;int&gt; max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mytzs123/article/details/76099380">vector建立堆</a></p>
<ul>
<li>剑指Offer（42）：连续子数组的最大和<br>思路</li>
</ul>
<p>数组分析：下图是我们计算数组（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析我们发现，累加的子数组和，如果大于零，那么我们继续累加就行；否则，则需要剔除原来的累加和重新开始。</p>
<p>过程如下：</p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1089.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123;</span><br><span class="line">        if(array.empty())&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 初始化变量，maxSum为最大和，curSum为当前和</span><br><span class="line">        int maxSum = array[0];</span><br><span class="line">        int curSum = array[0];</span><br><span class="line">        // 遍历所有元素</span><br><span class="line">        for(int i = 1; i &lt; array.size(); i++)&#123;</span><br><span class="line">            // 如果当前和小于等于0，说明之前的是负数，则抛弃前面的和，重新计算</span><br><span class="line">            if(curSum &lt;= 0)&#123;</span><br><span class="line">                curSum = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果没有问题，直接累加</span><br><span class="line">            else&#123;</span><br><span class="line">                curSum += array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            // 更新最大和</span><br><span class="line">            if(curSum &gt; maxSum)&#123;</span><br><span class="line">                maxSum = curSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：动态规划方法</p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1090.png" alt="upload successful"></p>
<ul>
<li>剑指Offer（43 ）：整数中1出现的次数（从1到n整数中1出现的次数）<br>题目</li>
</ul>
<p>输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字有1，10，11和12，1一共出现了5次。<br>方法一：</p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1102.png" alt="upload successful"></p>
<p>方法二：<br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1101.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int NumberOf1Between1AndN_Solution(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        // 统计次数</span><br><span class="line">        int count = 0;</span><br><span class="line">        for(int i = 1; i &lt;= n; i *= 10)&#123;</span><br><span class="line">            // 计算高位和低位</span><br><span class="line">            int a = n / i, b = n % i;</span><br><span class="line">            count += (a + 8) / 10 * i + (a % 10 == 1) * (b + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>剑指Offer（44）：数字序列中某一位的数字</li>
</ul>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1103.png" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;unordered_map&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;sstream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define max_len 9</span><br><span class="line">int TheNthDigit(long long f[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    if(n &lt;= 9)</span><br><span class="line">        return n;</span><br><span class="line">    int pos = 0;</span><br><span class="line">    for(int i = 1; i &lt;= max_len ;i++)</span><br><span class="line">        if(f[i] &gt;= n)</span><br><span class="line">         &#123;</span><br><span class="line">             pos = i;</span><br><span class="line">             break;</span><br><span class="line">         &#125;</span><br><span class="line">    n = n - f[pos - 1];</span><br><span class="line">    int temp1 = n / pos;</span><br><span class="line">    int temp2 = n % pos;</span><br><span class="line">    int temp3 = temp1 + pow(10, pos - 1);</span><br><span class="line">    return (int)(temp3 / pow(10,pos - temp2 -1)) % 10;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long f[] = &#123;0,10,190,2890,38890,488890,5888890,68888890,788888890,8888888890&#125;;//初始化长度数组</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout&lt;&lt;TheNthDigit(f,n)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二（书上的写法）：</p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1104.png" alt="upload successful"></p>
<ul>
<li>剑指Offer（45）：把数组排成最小的数<br>题目</li>
</ul>
<p> 思路</p>
<p>遇到这个题，全排列当然可以做，但是时间复杂度为O(n!)。在这里我们自己定义一个规则，对拼接后的字符串进行比较。</p>
<p>排序规则如下：<br> 若ab &gt; ba 则 a 大于 b，<br> 若ab &lt; ba 则 a 小于 b，<br> 若ab &#x3D; ba 则 a 等于 b；</p>
<p>根据上述规则，我们需要先将数字转换成字符串再进行比较，因为需要串起来进行比较。比较完之后，按顺序输出即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string PrintMinNumber(vector&lt;int&gt; numbers) &#123;</span><br><span class="line">        int length = numbers.size();</span><br><span class="line">        if(length == 0)&#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(numbers.begin(), numbers.end(), cmp);</span><br><span class="line">        string res;</span><br><span class="line">        for(int i = 0; i &lt;　length; i++)&#123;</span><br><span class="line">            res += to_string(numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    // 升序排序</span><br><span class="line">    static bool cmp(int a, int b)&#123;</span><br><span class="line">        string A = to_string(a) + to_string(b);</span><br><span class="line">        string B = to_string(b) + to_string(a);</span><br><span class="line">        return A &lt; B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1117.png" alt="upload successful"></p>
<ul>
<li>剑指Offer（46）：把数字翻译成字符串<br>题目</li>
</ul>
<p>　</p>
<p>　　给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别”bccfi”, “bwfi”, “bczi”, “mcfi” 和”mzi” 。请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。<br>回到顶部<br>思路</p>
<p>　　看到题目，很容易想到使用递归：用f(i)来表示从第i位开始的不同翻译数目，可以得到有：f(i)&#x3D;f(i+1)+g(i,i+1)*f(i+2)。i和i+1位数字拼起来在10~25范围内时g(i,i+1)的值为1，否则为0。</p>
<p>　　但是存在重复的子问题，所以递归并非最佳方法，我们从数字的末尾开始计算f(i)，自下而上解决问题，就可以消除重复的子问题了。先算f(len-1)，f(len-2)，再根据公式f(i)&#x3D;f(i+1)+g(i,i+1)*f(i+2)往前逐步推导到f(0)，这就是最终要求的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">自上而下，从最大的问题开始，递归 ：</span><br><span class="line">                     12258</span><br><span class="line">                   /       \</span><br><span class="line">              b+2258       m+258</span><br><span class="line">              /   \         /   \</span><br><span class="line">          bc+258 bw+58  mc+58  mz+8</span><br><span class="line">          /  \      \        \     \</span><br><span class="line">      bcc+58 bcz+8   bwf+8   mcf+8  mzi</span><br><span class="line">        /        \       \     \</span><br><span class="line">   bccf+8        bczi    bwfi   mcfi</span><br><span class="line">     /</span><br><span class="line"> bccfi</span><br><span class="line">有很多子问题被多次计算，比如258被翻译成几种这个子问题就被计算了两次。</span><br><span class="line"></span><br><span class="line">自下而上，动态规划，从最小的问题开始 ：</span><br><span class="line">f(r)表示以r为开始（r最小取0）到最右端所组成的数字能够翻译成字符串的种数。对于长度为n的数字，f(n)=0,f(n-1)=1,求f(0)。</span><br><span class="line">递推公式为 f(r-2) = f(r-1)+g(r-2,r-1)*f(r)；</span><br><span class="line">其中，如果r-2，r-1能够翻译成字符，则g(r-2,r-1)=1，否则为0。</span><br><span class="line">因此，对于12258：</span><br><span class="line">f(5) = 0</span><br><span class="line">f(4) = 1</span><br><span class="line">f(3) = f(4)+0 = 1</span><br><span class="line">f(2) = f(3)+f(4) = 2</span><br><span class="line">f(1) = f(2)+f(3) = 3 </span><br><span class="line">f(0) = f(1)+f(2) = 5</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">public class P231_TranslateNumbersToStrings &#123;</span><br><span class="line">    public static int getTranslationCount(int number)&#123;</span><br><span class="line">        if(number&lt;0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(number==1)</span><br><span class="line">            return 1;</span><br><span class="line">        return getTranslationCount(Integer.toString(number));</span><br><span class="line">    &#125;</span><br><span class="line">    //动态规划，从右到左计算。</span><br><span class="line">    //f(r-2) = f(r-1)+g(r-2,r-1)*f(r);</span><br><span class="line">    //如果r-2，r-1能够翻译成字符，则g(r-2,r-1)=1，否则为0</span><br><span class="line">    public static int getTranslationCount(String number) &#123;</span><br><span class="line">        int f1 = 0,f2 = 1,g = 0;</span><br><span class="line">        int temp;</span><br><span class="line">        for(int i=number.length()-2;i&gt;=0;i--)&#123;</span><br><span class="line">            if(Integer.parseInt(number.charAt(i)+&quot;&quot;+number.charAt(i+1))&lt;26)</span><br><span class="line">                g = 1;</span><br><span class="line">            else</span><br><span class="line">                g = 0;</span><br><span class="line">            temp = f2;</span><br><span class="line">            f2 = f2+g*f1;</span><br><span class="line">            f1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return f2;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(getTranslationCount(-10));  //0</span><br><span class="line">        System.out.println(getTranslationCount(1234));  //3</span><br><span class="line">        System.out.println(getTranslationCount(12258)); //5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>（47）礼物的最大值<br>思路一：递归，定义一个函数f(i,j)用来表示到达坐标为(i,j)的格子时能拿到的礼物总和的最大值，根据题意只能从右走和下走，所以对当前点(i,j)来说，最大值只需比较左边和上面的。另外考虑当处在上边界和左边界的情况时只有一个方向可以走。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">	public static int getMaxValue(int[][]a)&#123;</span><br><span class="line">	</span><br><span class="line">		int max = 0;</span><br><span class="line">		int i = a.length;</span><br><span class="line">		int j = a[0].length;</span><br><span class="line">		max = sum(a,i,j);</span><br><span class="line">		return max;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private static int sum(int[][] a,int row,int col) &#123;</span><br><span class="line">	</span><br><span class="line">	//当来到左上角时，终止条件</span><br><span class="line">	if(row==1&amp;&amp;col==1)</span><br><span class="line">		return a[0][0];</span><br><span class="line">	//当来到上边界，只能往左走</span><br><span class="line">	if(row==1)</span><br><span class="line">		return sum(a, row, col-1)+a[row-1][col-1];</span><br><span class="line">	//当来到左边界，只能往上走</span><br><span class="line">	else if(col==1)</span><br><span class="line">		return sum(a, row-1, col) + a[row-1][col-1];</span><br><span class="line">	//否则判断是哪边大</span><br><span class="line">	else</span><br><span class="line">		return Math.max(sum(a, row, col-1), sum(a, row-1, col))+a[row-1][col-1];</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1118.png" alt="upload successful"></p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1119.png" alt="upload successful"></p>
<ul>
<li>（48）最长不含重复字符的子字符串</li>
</ul>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。例如，在字符串中”arabcacfr”，最长非重复子字符串为”acfr”，长度为4。</p>
<p><strong>主要思路：</strong>使用动态规划，记录当前字符之前的最长非重复子字符串长度f(i-1)，其中i为当前字符的位置。每次遍历当前字符时，分两种情况：</p>
<p>1）若当前字符第一次出现，则最长非重复子字符串长度f(i) &#x3D; f(i-1)+1。<br>2）若当前字符不是第一次出现，则首先计算当前字符与它上次出现位置之间的距离d。若d大于f(i-1)，即说明前一个非重复子字符串中没有包含当前字符，则可以添加当前字符到前一个非重复子字符串中，所以，f(i) &#x3D; f(i-1)+1。若d小于或等于f(i-1)，即说明前一个非重复子字符串中已经包含当前字符，则不可以添加当前字符，所以，f(i) &#x3D; d。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public static int longestSubstringWithoutDuplication(String str) &#123;</span><br><span class="line">	if(str==null || str.equals(&quot;&quot;))</span><br><span class="line">		return 0;</span><br><span class="line">	</span><br><span class="line">	int maxLength=0;</span><br><span class="line">	int curLength=0;</span><br><span class="line">	int[] position = new int[26];</span><br><span class="line">	for(int i=0;i&lt;position.length;i++) &#123;</span><br><span class="line">		position[i]=-1; //初始化为-1，负数表示没出现过</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for(int i=0;i&lt;str.length();i++) &#123;</span><br><span class="line">		int prevIndex = position[str.charAt(i)-&#x27;a&#x27;]; </span><br><span class="line">		int distance=i-prevIndex;</span><br><span class="line">		</span><br><span class="line">		//如果当前字符没有出现过，或者出现后的d大于当前最长字串长度</span><br><span class="line">		if(prevIndex&lt;0 || distance&gt;curLength)</span><br><span class="line">			curLength++;</span><br><span class="line">		else &#123; //如果d&lt;=当前最长字串长度，说明两个相同字符在最长字串中</span><br><span class="line">			if(curLength &gt; maxLength)</span><br><span class="line">				maxLength = curLength;</span><br><span class="line">			</span><br><span class="line">			curLength = distance;	</span><br><span class="line">		&#125;</span><br><span class="line">		position[str.charAt(i)-&#x27;a&#x27;] = i; //更新当前字符出现的位置</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if(curLength&gt;maxLength)</span><br><span class="line">		maxLength=curLength;</span><br><span class="line">	</span><br><span class="line">	return maxLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>剑指Offer（49 ）：丑数</li>
</ul>
<p>题目</p>
<p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。<br> 思路</p>
<p>所谓的一个数m是另一个数n的因子，是指n能被m整除，也就是n%m&#x3D;&#x3D;0。根据丑数的定义，丑数只能被2、3和5整除。根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果（1除外）。因此我们可以创建一个数组，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以2、3或者5得到的。</p>
<p>这个思路的关键问题在于怎样保证数组里面的丑数是排好序的。对乘以2而言，肯定存在某一个丑数T2，排在它之前的每一个丑数乘以2得到的结果都会小于已有最大的丑数，在它之后的每一个丑数乘以乘以2得到的结果都会太大。我们只需要记下这个丑数的位置，同时每次生成新的丑数的时候，去更新这个T2。对乘以3和5而言，也存在着同样的T3和T5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        if(index &lt; 7)&#123;</span><br><span class="line">            return index;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; res(index);</span><br><span class="line">        for(int i = 0; i &lt; 6; i++)&#123;</span><br><span class="line">            res[i] = i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int t2 = 3, t3 = 2, t5 = 1;</span><br><span class="line">        for(int i = 6; i &lt; index; i++)&#123;</span><br><span class="line">            res[i] = min(res[t2] * 2, min(res[t3] * 3, res[t5] * 5));</span><br><span class="line">            while(res[i] &gt;= res[t2] * 2)&#123;</span><br><span class="line">                t2++;</span><br><span class="line">            &#125;</span><br><span class="line">            while(res[i] &gt;= res[t3] * 3)&#123;</span><br><span class="line">                t3++;</span><br><span class="line">            &#125;</span><br><span class="line">            while(res[i] &gt;= res[t5] * 5)&#123;</span><br><span class="line">                t5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res[index - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">注意：1，2，3，4，5，6都是丑数。所以当index小于7的时候，直接返回index即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetUglyNumber_Solution(int index) &#123;</span><br><span class="line">        if (index &lt;= 0) return 0;</span><br><span class="line">        vector&lt;int&gt; k(index);</span><br><span class="line">        k[0] = 1;</span><br><span class="line">        int p1 = 0, p2 = 0, p3 = 0;</span><br><span class="line">        for (int i = 1; i &lt; index; ++i) &#123;</span><br><span class="line">            k[i] = min(min(2 * k[p1], 3 * k[p2]), 5 * k[p3]);</span><br><span class="line">            if (k[i] == 2 * k[p1]) p1 ++;</span><br><span class="line">            if (k[i] == 3 * k[p2]) p2 ++;</span><br><span class="line">            if (k[i] == 5 * k[p3]) p3 ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return k[index - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>剑指Offer（50）：第一个只出现一次的字符<br>题目</li>
</ul>
<p>在一个字符串(1&lt;&#x3D;字符串长度&lt;&#x3D;10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置。<br> 思路</p>
<p>建立一个哈希表，第一次扫描的时候，统计每个字符的出现次数。第二次扫描的时候，如果该字符出现的次数为1，则返回这个字符的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int FirstNotRepeatingChar(string str) &#123;</span><br><span class="line">        int length = str.size();</span><br><span class="line">        if(length == 0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;char, int&gt; item;</span><br><span class="line">        for(int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">            item[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; length; i++)&#123;</span><br><span class="line">            if(item[str[i]] == 1)&#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>变式题：字符流中出现一次的字符<br>可以用数组模拟哈希表，先初始化为-1，然后用数字记录字符流中字符出现的位置，然后出现一次记为1，出现两次记为-2     </p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1123.png" alt="upload successful"></p>
<ul>
<li>剑指Offer（51）：数组中的逆序对<br>题目</li>
</ul>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。</p>
<p>思路</p>
<p>如数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}；</p>
<p>思路1：暴力解法，顺序扫描整个数组，每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成一个逆序对。假设数组中含有n个数字，由于每个数字都要和O(n)个数字作比较，因此这个算法的时间复杂度是O(n^2)。</p>
<p>思路2：分治思想，采用归并排序的思路来处理，如下图，先分后治：</p>
<p><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1124.png" alt="upload successful"><br>先把数组分解成两个长度为2的子数组，再把这两个子数组分解成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7&gt;5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}，{4}中也有逆序对（6,4），由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组进行排序，避免在之后的统计过程中重复统计。<br>逆序对的总数 &#x3D; 左边数组中的逆序对的数量 + 右边数组中逆序对的数量 + 左右结合成新的顺序数组时中出现的逆序对的数量</p>
<p>总结一下：<br>这是一个归并排序的合并过程，主要是考虑合并两个有序序列时，计算逆序对数。</p>
<p>对于两个升序序列，设置两个下标：两个有序序列的末尾。每次比较两个末尾值，如果前末尾大于后末尾值，则有”后序列当前长度“个逆序对；否则不构成逆序对。然后把较大值拷贝到辅助数组的末尾，即最终要将两个有序序列合并到辅助数组并有序。</p>
<p>这样，每次在合并前，先递归地处理左半段、右半段，则左、右半段有序，且左右半段的逆序对数可得到，再计算左右半段合并时逆序对的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">注意：InversePairsCore形参的顺序是(data,copy)，而递归调用时实参是(copy,data)。</span><br><span class="line"></span><br><span class="line">要明白递归函数InversePairsCore的作用就行了，它是对data的左右半段进行合并，复制到辅助数组copy中有序。</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int InversePairs(vector&lt;int&gt; data) &#123;</span><br><span class="line">        if(data.size() == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 排序的辅助数组</span><br><span class="line">        vector&lt;int&gt; copy;</span><br><span class="line">        for(int i = 0; i &lt; data.size(); ++i)&#123;</span><br><span class="line">            copy.push_back(data[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return InversePairsCore(data, copy, 0, data.size() - 1) % 1000000007;</span><br><span class="line">    &#125;</span><br><span class="line">    long InversePairsCore(vector&lt;int&gt; &amp;data, vector&lt;int&gt; &amp;copy, int begin, int end)&#123;</span><br><span class="line">        // 如果指向相同位置，则没有逆序对。</span><br><span class="line">        if(begin == end)&#123;</span><br><span class="line">            copy[begin] = data[end];</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        // 求中点</span><br><span class="line">        int mid = (end + begin) &gt;&gt; 1;</span><br><span class="line">        // 使data左半段有序，并返回左半段逆序对的数目</span><br><span class="line">        long leftCount = InversePairsCore(copy, data, begin, mid);</span><br><span class="line">        // 使data右半段有序，并返回右半段逆序对的数目</span><br><span class="line">        long rightCount = InversePairsCore(copy, data, mid + 1, end);</span><br><span class="line">        </span><br><span class="line">        int i = mid; // i初始化为前半段最后一个数字的下标</span><br><span class="line">        int j = end; // j初始化为后半段最后一个数字的下标</span><br><span class="line">        int indexcopy = end; // 辅助数组复制的数组的最后一个数字的下标</span><br><span class="line">        long count = 0; // 计数，逆序对的个数，注意类型</span><br><span class="line">        </span><br><span class="line">        while(i &gt;= begin &amp;&amp; j &gt;= mid + 1)&#123;</span><br><span class="line">            if(data[i] &gt; data[j])&#123;</span><br><span class="line">                copy[indexcopy--] = data[i--];</span><br><span class="line">                count += j - mid;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                copy[indexcopy--] = data[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(;i &gt;= begin; --i)&#123;</span><br><span class="line">            copy[indexcopy--] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(;j &gt;= mid + 1; --j)&#123;</span><br><span class="line">            copy[indexcopy--] = data[j];</span><br><span class="line">        &#125;</span><br><span class="line">        return leftCount + rightCount + count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-3-时间效率和空间效率的平衡"><a href="#5-3-时间效率和空间效率的平衡" class="headerlink" title="5.3 时间效率和空间效率的平衡"></a>5.3 时间效率和空间效率的平衡</h4><ul>
<li>剑指Offer（52）：两个链表的第一个公共结点<br>题目</li>
</ul>
<p>输入两个链表，找出它们的第一个公共结点。<br> 思路</p>
<p>这道题和160.Intersection of Two Linked Lists是一样的。都是求两个链表的第一个公共结点。</p>
<p>公共结点的样子：<br><img src="/myblog/%5Caoyue%5Cimages%5Cpasted-1130.png" alt="upload successful"><br>上图就是一个有公共结点的例子，在公共结点之后，两个链表指针指向的地址是相同的。</p>
<p>这道题有两个解法。</p>
<p>方法一：</p>
<p>我们可以把两个链表拼接起来，一个pHead1在前pHead2在后，一个pHead2在前pHead1在后。这样，生成了两个相同长度的链表，那么我们只要同时遍历这两个表，就一定能找到公共结点。时间复杂度O(m+n)，空间复杂度O(m+n)。</p>
<p>方法二：</p>
<p>我们也可以先让把长的链表的头砍掉，让两个链表长度相同，这样，同时遍历也能找到公共结点。此时，时间复杂度O(m+n)，空间复杂度为O(MAX(m,n))。</p>
<ul>
<li>剑指Offer（53）：数字在排序数组中出现的次数<br>题目</li>
</ul>
<p>统计一个数字在排序数组中出现的次数。<br> 思路</p>
<p>既然是已经排序好的数组，那么第一个想到的就是二分查找法。</p>
<p>做法就是使用二分法找到数字在数组中出现的第一个位置，再利用二分法找到数字在数组中出现的第二个位置。时间复杂度为O(logn + logn)，最终的时间复杂度为O(logn)。</p>
<p>举个例子，找到数字k在数组data中出现的次数。</p>
<p>数组data中，数字k出现的第一个位置：</p>
<p>我们对数组data进行二分，如果数组中间的数字小于k，说明k应该出现在中间位置的右边；如果数组中间的数字大于k，说明k应该出现在中间位置的左边；如果数组中间的数字等于k，并且中间位置的前一个数字不等于k，说明这个中间数字就是数字k出现的第一个位置。</p>
<p>同理，数字k出现的最后一个位置，也是这样找的。但是判断少有不同。我们使用两个函数分别获得他们。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123;</span><br><span class="line">        int length = data.size();</span><br><span class="line">        if(length == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int first = GetFirstK(data, k, 0, length - 1);</span><br><span class="line">        int last = GetLastK(data, k, 0, length - 1);</span><br><span class="line">        if(first != -1 &amp;&amp; last != -1)&#123;</span><br><span class="line">            return last - first + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    // 迭代实现找到第一个K</span><br><span class="line">    int GetFirstK(vector&lt;int&gt; data, int k, int begin, int end)&#123;</span><br><span class="line">        if(begin &gt; end)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int middleIndex = (begin + end) &gt;&gt; 1;</span><br><span class="line">        int middleData = data[middleIndex];</span><br><span class="line">        </span><br><span class="line">        if(middleData == k)&#123;</span><br><span class="line">            if((middleIndex &gt; 0 &amp;&amp; data[middleIndex - 1] != k) || middleIndex == 0)&#123;</span><br><span class="line">                return middleIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                end = middleIndex - 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (middleData &gt; k)&#123;</span><br><span class="line">            end = middleIndex - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            begin = middleIndex + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return GetFirstK(data, k, begin, end);</span><br><span class="line">    &#125;</span><br><span class="line">    // 循环实现找到最后一个K</span><br><span class="line">    int GetLastK(vector&lt;int&gt; data, int k, int begin, int end)&#123;</span><br><span class="line">        int length = data.size();</span><br><span class="line">        int middleIndex = (begin + end) &gt;&gt; 1;</span><br><span class="line">        int middleData = data[middleIndex];</span><br><span class="line">        </span><br><span class="line">        while(begin &lt;= end)&#123;</span><br><span class="line">            if(middleData == k)&#123;</span><br><span class="line">                if((middleIndex &lt; length - 1 &amp;&amp; data[middleIndex + 1] != k) || middleIndex == length - 1)&#123;</span><br><span class="line">                    return middleIndex;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    begin = middleIndex + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(middleData &gt; k)&#123;</span><br><span class="line">                end = middleIndex - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                begin = middleIndex + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            middleIndex = (begin + end) &gt;&gt; 1;</span><br><span class="line">            middleData = data[middleIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<ul>
<li>求最大最小值<br>给定n个数，要求比较次数1.5n同时找出最大值和最小值</li>
</ul>
<p>写出一个算法,对给定的n个数的序列,返回序列中的最大和最小的数.<br>设计出一个算法,只需要执行1.5n次比较就能找到序列中最大和最小的数吗？能否再少？</p>
<p>分析：要求比较次数为1.5n，使用一般的逐个遍历每个元素然后判断其是否为最大最小值是需要2n次的比较的，所以这样的方法是行不通的。现在考虑采用，每次从数组中取出两个元素，判断其大小，然后再分别判断其是否是最大或最小值，这样一次处理两个元素，每一次比较3次，最终的比较次数就是n&#x2F;2*3&#x3D;1.5n。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">#define	MIN	-1</span><br><span class="line">#define MAX	65535</span><br><span class="line"> </span><br><span class="line">void find_max_min(int num[], int len)</span><br><span class="line">&#123;</span><br><span class="line">	int i, j;</span><br><span class="line">	int max = MIN;</span><br><span class="line">	int min = MAX;</span><br><span class="line">	int tmax, tmin;</span><br><span class="line">	int count = 0; /*用来统计比较次数*/</span><br><span class="line"> </span><br><span class="line">	i = 0;</span><br><span class="line">	j = len - 1;</span><br><span class="line">	while(i &lt;= j)</span><br><span class="line">	&#123;</span><br><span class="line">		if(num[i] &lt; num[j])</span><br><span class="line">		&#123;</span><br><span class="line">			tmax = num[j];</span><br><span class="line">			tmin = num[i];</span><br><span class="line">			count ++;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			tmax = num[i];</span><br><span class="line">			tmin = num[j];</span><br><span class="line">			count ++;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		if(min &gt; tmin)</span><br><span class="line">			min = tmin;</span><br><span class="line">		if(max &lt; tmax)</span><br><span class="line">			max = tmax;</span><br><span class="line">		count += 2; /*上面的两次比较*/</span><br><span class="line">		i ++;</span><br><span class="line">		j --;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;The max number is: %d.\n&quot;, max);</span><br><span class="line">	printf(&quot;The min number is: %d.\n&quot;, min);</span><br><span class="line">	printf(&quot;Compare number is: %d.\n&quot;, count);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int num[10] = &#123;2, 4, 5, 6, 8, 3, 7, 1, 9, 10&#125;;</span><br><span class="line">	find_max_min(num, 10);</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://zouyunkai.github.io/myblog/2020/04/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87/" title="剑指offer-第五章-优化时间和空间效率" target="_blank" rel="external">https://zouyunkai.github.io/myblog/2020/04/13/剑指offer-第五章-优化时间和空间效率/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/zouyunkai" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/myblog/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/zouyunkai" target="_blank"><span class="text-dark">云开</span><small class="ml-1x">Stay Hungry , Stay Foolish.</small></a></h3>
        <div>Stay Hungry , Stay Foolish.</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/myblog/2020/04/13/ES6%EF%BC%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0-%E6%B3%A8%E6%84%8F%E7%82%B9/" title="ES6，箭头函数 (=&gt;)注意点"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/myblog/2020/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/" title="数据库笔记（三）"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/myblog/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/myblog/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/zouyunkai" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/zouyunkai" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/zouyunkai" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/zouyunkai" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/myblog/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/myblog/js/plugin.min.js"></script>


<script src="/myblog/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/myblog/',
        CONTENT_URL: '/myblog/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/myblog/js/insight.js"></script>



    <script>
(function ($) {
    $('.search-form').on('submit', function (e) {
        var keyword = $('.search-form-input[name="wd"]').val();
        window.location = 'https://www.baidu.com/s?wd=site:zouyunkai.github.io/myblog ' + keyword;
        return false;
    });
})(jQuery);
</script>




   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '9f5iImvmYajPaJ79pRkbVNU9-gzGzoHsz',
    appKey: 'n3qUzkAGTOqjKi9k5LKGLfgV',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>