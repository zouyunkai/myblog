{"meta":{"title":"Sweet@","subtitle":"Stay Hungry , Stay Foolish.","description":"Stay Hungry , Stay Foolish.","author":"zouqingzhi","url":"https://zouyunkai.github.io/myblog","root":"/myblog/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-04-03T03:15:55.455Z","updated":"2022-04-03T03:15:55.455Z","comments":false,"path":"/404.html","permalink":"https://zouyunkai.github.io/myblog/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-04-03T03:15:55.458Z","updated":"2022-04-03T03:15:55.458Z","comments":true,"path":"links/index.html","permalink":"https://zouyunkai.github.io/myblog/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-04T08:49:08.656Z","updated":"2022-04-03T03:15:55.457Z","comments":false,"path":"categories/index.html","permalink":"https://zouyunkai.github.io/myblog/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-04-03T05:39:47.749Z","updated":"2022-04-03T03:15:55.456Z","comments":false,"path":"about/index.html","permalink":"https://zouyunkai.github.io/myblog/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"Repositories","date":"2022-04-03T03:15:55.458Z","updated":"2022-04-03T03:15:55.458Z","comments":false,"path":"repository/index.html","permalink":"https://zouyunkai.github.io/myblog/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-03-01T07:52:18.000Z","updated":"2022-03-01T07:52:18.383Z","comments":true,"path":"tags/index.html","permalink":"https://zouyunkai.github.io/myblog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"软考笔记 （计算机组成与体系结构）","slug":"软考笔记","date":"2022-04-19T13:29:00.000Z","updated":"2022-04-20T05:09:17.388Z","comments":true,"path":"2022/04/19/软考笔记/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/04/19/%E8%BD%AF%E8%80%83%E7%AC%94%E8%AE%B0/","excerpt":"","text":"介绍 第二章2.02数的表示 cpu结构 1.累加寄存器(AC):专门存放算术或逻辑运算的一个操作数和运算结果的寄存器。能进行加，减，读出，移位，求补等操作。是运算器的主要部分。 2.程序状态寄存器(PSW）：该部件用来存放两类信息，一类是体现当前指令执行结果的各种状态信息(条件码)，如有无进位，有无溢出，结果正负，信息是否为零等；另一类是存放控制信息，如允许中断，跟踪标志等。注： ·CPU的寻址方式除了直接寻址以外还有多种寻址方式，目的是为了在效率和方便性上找一个平衡 ·CPU根据指令周期的不同阶段来区分内存中以二进制编码形式存放的指令和数据 ·指令最先进入到数据寄存器暂存起来，然后在拿到指令寄存器中，再交由指令译码器来解码进而运算(交给运算器)，而这一过程一结束，就会迅速提取程序计数器中的指令(即下一条指令)，因此，程序计数器中存储的始终是暂未执行的，下一条指令的“地址”； Flynn分类法 CISC和RISC 流水线 注：所有步骤花费时间相等的指令执行的效率最高 Cache基本概念 注：内存存储外存的部分内容，cache存储内存的部分内容，CPU只处理cache中的指令，cache的作用是精简内存中重复出现的指令（时间和空间局部性），是按内容存储的，提高CPU的执行效率，使得计算机的运算速度得到极大的提升；此外，结构中由上至下，速度越来越慢，但容量越来越大（是成本决定的）。 1.cache的功能：提高CPU输入输出的速率，突破冯诺依曼瓶颈，即CPU与存储器系统间数据传送带宽限制，在程序执行过程中，Cache与主存的地址映射是由硬件自动完成的。 2.与cache相关的计算：如果以h代表对cache的访问命中率，t1表示cache的周期时间，t2表示主存储器周期时间，以读操作为例，使用“chche+主存储器”的系统的平均周期为t3，则：**t3&#x3D;h×t1+(1-h)×t2；其中，(1-h)又称为失效率(未命中率)**。 注：CPU会在cache中寻找它需要的数据，如果不能找到，CPU就将前往内存中寻找，而chche的访问命中率就是CPU需要的数据在cache中被找到的比例，未能找到的数据CPU将前往内存中进行再次寻找。 3.内存与cache地址映射的三种方式：cache与内存的地址映像方式有三种，分别是直接映像(cache的区号与内存的区号一一对应)、全相连映像(cache的一个块号可以对应多个内存的块号，内存的一个块号也可以对应cache的多个块号)，组相连映像(即两种方式相结合的方法) 注：这三种映射方式都是计算机硬件自动完成的，不是软件 4.替换算法：替换算法的目的是使cache获得尽可能高的命中率，有以下四种： 随机算法（RAND）：随机地确定替换的Cache块。它的实现比较简单，但没有依据程序访问的局部性原理，故可能命中率较低。 先进先出算法（FIFO）：选择最早调入的行进行替换。它比较容易实现，但也没有依据程序访问的局部性原理，可能会把一些需要经常使用的程序块（如循环程序）也作为最早进入Cache的块替换掉。 近期最少使用算法（LRU）：依据程序访问的局部性原理选择近期内长久未访问过的存储行作为替换的行，平均命中率要比FIFO要高，是堆栈类算法。LRU算法对每行设置一个计数器，Cache每命中一次，命中行计数器清0，而其他各行计数器均加1，需要替换时比较各特定行的计数值，将计数值最大的行换出。 最不经常使用算法（LFU）：将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1，需要替换时比较各特定行的计数值，将计数值最小的行换出。 这里算法不要求？？？？ 先进先出（FIFO） 在二路组相联映射中采用 FIFO 替换算法： 在二路组相联映射中采用 LRU 替换算法： https://blog.csdn.net/badmer/article/details/118305208 注：现代的计算机cache系统是分为了三个级别的，访问时先从第一层开始访问，直至三个级别的cache都被访问完全时才会访问内存 5.虚拟存储器：即cpu在给出需要访问的内存地址时，给出的并不是真正的物理地址，而是物理地址的抽象，虚拟存储器是由主存-辅存两级存储器组成 随机存储器和只读存储器 磁盘工作原理 注：磁道一般分为许多个小的扇形区，即物理块，磁头在依次读取这些物理块时(磁头必须依次读取)，会在读取的同时将其存放进缓存区，缓存区可以是单个，也可以是多个，存放完成后会在缓存区花费时间进行处理，处理期间磁头的读取不会停止，因此，如果缓存区过少，就会出现：读取一个物理块花费了一个周期甚至更长的时间。 磁盘调度管理中，先进行移臂调度寻找磁道，再进行旋转调度寻找扇区，所以就是存取时间为寻道时间加等待时间。 计算机总线根据总线所处的位置不同，总线通常被分成三种类型： 0.概念：总线是连接计算机有关部件的一组信号线，是计算机中用来传送信息代码的公共通道。 1.内部总线：微机内部的，各个外围芯片与处理器之间的总线，属于芯片级别 2.系统总线：系统总线即为各个插线板和系统板之间的总线（如PCI总线，为了连接外部设备的）；包括(1)数据总线：如32位，64位等一次性能够传输的位(2)地址总线：假设该计算机的地址总线为32位，那就代表它的地址空间为2^32个字节(3)控制总线：发送相应的控制信号的总线 3.外部总线：即微机和外部设备的总线 注：总线上的多个部件之间只能分时向总线发送数据，但可以同时从总线接收数据 串联系统与并联系统可靠度计算 校验码 码距的作用：增大码距能够起到检错的作用，因为数据在传输的过程中如果链路出现了 问题，那么将会使得接收到的二进制数发生变化，若码距过小，则很可能造成信息的混淆，增大码距就使得被改变的二进制数混淆信息的概率极大的降低;若码距再进行增大，则能够起到纠错的作用，因为数据链路出错的概率比较低，只能造成传输中极少二进制数的改变，我们可以根据该传输失真的二进制数中大部分二进制数的构成来进行推断，推断出结果就达到了纠错的目的。 CRC 注(1)：生成多项式是一个二进制数，如”X^4+X^3+X+1”,这个生成多项式实际上就是二进制数11011；在相除时，需在原码后方添加一些0，添加的0的个数等于生成多项式的位数减去1，增加的0即为校验信息。 注(2)：二进制的除法与算术除法相似，唯一不同的是所得除数在作减法时，减得的值要取绝对值，即0-1&#x3D;1，就是异或操作；这样使得整个除法运算中不存在借位。 异或操作就是相同为0，不同为1 海明码","categories":[{"name":"软考","slug":"软考","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%BD%AF%E8%80%83/"}],"tags":[],"author":"aoyuehan"},{"title":"概率思维—把握不确定性","slug":"12概率思维","date":"2022-04-04T13:29:00.000Z","updated":"2022-04-04T08:12:33.452Z","comments":true,"path":"2022/04/04/12概率思维/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/04/04/12%E6%A6%82%E7%8E%87%E6%80%9D%E7%BB%B4/","excerpt":"","text":"第二课 概率思维—把握不确定性为什么要学 不确定性是世界的常态，概率论就是量化不确定性的工具；未来是不确定的，只要涉及到选择，涉及到决策，就一定会用到概率思维。 很多牵扯到概率的问题是非常反直觉的，必须依靠概率工具；而现在这个日新月异的社会，概率思维显得更为重要 要想了解当今的前沿科技，不管是大数据、人工智能，还是生物医药、基因编辑，都绕不开概率论 包括 【贝叶斯公式】科学抉择，把握不确定性。 【基础概率】选择大于努力。 【大数定律】不确定性中的确定性 【概率分布】上帝都有哪些 “筛子”？ 【数字特征】 资料 林超 跨学科工具箱 刘嘉 概率论22讲 吴军 数学之美 遇见数学 公众号 相关教材 贝叶斯公式 是什么 Bayes公式的直观解释就是，当你获得了一个新的信息后（似然度），你对原事件概率（先验概率，基础概率）估计的变化（后验概率）。 定义： 定义2 也就是带入【全概率公式】，用于计算P(B)了 完备事件组：两两互斥,和为全集 数学上怎么用 求的有一个新信息后对原事件概率认识的变化 已知某条件概率，如何得到两个事件交换后的概率，也就是在已知P(A|B)的情况下如何求得P(B|A)。 启发：既要很冷静的看待事物的基础概率，不要被表面现象迷惑，同时要在新证据，新信息不断积累的时候，及时调整对全局的评估。 贝叶斯就是数学版本的辩证法。一方面可以说明没读大学的人混的比读大学的概率低很多。另一方面也可以说明，如果身边没读大学但混的很好的人越来越多的时候，就是那个药检例子中，当新证据不断叠加的时候，最终概率是会不断高速增加的。所以收集新证据非常重要的 案例 【患病概率】 【吃禁药概率】 【女孩对我笑案例】 案例：患病概率亨廷顿舞蹈症患病概率：所长的案例样本空间没说清楚，这里结合结论反推完善了下题目，应该没啥问题。 已知 亨廷顿舞蹈症大概每一万人中大概有1人患病（基础概率），医生对这种病的识别率（真有病测出有病的概率）有99%，也有1%误诊率（没病被测出有病的概率）。 问题：当医生说张三有得了此病，那么此时张三得病的概率是多少？ 算法1 古典概型，拿10000个人来思考 真正的样本空间是由 测得有病的病人 和 测得有病的正常人组成，所以答案是 10&#x2F;(10+999)≈1% 所以说，就算是张三去医院检查身体，医生说他可能有99%的可能患有该病，但，张三真实得病率也就只有1%左右。因为有1%的误诊率，所以这里的99%是没有多大用处的。 幸存者偏差 算法2 概率公式解法 设P(A)是人口得病的概率（基础概率），为0.01%，P(B)是医生诊断出有病的概率 P(A|B)就是测得有病时，真有病的概率。P(B|A)是真有病时候，测得有病的概率，为99%，P(B|Ac)就是没病却测得有病的概率（误诊率1%），为1%。 要求的是P(A|B)，由概率公式可以得到： P(A|B)&#x3D;P(B|A)P(A)&#x2F;P(B)&#x3D;0.95*0.01&#x2F;P(B)， 由全概率公式可以得到P(B)&#x3D;P(B|A)P(A)+P(B|Ac)P(Ac)， 代入可得：0.990.0001&#x2F;(0.990.0001+0.01*0.9999)≈0.01。 常见误区：得出答案是99%的是因为忽略了基础概率，且弄错了问题的样本空间：99%样本空间是所有人，而问题的条件概率样本空间已经缩小至测的有病的人。 启发： 人的直觉倾向于既然医生都说了99%有病，那么基本就能确定有病才对，而忽略了真实得病率是0.01%，医生那1%的误诊率也是很重要的，看起来很少但比起真实得病率，差别之大，足以颠覆直觉。 小概率事件错觉：生活中如果遇到要在很小概率的事情上做推断的时候，一定要关注推断的错误率，即使是只有1%，如果真实世界这件事情发生的概率远小于1，足以把错误的绝对数字变得非常大。 检察官谬误：这不是说医生考专业知识的判断根本没有用，即使一次做出了诊断，也不能当做绝对的证据，需要结合多方证据，多检查几次才能确定，而医生99%的诊断率仍然是快速提升新证据确定性的最重要参数。 扩展：这一类问题叫作检察官谬误 案例：吃禁药概率 违禁品检测案例：跟上面的案例是一类案例，但因为很重要，多举几个例子 已知：违禁品被使用的基础概率是0.001，使用违禁品的情况下测出阳性的概率是0.95，清白的人也有0.1的概率被查出阳性。 问题：如果被测出阳性后，那么使用违禁品的概率会变成多少？多次测出阳性呢？ 求解 概率公式解法： 用条件概率公式，第一次检查阳性的真实使用禁药的概率是0.009，再检查两次都是阳性，真实使用概率是0.45，连一半的概率都没有。另一方面，当叠加一个新的证据之后，可能让最终概率增加十倍。 之所以上面一个人三次检测都有阳性，但是不能说明他用药，就是因为那个使用禁药的概率为0.001导致的。所以说，要看这件事情被误判的可能性有多大，也要看这件事在真实世界里面发生的概率有多小。 启发 首先是多次重复对概率的提升，所以要收集多个证据，多方验证或多次测验，才能保证结论的准确性。 其次是【基础概率】（先验概率）很小的情况 即使三次都不到50%，关键的不是误判率有多小，而是【基础概率】和误判率的比值，如果基础概率比误判率还要低几个量级，结果依然不可信，所以【基础概率】往往是决定性的。 资料：简书王阿根（所长案例的原始出处）https://www.jianshu.com/p/0e44aade0e60 女孩对我笑案例看到小芳对我笑，是因为喜欢我的概率 应用当看到很罕见的事情连续发生了两次，不要马上做判断，先思考下面两点 这个事情被误判的概率有多大 这件事情在真实世界会发生的基础概率有多小 即使误判率是只有1%，如果真实世界这件事情发生的概率远小于1，那误差也会非常大 基础概率 为什么很重要：根据前面的贝叶斯公式案例，可以得出一个结论：基础概率决定成败 是什么： 基础概率(先验概率) 是指根据以往经验和分析得到的概率 , 如概率公式中,它往往作为”由因求果”问题中的”因”出现的概率。 怎么做【应用】：我们不需要知道每个事情的基础概率具体是多少，只需要有个量级的判断力就行，一个量级可以理解为差十倍，结合【十倍压制原理】，可以有很多的重要应用 比如公司竞争中，公司规模如果差一个量级，就没什么争的了（大概率） 个人竞争中，比如考试排名，一个排年级第五，一个排年级第五十，也没什么争的了（大概率） 比如大学男女比例是1:10和是10:1，两种环境能不能找到女朋友（男朋友），不是努力能抵消的，这就是基础概率。很多时候我们不是努力不够，而是所在的土壤太贫瘠。 这个原理通用适用于选城市，选学校，选行业，选公司。 选择一个基础概率大的，往往更容易成功，因为我们的大量的努力都可能是在加减法的级别上，改变最终结果。但是这些努力被乘一个极小的概率，就等于在量级上被降维打击了。 应用【基础概率】结合【量级压制原理】可以帮助判断和解释很多问题，比如 为什么我班级第十名，却怎么努力也追不上班级第一名？别看只是超过9个人就行了，其实这是一个量级的压制，而不是能简单靠努力能达到的；并且放眼整个年级，可能就是差几百人了，放眼整个市，就是差几万人了，所也就是说这时候用”加减法”是解释不了的，需要用量级思维来分析。 再比如常常看到有报道举例 “为什么中国出了那么多高考状元，却没有诺贝尔奖得主？” 我们都知道高考状元很难得，诺贝尔奖也很难得，但这个“难度”是一样的吗？而真正考究一下，高考状元（省）概率大概是万分之一量级的，而诺奖得主概率大概是亿分之一量级的。此类“证据”常来批判中国的应试教育，不论结论对错，但证据却有失偏颇。这也说明了人们对跟大或跟小的量级其实并不敏感 所以应该多去搜集这样量级相关的数据，锻炼对量级的判断力。 比如在人与人之间，量级数据的搜集有一个非常好的来源，就是高考，样本量非常大。以下为早年做的一个表，里面体现了十个量级差别，帮助建立量级的感觉。 所以为什么要多关注宏观层面的东西，比如行业大趋势呀，国家大战略呀，因为这些东西都是和【基础概率】息息相关的 这方面要多看【所长林超】的视频，比如最新的2035年远景规划相关视频 均值与异常值 异常值：跟平均值偏差大于两倍标准差的数据 为什么：人们更习惯以均值思考，比如平均身高，平均体重都很有意义。但平均财富就没有意义了。当今整个世界变动基础概论提高了，所以需要格外关注异常值。 比如一个公司平均有8%的月均收益率，似乎很不错，但因为某个月亏损非常严重，突然倒闭了，就是因为这个异常值，而用平均值思维理解就会很困惑。 怎么做：如何处理异常值？ 1、舍弃掉 背后的假设是世界是连续的稳定的。 比如去掉一个最高分，去掉一个最低分。 2、一视同仁 3、单独研究 假设世界是不稳定的，每一次异常值都可能预示着一次大变化的开端 ，也就是见微知著 比如国家叫停支付宝上市，实际上预示着一次大变局。 大数定律大数定律：不确定中的确定性 是什么：如果统计数据足够大，那么事物出现的概率就无限接近他的期望值。 启发：在小数据时代，大道理可能毫无参考价值，比如早睡早起有益身体健康，多运动之类那些能够流传数百上千年的大道理大道理，其实都是经过无数次的抛硬币，最后沉淀下来的统计学经验， 随着年龄增加，阅历增加，接触的样本不断变多，会觉得他们越来越有道理。这也就是为什么我越来越觉着真诚是与人交往中重要的东西。 而人类很难抗拒，抛几次硬币就开始总结经验这种本能，比如你谈了两次恋爱，如果对象都不靠谱，或者你找的前两份工作老板都不怎么样，那么你很可能就已经对恋爱和求职这两件事产生了自己的经验。没错我就是这样，今天听到这突然顿悟了。 应该保持耐心，保持身心健康，多去尝试总结经验这也是反思和复盘的重要性，从贝叶斯公式总结的话就是不断获取新的证据更新先验概率，在迭代过程中让结果更准确。 我们生活中很多的事情根本就没有所谓的大道理来指导，所有人不得不自己去摸索跟这个世界相处的原则。这个时候理解小数据统计的结果可能会大幅偏离大数据结论的道理就非常有必要了。 注意：大数定律不需要通过补偿实现。比如看到一个硬币三次都是正面，那么第四次为正面的概率还是50%。 疑惑与解答：那条件概率公式失效了吗？应该因为这三次的信息让后验概率发生改变吧，但是如果收集的信息越多好，那么假如有一个超级观察者，他看这个硬币已经投掷来了100万次，那么概率肯定趋于50%的。 相关【小数定律】：小数定律是说，如果统计数据很少，那么事件就表现为各种极端情况，而这些情况都是偶然事件，跟它的期望值一点关系都没有。 概率分布 是什么：随机变量中的“随机”来自事件发生的概率。分布（distribution）是描述随机变量所对应的所有事件的发生概率的情况，一般指直接指分布函数（分布率）。研究一个随机变量，不只是要看它能取哪些值，更重要的是它取各种值的概率如何！ 常用概率分布包括：【幂律分布】【正太分布】【泊松分布】 幂律分布详见函数思维中的【指数效应】 是什么：马太效应，二八法则，长尾理论，赢家通吃，【指数效应】 但生活中而已有很多的事件符合幂律分布，比如收入、股市波动、网站访问量、照片点击量、公众号文章的阅读量…… 启发：在某个细分领域做到绝对的好，比如钻研小众领域 例子 现在很多人都在运营微信公众号。但排名前20％的公众号可能占了80％的点击量，而排名后80％的公众号只占20％的点击量。这个多数人“泯然众人”，少数人“牛到不行”的不均衡分布。 扩展：所长的 《六大新生存法则》和《疫情之后的新世界》 正态分布 是什么： 我们 生活中有很多分布都属于正态分布：平均的占主要部分，极好的和极差的占少数，而且和平均值差别不会特别大，比如身高的分布、智商的分布等等 一般的，若影响某一数量指标的随机因素很多，而每个因素所起的作用均不太大，则这个指标近似的服从正态分布，这就是概率论中的【中心极限定理】比较直观的描述。 泊松分布最近频发大暴雨，而泊松分布就是其数学模型。为什么”百年难得一见“”前年难度一见“的暴雨频发？ 是什么：实际意义，特定的时间特定的场合，源源不断的质点来流。（比如：每天某个地方在某个时间的人流数量） 其实泊松分布是正态分布的一种微观视角，是正态分布的另一种面具。 应用：传统上来说，泊松分布给出了在固定时间段给定次数时间发生的可能性，假定时间发生的时间独立于上次事件发生的时间，同时事件发生率是已知的。因为用于导出分布的技术的原因，在模拟事件发生的概率恒定不变但很小，即随机变量元素特征是“稀少事件”发生的个数（比如，每年骑兵由于被马踢中而致死的人数）的大量独立事件中，泊松分布极为有用。 方差（放大了标准差） 启发：【坚定聪明模型】努力做一个聪明而坚定的人， 还要多扩展眼界，当圆心变了的时候即使做出调整。 从坚定的愚蠢，不断做加法，不断接纳新证据和很多异常值，进入到不坚定的愚蠢这个阶段。然后逐渐逐渐的发现自己有机会接触到更加聪明的跟世界相处的方法，然后进入不坚定的聪明阶段，再不断做减法，然自己逐渐只集中在最能发挥自己能力的那个区间，产生价值，进而进入坚定的聪明阶段。但这不是故事的全部，因为随着时代的发展，那个圆心的位置还会偏移，而很多年轻人第一次成功之后之所以很难再次成功，就是自己没有意识到圆心已经偏移了，之前的坚定的聪明瞬间变为坚定的愚蠢！","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"个人简历","slug":"简历","date":"2022-02-24T13:46:00.000Z","updated":"2022-04-03T13:18:46.693Z","comments":true,"path":"2022/02/24/简历/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/02/24/%E7%AE%80%E5%8E%86/","excerpt":"","text":"","categories":[{"name":"面试","slug":"面试","permalink":"https://zouyunkai.github.io/myblog/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[],"author":"aoyuehan"},{"title":"关于备考的方法","slug":"关于备考的一些方法","date":"2022-01-25T13:29:00.000Z","updated":"2022-02-26T03:27:00.037Z","comments":true,"path":"2022/01/25/关于备考的一些方法/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/25/%E5%85%B3%E4%BA%8E%E5%A4%87%E8%80%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/","excerpt":"","text":"某个大目标分阶段！！心态 静下心来，不浮躁！不被外界像是无用的社交、没有发生但是些许期待或担心的事扰乱了内心。比如考研的时候能一坐下来，手机不碰，能写背记一天。 可能会出现这样的情况，自己非常有动力地学了三天之后，然后第四五天就开始出现反抗的心理，就会不那么用功，然后这一天没有完成既定的计划，然后这天临睡的时候开始抱怨自己今天没有好好学习。所以可以实行这样的一个安排：三天的非常麻痹且高强度的学习，然后第四天可以放出那么一两个小时把自己放空（来回顾这三天的学习情况或者想一些别的事或者是走神，只要不那么压抑的学习，符合人类的大脑的奖励机制，让学习不反人类）或者可以简单的做一些想做的事。再接着这样3+1循环。 认知 认识你自己 不要为了所谓的社会认同 和归属感而取无所谓的合群，自己一个人也可以，不用等到吃饭了却非要拉上自己的小伙伴一起，反而自己一个人的时候也很惬意。 学习和生活娱乐没有界限的，所谓的没有界限是，什么时候都可以学习，碎片化的时间利用起来其实可以干好多事。不应该将学习当做一个神圣的行为，反而越是逼自己刻意抽出固定时间去背单词内心就有些反抗，这样子就很难进入到一个自愿学习的状态。每当做下来打算要学习的时候，就欺骗自己锁上手机，我只学五分钟，然后其实你不知不觉的学了50分钟。 关于记忆知识点： 1、只有在吃饭或者走路的时候能把你学的知识讲出来，这才是真的记住了。这样不管在考场还是在宿舍，都能直接默写出来该知识点。 2、通过小的口诀或者自己串成的故事来记忆，比如第一手测试软轨迹来记忆关于天问一号相关的描述。 3、不要机械记忆！关键词+用自己的话掺杂这逻辑表述出来+真正的理解知识点（比如一个数学公式，你能通过一些简单的你已经认为其就是对的那种公式推导出来一个新的课本上的公式，知道什么时候用，怎么用，那么你这样才知道这个公式的来龙去脉） 大面上的方法 做计划（不用非要写在好看的本子上，但可以找一个盒子单独放这些计划纸） 每日计划 按照小时的大小来指定计划，并流出适当的调整时间 每八天的计划（两个3+1） 每月计划 tips 计划制定的一些约定： 1、计划的量的大小要根据实际及时调整，比如考研的时候我总列计划一上午背单词+做一套数学试卷并改完，实际就是一上午根本做不完一套卷子，而我就只有后来才真的服了自己的能力大小。 2、按照重要且紧急、重要不紧急、不重要紧急的顺序来安排计划。 3、在自己动力最强，最静下心来的时候先干最困难费事的工作，再来放松一下做不费力的，将琐碎的那种事放在自己比较零碎时间安排中来做，比如一个吃饭之后上课睡觉之前先背会单词。 4、SMART目标设定原则：目标必须是具体的（Specific）、 目标必须是可以衡量的（Measurable）、目标必须是可以达到的（Attainable）、目标必须和其他目标具有相关性（Relevant）、目标必须具有明确的截止期限（Time-based） 分析原因&amp;总结教训 1、如果自己的计划总是没完成，及时调整计划量和学习方法，不要陷入没完成-&gt;烦躁后悔压抑-&gt;指定计划又没有完成的恶心循环。 2、其实一天根本学不了太多，所以要接受自己内心想学很多但是干不完的事实，和自己和解。 认知和实践的辩证性关系，认识到实践，实践到认识的两个飞跃。 PDCA+创造性：Plan(计划)、Do(执行)、Check(检查) 和 **Act(处理)**，四者形成一个闭环。 另外注意的东西 不要在干一项重大的事，比如考研、法考、教资考试，这件事要干好久，但也不要忘了自己喜欢干的事，留一些给兴趣爱好。 低谷的时候去读书，走出个人认知的狭隘之处，站在人类总体经验的基础上去看待周遭的一切。 研究一些东西的时候1、要把所牵扯的相关知识都了解一下 2、了解这个行业内的比较厉害的人都在干什么，不要学了一些不太实用的东西 3、要走那种学了好多遍在回来一眼看穿原来学的东西不过如此的的那种眼界。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"脑科学重要模型","slug":"01模板","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-04T06:31:21.660Z","comments":true,"path":"2022/01/19/01模板/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/01%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"第二课 系统论重要模型","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"熵增定理-世界演化之道","slug":"01熵与热力学重要模型","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-03T13:18:43.029Z","comments":true,"path":"2022/01/19/01熵与热力学重要模型/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/01%E7%86%B5%E4%B8%8E%E7%83%AD%E5%8A%9B%E5%AD%A6%E9%87%8D%E8%A6%81%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"当今 大号2021年底走访各大创业者的公司之后，最大的收获不是什么新奇的商业模式，而是我们在选择方向的时候，第一中观层面，一定要结合当下的社会政治经济文化背景，时代迭代的速度已经远超我们的认知，每个市场的体量也都在经历翻天覆地的变化。第二微观层面，做自己擅长的事，而不是现在在风口浪尖的事。 第一课 熵与热力学重要模型 为我们的日常生活中的思考提供思考框架 0 简介 引子： 为什么自然情况下，热水会变慢慢变凉，整齐的房间会变杂乱，沙堡会变为沙堆，而不是反之呢？有没有一个统筹解释这些现象的规律呢？人类在这个演化趋势中又充当什么样的角色呢？这就要提到【熵增定律】了 【熵增定律】可以帮助我们理解世界的演化规律；以帮助我们更好的作出应对。定义：在一个封闭系统里，如果没有外力做功，其总熵会不断增大。用四个字概括就是：覆水难收。 广义封闭系统：一个与外界隔绝的不交流的系统（没有物质，能量和信息交换）。 【熵】是系统状态数，可以理解为 混乱程度&#x2F;不确定性&#x2F;无知度。 案例：比如屋子不收拾会变乱，手机会越来越卡，耳机线会凌乱，热水会慢慢变凉，太阳会不断燃烧衰变……直到宇宙的尽头——热寂，也可以解释很多生命现象，比如自律总比懒散难，封闭的国家会被淘汰等，这些都是熵增的案例 应用 如何利用该原理，对事物演化进行识别，解释和预测？ 如何抵抗熵增？ 制造一个好的耗散结构，使得自身的熵不断减小 1 概念 理解【熵增定律】的关键是理解什么是【熵】以及什么是【封闭系统】 熵 是什么：熵 -&gt; 系统状态数 -&gt; 可能性 ～ 混乱程度&#x2F;不确定性&#x2F;无知度 系统状态数 概念 【系统状态数】：系统宏观态中所包含的微观态总数 当我们谈论一个系统的“状态”时，要区分我们谈论的是“宏观态”还是“微观态” 一个系统的微观态就是一个系统中具体到每一个粒子的全部运动状态 宏观态就是一组我们无法分辨的微观态的集合，这些集合所表现出来的共同的宏观特征。 粒子：抽象概念，系统中不可分割，且不相关的事物看做一个个粒子 系统状态数与可能性：状态数越多，可能性越高，状态数越少，可能性越小。所以在这个世界上，混乱才是常态，有序是需要刻意营造的。可总结为，随机情况下，事物呈无序的可能性最大。相对于无序，有序的可能性更小，所以不容易做到。 案例：粒子运动案例 其中左二右二的熵是最大的，既可能性是最大的 3&#x2F;8，都在左边和都在右边的可能性是最小的 占 1&#x2F;8 混乱程度 为了方便理解，熵通常可以采取这些说法来表述：混乱程度，无规律程度，不确定性，无知度，限制度，分散程度 不确定性：一个宏观状态所对应的微观状态数越多，当我们用宏观态来描述它时，我们所忽略的信息就越多，这种描述的不确定性就越高。比如扑克牌抽到同花顺（宏观态）的不确定性就很低，因为可能的微观态组合数很少。 限制度：限制一个系统能取到的状态：整齐就是限制物品排放的位置，一个人很坏就是不守规矩 混乱度：混乱即使无序，因为有序往往代表着有规律，有限制条件；比如屋子变乱，手机线变凌乱，扑克牌洗牌打乱等，这些都是熵增的过程 无知度：当一件事情（宏观态）有多种可能情况（微观态）时，这件事对某人（观察者）而言具体是那种情况的不确定性叫作熵，所以熵是主观的，用无知度更能体现这一点。比如同样的题干，判断题的熵小于单选题，小于多选题，小于解答题。 ps 一般科普采用混乱程度来解释熵，但不少资料显示“混乱程度”很具有误导性，因为具有主观性，不够精确，目前学界不再使用这种解释，所以用【系统状态数】去分析还是更靠谱的 资料：https://www.zhihu.com/answer/52318529 封闭系统 定义：与外界隔绝不交流的系统。热力学详细定义中，封闭系统只是能量交换没有物质交换，而没有物质和能量交换的叫做孤立系统，都有交换的叫作开放系统。 正例： 将热水和凉水掺在保温杯里（封闭系统），最终会变成温水（熵增）； 将人放到与世隔绝的地方不学习思考（封闭系统），长此以往智能会下降（熵增）； 反例：什么不是封闭系统：正在加热的水，因为输入了能量；正在学习的人，因为输入了信息；【麦克斯韦妖】，因为感知和选择是需要能量和信息的 。 2 案例粒子运动 如图是熵增定律的一个经典的理论研究案例，如图封闭的盒子的粒子运动中会什么会随时间逐渐由图1变为图2呢？因为图2中状态数明显是更多的，在两倍大的空间里，它们能够随机分布的位置就更多了，能够产生可能的状态数就更多了，而状态数更多，熵就更大了。（具体计算见【系统状态数】案例） 麦克斯韦妖 是什么：1871年提出的一个著名物理学思想实验，可以简单的这样描述，一个绝热容器被分成相等的两格，中间是由妖控制的一扇小门，容器中的空气分子作无规则热运动时会向门上撞击，门可以选择性的将速度较快的分子放入一格，而较慢的分子放入另一格，这样，其中的一格就会比另外一格温度高，这样就违背了【熵增定律】，因为似乎在封闭系统中成功实现了熵减。 为什么：这个问题直到1981年才被成功解释，为什么这个问题困扰了学界一百多年？因为直观来看，这种思想实验中，的确提供了不用做功就可以熵减的方法，那么岂不是永动机都可以做出来？是因为没有意识到感知和选择就是需要能量和信息的。而这种能够不断地从外界输入能量、物质和信息，自己可以不断的排出熵的系统被命名为【耗散系统】 3 应用 理论概念学完之后，关键是如何应用到日常生活中，给我们的思维带来启发，为我们的行为带来关键的影响，从而知行合一，而这个过程需要大量的实践练习。 PS 目前理论了解的差不多了，之后就是慢慢积累案例练习了。 识别 首先要能快速判断出系统的趋势是熵增还是熵减，这是基础 如何判断系统熵的变化趋势？以下为目前总结的技巧： 不可逆的过程是熵增的，比如人死不能复生。 或逆过程需要的能量更大的是熵增的，比如把耳机线弄乱很容易，而整理整齐更费力。 定性判断：是否更混乱，限制条件更多，不确定性更大等，见【混乱程度】中的案例 自发的过程都是熵增的，即无外力干涉的，比如热水慢慢变凉 系统状态数变多是熵增的，但似乎无法用于生活案例？ 练习1 整齐到杂乱 定性分析，整齐熵更小，因为整齐的限制条件更多。比如说一个房间整齐，意思是所有物品摆放在该在的位置，而一个房间乱，则是东西随意摆放，显然前者物品可能的状态数更少。混乱，无规律，不确定性，限制程度，无知度都可以解释 定量分析，只能说随机情况下，呈现杂乱的概率（可能性）更大来判断吧 熵增原理，整齐会自发变乱吗？似乎也不会，因为总要和外界有交互，不能做封闭系统。 做功角度，肯定是到整齐消耗的能量更大先，依然是常识 解释 生命为什么变得越来越智能：世界整体是熵增的，生命的熵减过程，会加剧环境的熵增，于是环境会变得越来越恶劣，生命为了生存，为了获得足够的能量和物质，必须变得更加智能。 信息是什么？消除该人对这件事情不确定性的事物叫作信息，消除熵 &#x3D; 获取信息。 预测 宇宙的未来————热寂 耗散结构 问渠那得清如许，为有源头活水来——朱熹《观书有感》流水不腐，户枢不蠹——《吕氏春秋·尽数》 是什么：这个世界上有一种系统，它能够不断地从外界输入能量、物质和信息，自己可以不断的排出熵。 案例 流水不腐：最典型的耗散结构就是河流，河流要从上游注入水分子，而且水分子从高处往低走，还会带来能量。河流是永远不会腐败的，一直保持着动能和活力。相对的，死水，比如一个年久失修的游泳池，池水就会腐败，肮脏发臭，因为它是一个封闭系统。 人体耗散结构：新陈代谢，人体的运动方式就是不断通过注入能量、信息和物质，让自己不断地从身体里面排出熵。 4 抵抗熵增 人活着就是在对抗熵增定律，生命以负熵为生。——薛定谔 为什么：如果不是刻意去对抗，熵增定律会使组织变得臃肿，缺乏效率和创新；会使人变得安于懒散、难以坚持、难以自律 怎么做：从定义来说，熵增的条件有两个：封闭系统＋无外力做功。只要打破这两个条件，我们就有可能实现熵减。既开放系统和引入外力 减少状态数，以抵抗熵增 挺直腰可以集中精神，地铁上学习可以更专注，这都意味着更小的状态数。 感知和选择是可以使事物变得更有序的 即使无法改变环境，但我们永远有如何感知，如何选择的自由，因为无论什么情况下，我们面对世界的态度都是可以选择的 构建和寻找【耗散结构】，避免封闭系统 成长性思维 让自己接受更多的信息和能量 公司选择 我们应该加入那种能够不断从外界吸取能量和信息，不断做出成绩，让自己变得越来越有序的城市和公司。 案例 抵抗熵增最典型的例子就是生命的进化历程 思维有了模型：输入能量和开放系统 https://www.zhihu.com/question/27343287/answer/1184500866 应用到人的身上（人体也是一个耗散结构）：熵减：需要正确的感知+正确的选择（麦克斯韦的思想实验），需要构建耗散的动态平衡结构（逆人性） 对于人来说：处理好蓝色字体的这些方面，而不是过分关注负成果和红色字体的部分，因为只有通过调整蓝色字体的那些活动，才能使自身进行熵减。 5 资料 林超 https://www.bilibili.com/cheese/play/ep6945 思维有了模型 https://www.zhihu.com/question/27343287/answer/1184500866 YJango https://www.zhihu.com/question/27343287/answer/589137420 马同学 https://www.zhihu.com/question/24053383/answer/849500436 理论向 https://www.zhihu.com/question/20571208/answer/940922518","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"系统思维 - 深刻认识世界","slug":"02系统论重要模型","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-03T13:18:46.871Z","comments":true,"path":"2022/01/19/02系统论重要模型/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/02%E7%B3%BB%E7%BB%9F%E8%AE%BA%E9%87%8D%E8%A6%81%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"系统论讲解 一个小例子 （杠杆解） 什么是系统：简单的把一堆东西放在一起，这样子不叫作系统，比如一堆石头。很多实体通过相互联系形成一个有运作规律的整体，这叫做系统 。比如身体学校国家公司。把系统分为四个大类：生物系统、社会系统、机械系统、生态系统。 储蓄池：如果一个人可以长期坚持做自己认为正确的事情，那么他是拼什么扛过那个漫长的滞后期呐，其实靠的不是决心、毅力，打鸡血，靠的是在精神、情感、金钱上未雨绸缪的储蓄池。比如：和恋人相处的时候，很关心你的恋人，当你们之间的信任危急的时候，但是你自己有心理存款承受的储蓄池的话，你可以熬过那个让人忍受不了的波谷的时间段。 系统的三要素 要素、关系、作用和五大模型 一个好系统的三大特征 实用主义，将所了解的知识用到生活中。很多的人大脑里只有一幅画，当遇到问题的时候就去破坏这一幅画，因此我们会感到懊悔，所以我们要有一整个画廊。《幸福之路》 0 简介 引子 如何避免如只见树木不见森林头痛医头脚痛医脚按下葫芦浮起瓢治标不治本这类认识错误？ 为什么忒修斯之船中，即使把所有船板和零件都换掉之后，忒修斯之船还是原来的船？ 纷繁复杂的社会现象和生活问题，如何看到本质原因，找到关键解？ 避免孤立片面的看待事物，很多问题不是因为元素，而是因为关系和反馈延迟导致的认知错误，要更深刻的看到这些本质，这就要学习和训练系统思维了。 是什么 （概念） 【系统思维】是整体的看待事物，注重关系和结构的一种思维方式。 重要结构：两种【反馈回路】（增强和调节），重要特性：【反馈延迟】，还有【关键解】 怎么做 （方法）分析事物结构，比较相同系统，经常是反馈延迟问题。 如果多次更换要素还是不管用，就从系统关系和功能上思考 引导性提问 连问五个为什么，找到深层次的原因 注意考虑系统流量存量和增强回路，找关键解 重要方法 【系统循环图】，【丰田5why分析法】 如何解决系统性问题？ 如何应对系统延迟？缩短反馈延迟时间；耐心等待，确认变化趋势再做决定 相关【还原论】与整体论 1 概念 什么不是系统 一堆沙子，一堆石头，无关联的路人（硬要说的话，任何都可以算作系统，因为任何事物之间都有联系，只不过有些关系对我们来说不知晓，或不值得关注） 什么是系统 很多实体通过相互联系形成的有运作规律的整体 系统【三大组件】：要素，连接和功能 系统两大模型：增强回路和调节回路，统称为【反馈回路】 【关键解】（杠杆解，命门，关键变量，胜负手，主要矛盾主要方面） 系统是如何变化的，系统的动态结构 由存量（【储蓄池】），流量，增强回路，调节回路等很多个调节关系决定的 特点 不是单因单果，是多因多果，不是线性，是非线性 系统变化的关键特性：【反馈延迟】 既对系统施加的影响再很久后才会缓缓在现 好系统的三大特征适应性 自组织 层次性 系统分类（运筹学作者罗素艾可夫）：生物系统（张三，番茄，鸽子），社会系统（公司，城市，国家），机械系统（汽车，手机，软件），生态系统（森林，地球，海洋） 三大组件 要素 最明显的，重要性最低的，往往可以被替换 负要素 负能量 负信息 负债 正要素 正能量【信息】资产 连接（关系） 隐藏的，改变后系统就会发生重大变化 正关系既增强关系 负关系既减弱关系 功能（目的） 隐藏的，决定系统行为的最关键因素 为什么 为什么事物不仅仅是各部分的组合，见【忒修斯之船】悖论。并且系统出现问题，更换要素往往是不起作用的。 系统结构案例 为什么中国足球不行？关键因素是球员不行吗？但球员教练都换过多少轮了，还不行，说明问题可能出现在关系上，比如青少年球员的培训方法。 【忒修斯之船】，元素是木板，关系是木板的连接方式，目的是航行。即使木板全换了，后两者不变，系统仍然大体不变。所以细胞即使更新一遍，我们还是我们（系统角度）。 反馈回路 在系统思考中有且仅有两种回路，增强回路和调节回路，两者统称为反馈回路。 回路就是闭合的因果循环（鸡生蛋生鸡）一个回路包括两个以上事物和之间的关系。 事物的关系包括正反馈和负反馈，正反馈指的是一个实体如果表现出增强，另一个实体也表现出增强的状态。（鸡多蛋多） 反馈回路（包含增强回路和调节回路） 简单的动态系统模型中，流量和存量的影响是单向，当两者可以相互影响时这就形成了一个反馈回路。一个反馈回路，就是一条闭合的因果关系链。 增强回路：增强回路 也叫正反馈，它会不断地放大、增强一开始的发展态势，像滚雪球一样越滚越大。现实中有很多增强回路的例子，比如我们常说的赢者通吃马太效应。 恶性循环 负要素+正关系 良性循环 正要素+正关系 调节回路：调节回路 也叫负反馈 增强回路是让系统偏离初始状态越来越远，而调节回路是努力把系统拉回到原来的状态。 回归平庸 正要素+负关系 贤者时刻 负要素+负关系 增长极限 梅多斯说，如果我们观察到一个系统在呈指数级增长，那么这个系统中必然存在增强回路；同时，系统中也必然存在至少一个调节回路，因为在有限的环境中，没有一个物理系统可以无止境地增长下去。 增强回路案例 【复利效应】 调节回路案例 比如空调，当室内温度高于设定温度，就开始制冷；一旦到达设定温度，就停止制冷。再比如，我发现体重秤上的数字变高了，赶紧节食、天天吃草；一旦瘦下来点儿，又开始自我放飞、胡吃海塞，这也是一个调节回路。 反馈延迟 是什么 你对系统施加一个影响，它的结果往往会在很久以后才会逐渐显现。如果系统存在严重的反馈延迟，那么显然用试错法就不管用，还可能让问题变得更加严重。 怎么做 吃两片阿司匹林，并等待。我们知道药效会有延迟，所以会耐心等待，不会每隔五分钟就吃一次药。 缩短反馈延迟的时间。不是所有的反馈延迟都可以被改变，有些反馈延迟就是刚性的，人为改变不了。 增加观察时间 对环境信号的反应不要那么快，而应该慢一些，确认变化趋势是稳定的，再做决策，否则你就很有可能反应过头。 存量与流量 系统是如何变化的 由存量（【存储池】），流量，增强回路，调节回路等很多个调节关系决定的 特点 不是单因单果，是多因多果，不是线性，是非线性 流量的作用 如何提高存量？有两种办法：一是增加流入量，二是减少流出量，这两种方法是等效的。但梅多斯发现，我们一般人往往更容易关注流入量，而不太关注流出量。比如我们学习知识，很注重学习理论知识，而忽略知识的实践。 存量的作用 一个系统有了存量，那么流入量和流出量就可以相对独立，不用时时刻刻都保持一致。所以，如果说流量导致了系统的变化，那么存量对系统就起到了稳定和缓冲的作用。 特别是人生低谷的时候存量（存储池，缓冲区）显得尤其重要，用来抵抗【滞后效应】，增强系统的适应力 回路简单说就是一种闭合的因果循环。比如像先有鸡还是先有蛋的问题，是由于鸡的数量增加导致蛋多了，还是蛋的数量多了导致鸡的数量增加了？这两个是互为因果的关系，这样就构成了一个回路。 流量案例 比如，学习的时候，主要只关注了学到了多少东西，比较少考虑如何将这些知识保持下来，导致最终没什么知识剩下。 再比如，我想要存更多的钱，我肯定是整天琢磨怎样才能一夜暴富，而不是尽量降低消费。所其实按照财富自由的定义，这是指被动收入大于日常开支，那么很显然，实现财富自由有两种方式，一是提高被动收入，二是降低日常开支。 比如，一家公司想要扩大人员规模，它最容易想到的就是招聘更多的人，而不是减少在职员工的离职率。其实，减少离职率才是成本更低的办法。 存量案例 比如，有了存款，我的赚钱速度就不一定等于花钱速度，万一失业了也不至于挨饿；有了库存，产品的生产速度就不一定等于销售速度，允许有一定程度的偏离。 2 方法 如何解决系统问题呢？因果分析法 首先，确定是否是系统问题：如果多次更换要素还是不管用，就从关系和目的上思考 然后，分析系统结构，因果分析绘制 【系统循环图】，或引导性提问 连问【五个为什么】，找到深层次的原因； 最后找到关键解，这个关键解往往需要结合多个学科的知识才能得出 丰田5why分析法 见【认知心理学】https://www.bilibili.com/read/cv12540201 系统循环图第1步：准备工作。第2步：找问题。第3步：找原因。第4步：找后果。第5步：找回路。 准备工作。准备一张A4纸和笔，选一个较为舒适安静的环境。这些是进行系统思考的基本准备；或在线绘制【Process on】 找问题。在纸上写下你工作或是生活中经常遇到的问题或是非常困扰你的问题。如果问题经常出现或者越来越严重，说明问题背后有增强回路；相反，一次性的问题背后就没有回路； 找原因。思考这个问题可能发生的原因有哪些，即找出问题产生的原因。你可以把问题写在一张纸的中间，在问题周围写上三到五条原因； 找后果。找出现在的问题可能进一步导致的后果； 找回路。所谓的找回路，就是说思考你找出问题原因与问题导致的后果之间有没有相互连接和闭合的回路，如果有，就用带有箭头的直线标出，从原因指向结果，如果原因和结果之间是正反馈的关系，在箭头处标记一个加号，如果原因和结果之间是负反馈的关系，在箭头处标记一个减号。 按照以上5个步骤，基本上你就能画出一个系统循环图，并且能清晰地看到各个部分之间的关系。但在绘制系统循环图的时候还有几个关键点需要注意。第一，不要使用动词，要使用名词。人们通常倾向于使用动词来描述相应的行动，而不是使用一个名词。但是用动词来表述，得到的往往不是系统的结构，更像是在描述一个故事。比如说，使用服务质量而不是提供高质量的服务，使用处理能力而不是确保我们能处理，使用削减成本的政策而不是削减成本。第二，要注意箭头的方向，箭头方向代表了特定的含义。在系统循环图中，箭头被定义为因果的互动，从原因指向结果，所以箭头的方向一定不能画反，不然很可能会陷入思考的误区。 3 案例 头痛医头脚痛医脚：我们人体就是一个系统，其中还包括消化系统、神经系统、血液循环系统等子系统。如果你现在觉得头痛，你可能会认为是头出了问题，然后去吃头痛药，但事实上，很有可能是消化系统出了问题，从而导致的头痛，这就需要我们从整体上去看待人体系统中各个子系统相互的关系，不能犯了头痛医头、脚痛医脚的错误。 治标不治本：遇到问题的时候，只是看问题的表面或者某个方面，而看不到隐藏在问题背后一些本质上的结构性行为。这样在解决问题时，也只是把问题从系统的一个部分推移到另一个部分，没有进行彻底地解决，而且当事者也未能察觉到。这样，就导致了今日解决问题的方案就成了明日出现问题的原因。 比如一家大型零售公司，为了扩大销售额，在第一季度推出了多种促销手段，包括广告宣传、商品折扣、送货上门等等。这些手段都非常成功，使季度销售额增长了50%，但紧接着在第二季度，该零售公司的销售额却突然下降了50%。这是为什么？原因是第一季度搞促销活动，吸引了许多顾客提前购买，把应该在下季度购买的商品在这一季度购买了，而总需求容量本身没有太大的提高，这样就使得第二季度的市场需求急剧下降。 这就是只看到部分，没有看到整体的单向思维模式，销售人员只看到了一个因果关系，为了提高销售额，推出促销手段，这只是一个治标不治本的办法。问题看似解决了，但实际上并没有，还有可能引发出其他问题，比如像案例中提到的第二季度销售额下降。 4 应用 哪些问题可以用系统思维解决？ 如何养成习惯 最小良性循环原理：就是从最简单的开始，让飞轮转起来，比如要养成每天锻炼的习惯，开始先从最简单的做起，比如每天要养成跑步的习惯，先从每天跑10m开始，先让飞轮转起来，再越变越快。（即构造增强回路） 解释与解决问题 【魏则西事件】成甲 为什么魏则西会死？因为百度推荐了不良的医院 为什么百度会推荐不良医院? 因为不良医院给的钱多 为什么百度占小便宜不怕惹出大事？因为百度压根不知道这是不良医院 为什么百度无法及时发现不良医院？因为系统反馈不充分和延迟导致的 关键解：建立及时公开的反馈系统 【美铝利润下降问题】成甲 为什么收入不佳？因为竞争力低 为什么竞争力低？因为成本高，质量差，浪费多 为什么。。。？因为停工多，次品多？ 为什么。。。？因为生产安全性低 关键节：减少企业的安全问题 及时反馈解决的问题： 把电表装在能方便看到的地方，解决节约用电问题 每日记录饮食，解决肥胖问题 4 资料 《系统思维导论》 专业性和理论性有点强，看了一部分。先学下面的过度下吧 《好好学习:个人知识管理精进指南》 常用临界知识一节 《系统之美》 得到解读版 《系统思维》 内容和系统之美差不多，当做例子补充吧，重点是系统循环图 林超 跨学科工具箱 https://www.bilibili.com/cheese/play/ep6903","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"工程思维 - 如何从想到做","slug":"03工程学重要模型","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-03T13:18:45.071Z","comments":true,"path":"2022/01/19/03工程学重要模型/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/03%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%87%8D%E8%A6%81%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"第三课 工程学重要模型0 简介 引子：为什么要学习工程思维 有时常常是想的多，做的却不够；或是定了很多的计划，实现的却寥寥无几 … 那么如何从想&#x2F;知，转化为切实的行动呢？有了一个宏大的目标如何去一步一步实现它？如何真正的达到知行合一（知行统一）呢？ 将目标转化为实现，把理论转化为实践，就是工程领域最擅长做的事情。 是什么：工程思维，也可以叫作【搬砖思维】，如何从知道行，把一件事实现，重点是不断分解。。 怎么做 如何【从知到行】，包括分解结构、量化、列清单和取舍，还有OKR方法 相关【复杂性思维】工程思维的反面，分解vs融合，量化vs混沌，搬砖vs突变【系统思维】工程分解只是一种简化，分解的过程中会忽视掉事物的整体性，有时候有效，有时候确实致命的，这时候就需要系统思维来完善。 1 概念 工程思维是什么？既行胜于言，行胜于断。工程思维的核心是实现，什么事先动手做起来再说，工程师往往是这样一群人： 他们通常不太喜欢给一个事情的大方向做判断，更希望接手了一个东西就开始做，而且他们更享受的是精确的完成，而不是模糊的待定。 当遇到一个问题，他们的第一反应通常不是去沟通求助，而是自己钻研，看怎么动手解决，能动手就不动口。 你会发现工程思维，通常是在那个不确定性的坐标轴里面，更加倾向于去抓住了一些确定性更高的东西，而不喜欢跟那些不确定性高的东西打交道。 比如判断未来的大趋势；通过概率测算打赢德州扑克；赌一只股票能不能大涨，这方面的东西他们不喜欢干； 他们喜欢干一件事情就有一件事情的回报，这种行为特征有点像搬砖。 为什么要有搬砖思维：任何大事都需要脚踏实地一点一点做起，是相信量变会引起质变，只是空想什么也做不成；另外搬砖也是能获得快感的【多巴胺型，内啡肽型，这里应该是像古人打猎一样，很久的内啡肽加一次多巴胺，而非现在直接沉浸在多巴胺的快乐中】。 【风口思维】倾向于找找大方向，既战略问题胜过战术问题，必须找对方向再去做，其认为不是每件事情都会产生质变，所以其认为找到质变比积累量变到质变更重要。登山与冲浪的区别，因为浪需要等，山总是在那里。 2 方法 艺术的核心是表达；科学的核心是发现；工程的核心是实现。没有工程师解决不了的问题，只有不可以忍受的成本。 王阳明: 未有知而不行者,知而不行,只是未知把一件事做成，或一个想法实现实工程学最擅长的事，其中工程学积累了很多有用的方法，同样可以用到个人目标的实现上。 为什么：如何制定目标和计划并且完成，既如何从想到做，从知到行 是什么： 【分解】：看全局（想）-不断分解-找聚焦（做）-逐步完成，先明确目标，想要完成什么事情，然后从总体去了解，这直接关系到之后能不能有好的分解，然后不断分解，直到分解为动手就能做的程度，然后聚焦与此，逐步完成 【量化】：目标必须是具体的，可衡量的，不然很难明确需要做什么，导致可能永远无法完成 怎么做： 这里可以用【OKR】管理模型 比如看一本教材，先要然后读目录、建框架，把重要概念和练习学会 列【清单】 —— 每周计划 todo list —— 每天计划 时间表 【聚焦】并执行（行） 不断【分解】，直到到3月或2月，或一周的小目标，一定要【量化】 设定大目标，看全局（知） 案例 如何学习一个学科：首选要看全局，找到这个学科最权威的经典入门教材，读目录建框架，快速翻看，抓住目录中完全不懂的概念，一个个查概念与之间的联系，然后再分解来学习。 思考：很多事情一开始不可能看清全局的，随着不断行动才能更好的理解全局，所以计划是要不断调整的，但调整太快又会导致行动受阻，所以找到平衡是一个关键 （1）看全局（2）分解 天下难事必作于易——《道德经》既不能轻视也不能高估功能分解。分解不是牢不可破的真理，它只是便于人们克服自身能力的不足，无论是科学还是工程技术都是如此。 为什么：降低问题的复杂度 是什么：最常用的思维方式，将复杂的事物分解为部分，一一攻破。常用于各个部分相互之间影响小的。比如，成功的软件系统耦合度小，可以分解为各个部分来分析。再难的问题理论上只要把它拆分拆分再拆分，分解到我们轻而易举就能够上手动手的那个动作，然后就这么一做，实际上就能够实现从想到做的切换了。 怎么做： 先考虑这个系统适不适合做分解； 常见分解方式，分类，分组 构建系统的时候，尽可能降低耦合度 如何应用于计划的实现？ 找抓手爬梯子。第一步看全局，第二步分解并且聚焦，不断重复，直到找到抓手，开始行动，从易到难直到完成目标。 看全局：先要对要做的事有个全面的了解，掌握重点的概念，这直接决定到分解的好坏。 找聚焦：无论任何时候，你面对的都不是一座长城，而是眼前的这块砖； 注意：但是要知道这只是一种简化，分解的过程中会忽视掉事物的整体性，有时候有效，有时候确实致命的。 案例： 画出一幅画复杂的画，可以按空间切割成若干个小块 （3）聚焦 乔丹（Michael Jordan），有一句流传非常广的名言：Focus like a laser, not a flash light. 要像激光一样专注，而不是像手电筒一样。 在投资圈里面有个传说，说巴菲特和比尔盖茨第一次见面时，比尔盖茨的爸爸就问了两个人一个问题——人生最重要的品质是什么？然后两个人居然都不约而同地给出了一个答案——Focus（聚焦）这个传言从哪里来的无从考证，但这两个人的确在专注这件事情上，是做得非常好的。 案例造火箭 你要造的不是一个大的火箭，而永远是它的某一个零件。 当你专注聚焦到某一个小部分的时候，其他99%的部分都应该从脑海里消失，先去解决这一小部分，专注力。 重复看全局、分解、聚焦，直到解决问题。怎么从开始的想行动起来，就是找抓手爬梯子，天下难事必做于易。所以工程学的思维是让我们既见树木也见森林。 穿插的其他方法 清单（check list） 为什么：呈现优先级【取舍】，让人专注【聚焦】，利于推敲（找到忽略的细节和逻辑不严谨的地方），节省脑资源；阅读使人充实，会谈使人敏捷，清单使人精明。 是什么：分解和计划制定的工具，比如时间表和todo list，分为动态清单和静态清单 怎么做： 工具：飞书文档，把时间表和todolist融合到了一起；滴答清单；小米todo 【案例】建筑，金融等行业就是清单驱动的行业。又比如巴菲特的投资清单 取舍（trade off） Less is More 少即是多 在列清单时，会遇到另外一个问题——取舍。取舍，就是列清单之后的排序、优先级。排序是一个非常重要的工程学思想。你的时间有限，你总得思考先做什么后做什么。这就好像辩证法经常说到一个东西——我们要分清主要矛盾和次要矛盾，还要分清主要矛盾的主要方面和次要方面。这个说法它本质就是在甄选和取舍。 应用同时进行的不要超过五个，最好三个或以内 工程家往往是选择便宜和快的。而艺术家和完美主义者往往选好这一方面的。 投资界中有蒙代尔不可能三角，类比到男女关系中，不能同时拥有有钱、帅气、专一、浪漫，很多有结果的男生其实他不浪漫，因为他们的事业需要他们理智，如果你想找一个浪漫的人，这个男人大概率就是把他所有的心思都花在琢磨女人上面才会浪漫。 量化 为什么：分解过程中需要用到量化，比如一周学一节课，一天做三个页面等，目标必须是具体的，可衡量的，不然很难明确需要做什么，导致可能永远无法完成 比如面试的时候让你算万里长城有多重，这里一遇到问题就想到工程学来分解问题，然后想到第一个变量，如假设长城有1000公里，然后这就是解决问题的起点，然后再画图讲故事一样找到更多的变量，然后再通过简单的四则运算，进行量化。 怎么做：如何建立数学模型【数学建模】 先找到最容易想到变量。 通过叙事画图，找到更多的变量（写下来、画出来、说出来）。 通过简单的四则运算，把它们串联起来。 案例【人生目标】之前知识大融通这个目标一直很模糊，但量化为精通3个，熟悉9个，了解此外中图法所有学科，做出27个跨学科成果，一下子就很清楚了，并且可以作为一把衡量进度的尺子，量化的目标是不容易变化的，可以一直沿用，即使达到方法还未知 OKR（objective and key results） 为什么 如何把目标转化为行动 是什么 OKR（Objective and Key Results），又称「目标与关键结果法」，诞生于硅谷，是英特尔、谷歌 、甲骨文等公司使用的目标管理工具。 O 即 Objectives —— 想要实现的东西，是一个需要极致聚焦的明确目标 KR 是 Key Results —— 量化该目标的 1-3 个关键结果，是检查和监控我们如何达到目标的标准 action 达到关键结果的行动 怎么做 保持中等强度的动机，简单来说，就是你每天早上睁开眼，都为实现这个目标感到踏实和愉悦为宜。【动机强度理论】 有可能完成的最大目标，跳一跳能够着的那种 设定目标 目标应该是重要的、具体的、具有行动导向并且能鼓舞人心的。它能够有效防止思维和执行过程中出现模糊不清的情况。 设定关键结果 参考 【SMART法则】，既具体的，量化的(是为了可追溯），可达到的，相关的，基于时间段（最重要的是可量化），关键结果是对目标的细化再量化 指定行动计划 设定每周任务和每日任务 注意目标最好是一个季度或两个月的，长期目标需要进行拆分同时的目标控制在三个以内（3-5），少即是多【取舍】 案例 资料https://zhuanlan.zhihu.com/p/372093831https://zhuanlan.zhihu.com/p/266000663 相关【黄金圈思维】一般思维是从what-how-why，而黄金圈是从why-how-what，其中why就是目标和信念，和OKR一样都是要聚焦目标【清单】清单适合简单工作，因为清单不能帮助你战略性地分辨优先级，也不能结构化地添加可执行细则。而这些，正是 OKR 的强项。OKR和清单在日常中的应用并不互斥，而是相互补充——OKR 是你目前在做的主要项目，每天当然也会遇到各种与主线不相关的支线任务，这些杂事则用清单记录（因为人脑更容易记下图片而非抽象的关系）。 另外一点 3 案例画一幅画 比如对于没有任何美术基础和缺少绘画天赋的人，似乎画出一幅艺术作品是不可能的梦想，但用上分解的方法后，即使用 [左手] 也能画出《蒙娜丽莎》。 PS 这是托尼伯赞《唤醒创造天才的10种方法》中的案例，文中是为了证明每个人都有艺术家的天赋，而文中的方法就是分解。 具体地方法如下图所示，你会看到一些放个，每一个方格以一个字母和一个数字标记出来，每一个放个都填上了一些不同长度和角度的线条，但每格的线条不是太多。 你的任务是，用你不常用的手仔细模仿前一页的图案，在对应的方格中画下来。 可以发现，每一格的内容都不算复杂，但组合在一起就方程了一幅复杂的艺术作品，这就是【分解】的力量。 上面的分解方式很简单，人人都可以理解并且动手操作。其实专业的绘画者也是采用的【分解】的方法，只不过不再是这种简单粗暴的方式了。 如下为达芬奇画的一幅马的轮廓图，在这副轮廓图中，他将马腿分成不同的部分，即几个基础的艺术构建单元，然后再够画最终的，详细的线条。 而当下受过美术训练的绘画者，也是将一幅画【分解】为结构与细节，先画出骨架，在一点点完善，这也是分解的思想。 这个案例可以体现出【分解】的强大效果和重要作用，同样分解的方式有很多，而分解方式的不同往往代表着认知层次不同，更好的分解应该是更深刻，的更接近事物本质结构的，更具有一般性的。 练一首曲子 分解是有好坏的，比如上面案例中的以结构和细节的分解角度，显然比空间的分割更好，因为练习过程中前者更能够具有举一反三的作用。 其他领域的练习通用如此，分解思维固然重要，但好的分解更关键。 比如想练习一首曲子，最直观的分解方式是一个小节一个小节的练习，如果还难的话，就四分之一小节的练，甚至一个音一个音的练，然后不断熟练，最终连在一起弹出来。用这种方式可以把曲子练出来，但练得多了会发现，技术没啥提高，曲子一首一首练过了留在脑子里的却没什么有价值的东西，仅仅靠肌肉记忆死记硬背下来罢了，过段时间忘了之后就基本什么也不剩下了。 这和把一幅画从空间角度上分割成很多小块一样，这样的分解是粗暴的。更有效的分解应该是建立在事物本质之上的，比如音乐的分解应该是乐理角度的分解。 比如把曲子分解为，主旋律，伴奏加技巧，伴奏可以分解为一个个和弦进行，更细致的可以从和声角度进行分解 例（黄：旋律，蓝：伴奏，绿：技巧） 这时候练习一首曲子之后，就是把一大类曲子都学会了，这就是认知层次的提高，这类分解往往考虑到了整个系统的关联，而保留了这些重要的结构信息。 开发一个软件 软件是人类有史以来生产的复杂度最高的工业产品。软件工程也是工程分解结构应用到极致的学科之一，其中有大量的案例和方法可以学习 比如任何复杂的软件都可以分解为一个个服务，服务在分解为一个个包，再分解为一个个接口与类，再分解为一个个方法，最终落实套某个小问题的解决上。 还有一些分解方法，比如前后端分离，三层架构等等 软件工程对解耦上有着大量的成功案例，几乎每个成功的技术都是因为其在解耦上做出了的贡献。 。。。 这方面可以总结的太多了，之后专门总结下 实现人生目标 比如个人目标是实现知识大融通，这是一个很大的目标，也是一个理想的方向。多年来陆陆续续看过不少学科和领域的东西，但似乎一直感觉在原地打转，这还是目标分解和量化做的不到位，所以这节课程后重构了实现目标的计划细节。 最早确定人生目标是几年前，当时目标就是一句话：”不断学习领域外的知识思维”。 如今看来太简略了基本没做什么分解，并且完全没做量化，这样子的目标和计划没法有效的执行，这几年的实践结果也是如此的。 那么如何【分解】呢？首先要知道这个事情的实质是学习，就如曲子可以分解为旋律和伴奏一样，学习的本质可以概括为 知识 和 实践，而并不是所有知识都值得学习的，应该优先学习更底层的临界知识，比如思维方法这类的一般性更强的知识。于是可以分解如下：从知到行，临界知识——学科知识——生活实践，但重点是如何【量化】。 其实量化的思路还是比较清晰的，人类已有的学科是有确定的，比如看中图法，分类大概有几万个，虽然很多，但是是有限的。之后就是一个【取舍】的过程了，根据自己的兴趣和情况有主次的学习，比如目标可以分解如下： 目标：知识大融通——（以临界知识为终点），融通所有学科，并做到知行合一；关键结果：精通3个，熟悉9个，总结27个跨学科临界知识，做出81个跨学科成果，了解此外中图法所有学科，最终实现百万量级的知识图谱，将所有学科贯通到一个图谱上 目标1：精通3个方向：知识管理，程序开发，吉他 目标2：熟悉9个领域：计算机（人工智能&#x2F;NLP，爬虫，python，算法VR，3D打印，机器人），数学（初等数学、高等数学、离散数学（群论）、数学建模，数学史，分形几何，混沌，维度，无穷，博弈论、趣题与悖论、数学科普视频），艺术（唱歌，绘画，手工，视频制作，摄影，编曲，舞蹈，练字，魔术），文学写作，心理学，做饭，体育（羽毛球，乒乓球，健身，围棋，武术，健康管理），教育学及学校科目，英语 目标3：总结27个学科临界知识：数学（函数），物理学（热力学），生物学，心理学（认知心理学），文学，化学，哲学，社会学，计算机，工程学，复杂性科学，系统论，信息论，会计学，概率论，金融学，投资学，管理学，脑科学，历史学，语言学，逻辑学，经济学，营销学，人工智能（超智能体），艺术 目标4：做出81个跨学科成果。。。 目标5：了解此外中图法所有学科 到这里继续从时间上量化，比如，每年熟悉一个学科，每年做出3个跨学科成果等，这样子可能需要三五十年，但是终究是一生可以实现的目标，即使实现方法可以变，但量化的目标是固定的，就可以明确知道自己的进度到哪里了，这种量化的反馈就很重要。 然后就可以正式计划第一个去做的目标了，比如半年把跨学科知识学完，相当于打一个大框架，作为以后学习各个学科知识的基础，这也是看全局的过程。这里可以用上OKR。 O ：半年学完27个邻接知识 。。。 。。。 KR1 跨学科工具箱听完，每个搜集5篇相关资料 KR2 每个发表一篇笔记，先能看然后慢慢优化 KR3 笔记阅读量达到500 时间表 每天早熵课程资料，周末发一篇文章 action1.1规划 action2.1规划 action3.1规划 然后就是每周计划和todo list了：每周学习一个学科临界知识。 然后就是【聚焦】当下了：比如这周的 【工程学思维】的学习。 。。。 这样子制定的目标，有明确【量化】的完成结果标准，并且【分解】为了可执行的小部分。 长此以往，最终的标终会一步步到达实现。 4 资料 林超跨学科工具箱 https://www.bilibili.com/cheese/play/ss298 托尼伯赞《唤醒创造天才的10种方法》https://www.soupan8.com/file/877968 OKR相关资料 https://zhuanlan.zhihu.com/p/372093831https://zhuanlan.zhihu.com/p/266000663 吴军 谷歌方法论（待学习） 老喻 聪明人的10个工程思维（待学习）","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"函数思维 - 因果变化之器","slug":"04函数的重要模型","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-03T13:18:47.086Z","comments":true,"path":"2022/01/19/04函数的重要模型/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/04%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%A6%81%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"函数重要模型总论 为什么 更好的描述和理解世界的变化规律。从直觉到理性(棋盘，并且一直有启发作用，比如黎曼函数) 人的思维有短视性，需要时间函数帮助看到全局 很多成熟函数模型都是可以直接拿来用到生活中的 人的思维习惯是线性的，但很多变化规律是非线性的 是什么 函数是描述客观世界变化规律的重要数学模型 基本函数 指数函数 对数函数 幂函数 时间函数 最常用到的变量是时间，可以进行时间预测，避免只收到短期趋势的影响而跳出时间看到全局（收益，成本，骨架，情绪，精力） 怎么做 所以要不断收集成熟的函数模型 如何得到两个变量的函数关系，首先看有没有现成的，或者现有函数模型的组合 任何一个结论，往往需要多个学科模型的相互验证才可以，也就是多元思维指数函数 y&#x3D;a^x , a大于1或者小于1 是什么 事情A，会导致结果B，而结果B又会加强A，不断循环。简单来说，就是利滚利。有两个因素会极大地影响复利的效果——利率和执行次数。 所谓“利率”，就是做A导致B后，B对A能有多大的强化作用。 特点 在刚开始的时候复利效应是很微小的、不易察觉的，但当发展到一定阶段就会产生非常惊人的效果。 数学描述 F&#x3D;P×(1+i)^n。其中F代表终值（future value），或叫未来值，即期末本利和的价值。P代表现值（present value），或叫期初金额。i代表利率。n代表计息期数。 这正是1.02的365次方等于1377.4，0.98的365次方等于0.0006的原因啊 复利效应带来的结果 幂律分布，而很多都是正态分布，两者都区别在于有没有触发临界点 为什么大多数人很少能有意识地将复利效应应用到我们的生活中呢？见 &amp;nbsp;数学与生活 人的思维习惯是线性的，毕竟生活中指数很少，所以很容易被刚开始平稳的发展给迷惑，即使专家也容易忽略，比如新冠疫情，所谓的突然爆发只不过是一开始被人们忽略了。 怎么用 首先，我们要在生活中发现“A导致B，B加强A”这样的事情；其次，我们要尽可能地提高这件事情的利率；最后，我们要加强这件事情重复发生的可能性。 指数增长的脆弱性 很容易被拦腰截断，比如在逻辑斯蒂方程中，正是有一个环境阻力把方程限制在一个数量之下。又比如，给你一个鸡蛋，然后蛋生鸡鸡生蛋，就会有很多鸡，但是有一天鸡蛋突然碎了。 假设你有机会能进入到一个指数级增长的行业里，或者在自己身上引发一个指数级的变化，那么你就要打起十二分精神来，因为只要成功应用一次指数效应，人生就会被改变。 对数函数是指数函数的反函数。出道即巅峰，这里log函数的就有一个玻璃顶。如一个城市里共享单车的数量是有一个玻璃顶的。玻璃顶&#x3D;》时间约束、空间约束、青春约束、内在价值约束（如一个内在价值不强的产品宣传之后的销量）。 案例 银行的存款越多，每年的利息就会越多，那么银行的存款就会更多。一个人认识的朋友多，就会有人愿意将你推荐给更多朋友，那么你就能认识更多的人 棋盘与米粒 每一次都会比上一次多一倍，不断累计，这就是复利的威力复利效应会导致 穷者愈穷，富者愈富 相关复利效应可以作为，系统增强回路的拓展 logistic 函数 源自人口增长模型，比如描述人类历史的人口增长，可以广泛应用于各个领域，用来描述事物经过告诉发展后逐渐趋于稳定的过程。 为什么 罗基斯特方程就是指数增长曲线和环境阻力共同构成的【指数函数】 高特纳曲线 倒u型曲线 没有什么是永恒的 用来描述事物到达顶峰的衰退现象，可以用来描述国家发展，生命机能发展，流体智力的发展 过犹不及 事情做的太多了，跟做的不够一样，都是不合适的。这也就是哲学里度的概念。 怎么做 善于发现有拐点的事物，然后去找到拐点 案例 拉弗曲线X 税收 愉悦度 健康度 国家水平 流体智力 身体机能 记忆效率Y 税率 &amp;nbsp;进食 &amp;nbsp; 锻炼 &amp;nbsp; 时间 &amp;nbsp; &amp;nbsp;时间 &amp;nbsp; &amp;nbsp; 时间 &amp;nbsp; &amp;nbsp; 压力 耶克斯道森法则 应用描述【心流】的产生条件。 心流（英语：Mental flow）在心理学中是指一种人们在专注进行某行为时所表现的心理状态。 如艺术家在创作时所表现的心理状态。心流：将注意力完全投注在某活动的感觉。 凹凸幂函数y&#x3D;x^a,a大于1或者小于1 持续增长，没有上线 《规模》头部国家发展曲线 职业发展曲线 线性函数不要滥用线性函数，生活中很多都是复杂场景 伦敦大学的反恐专家曾经在报纸上说： 2005年10月底，恐怖袭击让1074个以色列人死亡，7520人受伤。对以色列这样一个小国而言，这两个数字已经大得惊人了，按照比例换算，相当于有5万个美国人死亡，30万个美国人受伤。 美国大作家马克·吐温，早年间，曾经在密西西比河上当水手，还写过一本《密西西比河上的生活》，里面这样写着： 176年前，下密西西比河在凯罗与新奥尔良之间的河段长1215英里，经过截弯取直之后，缩短为1180英里，之后在美洲湾取直，缩短为1040英里，再后来，这个河段又缩短了67英里。也就是说，在176年的时间里，下密西西比河缩短了242英里，平均每年缩短一又三分之一英里，因此，只要不是瞎子和白痴，我们就不难推测出，再过742年，下密西西比河将只剩下不到两英里长。 人性曲线 细胞收到刺激的电位变化情况是人收到刺激时情绪变化情况的缩影。 波动函数普适性很强，从波动函数看大趋势，是黎明前到黑暗还是黑夜前的黄昏。 意义 不要因为一时的低估而放弃，也不要因为短期的光鲜就认为会一直上升。 这个大趋势往往就是多元思维，多个模型的相互映证才可以判断出来这个大趋势是怎样的，系统论当中会解答一些。 不要因为遇到一点挫折就退出朝阳赛道，但是衰退的赛道，你一进去，就会跟着下滑。 曲线来描述职业 资料魔鬼数学 得到解读版 数学分区 https://www.sohu.com/a/288952037_115476 吴军 数学通识50讲https://www.dedao.cn/article/WqavDm012GolV7OOQ0VxPjEy8zdk73?source=search 遇见数学 公众号 相关文章 matrix67 奇怪的函数","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"脑科学模型 - 通向知行合一","slug":"05脑科学重要模型","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-03T13:18:46.480Z","comments":true,"path":"2022/01/19/05脑科学重要模型/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/05%E8%84%91%E7%A7%91%E5%AD%A6%E9%87%8D%E8%A6%81%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"第五课 脑科学重要模型 引子：脑科学几乎是所以研究人类行为的基础学科，对我们的学习、思考、工作、投资、恋爱都有帮助 三元脑（triune brain）模型：分别是【爬行脑】、【哺乳脑】和【人类脑】 利用更容易控制的人类脑（知）驯化更加不可控的哺乳脑（行），这是【刻意练习】的原理，也是不断进步与通往【知行合一】的关键。 人类一些能力具有相关性，往往是因为负责这些能力的脑区挨得比较近。 越底层越不受我们控制，而这往往被商家所控制。 脑区激活的越多，印象就越深刻，比如【费曼学习法】 大脑微观结构：【神经元】 人类脑（新皮质） 人类脑（新皮质）：分为【额叶】【顶叶】【颞叶】【枕叶】，主要功能有 分析推理、复杂思考等、慢决策，比如换工作、换城市 额叶：智慧、分析、推理、抽象 顶叶：统筹协调 空间想象 处理与环境都关系 数学 枕叶：视觉 颞叶 语言理解 人脸识别 洞察力 学习和记忆 额叶 额叶主要负责：智慧、分析、判断、推理、社交、自控、学习、语言、洞察 前额叶皮质是之所以为人的关键区域（人类占比最大）； 15-25岁才会发育完全，15岁之前的孩子社交自控能力和成人不一样；前额叶皮质越大的动物，它就越聪明，而且只有前额叶皮质大到一定程度，才会出现语言神经中枢，而这个中枢只有人类有。 人类的额叶中的布洛卡区（语言表达）和颞叶中的威尔尼克区（语言理解）是人类最主要的两个语言神经中枢 。 自控：自控力是人类成熟的标志之一，取决于前额叶皮质的发育程度，所以小孩通常没有什么自控力，年轻人容易冲动。 自控与延迟满足感的能力，是成长和幸福的关键；（Between stimulus and response there is a space . In that space is our power to choose our response . I our response lies our growth and our freedom .刺激和回应存在一段距离，成长和幸福的关键就在那里。） 现代自控能力成熟的更慢了，因为信息分析需求更高，此消彼长。 镜像神经元，核心功能是凭借本能去模仿他人的行为，而且提供共情能力和同理心，主要分布在前额叶皮质的两大区域。 运动区：运动区直接脑干和脊椎，所以你会发现有时模仿别人是情不自禁的。 布洛卡语言区：所以学习语言的本质是—模仿和社交。 镜像神经元还与我们产生共情的能力、同理心有很大的关联。 还跟音乐能力高度相关： 所以音乐天赋好的人，通常语言能力都不会差。 因此语言和音乐学习的捷径，其实都是深度浸泡在大环境里面，拼命模仿别人。而反过来通过考试做题，分析推理来学习是会事倍功半的。 顶叶 顶叶：顶叶最核心的能力是综合处理环境和自己的关系、宏观调控、统筹协调、整合信息、空间想象力、数学能力。 以顶叶的关键词就是整合、想象、协调、抽象。 &amp;nbsp; 特点：顶叶发挥作用的过程，很多时候无法解释，它具有突然性和天然性，比如 “开窍” 和 “顿悟”，其实说的就是自己的顶叶。 &amp;nbsp; 很多的数学天才，说自己能够在大脑里面看到一些数学公式呈现的复杂图像结构。这是因为他们的顶叶非常发达，想象力和数学能力因为都在顶叶。 枕叶 枕叶：主要负责视觉，也是处理视觉最大的脑区，所以猛地敲一下后脑勺会眼前一黑； 启发：处理视觉的脑区非常多，相对的听觉较少，所以一图胜千言。 颞叶 颞叶：语言理解、人脸识别、学习和记忆。颞叶主要功能是接受和理解世界的各种信息，所以它也是洞察力的主要来源。 人的大脑里观察和倾听细节的功能，几乎都集中在颞叶。 &amp;nbsp; 颞叶三回：颞上回，听觉记忆；颞中回，语义记忆；颞下回，人脸记忆。 启发： 我们学习和记忆的能力跟我们观察细节的能力高度相关； 我们对人脸或者图像的记忆力尤其强是因为，一整个区域（颞下回）加枕叶，加顶叶的一部分都在处理它。 费曼学习法 怎么做：以教为学，言传不如身教。如果你要学会某个知识，最好的方法是去教会别人，而教会别人的最好方法，又是能够边说边画，调动所有感官。 为什么：唤醒的脑区越多，知识掌握就更深刻。 学习时如果你能说出来，就比你单纯在脑子里面去想，记忆更深刻，因为你同时激活了前额叶、布洛卡区、颞上回； 如果你还能够写下来和画出来，那么你又唤醒了多个视觉神经中枢； 如果你还能跟别人讲一回，那么很可能更进一步唤醒自己的镜像神经元； 如果对方还能听得津津有味，那么你还会进一步唤醒头脑里面负责奖赏的下丘脑； 这个原理其实不只是用在学习上，也包括营造体验、同事沟通、打造品牌很多领域。 哺乳脑（边缘系统 limbic system） 哺乳脑：越往下走，其实就越发进入了本能、直觉和情感这些区域。 &amp;nbsp;边缘系统主要负责长期记忆、情绪管理、性唤醒、嗅觉，快决策。比如一见钟情，买瓶可乐，吃什么饭。 嗅觉：这个区域即跟情绪相关，又跟嗅觉相关，所以嗅觉往往对我们的身心影响会非常直接。嗅觉关系情感和记忆，所以约会时气味很重要，还有蛋糕房可以制造香气，激发购买欲望的。 扣带回：负责焦虑、负面想象、情感、痛苦、自我调节。女生这方面比男生发达，所以说，女生会想一些男生认为乱七八糟的东西，所以女生看到一个东西的时候，会产生很多联想 ，注意更多的细节，这样更容易产生焦虑感。但女生的自我情绪调节能力也比男生强。 【杏仁核】：负责恐惧、愤怒、兴奋、决定我们遇到危险时战或逃的选择。 下丘脑：功能是出汗、控制体温、口渴、血压、心律、饥饿、性、颤抖、生物钟、养育本能等，这些都是人类非常基础的功能。 因为下丘脑和杏仁核挨得非常近，养育本能可以反过来让下丘脑去抑制杏仁核的劫持功能。比如老虎扑过来，如果妈妈带了孩子，她则可能会战斗，因为要保护孩子。 基底神经节：作用是操作技巧习得、习惯养成（上瘾）、奖赏系统。 这里面最关键的区域叫伏隔核， 好比是人类大脑的后面，可以绕过理性被商家利用。 另外，女生的边缘系统往往更发达，而且嗅觉也比男生更强一些。 杏仁核 理性和感性的中转站，三大脑区的交汇点。 作用：遇到恐惧刺激时，杏仁核会直接让整个额叶失去思考能力，只留下本能在发挥作用。 &amp;nbsp;恐惧会让一个很聪明的人，瞬间变成白痴。 例子：比如现在旁边突然出现一条毒蛇，你的大脑会迅速被杏仁核劫持了，你根本来不及思考，会立即逃走，除非你家里是世代捕蛇的人，这里决定你是退还是战，和你的过往的经历有一些关系，第一反应才可能是一把抓住，这也是杏仁核决定的。 启发：巨大的恐惧和压力面前，读再多的书都是没用的，智慧知识经验都是没用的，身体会本能做出反应。 如何训练杏仁核：只能让自己多身临其境，直面恐惧；比如你想训练炒股能力，就尽早的去亏一些钱，多去体验这种恐惧感， 使之后遇到这种情况更有可能理智决策。 爬行脑（脑干&amp;小脑） 爬行脑：分为脑干和小脑，是大脑最早进化的部分，属于生存的本能，基本无法被驯化 脑干：生物钟、睡意、呼吸、心率、消化、体温； 其中【呼吸】是唯一可以控制的功能。 呼吸：呼吸的区域，从人类脑的运动区，到哺乳脑的下丘脑 ，再到爬行脑的脑干，再到脊柱，控制连成了一条直线。 &amp;nbsp;所以，呼吸的训练几乎是古今中外，所有修行都会涉及到能力。道家、瑜伽和现代医学，都很重视呼吸调节对神经的作用。 安那般那法门简化版：吸气，缓慢吐出之后（达到“空”的状态），屏息数数，憋不住了再呼吸调整下，多做几组帮助快速平静下来，注意用腹式呼吸，能数的数越多，表明思绪越少 腹式呼吸：它可以刺激我们内啡肽和血清素的分泌，让它成为一种习惯，对我们的身心和减缓焦虑都是有帮助的。 小脑：功能为保持平衡、条件反射、身体协调 神经元 神经元：它的细胞体是由树突和轴突两部分构成，两边的树突通过神经末梢相互连在一起，中间的轴突用来传递电信号。 神经元的连接机制：每个神经元都可以和若干个其他神经元相连接，不断重复的去激活，一起被激活的神经元才能够慢慢的链接在一起，最终长成一条坚固的链路。 髓鞘质：我们假设神经元是一个电线，那么电线的电信号传递的过程中，它外围其实包裹了一层绝缘体，这层绝缘体就叫做髓鞘。 刻意练习 如何学习一门技能：通过刻意练习。学习一个新的技能的本质，就是不断重复激活让相关的神经元链接到一起。 怎么做：重复训练 + 针对性训练 练习：要重复训练，只有重复次数够多了，链接才能被牢牢建立起来 刻意：要有针对性的训练，要全面，并且针对弱项，更基础和底层的更需要训练 慢速：以慢为快，只有放慢速度，才能够实现过脑子。 为什么：重复联系是因为不断激活神经元，形成链路；慢速才可以调用更多脑区，并且促进新的髓鞘质形成，提高思维效率。 实例，富兰克林训练法：每一页从左到右是周一到周日，而从上到下，是想到要掌握每一种能力的首字母，然后每天自省，把发现有过失的地方标注一个小黑点，并且每周只关注其中一项能力，比如一周下来，早起这一栏打满了黑点，就表明这周的练习很失败，下周还得继续练习早起，反之则进行下一项能力训练，如此重复，不断迭代。 横轴代表不断重复；纵轴代表刻意选择 启发大家不是单一的人，不是只有一种行为模式，而是一堆不同的脑区域行为模式的组合体，你喜欢或者讨厌的人，在完全不同的场景下，也可能显示出不同的人格特征。","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"复杂性科学：从量变到质变","slug":"06复杂性科学","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-03T13:18:44.759Z","comments":true,"path":"2022/01/19/06复杂性科学/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/06%E5%A4%8D%E6%9D%82%E6%80%A7%E7%A7%91%E5%AD%A6/","excerpt":"","text":"第六课 复杂性科学引子 人体的功能远大于各个细胞之和，研究夸克并无法帮助我们理解人类社会，简单事物和规则的聚集往往会产生质变，复杂性科学就是着眼于此现象的科学。 【还原论】：分解，聚焦，逐个解决；这是这几百年科学研究的主要思路，科学之所以称作科学，也就是分科之学，分而治之的研究问题。 【整体论】：因为事物的系统性和复杂性，还原论的局限性愈发明显，所以近几十年来科学界开始重新研究和反思，采取整体论的思路，因此产生了【复杂性科学】 【复杂性科学】：上世纪八十年代诞生，目前还没有形成完整的学科体系，但仍然举足轻重，被称作是“21世纪的科学”，对公司管理，金融系统，人工智能，生命科学，国家治理，自我管理都有指导意义 扩展资料：《复杂》《规模》《失控》《系统之美》《复杂性思维》 相关： 【系统论】是复杂性科学的一个子集 【跨学科工具箱】也可以看做是复杂性科学的一个衍生品 复杂性科学与以下众多的名词有关 概述 复杂性科学-定义：运用跨学科方法，研究不同【复杂系统】之中的【涌现】行为和统一性规律的一门学科（北师大张江定义） 复杂系统-定义：大量个体【聚集】之后，通过个体简单运作，产生群体复杂行为，并能通过【进化】产生【适应性】的一种系统； 例子，常见的复杂系统：蚁群，大脑，人体，经济系统，互联网等 【蚁群】：大量蚂蚁聚集之后，虽然每一只都很简单，但却产生了集体智能，可以进行筑巢觅食等复杂活动 【大脑】：每个神经元都很简单，几百亿的神经元通过简单的交互规则连接后，就涌现出了智慧 聚集 【聚集】是产生复杂系统的必要非充分条件，即大量的聚集也可能反而产生 1+1&lt;2 的效果，即集体愚蠢 【集体愚蠢】是怎么产生的呢？特点是单体复杂，规则复杂肤浅，集体高度同质化和内卷，此时是1+1&lt;2； 比如堵车，每个司机都希望最快到达目的地，试图战胜交通规则，然后所有人都到不了目的地； 比如大学生求职，因为大部分人受到的教育都类似的，所以产生了高度同质化，也就造成了内卷； 与之相对的是【集体智慧】，特点是单体简单，规则简单深刻，集体多元化与和谐，此时是1+1&gt;2； 比如由中央系统统一调度的自动驾驶，减少人性所导致的例外情况发生，让集体利益最大化； 比如亚马逊丛林，每个物种都有自己的生态位，多样性的物种大量聚集之后，构成的和谐共融的生态系统， 产生集体智慧的关键 ：1-简单个体 2-简单规则 3-大量叠加 比如【蚁群算法】：派出大量蚂蚁寻找食物，每只蚂蚁都按照简单的规则（就是找到食物就返回巢穴，每只蚂蚁都延信息素最多的道路走，而不是想着停下来看看风景或者找到一个食物再去找下一个食物）不断往返形成闭环，最终蚁群得以发现食物并且找到最短路径 蚁群对人生的启发：人生寻找并实现目标的过程类似蚁群觅食，如果我们把每时的自己切分为不同的“小我”，而这些“小我”能遵循简单深刻的规则，聚集成一生后，也有可能产生超越自我的”高维智慧“。 切割时间：切割的越细越能产生质变；人的一生有几万天，但有接近百万个30分钟 化繁为简：在切分的时间段里保持高度【聚焦】，尽可能保持头脑里只有一个念头，因为每时每刻头脑中都会显现不同的念头，所以要尽可能减少念头的数量。 不断闭环：做一件事情尽可能盯着结果去做，形成闭环，即以终为始 不断重复，积少成多 复杂事情简单化，简单事情重复做 那么这个简单的规则是什么呐？ 聚焦四段论（如何在一个碎片化的时代聚焦起来做一件事，比如写一个论文） 清理念头：在集中注意力做某件事之前，先提前抽出三十分钟到二十分钟来清理念头，把这个时间段里所有的念头写下来，比如我担心的事，我计划的事，然后对其排序，保证我的大脑里在开始干这个事的时候只有一个念头。 忘我聚焦：聚焦一段时间，把这个任务的最难的部分消化掉。 刻意休息二十分钟：可以定闹钟，只有这段时间可以玩，想好玩什么。刻意休息要比不刻意休息一两个小时的放松效果要好。 惯性工作x个小时：把该任务的剩余部分完成。 涌现（是复杂科学中最精髓的概念） 【涌现】：整体大于部分之和；随着成员数目的增加，链接数会不断增加，而当链接度超过某一临界值的时候，就会出现涌现。 比如大脑神经元链接数达到某个数量级后，会涌现出”意识“ 涌现的【层次性】* 原子—分子—蛋白质—细胞—器官—人体—社会，每一层都是一次涌现* 每一层的涌现，都会产生更高级的行为，产生全新的特性* 即使今天再复杂的生物，他的生命力，生命的体现，是层级涌现、递进的结果。所以说，公司或者厉害的决策人，剖析出来都是使用简单的决策模型，层层涌现出来构成的。 层次性】案例 《盗梦空间》拍的很好，因为你会从它的音乐、视觉、表演、剧情、逻辑的很多不同角度去看它时，都会发现这些细节都有可圈可点的地方，这个东西就是它的层次性。 好的音乐，甚至好的乐器的音色，也会被称为“有层次感” 人生启发：围绕最小内核，逐层构建一层又一层的涌现和递进的系统。所以说在年轻的时候就找到自己的最小内核，这是很有价值的事。 ​ 迭代(进化) 【迭代】：我们做任何复杂事情，这个创作的过程都不是一蹴而就的，应理性接受我们总是能够从一个相对粗糙的版本不断优化，最后慢慢变成一个相对完美的版本。比如软件的版本迭代。迭代将复杂事物慢慢搞到一个相对完美的版本。 与之相对的【工程分解结构】中的方法论，比如一辆汽车，可以先把发动机造出来，然后再把身体造出来，然后再逐层递进。 如果这个世界上没有汽车，那么你想探索一种四轮代步工具，就应该从最简单的一个滑板车开始造起，它就叫最小可用产品，然后找到产品市场契合点，不断迭代到汽车。 延伸概念-【精益创业】：想法-行动-结果-衡量-数据-复盘，不断循环迭代，让结果变得越来越好 需要注意的是，迭代不可能每一次都是前进的，很可能原地踏步，甚至倒退，因为本来就是一种探索的过程，但不断迭代就会遇到拐点，进入下一阶段。 人生启发： 钢笔画目标，铅笔写道路；即道路（铅笔画的）很灵活，目标（钢笔画的）很坚定。扩展资料《坚毅》 我们做创新时或寻找自己人生的道路时，也可以使用这种方法论。 简单总结，就是不要追求完美，尽快交付，然后闭环，不断改进复盘，再交付再闭环，并且要保正确的心理预期。这样子就能避免铅笔画完几格之后，但是自己发现再原地踏步，接着灰心丧气感叹人生好难。 上图就可以部分解释：为什么很多人会放弃的底层逻辑就是他对这个世界的版本迭代的模式的理解有偏差。 没有一个方法论是万能的，与之相对的方法论，比如大力出奇迹，顶层设计，集中精力办大事，即经过深思熟虑之后，一次性把东西做成。 比如今天中国要干芯片，中国突破一些关键技术，就得猛虎搏兔，超高规模的投入之后，一定要确保把这个事情干成。 商业中有一个思想叫精益创业，其最底层的内核如下图所示 适应性 如何提高适应性？**伤害-恢复-变强 ** 的闭环，对人类、对任何复杂系统而言，它其实都是成立的。 比如健身，我们想练出肌肉就必须在某一个时间集中训练之后，练出酸痛感。这个过程你需要给它时间恢复，它长出来之后，你继续锻炼，就继续变强。 很多国家在战争中被摧毁，在它之后重建时反而一下子爆发出来更强的生命力。所以这个就涉及到老概念——走出舒适圈，适度受伤害对我们的成长是有价值的。 人生启发：走出舒适圈，但别走太远； 就好像运动非常好，但是如果过度运动让自己致残，那么这个反而得不偿失，因为你已经过度拓展舒适圈，以至于进入死亡区了。 一个非常好的复杂系统就会产生良好的适应性，人类就是一个很好的复杂系统 成果圈比能力圈小很多，这正是厚积薄发的意思。","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"认知心理学—认知你的认知","slug":"07认知心理学","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-03T13:18:46.437Z","comments":true,"path":"2022/01/19/07认知心理学/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/07%E8%AE%A4%E7%9F%A5%E5%BF%83%E7%90%86%E5%AD%A6/","excerpt":"","text":"第七课 认知心理学—认知你的认知 为什么：认知是如何认知的，可以帮助更好的认知 是什么：对自我和世界的感觉-&gt;记忆-&gt;理解-&gt;思考的全过程进行研究的学科。 人类记忆处理过程模型：人类在接受刺激与产生回应一系列的内在处理过程，作为人类整个认知过程的分析框架。 方法：实验法，计算机模拟等。把人看作是计算机，以信息加工的特点，即信息的输入、编码、转换、储存和提取等的加工过程来研究人的认知活动。 评价：认识心理学与神经科学的结合促使了认识神经科学的诞生。认知神经科学采用脑成像技术了解心理活动的脑机制，有望成为心理学的主流。 记忆 记忆：包括 感觉登记—&gt; 短时记忆—&gt; 长时记忆 过脑子的极简原理（首因近因效应） 在3秒内默默的进行一次复述 在12秒内默默的进行一次复述 语义屏蔽 语义屏蔽（感觉存储-&gt;短时记忆 时发生的现象） 概念：即充耳不闻，有色眼镜看世界。 原因：因为词汇组成了我们的世界 案例： 比如看一段完全不懂的专业概念，可能每个词都认识，但是组合在一起就不知道什么意思，就是发生了语义屏蔽现象，是无法到达短期记忆的，更不用说后面的理解分析和判断了 【士兵传话】 应用： 专业名词的学习：想要快速熟悉一个行业，为了防止语义屏蔽，可以快速掌握行业交流常用名词，并自己也可以用起来；最好方式是参加业内人士的聚会。 长时记忆 外显记忆（陈述性记忆） what 包括 语义记忆 情景记忆 这类记忆的细节很容易被改变，容易遗失，随着时间的推移，有的时候不自觉的替换了里面的元素，会被变得越来越不靠谱。 【记忆篡改】 省略 合理化 信息转换 顺序调换 个人态度 自我记忆图式 案例【士兵传话】 情景记忆：对过去发生事情的记忆，特点是比较主观容易有偏差，但记忆成本很低 语义记忆；更可靠，不容易被篡改，但记忆成本更高，所以名言警句和唐诗宋词比各种故事传承下来，信息传递的准确率更高。 内隐记忆（非陈述性记忆） how 案例：知道一个自行车由什么组成是外显记忆，学会骑车是内隐记忆 应用： 凭借经验做事情（情景记忆）不靠谱，应该凭借方法论做事情（语义记忆） 多做记录，不要太相信事后的记忆 相关：【从知到行】知主要在内隐记忆中，行很多在内隐记忆中 记忆篡改 相由心生，记忆是主观的 省略：本能的把不合逻辑或者不符合我们期望的信息给忽略掉。比如推卸责任。 合理化：不自觉的添加一些信息，帮助解释不合理的地方。比如，小说里常见的脑补能力。 信息转换：不熟悉的词汇替换为更熟悉的词汇。 顺序调换：把印象深刻的地方提前，把不太熟悉的事情靠后了 个人态度：价值观决定记忆 因为有记忆篡改，所以说有时候眼见不一定为实。 自我记忆图式：抽象的结构记忆难度最大，和‘我’相关的事情记忆起来难度最小 案例：最容易记住对自己的批评，自己的出糗，不会太在意对别人的批评和出糗，这也是【自我中心带】带来的偏差； 应用：所以学习时候要不断结合自身，找到有关自己的案例 首峰终效应 峰终定律 &#x3D; 首因近因效应 + 雷斯多夫效应 人们对一段体验的评价由两个因素决定，一个是过程中的最强体验（最好或最差），一个是结束前的最终体验 应用：如何带来好的体验？比如安排约会，组织活动，做好的产品，开头结尾的仪式感，和突然的惊喜感，中间不要出现很差的体验；并不是要平均发力的 首因近因效应（尾音效应可以归为近因效应） 案例： 第一印象很重要，“新官上任三把火” 背完单词表，只记得第一个单词 abandon 反例：单词表中间出现一个很奇怪的单词，也容易被记住【雷斯多夫效应】 案例：士兵传话文字版 据说，美军1910年的一次部队命令传递是这样的： 营长对值班军官：明晚大约8点钟左右，哈雷彗星将可能在这个地区看到。这种彗星，每隔76年才能看见一次。命令所有士兵着野战服在操场上集合，我将向他们解释这一罕见的天文现象，如果下雨的话，就在礼堂集合，我为他们放一部有关彗星的影片。 值班军官对连长：根据营长的命令，明晚8点哈雷彗星将在操场上空出现，如果下雨的话，就让士兵穿着野战服，列队前往礼堂，这一罕见的现象将在那里出现。 连长对排长说：根据营长的命令，明晚8点，非凡的哈雷彗星将身穿野战服在礼堂中出现。如果操场上下雨，营长将下达另一个命令，这种命令每隔76年才会出现一次。 排长对班长说：明晚8点营长将带着哈雷彗星在礼堂中出现，这是每隔76年才有的事。如果下雨的话，营长将命令彗星穿上野战服到操场上去。 班长对士兵：在明晚8点下雨的时候，著名的76岁哈雷将军，将在营长的陪同下，身着野战服开着他那彗星牌汽车，经过操场前往礼堂。 视频版 https://www.bilibili.com/video/av77040109 解析： 可以说明【记忆】的一些特性，首先是“哈雷彗星”这一专有名词容易被【语义屏蔽】，更容易被主观篡改【记忆篡改】 意识 意识：awareness组成模型，包括 相关：【精力周期】 【注意】（attention）意识的探照灯，特点是【选择性】，可以照外面也可以照里面（外观和内观） 觉醒（wakefulness）大脑清醒程度，就是俗称的状态 构筑（architecture）承载意识的大脑位置，现在为止还没找到具体是那个部分负责意识，似乎是各个部分都有参与 知识（recall of knowledge）自我知识 世界知识。自我认知可能更重要，要知道自己能干好什么不能干好什么，然后聚焦于自己能干好的，而学生时代通常是世界知识很多，自我认知（自我觉察、认知）不足。 情感（emotive）意识通常都掺杂着情感的底色，人们观察任何事物的时候，都会有一种原始的厌恶或喜欢的情感在里面，而这往往容易被忽略 意识的八大功能： 自我监视 既 【自省】 元认知 不断提高认知的层次（提高自省能力 【丰田5why分析法】），比如可以去学习知识，也可以研究学习知识的方法，比如学习知识管理方法 这里说的自我监视就是元认知：而自省之所以非常强大的能力在于 它能够无限叠加层级性。如你造一张桌子，你可以观察你造一张桌子，你可以观察你造一张桌子的方法对不对，你可以观察你造一张桌子的方法的方法好不好，这样下去，自省的能力就是一个指数级的能力，是会出现涌现。&#x3D;&#x3D;&#x3D;》提高自省可以用丰田5why分析法 选择性注意 选择性注意 为什么：接受的信息很多，但大脑处理的只能处理二十万之一的接受信息，所以注意力这个探照灯只能选择性的聚焦在某个区域 案例 鸡尾酒会效应 应用： 为了谈话时对方没有走神，要让对方复述确保真的听了 团队管理 如何帮助下属成长 16字要诀：我说你听，你说我听，我做你看，你做我看 分心走神：就是探照灯没有聚焦，所以提高效率首先要去刻意注意，聚焦一件事。所以选择很重要可以选择更重要。【聚焦】 真正的高手通常不需要什么都知道，他只需要非常清晰的指导自己能干好什么和不能干好什么。然后保持高度的聚焦。所以说年轻的时候了解自己比了解世界更重要。 丰田5why分析法连问五个为什么，找到深层次的原因（这只是帮助找到原因，但如何解决则需要用到更多的知识和方法。你可能需要对知行合一，如何构建系统，如何理解人生的无常，所以通常解决一个复杂的问题需要从不同的领域获取工具。） 案例1 引导性提问案例 日本丰田公司有一个著名的调研方法，就是问五次“为什么”。 比如，你看到工厂车间地上漏了一大片油。你肯定会问： 为什么地上会有油？因为机器漏油了。 为什么机器会漏油？因为一个零件磨损严重，导致漏油。 好，问了两个为什么之后，我们有了一个解决方案，就是换掉有问题的零件。这是典型的从要素层面解决问题。但是，如果你再接着问： 为什么零件会磨损严重？因为质量不好。 为什么要用质量不好的零件？因为采购成本低。 为什么要控制采购成本？因为节省短期成本，是采购部门的绩效考核标准 你看，再问三个为什么，我们就找到了系统的深层次问题。可以想见，如果采购部门的绩效考核标准不改，零件磨损导致机器漏油的现象，就会反复出现。 案例2 比如你是一家水果店老板，你的特色是水果新鲜。所以在店里墙面上张贴着“新鲜水果，快速送达”之类的宣传语。可是你的生意并不是那么好，因为周边还有不少水果店，怎样才能让你的水果店脱颖而出呢？ 我们可以用问“为什么”的方法，来洞察顾客的深层需求——我们在水果店询问一位购买水果的典型顾客：下班后的妈妈。 问1：为什么大家喜欢新鲜的水果？ 顾客：我觉得新鲜的水果味道最好。 问2：为什么味道对你这么重要？ 顾客：因为味道好，我的小孩就喜欢。 问3：为什么孩子喜欢吃苹果对你很重要？ 顾客：苹果对他的健康好。 问4：为什么孩子健康对你这么重要？ 顾客：因为我想要做一个好妈妈。 问5：为什么照顾家庭对你很重要？ 顾客：这难道不是理所应当的吗？ 我们可以发现，购买新鲜水果这一行为的背后是妈妈守护家庭安全、健康，做一个负责好妈妈的底层价值观动机。因此，我们可以将原先what层面描述“新鲜水果，快速送达”的宣传语，更换成类似“我们与您一起守护家人健康”的观点。 相关 【系统思维】可以通过使用5why分析法来解决系统问题 【黄金圈思维】可以联合起来使用，目标都是让认知更深刻 遗忘 及时复习（艾宾浩斯记忆曲线）和适当压力（叶克斯道森法则），可以帮我们减少遗忘其他因素还包括学习者的需要和兴趣，识记者的态度。材料的性质，数量与意义学习的程度（150%过度学习，记忆效果更好） 材料的系列位置（近因效应和首因效应)； 认知系统 认知过程：辨别—概念—规则—掌握知识—运用知识—掌握智慧 辨别：清晰的辨别是一切认知的基础 当你开始用大概好像明天下午的时候，你的头脑并不清晰。而当你接受别人不清晰的时候，此时你也是不清晰的。比如明天下午vs明天下午三点半 如何让大脑变得清晰？会谈和书写，【黄金圈思维】（会谈使人敏捷，书写使人精确。——培根） 会谈也可以自己和自己谈 书写是边说边听边写边画 分散大脑压力 提高效率，光思考会感到乏味","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"社会网络学：深刻认识社会","slug":"08社会网络学","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-03T13:18:46.806Z","comments":true,"path":"2022/01/19/08社会网络学/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/08%E7%A4%BE%E4%BC%9A%E7%BD%91%E7%BB%9C%E5%AD%A6/","excerpt":"","text":"第八课 社会网络学：深刻认识社会 网络模式 中心式 分散式 分布式 结构洞 多个子网络的桥梁 中心度 衡量节点重要程度的指标 弱联系 关系不强，但力量不弱 人类网络模型 人以群分与如何实现后来者逆袭 基本再生数 疾病传染模型与人口生育模型 差序格局 中国特色社会关系 网络模型 此分类来源于计算机科学家对通讯网络的分析，通用可以应用在日常生活中的案例中来 中心式网络 所有节点都指向一个中心节点 分散式网络 一些节点指向一个局部的中心节点，局部的中心节点又指向一个全局的中心节点 聚会模型：人以群分 描述的就是分散式网络，比如一个聚会中100个不认识的人，随着时间进行会三三两两分成几十个小组进行交谈。* 分布式网络 最常见的网络形态，最开始人们建立的通讯网络，是中心式和分散式的，直到互联网的出现，人类之间的通讯网络才变成了分布式网络。 结构洞（structural hole） 是什么 几个群体之间的桥梁，被称为“跨界者” 比如中国刚开放时，懂外语的人；工作中连接不同部门的人 启发 中心度 是什么 中心度是衡量节点重要程度的指标，中心度。有几十种计算方法，常用的如下 度中心度（联系数量） 单纯计算连接的数量。比如一个人的微信好友越多，粉丝越多，度中心度就越强。 特征向量中心度（联系质量） 每个节点的权重是不同的，比如a的10个好友都是出生入死的兄弟，小b 100个朋友都是普通同学，a的特征向量中心度就更大。 传播中心度（影响范围） 不只考虑直接的联系，还考虑二度联系（或更多）。比如一度人脉和二度人脉，即使你不是微博大号的拥有者，但认识很多大v，你的传播中心度可能比某个大v还强 中介中心度（类似结构洞）。如果两个群体可以因为一个关键联系人断掉就不再连通，那么这个人的中介中心度就很高。 怎么用 这些计算方法各有各的适用场景。 启发 面对同样一个人群，从不同的需求角度看，群体里每个人重要性评估就可能完全不同。 例子 黑帮结构中的老大（分散式网络） 如果只用度中心度，我们肯定不觉得他重要。 中介中心度，没有了他其他全部节点都会断掉联系； 传播中心度，他的二度和三度人脉可以直接影响到很多人，所以传播中心度非常高； 特征向量中心度，他认识的只有几个人，但是每个人都很重要，所以特征向量中心度也很高。 弱联系（weak ties） 是什么：关系不强，但力量不弱。弱联系就是我们认识但不太熟的人，在一些时候这些人比亲戚朋友能帮上更大的忙。 无论是我们要找一份新的工作，或者找到一个重要投资机会，拿到一个重要的新项目。 为什么：因为熟悉的人，无论是老乡同学还是同事，往往和你生活在差不多的世界里。所以他们很少知道你完全不知道的事情。 怎么做：想要拥有好的弱关系网络，重点不在于你直接认识多少人，而在于你能跟多少个枢纽型的人保持一定的关系，至少是那种一定时间会通一下微信、问候一下彼此的关系。 那么什么样的人是枢纽型的人呢？比如各种群主、猎头、专业销售或者活动会议的组织者。（搞传销和微商型除外） 人类网络模型 小世界网络：也叫圈子，就是通讯网络里的分散网络，存在着人以群分和枢纽型的人，所以人与人的关系并不是随机平均分布的。 无尺度网络：连接呈现幂律分布而不是正态分布，这个现象在互联网平台司空见惯，很多高速增长的行业、高速发展的公司、新论文大量出现的学术领域，都会看到这种无尺度网络的现象。 成因：网络需要处在一个不断扩展的状态，每一个进入网络的节点，都会去和链接更多的节点去连接。随着时间的推移，节点越来越多，最初的两个节点就成了最大的受益方，这就是典型的先发优势。 适应度网络：如何实现后来者逆袭呢？从微观层面，后来者只要比前辈的适应度更高、吸引力更强，彻底改变吸引力的维度。 比如当年苹果手机颠覆诺基亚时，因为苹果手机的使用体验实在是跟诺基亚差别太大，以至于它直接开辟了一种新的使用体验战争，彻底破坏掉了诺基亚曾建立一种赢家通吃的惯性。 如何找到新玩法呢？更多的来自跨界融合，创造新体验。 价值网络：如何实现后来者逆袭呢？从宏观层面，抓住变革的机会，重构整个价值网络。很多成熟的公司在面临变革时都会遭遇失败，因为价值网络已经稳固，需要同时改变多个节点才可能发生改变，所以这时候一些没有负担的新来者机会更大。 比如字节跳动作为信息分发的后起之秀超越了百度。 大屏电脑到小屏手机的改变，人们的慢慢更习惯接受推送而不是搜索，字节跳动就是紧紧地抓住了这一点所以才逆袭了百度 基本再生数 概念来自于生物数学，它通常用来研究疾病传播的网络，基本再生数衡量一个典型的传染者会让多少个其他人受到新感染 如果基本再生数＞1，那么疾病就会不断蔓延； 如果基本再生数＜1，那么疾病就会逐渐消亡。 从网络科学角度，疫苗并不需要完全有效接种到每一个人才能够阻止疾病的广泛传播，它只需要把再生数降低到 1 以下即可。 可应用与生育模型，中国今年的总和生育率已经到了 1.3 ，换算成基本再生数已经远远少于 1 ，如果这个现象持续下去，那么整个中国社会就会走向衰落。 这也是我们今天突然看到，中国举国总动员，发展育幼产业，改革教育压力，推出保障性住房等这些措施的根本原因。 差序格局 费孝通先生把中国传统社会每一个人的社交关系比作一个像水波纹一样涟漪式扩散的同心圆，越远离中心就越疏远，越接近中心就越亲密。而与之相对的，是西方传统社会里团体格局，就像一捆一捆木材，这些团体内部成员相对比较平等，遵循某些共同的规则。 中国人对关系的理解更像这样一种情况，里层偏感性，外层偏理性，夹在中间那一层所谓熟人关系。 启发： 陌生到认识：“有什么东西我可以帮到你？”遵循最外层的对等交换原理，思考对方需要什么是你可以给到的，表达自己的心意。因为陌生人之间，大家是没有情感联系的基础，所以套近乎是几乎没有意义的，所以直接交换价值。 认识到熟人：超出公平兑换原则，给对方超额的汇报，形成人情债。所以索取之前先要给与适度慷慨。实际上是你在跨越社交圈或者阶层的时候最有力的武器。 非正式组织 正式组织，比如学校、班级、公司部门，它们有明确目的和运作规则。 非正式组织，以情感、兴趣、爱好和需要为中心，没有正式文件规定的自发形成的社会组织。自己如果因为非正式组织（如认识的学长）进入某个公司的话，也会在工作中更自律，想维护这个非正式组织的名誉。 启发：进入一家大公司后，搞清楚这些非正式组织的存在对于推进工作、更换部门都会非常有用。","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"金融学模型：经济运行规律","slug":"09金融学","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-03T13:18:47.266Z","comments":true,"path":"2022/01/19/09金融学/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/09%E9%87%91%E8%9E%8D%E5%AD%A6/","excerpt":"","text":"第九课 金融学模型：经济运行规律 为什么要学习金融学：人活着就离不开钱，无论是理财还是投资，而对于非专业人士而言，我们也要具备基本的金融思维，了解金融是怎么运行的，了解金融的基本概念，以及如何把金融学的方法和思想用到生活中。 如何学习金融学：经济学&#x2F;金融学 理论与模型太多了，而经济作为一个复杂系统，能预测解释程度有限，各家理论都是这样，而作为入门，所长推荐 Ray Dalio 的经济学模型，因为 Ray Dalio的这套框架十分清晰，虽然也有争议（哪个又没有呢？），几乎是最低门槛的入门方式了。 Ray Dalio 经济运行模型 ：从[第一性原理]出发思考，经济的本质是什么，而经济的本质无非就是由无数【交易】组成的，每个交易其实很简单，那关键点就在于是什么让其变得如此复杂？Ray Dalio 说这个关键就是 【信贷】 ，在此基础上推演出了【瑞达里奥增长曲线】，作为理解经济运行的最简模型，以此为主线贯穿了一系列经济学中的重要概念 怎么学：从每一笔交易（微观）到经济运行的规律（宏观），来概览整个经济体系，并且理解经济学重要概念，尝试运用到生活中 资料： 所长林超-跨学科工具箱 &amp; 瑞达利欧-经济机器是怎样运行的 &amp; 知乎-如何评价 Ray Dalio 的文章《宏观经济运行的框架》 经济曲线 瑞达里奥增长曲线：经济增长的最简模型，包括 生产率的提高、短期的债务周期、长期的债务周期。 生产率的提升 在人类历史上一直是在叠加的，即只有一个发展方向，整体上从来不会走回头路。[增长函数] 债务周期 有短期和长期的差别，在瑞·达利欧的观点里面，短周期大概是 5 ~ 8 年，而长周期大概是 75 ~100 年，这三股力量合在一起形成了下图。 [波动函数] 经济整体不断增长好理解，因为生产力是不断提高的，但是为什么会有波动（周期）呢？关键在于 信贷 的力量 信贷（Credit） 其实就是给“未来的自己”借钱，之后自己的经济会比自己实际的生产力要高，所以会向上波动，但借钱总要还的，当还钱的哪一天，你的经济就会向下波动，来弥补当初欠下的债了，这是个人层面； 注意这种填补不是平均的，社会总体的信贷是会不断扩展的，因为当你生产力是 100 时候，算上信贷其实可以消费 110，因为你的消费就是别人收入，所以第二个人可以消费110*1.1&#x3D;121，注意不断积累 经济整体的波动是由无数人的信贷行为形成的，整体而言，当借钱的人比还钱的人多的时候，经济整体向上波动，反之则反，而操控这个趋势的力量，就包括国家的【宏观调控】 波动最底层的动力来自于人性的贪婪和恐惧 交易 详细分析一下 交易 交易：经济运行的最小单元就是交易，而交易无非是由 货币、信用、服务、金融资产、商品 这五样东西之间换来换去； 信用（Credit）：刷信用卡时当时并没有支出货币，但是用信用向未来的你借了一笔钱 信用在使用时和货币一样，因此把花费的货币和信用加在一起就可以得出支出总额。 支出总额是经济的驱动力，因为一个人的支付就是另一个人的收入，你花的越多，别人就挣的越多，如果用支出金额除以销量就得出价格， 金融运转的核心是一张张金融合约，比如A把钱借给了B，B希望未来可以借此赚取更多的钱，A则希望B未来可以还给更多的钱，这时候B就需要给A一份金融合约作为保障和交换 众多交易形成了市场，不同类型的市场又聚合为了经济体，不同市场组成的经济体耦合在一起，环环相扣 市场经常会出现过冷或过热的，或分配失衡的现象，这时候就需要国家层面的宏观调控 了 宏观调控 国家有两股理论参与到市场调控中，就是 中央银行，和 中央政府 中央政府：三种调控手段，分别为 发行国债的数量、税收的数量 和 财政支出的数量 ，其中 国债 和 税收 是政府的收入， 财政支出 是政府的支出 税收 ：如果政府减税，那么企业的压力就变小了，人民的可支配收入也会增多 财政支出：比如搞基建、搞科研投入等 国债 ：国债可以卖给自己的国民，也可以卖给别的国家。这方面美国是典型，美国国债卖给了全世界，这是美国剥削全世界的一种方式。 中央银行： 中央银行的两项核心功能是 调整利率 和 发行货币。 调整利率 利率 对于 存钱就像磁铁一样，可如果利率降低，大家不愿意把钱存在银行，那么市场上流通的钱就变多了，钱变多经济就容易变热，反之则反 发行货币 也就是俗称的放水。，印钞多了市场上的水就多了，经济就容易出现流动性过剩，俗称“过热”。 宏观调控 与 债务周期： 短期债务周期：当经济向上的波动因为【信贷】不断扩张，而实际的生产变化并不大，则会引起物价上涨，通货膨胀，这时候央行就会调高利率，社会整体借款会变少，经济变为了向下波动，到一定程度，则央行又会降低利率，这就形成了经济波动的小周期 长期债务周期：但央行调控下，一个个小周期后欠款会积累，一次次信贷下，消费越来越超出实际的产出，当欠款超过了人们的产出，总有换不起的一天，这时候央行的利率政策就无效了，因为这时候利率已经低到不能再低了 为什么消费会出现这种“累积上升”的趋势呢？这就要提到【杠杆】了 杠杆 杠杆的作用：金融工具对于实体经济最大的作用就是为实体经济加上了杠杆，四两拨千斤，让那些有生产力的人在短时间内加速发展，有机会弯道超车资本本来比自己多很多的人。 什么是杠杆：加杠杆可以理解为加倍数，假如拿1万块钱投资，一天只能上下波动10块钱没什么感觉，但如果加100倍的杠杆，就会变为一天亏1000元。常见的杠杆类型如下 贷款买房、买车、买手机； 金融投资、融资； 使用了某些技术手段来节省劳动力； 招聘帮手来帮助我们做事情； 我们到处去宣传扩大自己的影响力； …… 任何一个杠杆，都由 长度，支点和用途组成，可以分为良性杠杆与不良杠杆 用途：加杠杆之后撬动的资源拿去干什么 支点：一个好的支点，是一种能够 稳定、低风险、获得收益 的资产或能力； 比如买股票就不是一个好的支点，你不知道这家公司的业务逻辑，潜在风险，实际控制人的性格想法都不知道，那有一天他跌了，你也不知道怎么跌的，毕竟不可控。不好的支点就是看似拥有，实际支配不了。 长度：就是加大的倍数，两倍的杠杆就是放大了2倍的损失和收益，波动也就更大 能扩大生产力的就是良性杠杆，比如农民贷款买了一个拖拉机； 没有增加生产力的就是不良杠杆，比如贷款卖消费品 应用，分析贷款买房 看房子增长的价值是否高于同期的利息，来判断是否为良性杠杆 按照中国房地产过去 20 年涨幅，贷款买房绝对是一个良性杠杆。如果加了很大的杠杆，然后如果房地产崩盘，就会干翻一个中产家庭。 但要考虑到国家政府当前的调控政策，现在正是转为不良杠杆的转折点熵 未来还在变化中，这是不可控的，所以贷款买房并没有一个好的支点 三个建议 基于这个波动模型，瑞·达利欧给了大家三个建议。 不要让债务的增长速度超过自己的收入。 因为一旦债务超过了收入，增长的速度就会形成恶性循环，挣的钱永远还不上利息和本金，除非可以债务重组或者找家人借钱。 不要让收入的增长速度超过生产率。首先我们的收入其实是由货币和信用构成的，这部分透支的信用就是我们身上的杠杆，不要看当下收入多，但支点不稳，欠下的迟早要换的，甚至是加倍奉还，这种情况下就是所谓的“君子立于危墙之下”，你只能天天祈祷那个墙不要倒。 尽一切努力提高生产率。不断的提升自己的实力，是应对一切变化的终极法门。 金融要素 北大的香帅教授在课里面做过总结，就是时间、杠杆和风险这三个要素。 【杠杆】 时间：金融最厉害的地方就是可以在时间轴上移动我们的财富，比如信用卡和养老保险，给我们带来了很大的不确定性。。 风险：对未来的估计总是会有极大偏差的，这就是时间带来的不确定性，这是金融业最重要的一个词，做金融的通常风险意识更强，这也是普通人需要培养的 金融工具可以把时间带来的风险和未来的收益进行计价，有很多种方法，比如折现值（present value），也可以计算别的东西（如两种工作的价值）的折现值。 比如b站2021年第一季度利润为 -9亿元，但估值却超过了400亿美元，这个估值估算的就是他未来能赚的所有的钱折算到现在的价值，说明大家对b站的前途都很看好。 风险收益流动性：投资学的不可能三角，即高收益，高流动和低风险是不可能兼得的 流动性：资产变成钱的速度或能力，比如股票流动性就很高，因为可以随时买入或卖出，相反古董流动性就很低 现在政府就在通过限制贷款，积分买房，审核资质等很多手段，限制买卖双方达成加以，通过降低流动性来控制房地产市场 所以注意需要花费很多代价去获得某项资产时，除了考虑收益风险，一定也要考虑流动性 另外一个例子就是没有上市的公司的期权和股票，但是此时其流动性很低，如果找不到合适的买家，只能以极低或者卖不出去。 风险收益模型：高风险更可能获得高收益，低风险更可能获得低收益； 比如找工作大部分情况是，想要高工资就要放弃稳定去大城市，风险就会大，而反之铁饭碗往往收益低； 但如今金融工具已经非常复杂了，金融市场被核心玩家垄断，在高风险高收益区域，很多普通人承担了完全不对等的高风险，却极小概率得到高收益；","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"心理学模型—认识你自己","slug":"10心理学模型","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-03T13:18:45.720Z","comments":true,"path":"2022/01/19/10心理学模型/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/10%E5%BF%83%E7%90%86%E5%AD%A6%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"第十课 心理学模型—认识你自己 引子： 不论是生活，学习，还是职场。只要是人参与的游戏，就有了解一点心理学的必要。 人生最重要的课题之一：认识你自己，进而掌控你自己。而其实大多数人并不能真正做到这点，且不自知。【自我认知】 总之，心理学可以为理解和处理自我，他人和社会这些问题提供帮助。 内容：虽然现代心理学发展较为落后，还缺乏生物学中之达尔文，物理学之牛顿的角色，但是我们自己可以把实用的片段，拼接起来形成对自己有用的行为模型。比如心理学三大势力：【精神分析学派 psycho analysis】、【人本心理学】、【行为主义心理学】；比如心理学三巨头中，不太为人知晓的阿德勒创立的【个人心理学】、再比如一些新兴的流派如：【认知心理学】，【进化心理学】等 自我认知 认识自我的误区: 我是这个世界上最懂我自己的人 为什么我们其实并不了解自己？ 难以捉摸的潜意识与意识，使得我们并不能清晰、准确无误地洞悉我们的内心，我们只能依靠观察我们此时的情绪与行为，此时的生理状况等，来了解自己的内心状况。更不幸的是，我们因为聚焦行动、聚焦场景和聚焦自我，还在认识自我上有很大的偏差等。 为什么我们会觉得很了解自己？ 理由1: (自恋) 对自己的关注程度肯定比对别人的关注程度要多 但这种聚光灯效应, 往往会导致&amp;nbsp;聚焦偏差, 从而缺少宏观的视角, 夸大自己的感受等, 从而导致”当局者迷,旁观者清”,”不识庐山真面目，只缘身在此山中” 理由2: (历史) 只有我知道我自己完整的历史 记忆是主观的，常常会被不自觉的发生&amp;nbsp;记忆篡改。包括省略、合理化、信息转换、顺序调换、个人态度、自我记忆图式等 理由3: (自省) 我能够随时随地洞悉自己的内心, 分析自己行动的动机理由; 当我们去观察我们内心状态的时候，我们事实上只是在观察自己的行为、自己的表情、自己的动作、自己的生理状态，从而来理解自己现在究竟是一个什么样的心理状态。而这个推理的过程中，经常会出现各种偏差。(具身认知) 怎么做：学习心理学可以帮助我们更好的认知自己。 个体心理学 决定我们自身的不是过去的经历，而是我们赋予过去经历的意义。 阿德勒 为什么学1：相对于【原因论】的【精神分析（是一种原因论，这里就算知道了自己变成现在这个样子的原因，但是对改变自己没有卵用，这好似别想大象悖论）】，【个体心理学】是一种目的论。它能帮助更好的改变自己。 对于弗洛伊德的原因论，一个人有社恐，可能是因为小时候父母没有给足够的社会环境，在学校被孤立，老师没有正面引导，所以在长大之后才有社恐。而用阿德勒的目的论来分析，有社恐的原因，很可能是因为实现了某种目的，比如这个人自称有社恐，这人就可以名正言顺的待在家里，不用去面对求职被拒绝的痛苦，也不用去面对别人询问简历的时候答不上来那种恐惧，而且一旦朋友家人知道他有社恐，也会认为他找不到工作可能因为他有难言之隐而非实力不行。 为什么学2：如何更好的认识自己和他人？重新解读过去的经历和拥有被讨厌的勇气。 是什么：某个人现在的很多问题之所以会发生，其实是它符合你的某种内在目的，过去的经历如何影响你，在于你如何看待它。强调人的主观能动性。重点概念【自卑感】 应用： 人际是一切烦恼和不良观念的源头，解法就是拥有【被讨厌的勇气】。 如果有某些改不了的坏习惯或慢性疾病时，可以从心理学角度思考，它是否给自己带来了某些好处。好处往往指避免在于他人的关系中受到伤害，人际关系是烦恼和不良情绪的源头。 人类可以通过创造性的重新解读自己过往的经历改变自己的思想，从而改变自己的行为。困扰我们的并不是客观事实，而是主观上的解释。比如家庭贫寒，可以解读为困难更容易让人产生向上的动力。 评价 过于强调主观能动性，忽略了环境的影响。 案例 头疼的病人是因为头疼可以带来他人的关怀和注意 资料 《自卑与超越》《被讨厌的勇气》 原因论与目的论著名心理学家弗洛伊德，认为过去所受的伤，是现在不幸的罪魁祸首，不管是我们的情绪，还是行为习惯，都可能从过去当中找到原因，我们的现在甚至未来全部都由过去的事情所决定，而且根本无法改变。过去经历所有的事情都是现在赋予它意义的。这就是弗洛伊德的【原因论】。 而【阿德勒】却认为，过去任何经历本身并不是一个人成功或失败的基本原因，我们也并非因为经历所受到的伤害而永远痛苦，实际我们会从过去经历中，找到现在的目的因素。决定我们自身的不是过去的经历，而是我们自己赋予经历的意义。这就是阿德勒所提出的【目的论】 大部分人喜欢原因论，是因为可以推卸责任，这符合人性 阿德勒的理论也有不足之处，就是他过于强调主观能动性，忽略了环境的影响。 自卑感 是什么：不一定是通常语义上的自卑，可以理解为一种广义的不满足感，而不满就会产生改变现状的可能性，这是一个中性词，而作为贬义词的是【自卑情结】。当我们意识到自己没有其他事物那么强大的时候，自卑感就会产生。 案例：三个孩子在动物园看到一个非常凶猛的狮子，小孩A马上躲到妈妈身后，小孩B站在原地脸都吓白了，小孩C问妈妈如果向它吐口水会怎么样。三个小孩都是自卑的，因为都意识到远没有狮子强大。 自卑情结：面对棘手的问题时，感觉自己再怎么努力都没有，然后宣传是因为自己有A这个缺点，所以导致做不到B。有了这个前提就可以顺理成章的逃避重大问题，转而把精力集中在鸡毛蒜皮的小事上，去得到优越感。 人类可以通过创造性的重新解读自己过往的经历，改变自己的思想，从而改变自己的行为。困扰我们的并不是客观的事实，而是我们主观上的解释。– 阿德勒 被讨厌的勇气 专注于自己的人生课题，不必在意别人的看法，才能获得幸福安宁的人生？我们不需要满足别人的期待而活着，反之别人也不是为了满足你的期待而活着；真正的自由是毫不在意别人的评价，不害怕别人的讨厌，不追求被别人认可，这样才能走上自己的道路。 为什么：要有被讨厌的勇气，想有时刻良好的社会关系因为原始社会来自基因的缓存，但现在社会不是必须的，因为社群很多，没需要被所有人都满意。这样才能获得安宁的人生。 怎么做：【切割人生课题模型】 专注自己的人生主题，不要干涉别人的人生主题。大多的烦恼来自于干涉别人的人生课题，想去掌控自己无法控制的东西。 相关 ：【共同体】 还要有敢于信任的勇气，这会消除切割课题带来的孤立感。一边是冷漠的切割，一边是温暖的信任，这样才能构成完整的人格。 人生课题 不要尝试控制自己无法控制的事情，专注于自己可以控制的事情。才能获得幸福安宁的人生。 什么是人生课题：自己能控制的事情就是自己的人生课题 如何判断人生课题：这件事的最终后果到底由谁来承担 比如男孩像女孩表白，男孩的应该把所有关注点放在是否表白上，而忽略女生是否接受表白上。即“我爱你，与你无关”。为什么一般来说，男孩会很在意女孩是否接受呢？就是因为没有【被讨厌的勇气】 人本心理学观点：心理学应研究正常人。人的本质是好的，善良的，有自由意志，有自我实现的需求，只需要适当的环境。 评价：理论体系不完备，理论难以检验。 需求层次理论 生理需求 呼吸 进食 喝水 排泄 睡眠 维持体温（衣食住行） 自我实现 与其他四个底层 最大不同 不是向内索取，而是由内到外表达的东西，即一个人对自己的能力充分发挥的那种渴望。 自我实现者的特点 对现实的感知，既洞察力 情绪比较稳定 情绪缺陷比较少，所以不会过度乐观和过度悲观，所以更能比普通人看到被隐藏或者混淆的现实真相。 对现实的认同 ，平常心看待自己的缺点 以问题为中心 ，不是以自己为中心 独处能力 幽默感 大多是自嘲 辩证统一 不是非黑即白，认为世界上两个对立面是可以共存的。（正确的反面是谬误，但一种深刻的真理的反面，可能是另一种更深刻的真理。） 应用：解释有的老人有暴饮暴食的倾向，执着于贮蓄，缺乏安全感。毕竟经历过三年自然灾害 案例《一出好戏》解析 小王司机带大家摘果子捕鱼打水，解决了生理问题，又带大家找到山洞可以避免风吹雨打，解决了安全问题。 张老板教会大家要懂得分工合作，付出和回报，如何理财，还告诉大家在吃饱穿暖以外要懂得生活，那些跟着张老板出走的人，提高了社会地位和被尊重需求。 最后由马进和小兴主导的阶段，他们为大家带来了电灯、光明、音乐。大家开始懂得享受生活并去做自己喜欢做的事，这个时候开始迈向自我实现的阶段。 传播学中得出，有三种力量最能吸引你点击某个标题：逃避恐惧，寻求认同，追求渴望。 人类的性行为和性需要也属于归属社会需要这一层次。 积极心理学 积极心理学 研究人类的幸福感 市场上鱼龙混杂 二十世纪末马丁塞利格曼 真实的幸福 活出最乐观的自己米哈里 契克森米哈赖 心流象与骑象人哈佛幸福课 视频活出心花怒放的人生 中国 心流心流（英语：Mental flow）在心理学中是指一种人们在专注进行某行为时所表现的心理状态。如艺术家在创作时所表现的心理状态。通常在此状态时，不愿被打扰，也称抗拒中断。是一种将个人精神力完全投注在某种活动上的感觉。 心流产生的同时会有高度的兴奋及充实感。米哈里·契克森米哈赖认为，使心流发生的活动有多样性。——来自百度百科 是什么 ：大量的信息冲击，失去了内心的秩序，既精神熵，心流就是持续创造负精神熵的过程 产生条件： 接受适度的挑战 发挥适度的高技能 如何产生心流 有头有尾的能闭环的工作可能产生心流，所以事情再多也要把他们分解为块状，一个时间只闭环一件事，压力再大也不要想一次把事情做完 相关可以用【耶克斯道森法则】解释，两个曲线的焦点，适当的记忆效率（高技能）+适当的压力（挑战） 【熵】的解释：大量的信息冲击，失去了内心的秩序，既精神熵。心流就是持续创造负精神熵的过程，这个过程伴随着物我两忘，伴随着高度的兴奋感和充实感的这样一个状态。 是什么: 个体和社会的行为都受到潜意识(无意识)的影响，根源于心灵深处的某种欲望和动机，特别是性欲。 弗洛伊德把我们的意识比作是一个探照灯，照亮的地方，是我们能感知的地方；而心灵中的黑暗处，才是我们的本性。这个地方，弗洛伊德就称为【潜意识】。潜在水面之下，伏于黑暗之中。 基于这个假设，弗洛伊德提出我们每个人都可以分成三个部分，第一个叫本我，第二个叫自我，第三个叫超我。其中本我就是【潜意识】, 是兽性所在。 评价: 弗洛伊德的重要性在于，他是第一个让我们直视我们内心的黑暗的心理学家。 现代心理学认为，弗洛伊德对潜意识的解释，其实是有些片面和极端的。我们的潜意识并非都是兽性的和肮脏的。在很大程度上，我们的潜意识是中性的，无所谓好与坏。所以，弗洛伊德的理论，对整个心理学的影响越来越弱，逐渐被认知的无意识理论所取代。 但是，弗洛伊德的理论对文学和艺术的影响很深远。可以说，不懂精神分析，就不懂现代艺术。 案例: 一个人看见有个姑娘非常漂亮，那么他的本我就会说，“我要和这个女孩上床”。这里，本我代表的是我们的动物本性。而超我就会说，“不行，你这个流氓，你不能这么干”。这里，超我就是代表着文明、道德约束和社会规范。当本我和超我发生冲突时，自我就会跳出来说：“不用吵，你可以去追那个女孩，把她娶了，这样你就能和她上床了”。 本我和超我之间，是兽性和文明之间的冲突，而自我，就不得不随时随地来解决这种冲突。 如何解决本我和超我之间，兽性和文明之间的冲突？ 【防御机制】 潜意识 潜意识(无意识): 人类的动物本性都藏在潜意识中, 而人类心理的防御机制帮我们压制住这些兽性的本能, 表现出文明、动机与欲望、冲突与困扰，才构成了我们真正的人性。 怎么做: 潜意识是由基因, 生理, 社会等因素造成的, 我们看不到, 需要通过表现出的自由意志和心理学知识来分析他, 分析人行为的根本原因。 防御机制 压制: 解决冲突最简单的办法，就是将本我压制住。把那些不能被社会所接受的观点或者糟糕的想法，都深深地关起来，不让这些想法表达出来，不让它们进入到我们的意识当中。 在压制这个防御机制不能解决冲突的时候，我们发展出了五种疏导的方式来解决冲突: 取代, 用可接受的行为取代不好的行为 升华, 把不好的行为转化为大家尊重的行为 反向形成, 当发现自己的某些特质不被社会接受, 不愿被看出来, 走到另一个极端 投射, 将自己具有的, 不被认可的特质, 投射到别人身上, 认为是别人有这种特质 合理化, 为自己的错误的行为群钊合理的解释 案例 父亲殴打小孩时会说, 说这是为了孩子好, 可能是父亲有暴力倾向所做的合理化 一个小气的人，通常会认为别人小气；一个挑剔的人，会认为别人挑剔。 心理学家对反同性恋人士的调查发现，那些极端反同性恋的，其实有相当一部分人是同性恋。 把暴力倾向转化为商业竞赛行为, 被社会接受和赞赏 把恋母情结升华到艺术创作之中(达芬奇的蒙娜丽莎) 用啃手指头可能取代对母乳的依恋 在一些时候，当冲突没有得到解决而且越积越多的时候，就会导致人出现各类精神疾病。所以，弗洛伊德也相应地提出了一套治疗精神疾病的理论和技术，叫做精神分析法，用以找到冲突的根源。 行为主义心理学待学习。。。 进化心理学待学习。。。 认知心理学见 https://www.bilibili.com/read/cv12540201 资料 所长林超 跨学科工具箱 刘嘉 心理学基础30讲 心理学相关教材","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"语言金字塔—表达的艺术","slug":"11语言表达领域重要模型","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-03T13:18:47.404Z","comments":true,"path":"2022/01/19/11语言表达领域重要模型/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/11%E8%AF%AD%E8%A8%80%E8%A1%A8%E8%BE%BE%E9%A2%86%E5%9F%9F%E9%87%8D%E8%A6%81%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"第十一课 语言金字塔—表达的艺术 所长林超语言学模型将的并不深，只讲了一个【金字塔模型】。其实语言学是非常有意思的，例如语言学转向，维特根斯坦，罗素等一干大师的思考过程……毕竟语言是思维的载体，语言学的很多的东西都很有思考性。但【金字塔模型】还是非常受用的，可以作为一个开端，之后再去深入了解。 0 简介 为什么学：如何使说话写作更有逻辑（更符合认知心理学），到如何使表达、思考和解决问题更有逻辑。 是什么：金字塔模型 最关键的信息-1；即内容【核心】的中心思想。 支撑项目＜7；即支撑内容的【骨架】。 数据&amp;细节&#x2F;图表&#x2F;例子&#x2F;比喻-N。即填充内容的【血肉】。 怎么做：如何获得金字塔结构 简单内容 坚持先说结论再说论据 复杂内容 画出来说出来，先罗列再整理，把【核心】要点分类分组，搭建【骨架】，每组要有顺序，再填充【血肉】来丰富表达 注意 金字塔原理描述的并不一定是整场对话，可以让每个片段都应用* 反例 想到哪里说到哪里 反例 想到哪里说到哪里 金字塔模型就是符合高效率表达的底层逻辑（因为进入长时记忆的只有那个最关键的信息） 资料：《金字塔原理：思考、表达和解决问题的逻辑》 林超跨学科思维工具箱 https://www.bilibili.com/cheese/play/ep9009 1 核心 是什么 既最关键的信息，中心思想，有且只有一个 为什么 因为能进入【长时记忆】的只有很少量信息，所以要总结把所有语言封装为一个记忆项目，进入长时记忆成作为记忆挂钩。 怎么做：如何获得基本的金字塔结构 为什么 思考是一件很费力的事情，手嘴并用可以有效分散压力；很多人还有个误区就是想着从有序到有序，既一开始就画出结构，然后慢慢填充 简单内容 坚持先说结论再说论据 复杂内容 画出来说出来，先罗列再整理。从无序到有序 抽象能力（对抽象共性的理解力），即找到事物更高层次共性的能力起到关键作用，比如香蕉苹果都是水果，苹果和凳子都是商品。 **案例1 ** 犯罪集团开会 反例 * **正例&amp;nbsp;** ![image-20220220203247283](https://yunkaiblog.oss-cn-qingdao.aliyuncs.com/images1/image-20220220203247283.png) 案例2 超市买东西 反例：写作的时候不能想着从有序到有序，所以人在写作的时候才比较困难。&amp;nbsp; 正例 先罗列混乱的东西，然后再着步从混乱到有序，然后也能从中发现逻辑漏洞。 2 骨架 小于七个的支撑论据，作为骨架，这里面最关键的点是【表达顺序】 为什么：语言是时间的伴侣，同样的几句话，表达顺序变了就会从清晰明了变得混乱不堪。 以下包括 【承上启下】模型：eg视频《疫情之后的新世界》，12秒内新概念的咬合和重复； 【铺垫转折】模型 笑话2部分：铺垫制造预期 笑点揭示意外 【时间顺序】模型 常用、好用；无论什么主题从历史角度开始叙述，就会显得很宏大 【空间顺序】模型-微观（微观）→宏观（中观）→宇观（宏观）模型；【苹果模型】，以苹果打比方（内层概念，往外依次形式、风格、结构、工艺、外观，适用产品、影视作品等）； 【升级递进】模型：从表面的直观的原因切入，然后不断递进深入到不容易思考到的 【翻转模型】：不断制造反转，类似讲笑话原理 【英雄之旅】模型：好莱坞电影经典桥段，缘起→危机→高潮→结尾； 【因果模型】：图文结合产生高能感，希望能掌握的演绎方式（参考系统论课程），达到多场景使用。 承上启下模型 12秒内新概念的咬合和重复；这样就会显得很连贯 为什么：符合认知心理学中【短时记忆】的原理，非常符合人类大脑接受习惯的 案例 eg视频《疫情之后的新世界》， 铺垫转折模型常用于笑话写作 eg老婆和朋友跑了、泥浆面膜； 资源 书籍《手把手教你玩脱口秀》 时间演绎模型从历史的角度来看某件事的变化，它的过去现在和将来。 空间顺序模型从南到北、从大到小、从内到外、从城市到国家到全球。 模型一 苹果模型：不仅可以描述动漫作品，还可以描述如何做好产品，写好文章，做好视频都有帮助 概念：想对什么样的人表达什么样的观念理念，或者解决什么样的痛点 形式：产品的形态，是短视频还是电影还是文章 风格：是诙谐的（说话风趣，引人发笑），严肃的，宏大的，草根的，硬核的，亲切的等等 结构：内容的骨架，演绎的先后顺序等 工艺：各种细节。如何画，音乐如何配等 外观：最后的包装和呈现，视觉的优化等。 升级递进模型 所以说，侦探解密类型的电影都是使用升级递进模型的高手，这种模型运用的好，可以勾起用户强烈的好奇心。 翻转模型 故事结构模型 英雄之旅（小说创作经典模型） 凤头猪肚豹尾（中文写作模型） STORY EMBRYO任何好的故事结构都可以看做一个循环的圈——从起点下降到未知和最终回归。其中针对你的故事在这个框架上加入具体的描述。完成这个圈分为八个步骤，这些步骤构成了写故事的一个框架，当然，实际中肯定会有例外，但这里不表，因为一切都会有例外，但那就是风格问题了，而不是结构。 虎头表示文章开头威猛精彩，豹尾则表示文章结尾表现有力，猪肚子则表示文章中间内容丰富。 丹哈蒙八步创作法 综合模型 故事&#x3D;冲突（渴望+障碍）+行动+解决 某人渴望得到某事 冲突&#x3D;吸引力：让读者好奇主角将如何解决难题？行动&#x3D;期待感：让读者感到更多有趣的事情将要发生； 读者希望主角成功，主角开始克服重重困难行动起来解决&#x3D;满足感：克服重重困难，问题得到解决 比例分配，各占四分之一第一个部分（渴望） ​ 1、让读者认同某人或某事 认同感+悬念 ​ 2、给某人或某事一个需要 布局 ​ 3、开始要改变当前的环境 故事出现变化 第二个部分（障碍） ​ 1、适应新环境处理新情况 旅途开始 ​ 2、并且找到所需要的东西 主人公顿悟 第三个部分（行动） ​ 1、让某人或某事付出代价 主人公成为xx的催化剂 ​ 2、然后开始回到1 第四个部分（解决） ​ 1、显示原始情况如何因此而改变 因果模型为什么有用：天生自带【承上启下】的咬合结构缺点：依赖图文结合。案例所长林超很多视频常用 《疫情之后的新世界》 相关【因果分析法】多看看系统论会帮助建立因果模型 3 血肉 作用：让谈话写作显的有内涵的关键部分 为什么 选择性注意中显意识未处理的信息也会潜意识发挥作用【注意】【潜意识】 包括： 【数据&amp;细节】：eg人口数据、名言警句（细节-选择性注意）； 【图表】-一图胜千言 【例子】-适度适当，贴近听众（自我记忆模式，eg漫画主角）； 【比喻】-深入浅出（找任何人都能理解的例子，更好解释专业抽象内容），eg看不见的手，书籍《我们赖以生存的隐喻》。 数据&amp;细节数据&amp;细节，还有名言警句（高度凝练有美感的词句） 案例对比 人口数据 ​ 中国人口有十四亿人 ​ 根据七普数据，中国人口有14亿1178万人 ​ 评价：第二种更有冲击力，大脑能接受所有的信息，虽然只能处理一些部分，但剩下的信息会让你感觉很有道理。 表达观点 ​ 多练习有好处 ​ 操千曲而后晓声，观千剑而后识器 例子或故事是什么 故事和例子为什么 【自我记忆图式】不讲故事例子，即使逻辑结构再好，听众也记不住怎么做，举什么样的例子最好？例子要贴近听众，不同的听众讲不同的例子。比如向高中生讲不确定性，不应该讲股票的波动，而应该讲他们接触到的抽盲盒。 注意：例子和故事太多也会使内容太水，不够硬核。所以要适当。 比喻 厉害的比喻就是深入浅出，理解隐喻的能力是人类潜意识里非常关键的能力怎么做，从日常生活入手，找任何人都能理解的事物作为素材，更好解释专业抽象内容。 案例 看不见的手，时间就是金钱，冬天来了春天还会远吗 所长林超 【中国的2021，牛转乾坤】 为了解释中国接下来的经济动荡反而是好事，用了“阳光照到屋子里的灰犀牛”这个比喻 【光刻机的制造】经典比喻案例 资源 《我们赖以生存的隐喻》。 作者：王小c的c https://www.bilibili.com/read/cv12675072/?from=readlist 出处：bilibili","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"社会经济学重要模型","slug":"13社会经济学重要模型","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-09T13:01:52.844Z","comments":true,"path":"2022/01/19/13社会经济学重要模型/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/13%E7%A4%BE%E4%BC%9A%E7%BB%8F%E6%B5%8E%E5%AD%A6%E9%87%8D%E8%A6%81%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"第二课 社会经济学重要模型经济学重要模型 学什么：经济世界变化太快，今天的主流经济学（古典经济学[有关理性人的假设)在解释世界这个问题上越来越缺乏说服力，这里只收集一些争议较小的基础模型。 比如行为经济学中的禀赋效应、心里账户效应。 很多都是从众决策（一方面的和亲戚朋友一起） 供需模型：找到能够灵活定价的大市场，在里面做一个稀缺供给者 投入产出比：学会用 ROI 的方式思考问题 机会成本：有得总有舍 激励模型：改变激励方式来改变人的行为 新经济社会学：要理解其中个人的经济行为，就必须理解他身边的各种人 心理学是帮助了解自己最容易想到的门类，经济学是帮助我们了解社会的门类。 资料：所长林超-跨学科工具箱 供需模型 概念：供给和需求是一个交易达成的对立面，而交易是经济社会运行的最基本要素，正是一个个的交易在为这个世界上很多东西定价。 定价的过程：定价过高的时候，因为有利所图，会导致供过于求，这时候总会有人降低价格，逼其他人也降价，越来越多的商家又会觉得无利可图而退出，商家们的竞争会促使价格达到一个平衡点。当一条路上有五家便利店，但是顾客是稀缺的，此时便利店才有定价权，但是五星级酒店房间里十分钟的路程只有40块那个可乐这一个选择。 应用：可以帮助解决一些现象，和为如何提高自己的收入提供参考 为什么垄断之后就能最大利润呢？这时候只有一个选择，没有竞争。 清晰的思考如何不断提高自己的收入？找到能够灵活定价的大市场，在里面做一个稀缺供给者，这里的灵活定价、大市场、稀缺供给这三个要素缺一不可。比如最近的国产3A游戏，因为很火，要开除高新聘请游戏设计师，但是校外培训行业，因为有公共属性，所以不是一个可以灵活定价的市场。 例子：比如买一瓶矿泉水，在便利店里面卖2块钱，到了景区的酒店里面就可以卖20块钱。 反例：比如公交车地铁的票价就不是由供需决定，每天早上挤地铁的人那么多，明显供过于求，但地铁的票价是不会随之提升的。 注意：供需决定价格并不是万能的，前提是必须存在一个可以自由定价的市场。 相关：从根本上决定价格的是商品本身的价值，供需只是影响价格。 投入产出比（return of investment，辩证思考法） 概念：投入-产出，也叫成本-收益，它们之间的- 比率叫投入产出比。 举例：如果你去种玉米，种子撒下去长出玉米的价值，减去之前投入种子的价值，再除以投入的种子价值，就会得出投入产出比。英文是 return on investment 简称 ROI 。 但是很多人终其一生都很难学会用roi的方式来思考问题，比如说有的人很重视省钱，就会在生活中所有的地方都省钱，而不会想有些地方其实花额外的钱很可能产生比花的钱多得多的回报。这地方的例子就是买书和健身卡。 启发：学会用 ROI 的方式思考问题 误区1（只盯着成本） 只看投入而不看产出：比如有的人很重视省钱，用ROI思考则其实生活中有些地方，多花点前可能会产出更多的回报，比如买书或办健身卡 误区2（只盯着回报） 只看收益而不看成本：比如（艺术家气质的人）明星开餐厅很多时候都是亏钱的，只靠明星的光环效应，而解决不了成本控制问题，最后往往就是餐厅收入越多，亏损的越厉害 所以分析问题时候，一定要两者都要辩证的考虑 机会成本 概念： 假设有一个人他前面有三道门，走进1号的机会成本就是他舍弃了2号和3号的可能性 大学毕业选择读研，机会成本就是这三年你去工作的收益； 把原本研究买房的时间拿来研究股票，机会成本就是研究买房可能带来的收益 启发： 第一，我们要建立决策底线。比如去参加一个谈判，如果你清楚知道自己的手头 plan B 的成本和收益，就会使得你更容易坚持底线。因为实在不行，你就选planB，这就是决策底线。 第二，要明白可选择权的价值。虽然最终往往只能选一个，但有很多其他选择，或根本没得选是完全不同的。比如没有储蓄，或负债就是典型的让一个人丧失选择权的情况；不仅仅是金钱上的可选择权，又如人情上的负债，比如你怕得罪人而不去做你喜欢的事情。又比如父母（面对人情债，就是要保持头脑清醒，知道什么债务必须现在还，什么可以放到以后还；记住，在我们年轻的时候，过早地丧失可选择权是非常可怕的，因为你不知道你会失去什么。 激励模型 在经济学研究里面对于激励的研究非常重要，因为正是人类对经济激励做出了反应，才会产生一系列的经济行为。 比如当老番茄价格上涨的时候，人们会不自觉地少吃番茄，而果农却会增加投入做更多的番茄，所以番茄价格对于供需双方同时产生了激励作用。 比如把激励制度从按照工作小时计费的，改成按件计费，提高工作效率。 应用：如何改变自己的行为习惯 很多时候要改变行为习惯，花点钱找个老师监督和反馈，大多时候远远比自己找一大堆资料方法，做心理建设成本小的多； 比如想学习吉他&#x2F;编程&#x2F;健身，预期自己找一大堆资料&#x2F;方法，较劲脑汁让自己可以坚持更久，不花点钱找个老师监督（对，即使仅仅只有监督） 边际成本 边际：生活中很多的决策很少是非黑即白的，往往都是处于灰色地带。这时候我们需要考虑的不是做或不做，而是要做多少、做到什么程度的问题。比如吃午饭的时候不是吃和不吃的选择，而是已经吃和吃到半饱的时候要不要多点一个甜品的选择。 在经济学上这个叫边际变动，即随着投入规模变大之后成本的变化趋势（多投入的一个单位的增量会产生的新增成本或者收益），以下为几种类型的边际成本 边际成本低：比如开发一个软件，如果全世界只有几个人在用，那么成本分摊到每个人头上就是天文数字。但如果全世界有 10 亿人在用，每增加 1 万个用户，新增加的成本几乎微乎其微 固定边际成本：比如共享单车即便规模做到 1 亿人，想要新服务 1 万人，新投入的共享单车的成本还是放在那里，没多少变动 边际成本高：比如当一个发型师，当用户排满之后，用户继续增加，想要维持原来的服务质量，成本就会愈发增加 比较优势 b对于a来说在填色上有比较优势，所以说，很多职场新人有机会和大牛合作，就是因为大家生态位错开了， 有互补性。 新经济社会学 为什么学： 作为身在中国的我们来说，新经济社会学也许比经济学它更能解释中国的很多经济现象。因为我们大家知道中国本质上它还是一个人情社会。【差序格局】 但现在有了移动通讯、大数据、人工智能这些技术之后，学术界可以绘制出一个区域甚至一个城市的人际关系图谱，通过更加复杂的计算模型去模拟真实的世界。 是什么：新经济社会学的一个核心理论就是嵌入性——个人行为是紧密地嵌入到人际网络关系中，要理解其中个人的经济行为，就必须理解他身边的各种人（比如从众决策）。从小群体到亚文化，再到国家、民族文化，都跟个人的经济行为有着很大关系。 例子： 要理解中国年轻男性为什么必须攒钱买房子，就必须要理解未来丈母娘的选婿标准。 统经济学家发现一个商店要排队，很可能这个商店供不应求，此时商店应该立即涨价才对，但很多情况下都不符合这个道理。之前郑州下大雨，很多市民要到超市排队买应急物资，此时你让超市涨价试试看。 坐地铁时非常拥挤没有座位，此时你会不会跟你旁边的人说“我给你50块钱，你把座位卖给我。” 基本是不会。 扩展资料：《社会与经济》","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"人类学重要模型","slug":"14人类学重要模型","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-10T01:55:35.323Z","comments":true,"path":"2022/01/19/14人类学重要模型/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/14%E4%BA%BA%E7%B1%BB%E5%AD%A6%E9%87%8D%E8%A6%81%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"第十四课 人类学重要模型 研究人类可以从生物和文化两个角度，用基因和模因两个概念串联起来 人类的最重要的特质：【虚构共识】 人类和现代社会的巨大矛盾：【进化迟滞】 有一门专门研究这个现象的学科【进化心理学】 晚熟反而是件好事？【幼态迟滞】 人类后天习得的特征【文化】 想象与共识 概述人类是唯一一个能够运用想象力达成虚构共识的生物。——《人类简史》 人类的最重要的特质是什么？人类是唯一一种可以进行超大规模【协作】，并且保持灵活性的生物。 与黑猩猩和蚂蚁的合作进行比较；对比古人类进化史中不同人种。【协作案例】 为什么人类能达成这种协作？因为能通过想象力达成【虚构共识】。 比如宗教，国家，民族，就是有了这些共识才达成了大规模的协作 为什么虚构的共识很重要？实从虚中来，无虚便无实。 并不是看得见摸得着的东西一定比抽象的东西好 自行车，保温杯，热水壶，卤肉饭这些如今实实在在的东西都抽象概念的演化 概念的存留，也是一个成王败寇的过程，好的概念曾经也会被认为是假大空 应用： 解释一些事情，比如为什么科学技术这类抽象的概念很重要。 如何快速消除陌生感？找到共识，比如共同话题。 相关【进化心理学】为什么人类会对抽象概念有天然的排斥，因为原始社会产生抽象概念，即新共识的速度很慢，相应的处理机制还没进化完善，但现代信息社会就很快了，需要后天去增强这方面的能力 协作案例【蚂蚁】协作规模可以达到几十万甚至几百万，但是蚂蚁部落的协作规则是永远不变的，即使环境发生变化，也无法进行调节，无法应对突发的危险【黑猩猩】可以重新推选领袖，是有一定的灵活性的，但只能进行几十到100只的小规模协作 【尼安德特人】脑容量比智人还要大，也有语言能力，体格更强壮 【人类进化史】中七万年前的大变革，智人全面战胜了其他人种，而这些文明成果也是大规模协作的产物（语言，工具和火其他人种也都会，只有智人能虚构共识进行大规模协作） 进化心理学概述 是什么：因为【进化迟滞】，通过研究人类在原始社会的生活状态，可以找到现代人行为的内在原因。 为什么学：对很多问题都非常有解释性 比如 男女差异可以从原始社会男女分工来解释（狩猎逻辑和采集逻辑）；人类很多的恐惧都于古代环境有关 反例：进化心理学不是万能的，比如在一夫一妻制的看法就有失偏颇，还是需要多学科进行验证。 启发：远古人类本能是现代人痛苦的根源之一 应对：了解原理，建立仪式，刻意练习 扩展资料：《进化心理学》by 戴维巴斯 幼态迟滞 是什么：因为【进化迟滞】，通过研究人类在原始社会的生活状态，可以找到现代人行为的内在原因。 为什么学：对很多问题都非常有解释性 比如 男女差异可以从原始社会男女分工来解释（狩猎逻辑和采集逻辑）；人类很多的恐惧都于古代环境有关 反例：进化心理学不是万能的，比如在一夫一妻制的看法就有失偏颇，还是需要多学科进行验证。 启发：远古人类本能是现代人痛苦的根源之一 应对：了解原理，建立仪式，刻意练习 扩展资料：《进化心理学》by 戴维巴斯 应用 例子1：为什么男女购物习惯不一样？因为原始社会，男性主要职责是狩猎，女性是采集，所以男性注意力狭窄而集中，女性注意力宽广而扩散。 例子2：为什么人们大多喜欢甜食？因为原始社会高热量的食物稀缺，并且很有助于生存。 例子3：为什么女性更喜欢吃甜食，对气味和色彩更敏感，也可以用原始社会女性负责采集来解释。 例子4：为什么人们害怕被别人讨厌，因为原始社会里被社群抛弃就意味着死亡。 但现在社会这不同，所以要学会【切割课题】 例子5：为什么不少人有【社恐】，远古时代如果智人碰到了其他部落的陌生人，那很有可能就有生命危险 例子6：为什么人类害怕蛇和蜘蛛？因为原始社会人中毒死亡的概率很高。 现代社会几乎不会有人因为蛇和蜘蛛而丧命，反而因汽车丧命的人更多，但也没人害怕汽车。 例子7：【快乐】类型 例子8：直播电商内在逻辑 例子9：今天世界上致死率最高的疾病之一【心血管疾病】产生的根本原因，就是因为远古社会食物资源的严重稀缺，造成了人类对脂肪强烈的偏爱；导致事物丰富的现代人，长期过度摄入脂肪 等等等等， 幼态迟滞 人类学和动物学的交叉学科——社会生物学中的重要概念 幼态迟滞：简单说就是晚熟 对比其他动物来说，人类晚熟的现象尤其明显 人类9个月才能走路，而牛羊刚出生就能。 人类大脑23岁才发育完成，猴子则半年就可以，黑猩猩一年就可以。（脑科学） 好奇心和探索欲在其他灵长类动物身上也可以看到，但只存在幼儿期，但人类却可以一直持续下去，实现终身学习。 启发1 某种能力的晚熟的程度，往往代表这个能力的优越性。 狗就可以看做幼态持续的野狼 人类可以看做幼态持续的黑猩猩 启发2 一个社会保持儿童时期好奇心状态的能力是这个社会发达程度的一个指标；成年人保持好奇心的探索欲的能力，也是决定其能否延长寿命的重要因素。 启发3 晚熟不是坏事，但也要取决于所处的社会环境。 文化人类学 体质人类学从生物学研究人类，还有一种叫做文化人类学。 概念：文化是一群人通过（后天）习得对其行为和身边事物意义的共有认识。 后天习得：在西方长大的中国人，行为和思想也会西化 亚文化：包括语言，意见领袖，行为，符号 比如b站的亚文化，“双厨狂喜”“高质量男性”“书无店砸”，一键三联 还有快手的老铁文化，二次元的亚文化，汉服圈和饭圈的亚文化，阿里巴巴也有自己的亚文化 特征： 文化是历史的产物；中国作为历史悠久的文明宝库的确躺在文化的宝库，所以能形成组织十几亿人的共识，成为超级大国 亚文化可以迅速变迁：中国几十年来亚文化的确不断发生着变化，亚文化圈层出不穷 社会价值会影响亚文化：比如两三年前整个社会价值观还是拼命工作追求成为富人，所以996成为了一种副产品，现在2021年国家倡导共同富裕，很多公司开始调整自己的加班策略 资料：《像人类学家一样思考》 扩展：可以通过研究b站研究亚文化 相关：进化迟滞，幼态迟滞都是人类先天习得特征，文化则是人类后天习得的特征 模因 基因和模因，刚好可以把体质人类学和文化人类学串联起来 概念：文化的基本单位，可以通过模仿得到传递。 重要性：影响我们行为的不单有基因，文化观念也影响很大，也就是模因。 特点：和基因一样，也是三个特征，遗传性，变异性和选择性 启发：传承给下一代的不单可以是基因，也可以是模因。 资料：《自私的基因》","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"信息论模型：消除不确定性","slug":"15信息论模型","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-19T13:01:24.219Z","comments":true,"path":"2022/01/19/15信息论模型/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/15%E4%BF%A1%E6%81%AF%E8%AE%BA%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"第二课 信息论模型：消除不确定性 哈夫曼编码：合理分配资源 帧间压缩算法：关注变化 忽略重复 冗余度：资源的重复度 资料 跨学科工具箱 林超 YJango 学习观 信息简史 信息论40讲吴军（待学习） 前言 E&#x3D;mc^2 这里将能量和物质通过一个简单的数学公式结合在了一起。 世界的本源：能量、物质、信息。能量，信息，物质三者的关系是：信息分主观载体信息和客观本体信息。主观载体信息是经过大脑抽象思维处理过的物质的存在方式特征。客观本体信息就是物质本身的存在方式以及在和其它物质作用时的直接的作用。 海森堡测不准原理告诉我们科学的边界在哪里，当我们的仪器越来越好，那么理论上可以把基本粒子的位置和速度测得越来越准，最终完全掌握他的行踪。但是该原理告诉我们，不论科学怎么发展，我们都不可能测算基本粒子的状态。**因为我们观察粒子这件事就会改变他们的行为。也就是我们的观察改变了客观世界。因为我们将光子打到他们什么上的时候，粒子吸收了光子的能量，就会改变原来的状态。 ** 能量守恒，但信息不守恒。所以说人类分享知识是给这个世界创造纯粹增量的事情。 信息 信息：消除不确定性的叫做信息 无法消除不确定性的叫作噪音，需要通过知识将其与信息进行分离 信息量（Amount of information）：消除信息熵所需要的信息的量，单位是bit。 还有一种定义将此称为正信息，增加不确定性的则叫做负信息，比如欺骗，撒谎，谣言 信息可以被认为是从无序中夺得的有序 信息熵（information entropy）：描述一个东西不确定性的程度，通俗讲就是你要搞清楚一个东西的难度。可能性越不平均，信息熵就越低。比如：模棱两可的决定是最没有信息量的。 信息量的计算：n比特信息就是我们，要在2^n个可能选择中（出现概率不一定相等）做出选择需要的信息量。不如我们判断一个人是高于六英尺还是低于六英尺，并且已知两种情况出现的可能性相等，那么我们只需要1比特信息。 例子1（猜盲盒）：猜测盲盒中会出现哪个娃娃，如果只有一种娃娃，猜中没有难度，信息熵为零，如果有很多种娃娃，猜中难度较大，信息熵也很大。会有一下结论： 1、可能出现娃娃款式数量越多，信息熵越大 2、款式确定去情况下，如果每一款出现概率一样，这时候信息熵最大。 3、如果有一个款式出现概率很大，信息熵会大大降低。 例子2（选择题）小明做某道数学题，有ABCD四个正确选项，正确答案是C 1、小明认为ABCD选项都一样可能，这时候选项在等概率的时候信息熵最大 2、小红告诉小明选有一半可能选C，提供了信息，将C选项的可能性从25%提高到了50% 3、小红告诉小明不选B选项，提供了信息，将B选项的可能性从25%降低到了0% 4、小红告诉小明正确答案是C，提供了信息，将C选项概率提升到了100% 5、但是当小明已经知道正确答案是C，小红对小明则提供了0bit的信息 6、小红告诉小明肯定是ABCD其中一项，就提供了0bit的信息，也就是所谓的“废话” 7、无论是小红用纸条还是直接告诉小明正确答案，提供的信息都是一样的 8、小明主观认为C是错的，实际的信息熵不会减少 9、小明对正确答案是ABCD哪个选项的熵是2bit，对答案属于AB还是CD的熵是1bit 10、解答这道题的信息本质是调整每个可能情况（微观态）的概率 例子3 “太阳从东边升起” 这句话对于知道的人，提供了1bit信息，对于知道或东或西升起的人，提供了1bit信息，对于觉得东南西北都有可能的人提供了2bits的人 启发： 1、模棱两可，平均用力，是一种相对无效的资源配置方式。因为从热力学和信息论中得知，不做选择，随波逐流就会增加整个系统的无序性。（例子1.2，2.2） 2、对同一件事情接收到的信息与用于传递信息的信号形式无关（例子2.7） 3、信息量是相对的：是相对于人的：接受到的信息量是相对于观察者已经对这件事情实际的了解程度而言的，所以说到信息量就必须不能脱离观察者（例子2.5，例子3）；也是相对于事的（例子2.9）；很多人在思考问题的时候，会不自觉的认为所有观察者都和自己一样，或不经意间切换所要思考的事情，或根本不知道自己思考什么事情，这会导致怎么也想不明白或白费力气 4、但信息是客观的物理量，不随观察者主观意识改变（例子2.8） 相关 语言的“信息”不仅仅包含在每个字词上，还包括在音调上，还包括在句话，整篇文章，整个语言背景的综合里。 哈夫曼编码 用途：在计算机领域广泛应用于数据压缩，可以对涉及到资源分配的生活场景提供启发。 哈夫曼编码：如果我们能把较短的编码分配给高频出现的词汇，使用编码时就可以达到效率最优化。 哈夫曼编码是一种不定长编码&#x2F;前缀编码 编码：把一个东西映射到另一个东西上。好的映射应该保证信息不丢失 启发：为了提高效率，我们应该把生活中最重要的资源分配给人生中最高频出现的场景。即围绕关键领域饱和配置&#x2F;集中精力夯实基础知识。 应用：比如安排家具物品的位置，常用的放到更顺手的地方，爱看书就把书房设置大一点； 相关：奥卡姆剃刀【如无必要，勿增实体】即大刀阔斧的做减法，可以和霍夫曼编码结合起来。比如认真反思自己生活中最高频的场景有没有可以优化的空间，比如吃饭，睡觉，运动，呼吸，工作，娱乐，排便等；把资金花在自己最高频使用的工具上，比如笔记本电脑和手机。 帧间压缩算法（Interframe compression） 是什么：压缩信息的一种算法。 为什么要压缩，如果不压缩的话，一个两小时的高清电影可能会12000GB大小，压缩后能降低几千倍大小，但还是看起来很流畅 怎么做：视频连续的画面间有很多重复的部分，只需要存储变化的部分即可，而因为视频大多是连续的，所以变化的部分其实不多。 启发： 关注变化，忽略重复，可以使我们的学习效率提升n倍 结合霍夫曼编码原理，起步的时候把基本功练扎实是最重要的，后面就可以只关注增量 通过关注信息增量，而不是关注信息存量，来极大提升效率。比如用来快速阅读和学习。 其他： 只要有序的东西都是可以压缩的，只有完全随机的序列才无法压缩。 如果某个对象能用其他较少bit的方式表达，那么他就是可压缩的 人是如何创造出各种理论，来解释自身对于世界的经验呢？他们必须将经验一般化，从深受随机性和噪声影响的数据中找出模式。当人或计算机从经验中学习时，他们在采用归纳推理，从无规律的信息流中识别出规律来。从这个意义上来说，科学定律其实就是一种数据压缩。 互信息（Mutual Information） 相关性！&#x3D;因果性 我们小时候读的书是十万个为什么的追求原因的，但是世界是非常复杂的，大多联系都是相关联系，而不是因果关系。所以可以通过信息论和数据科学，去分析万事万物之间的关联性。因为科学是可量化、可证伪、清楚自己能干什么，清楚自己干不了什么。 冗余度（Redundancy） 冗余度：资源的重复度。信息论中语言的冗余度D度量了某种文本在不损失任何信息的前提下可以缩减多少篇幅。 用途： 为了保证安全性可靠性，用数据备份等手段增加冗余度，等等。 语言上的冗余指的是“为了克服歧义和进行纠错而专门引入的额外的信息”，事实上每一种语言都包括冗余，这也就是为什么人们可以读懂错别字连篇的文章。但在通讯中，这种冗余明显会造成巨大的浪费。 启发 冗余并不一定是坏东西，在工程领域它可以保证系统运作安全，在表达上，它能更好的服务于人类的认知习惯。 时代在进步，人类习惯接受的冗余度也在减少，所以我们越来越需要掌握去除冗余度的方法。 如何去除冗余度：画分析框架 1、把关键概念零散的列出来（这个摘要的就是） 2、寻找整理概念之间的关联 3、套用和矫正自己原有的知识体系或模型 其他 质能方程：物质和能量的关系，意义在于两个完全不同的概念联系到了一起。 信息熵公式：整个信息论的基础，描述信息如何量化【信息熵】 海森堡测不准原理：描述科学的边界，无论科学怎样发展，都无法测算基本粒子的状态，因为我们观察粒子这件事情，本身就会改变粒子的行为。 启发：我们的观察会改变客观世界，所以我们生活的世界是没有绝对客观的存在的，我们真正能观察到的只能是客观世界和主观想象之间的结合体。 能量和信息：能量守恒，但信息不守恒。 整个宇宙最主要的两个概念，能量（物质）和信息 哲学家希望思考的是事物的本质，但他们思考的却只能是事物的符号【语言学转向】 “完美”与”确定性”这些概念与语言的本质是相互对立的，信息论已经帮我们理解了这一点","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"上大学的意义","slug":"上大学学到了什么","date":"2022-01-19T13:29:00.000Z","updated":"2022-02-26T03:26:59.774Z","comments":true,"path":"2022/01/19/上大学学到了什么/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/%E4%B8%8A%E5%A4%A7%E5%AD%A6%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88/","excerpt":"","text":"大学关于个人成长方面的见解 一转眼，四年过去了。身处十七八、二十来岁的年纪，对时间的衡量大概都是以年为单位了。一年、两年、三年、四年，就像是在心里默念数字1234这么快。大一，看山是山，看水是水，那时天真的以为自己看到的都是对的。大四，看山不是山，看水不是水，对好多事有了推翻了再建的认知。现在，对好多事的理解真的深刻了好多，就像是做一道数学题，比如线代里的tr（A），刚学的时候以为就是那样子算出来，考研的时候直接用另一个矩阵算，最后转到A的tr上。又比如，现在对自信的理解，哈，以前以为只是做事之前骗自己要有把握一些，后来读了《自卑与超越》，又有好多事来做你前进的底气的时候，这时候对自信的理解又上了一层楼。 前两年，后两年有好多打击，现在时而很厌世，时而又对各种各样的事充满了好奇心。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"最小内核","slug":"人生最小内核","date":"2022-01-19T13:29:00.000Z","updated":"2022-02-26T03:26:59.321Z","comments":true,"path":"2022/01/19/人生最小内核/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/%E4%BA%BA%E7%94%9F%E6%9C%80%E5%B0%8F%E5%86%85%E6%A0%B8/","excerpt":"","text":"关于决策某方面的决策关于学习一样简单的东西比如看一个电影你会 从他的音乐、视觉、表演、剧情、逻辑等角度来看他，但是这其中包含的所有的看法，怎么来的，等等的所有体系总结出来","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"房屋设计","slug":"关于房屋设计","date":"2022-01-19T13:29:00.000Z","updated":"2022-02-26T03:27:00.115Z","comments":true,"path":"2022/01/19/关于房屋设计/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/%E5%85%B3%E4%BA%8E%E6%88%BF%E5%B1%8B%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"想写一个3d模型加上自己的所有设计，担心的事等等，以后买一个房子，我要自己动手全都弄成我温馨的小家","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"化妆入门","slug":"化妆入门","date":"2022-01-19T13:29:00.000Z","updated":"2022-02-26T03:27:00.068Z","comments":true,"path":"2022/01/19/化妆入门/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/%E5%8C%96%E5%A6%86%E5%85%A5%E9%97%A8/","excerpt":"","text":"第二节","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"音乐","slug":"吉他练习","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-16T11:47:05.776Z","comments":true,"path":"2022/01/19/吉他练习/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/%E5%90%89%E4%BB%96%E7%BB%83%E4%B9%A0/","excerpt":"","text":"吉他第二节 左手按弦的时候指尖要立起来 右手的大拇指拨的音要比其他手指要大，因为大拇指是侧拨，力量大，这样子大拇指拨的音才不会被后来弹的其他手指的音盖掉。这里注意一下使用情况？ 对于弦乐器，声音的频率取决于弦长、拉力和线密度三个因素。如果将弦长增大，频率就会降低。弦长变短，频率就会变高。钢琴发音是因为一个小锤敲击钢丝，钢丝的长短不同，发音频率就不同。对于同一根弦，用手按住不同的位置，也可以改变弦长，于是就可以发出不同的音。小提琴演奏的时候用左手按住弦上不同的位置，就是为了改变弦长。如果改变拉力，也可以影响发音频率，拉力越大，频率越高。国际标准音将中音A定为440Hz，其他音按照十二平均律依次确定。 还有一个影响因素是线密度，比如吉他所有的弦长度都差不多，但是粗细不一样。细的线线密度小，发音频率高；粗的线线密度大，发音频率低。 第三课 c调和弦的前三个八位是不用移动左手的，手腕保持不上下移动 音感的训练，123456的调掌握好 第四课 8、找准最省力的点，就是最靠近品丝但不按住品丝的地方，要放松的按 9、按弦的力度刚刚好，按紧了自己会累，按松了会有杂音。 第五课吉他和弦中作为根基的音称为根音（root），基础音。一般和弦中的音都会以各个音与根音之间的关系命名。以根音为基础向上做三度叠加，形成至少三个音，至多七个音的组合，称为和弦。 和弦后有后缀“m”,表示它是一个小三和弦,也就是把C和弦的三音（此时C和弦的三音是E）降低半音，但是纯五度的那个G音不变。m的缩写minor 。 扫弦的时候要把这个和弦的根音用力扫出来，为了突出这个音 第六课按那个c调下的f的时候，可以食指侧着按，这样的话能够将力量发出来 4|4拍子就是四分音符为一拍，每小节四拍。其节奏为强弱次强弱。而且一般都是两个八分音符凑成一个四分音符，用脚去打拍子的话就是脚每下去一下，就要弹两下，如果上下一次算一拍的话，然后脚下去上来、下去上来、下去上来、下去上来这就算一个小节。也就是12345678这样子，每一个数就是弹一下。1234这就是弹四下也就是对应着脚上下这样一个拍子。 有个吉他标准调音法：55545，也就是六弦的第五品和五弦的空弦音高相等，五弦的第五品和四弦的空弦音高相同，然后以此类推 吉他C大调若以C大调为例，一级和弦就是C大调中的C为I级音，那么吉他中的一到六级和弦为（第7级和弦一般不用）： 每一个调都有1-6级最基本的和弦，这些基本和弦都是三和弦，由两个三度音叠加形成的，比如在C调里C和弦是由（135）构成，1-3是一个大三度，3-5是小三度。三度音中包含了3和4（mi,fa)或7和1（si,do)的就是小三度。 145级和弦是大三和弦（大三度+小三度）构成，直接用单个的音名表示，C调的145级和弦分别是C，F，G。 236级和弦是小三和弦（小三度+大三度）构成，用音名后面加一个小写的m来表示，C调的236级和弦分别是Dm，Em，Am。 乐理五度相生法拿下图中的1&#x3D;C来说，如果两个音差8度，则高低音的频率比为2：1。如果两个音差5度，则高低音的频率比为3：2。如果两个音差4度，则高低音的频率比为4：3。 我们可以用现代的语言把毕达哥拉斯的方法描述如下：把不同的音调写作C、D、E、F、G、A、B，在C大调中，它们就表示do、re、mi、fa、sol、la、si。下一个C就称为高音do。 不过，五度相生法并非完美和谐，例如两个相邻音之间的频率比：re和do之比为9：8，mi和re之比也是9：8，但是f和mi之间的比例是256：243，与之前不同。再比如，fa和si之间也相差4度，但是频率比却不满足4：3 的关系。不过，人们依然承认毕达哥拉斯是第一个提出七个音阶的音乐家，他只用了三个简单的有理数，就定义出了完整的音律系统。 三分损益法中国的管仲也提出了自己的音律系统，称为三分损益法。三分损益法的结果与五度相生法差不多，但是管仲只提出了五个音，分别是：宫、商、角、徵、羽如果一根笛子发出的声音频率是f，将笛子的长度平均分为三份，减少其中的一份，这样一来获得一个高音。现在我们知道，这个音的频率是3f&#x2F;2；如果把笛子的长度增加三分之一，就称为益，就会获得一个低音，频率为3f&#x2F;4。管仲经过反复的损益，获得了五个音阶。 十二平均律 无论是毕达哥拉斯还是管仲，它们都采用了2：1，4：3和3：2三个数字来定义音阶，但是这样的方法都面临一个问题：相邻音阶之间的频率比不相同。这样一来，如果需要做音乐上的转调，就很不方便。所谓转调是指将do的位置进行改变，例如C大调是将中音C定为do，而A大调则是将A定为do，两个do的基础频率不同，按照上述方法，后面的re、mi、fa、sol等音，音调的升高比例也不同。 在现代，最流行的音律系统叫做十二平均律。这种方法虽然繁荣于西方，却是一个中国的皇族最早发明的。朱载堉认为：要让音乐和谐动听，必须保证所有相邻的音阶音高相差相同，也就是频率之比相同。一个八度内频率相差两倍，如果将其分成12份，每一份应该相差2的十二次方根。 现代音乐大部分是基于十二平均律的，也就是将一个八度分为十二份！。例如钢琴有88个按键，每个八度中有12个按键，就分别对应了以上的频率关系。音名的CDEFGAB是对应着特定的频率的，是不随曲子改变的，变的是唱名。 每一个八度的白键称为主音，在C大调中唱名是do、re、mi、fa、sol、la、si；黑色的按键称为半音，C和D之间的黑键称为升C（C#）或者降D（Db）。无论这两个按键是两个白键还是一个白键和一个黑键，每两个相邻的按键之间，频率比约为1.059。相邻的两个八度同名音之间的频率比为2：1。 大调与小调 基本音阶为C调大音阶，在钢琴上弹奏时全用白键。 音阶分为“大音阶”和“小音阶”，即“大调式”和“小调式”。 大调由7个音组成，其中第3、4音之间和第7、8音之间是半音程，其他音之间是全音程。小调第2、3音之间和5、6音之间为半音程。 大调式是【全全半全全全半】的关系， 小调式是【全半全全半全全】的关系。 一个半音为小二度。一个全音为大二度。 四个半音，两个全音为大三度。 三个半音，1.5个全音为小三度。 这里所说的半音就是十二平均律中的那一个半音。 图解自然大小调（即C大调与c小调）的关系 例如：用音名排列出c自然小调音阶。 思路：c自然小调音阶的简谱形式是6（低音）、7（低音）、1、2、3、4、5、6，其中6&#x3D;c，7（低音）与1之间是半音，3与4之间是半音。接下来就可以按首调唱名或简谱唱名依次排出音名：C（6）、D（7）、降E（1）、F（2）、G（3）、降A（4）、降B（5）、C（6）。 目前国内的音乐基础知识业余考级里所指的音级是调式音级。调式音阶中的各音就叫做调式音级。每个音阶中的主音也就是调式音阶中的I级音。每个调式音阶的主音不同但标记永远以主音为I级。所以说c大调中的C和弦就是一级和弦，因为其以1&#x3D;C中的C为根音。 关于唱名这里为什么有do re mi fa so la si这七个唱名，就是因为容易发音，因为这几个后面都是元音结尾的。这里有这几个唱名，只是为了让你发的音有一个稳定的跨度，而真正形容音的高低是用C D E F G A B 来衡量的。因为只要频率的跨度有一定的比率，所发出来的调就是好听的，所以说，男生女生起始的调不一样，但是按照频率的跨度唱出来的歌都是好听的。这正好就是有c大调（唱名do&#x3D;音C的频率），a调等不同的调之分的原因。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"投资方面的知识","slug":"投资","date":"2022-01-19T13:29:00.000Z","updated":"2022-02-26T03:27:00.416Z","comments":true,"path":"2022/01/19/投资/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/%E6%8A%95%E8%B5%84/","excerpt":"","text":"找本书系统的看一下巴菲特的一个投资前的清单 工程学那节课的里一个表","categories":[{"name":"投资","slug":"投资","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%8A%95%E8%B5%84/"}],"tags":[],"author":"aoyuehan"},{"title":"拍照场景与技巧","slug":"拍照场景与技巧","date":"2022-01-19T13:29:00.000Z","updated":"2022-02-26T03:26:59.851Z","comments":true,"path":"2022/01/19/拍照场景与技巧/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/%E6%8B%8D%E7%85%A7%E5%9C%BA%E6%99%AF%E4%B8%8E%E6%8A%80%E5%B7%A7/","excerpt":"","text":"第二节","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"脑科学重要模型","slug":"拍照的模式","date":"2022-01-19T13:29:00.000Z","updated":"2022-02-26T03:26:59.897Z","comments":true,"path":"2022/01/19/拍照的模式/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/%E6%8B%8D%E7%85%A7%E7%9A%84%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"第二课 系统论重要模型","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"本科论文怎么写","slug":"本科论文","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-21T02:07:14.179Z","comments":true,"path":"2022/01/19/本科论文/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/%E6%9C%AC%E7%A7%91%E8%AE%BA%E6%96%87/","excerpt":"","text":"降重方法 换一种表达方式来表达同一个意思 降重方法：1、按理解重述。2、查必过近义词替换。3、前后顺序调换。4、长短句切换组合。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"关于汽车的知识体系","slug":"汽车总的知识体系","date":"2022-01-19T13:29:00.000Z","updated":"2022-02-26T03:26:59.697Z","comments":true,"path":"2022/01/19/汽车总的知识体系/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/%E6%B1%BD%E8%BD%A6%E6%80%BB%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/","excerpt":"","text":"想写一个那种3d模型加上自己所有对汽车驾驶，设计，搭配方面的所有知识","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"脑科学重要模型","slug":"穿搭","date":"2022-01-19T13:29:00.000Z","updated":"2022-02-26T03:27:00.198Z","comments":true,"path":"2022/01/19/穿搭/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/%E7%A9%BF%E6%90%AD/","excerpt":"","text":"第二课 系统论重要模型","categories":[{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"}],"tags":[],"author":"aoyuehan"},{"title":"阿里云自建k8s集群","slug":"阿里云自建k8s集群","date":"2022-01-19T13:29:00.000Z","updated":"2022-04-09T09:53:32.097Z","comments":true,"path":"2022/01/19/阿里云自建k8s集群/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/19/%E9%98%BF%E9%87%8C%E4%BA%91%E8%87%AA%E5%BB%BAk8s%E9%9B%86%E7%BE%A4/","excerpt":"","text":"阿里云ecs实例安装k8s安装kubesphere当ecs重启之后出现ks-ks-account一直Init:0&#x2F;2；并且ks-apigateway一直CrashLoopBackOff 先启动master节点，在master中删除其他从节点，从节点重新加入k8s的master节点中 12345678910111213141516171819202122232425# 首先驱逐要删除节点(假设节点名为k8s-node1)上的pods（master节点执行）kubectl drain k8s-node1 --delete-local-data --force --ignore-daemonsets# 然后执行删除（master节点执行）kubectl delete node k8s-node1kubeadm token create --print-join-command //重新生成token# 最后在删除的节点机器上执行kubeadm resetkubeadm join 192.168.1.1:6443 --token cbjtfp.flf3hy5y3uoe8twz --discovery-token-ca-cert-hash sha256:6dd10942ca46910fa44c762859975ca64ee218ba970ea1fatips:执行重新加入master节点的时候出错（https://blog.csdn.net/qq_40460909/article/details/114707380）[ERROR FileContent--proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`To see the stack trace of this error execute with --v=5 or higher执行echo &quot;1&quot;&gt;/proc/sys/net/bridge/bridge-nf-call-iptables或永久解决方法：在/etc/sysctl.conf中添加：net.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1执行sysctl -p 时刷新 sysctl -p https://blog.csdn.net/qq_27156945/article/details/102628093 最终发现我为什么重启整个集群之后，这个master总是在node节点上拉不起kubesphere，一直是ks-ks-account一直Init:0&#x2F;2；并且ks-apigateway一直CrashLoopBackOff，这就是因为我没有设置其他从节点中的net.bridge.bridge-nf-call-iptables &#x3D; 1，导致主节点不能在从节点上拉起容器，当我设置其值在系统表中，至此，重启之后，master节点能拉起来kubesphere 脚本删除安装的kubesphere v2.112345678910111213141516171819202122232425262728293031323334353637383940#！/bin/bash#helm deletehelms=&quot;elasticsearch-logging elasticsearch-logging-curator istio istio-init jaeger-operator ks-jenkins ks-sonarqube logging-fluentbit-operator metrics-server uc&quot;for id in `helm list|awk &#x27;&#123;print $1&#125;&#x27;|grep -v NAME`; do result=$(echo $helms | grep &quot;$id&quot;) if [[ &quot;$result&quot; != &quot;&quot; ]] then helm delete --purge $id else echo &quot;helm resource deleted&quot; fi done#namespace resource deletenamespaces=&quot;kubesphere-system openpitrix-system kubesphere-monitoring-system kubesphere-alerting-system kubesphere-controls-system&quot;for namespace in `kubectl get namespaces|awk &#x27;&#123;print $1&#125;&#x27;|grep -v NAME`; do result=$(echo $namespaces | grep &quot;$namespace&quot;) if [[ &quot;$result&quot; != &quot;&quot; ]] then kubectl delete all --all -n $namespace else echo &quot;namespace resource deleted&quot; fi done# pvc deletepvcs=&quot;kubesphere-system openpitrix-system kubesphere-monitoring-system kubesphere-devops-system kubesphere-logging-system&quot;for pvcnamespace in `kubectl get pvc --all-namespaces|awk &#x27;&#123;print $1&#125;&#x27;|grep -v NAMESPACE`; do result=$(echo $pvcs | grep &quot;$pvcnamespace&quot;) if [[ &quot;$result&quot; != &quot;&quot; ]] then kubectl delete pvc -n $&#123;pvcnamespace&#125; `kubectl get pvc -n $&#123;pvcnamespace&#125;|awk &#x27;&#123;print $1&#125;&#x27;|grep -v NAME` else echo &quot;pvc resource deleted&quot; fi done 集群重启之后出现集群重启后 ks 关键pod 状态异常以ks-account相关举例，其余的ks-apiserver,ks-console等也有类似情况 在我们集群重启服务器之后，发现ks-account pod有一个状态为pending： 解决方案： 1.重启后ks-installer会重新启动，会触发此类deploy重启更新。2.可以describe查看pending状态的pod，由于此类pod设置了反亲和性，所以应该是没有可调度的节点导致重启异常。 临时解决办法：可以手动删除一个旧版本的pod 最后建立k8s的方法最后用ecs自建集群安装kubesphere很成功，但是，重启整个集群之后总是会因为pvc挂在失败，导致剩下的容器启动失败。最后通过镜像备份的方法始终没能解决，最后换成使用阿里云的ask集群搭建的k8s","categories":[{"name":"k8s","slug":"k8s","permalink":"https://zouyunkai.github.io/myblog/categories/k8s/"}],"tags":[],"author":"aoyuehan"},{"title":"本校去阿里那个学长的演讲","slug":"本校去阿里那个学长的演讲","date":"2022-01-11T13:29:00.000Z","updated":"2022-04-15T06:25:16.101Z","comments":true,"path":"2022/01/11/本校去阿里那个学长的演讲/","link":"","permalink":"https://zouyunkai.github.io/myblog/2022/01/11/%E6%9C%AC%E6%A0%A1%E5%8E%BB%E9%98%BF%E9%87%8C%E9%82%A3%E4%B8%AA%E5%AD%A6%E9%95%BF%E7%9A%84%E6%BC%94%E8%AE%B2/","excerpt":"","text":"（1）核心：不打无准备的仗 1、 打好基本功，特别是数据结构，计网数据库也要看看 2、 积累项目经验 3、 简历要写好，人家想要你，因为你可以带来价值 （2） （3）关于未来，职业规划 所谓职业规划就是工作能力的提升、大道至简。 拿结果能力，一杆到底能力，专业技能专业，系统性思考能力。 职业规划不是某个岗位，某个角色，而是工作能力的提升。针对自己岗位需要的能力，职场需要的能力．然后用专家思维*.多维视角重点突破3-4项能力、抱着120%的努力拿到结果，甚至是超出期望的结果，事情成了，能力也就被认可了．所谓的角色.*岗位只是顺其自然的结果 现在苦多吃一点，有些苦能吃就吃，最后这些苦都会以现金的形式回馈给你。 （4）不用和别人比较，不管是生活还是工作还是其他别的东西，看开就好。比昨天的自己进步一点点。 专注于自己的成长，只要感觉到自己的，就不感到焦虑，就可以应对多变的未来。18岁干不了25岁的事，22岁干不了30岁的事，所以20岁不要焦虑未来很长的事，当下才是要考虑的。 没事的时候多自省，这样才能不迷茫，才不会承受迷茫的时候带来的痛苦。 （5）如何做到知行合一？ （6）干一点挑战性的东西。 （7）社会上真的有一帮人，他们真的有家境，有能力，但还是比你努力。 （8）互联网发展和工作的方向联系起来，学完了但是用不到了，这样的不要学，走一步看一步，在工作里工作一下试试，然后了解到了方向之后再打算走什么方向才最好。所有我以为的硕士学的机器学习用不到，直接去干后端，这样的想法可能不对。 硕士的时候老师可能偏学术搞模型写paper，所以你自己选好开发或者学术，两手抓。给老师干完，就干自己的。实事求是，走一步是一步，然后结合当时的实际情况现状来选最优的。 （9）实习的时候，不局限于crud，要看到上面和下面的，上面的人怎么设计架构什么的，下面的人怎么实现的，这一套怎么弄的。要把点线面穿起来。 （10）解决问题的能力，项目教到你手里不能黄，这比证书要强。 （11）考证，pm项目管理的证，能考则考。 (12)数学建模来一下试试。 （13）持续学习，个人成长 成长无法急于求成，无法急功近利，唯有每日在不被打扰的时间中不断投资自己，通过不断输出确认自己成长上的不足， 褴环弥补不足之处。通过把自己逼近或长临界点，然后跨过临界点的那一刻，自己立马可以体会到自己的变化,自己的成长。 而自己一旦体会到成长，我们会把前一段时间的成长过程进行总结，抽象总结出自己的成长最佳实践。再次践行. 把自己逼向下一个成长临界点，然后再次跨过去，以此反复循环，慢慢提升自己的多元能力，跨界能力。所有这些能力的提升，在未来某个机会来临的时候。因为具备足够的能力去驾驭他此时我们要做的是，抱着120%的努力把事做成功，事情威功了.能力也有了。空间白然会有。也就被认可了 （14） https://blog.csdn.net/b0Q8cpra539haFS7/article/details/84848613 偏在技术深度达到了一定阶段后，需要对自己做出一个选择，就是偏业务方向，还是偏基础技术方向。 业务方向的技术人员，我认为做的好的表现是： \\1. 对业务发展的未来有一定的预判，有商业敏感意识； \\2. 能对复杂的业务进行合理的抽象； \\3. 在系统的设计上能对未来业务的变化有一定的预留处理。 偏基础方向的技术人员，我认为做的好的表现是： \\1. 能结合业务的发展趋势对基础技术的方向有一定的预判，避免业务发展受到基础技术的拖累； \\2. 对业界的技术发展方向有自己的认知和判断； \\3. 在对应的基础技术领域有不错的技术深度。 而再往更高阶走的同学，通常就会出现一种新的角色，就是成为团队leader，做为一个技术团队的leader，无论是业务的还是基础技术的，在技术能力上还是不能差的，尤其是判断力上，另外，作为一个团队leader，就意味着承担了团队方向的判断的职责，一个团队的方向基本会直接影响到团队所有成员的未来，以及所支持的业务的发展状况，所以对于一个团队leader，我觉得最重要的能力就在方向的判断上，然后是根据方向的判断的组织建设（团队搭建，人才识别、培养、招募等）能力。 如果不是往leader方向呢，那基本就是往架构师方向为多，架构师的话，在至少一两个领域的深度外，对广度的要求非常高，还有同样就是判断能力，无论是业务架构师，还是基础方向的架构师，领域的知识宽度是非常重要的，意味着能做多大范围的事，判断能力会体现出一个架构师在做一个架构设计时重点是怎么判断的，在有限的资源和时间情况下取舍是怎么做的，对未来是怎么做铺垫的，以及TA对事情的技术控制能力，一个好的架构师在技术风险的控制能力上必须是非常强的，例如一个强大的基础领域的架构师，应该是可以很好的控制跨多个专业技术领域的技术演进。 还有一种是往专业技术深度领域方向走，例如内核、JVM等，这些领域是真正的需要非常深的技术功底才能hold的住的。 （15）投资自己？ （16）编程能力的成长 https://www.sohu.com/a/290511403_494946 作为程序员，最重要的能力始终是编程能力，就我自己的感受而言，我觉得编程能力的成长主要有这么几个部分。 \\1. 编程能力初级：会用 编程，首先都是从学习编程语言的基本知识学起的，不论是什么编程语言，有很多共同的基本知识，例如怎么写第一个Hello World、if&#x2F;while&#x2F;for、变量等，因此我比较建议在刚刚开始学一门编程语言的时候，还是就看看编程语言自己的一些文档就好，而不要上来就去看一些高阶的书，我当年学Java的时候上来就看Think in Java、Effective Java之类的，真心好难懂。 除了看文档以外，编程是个超级实践的活，所以一定要多写代码，只有这样才能真正熟练起来，这也是为什么我还是觉得在面试的时候让面试者手写代码是很重要的，这个过程是非常容易判断写代码的熟悉程度的，很多人会说由于写代码都是高度依赖IDE的，导致手写很难，但我绝对相信写代码写了很多的人，手写一段不是太复杂的可运行的代码是不难的，即使像我这种三年多没写过代码的人，让我现在手写一段不太复杂的可运行的Java程序，还是没问题的，前面N年的写代码生涯使得很多东西已经深入骨髓了。 我觉得编程能力初级这个阶段对于大部分程序员来说都不会是问题，勤学苦练，是这个阶段的核心。 \\2. 编程能力中级：会查和避免问题 除了初级要掌握的会熟练的使用编程语言去解决问题外，中级我觉得首先是提升查问题的能力。 在写代码的过程中，出问题是非常正常的，怎么去有效且高效的排查问题，是程序员群体中通常能感受到的大家在编程能力上最大的差距，解决问题能力强的基本很容易在程序员群体里得到很高的认可，在查问题的能力上，首先要掌握的是一些基本的调试技巧，好用的调试工具，就像在Java里JDK自带的jstat、jmap、jinfo，不在JDK里的mat、gperf、btrace等，工欲善其事必先利其器，在查问题上是非常典型的，有些时候大家在查问题时的能力差距，有可能仅仅是因为别人比你多知道一个工具而已，除了调试技巧和工具外，查问题的更高境界会和编程能力的高级阶段有非常大的关系，就是懂原理，一个懂原理的程序员在查问题的水平上是有明显差距的，我想很多的同学应该能感受到，有些时候查出问题的原因仅仅是因为有效的工具，知其然不知其所以然，我给很多阿里的同学培训过Java排查问题的方法，在这个培训里，我经常也会讲到查问题的能力的培养最主要的也是熟练，多尝试给自己写一些会出问题的程序，多积极的看别人是怎么查问题的，多积极的去参与排查问题，很多最后查问题能力强的人多数仅仅是因为“无他，但手熟尔”，就像我自己，排查问题能力的提升主要是在2009年和2010年，那两年作为淘宝消防队（处理各种问题和故障的虚拟团队）的成员处理了很多的故障和问题，当时消防队还有阿里最公认的技术大神多隆，向他学习到了很多排查问题的技巧，和他比，我排查问题的能力就是初级的那种，我印象最深刻的是有一次我们一起查一个应用cpu us高的问题，我们两定位到是一段代码在某种输入参数的时候会造成cpu us高的原因后，我能想到的继续查的方法是去生产环境抓输入参数，然后再用参数来本地debug看是什么原因，但多隆在看了一会那段代码后，给了我一个输入参数，我拿这个参数一运行，果然cpu us很高，哎，而且这种case不是一次两次，所以我经常和别人说，我是需要有问题场景才能排查出问题的，但多隆是完全有可能直接看代码就能看出问题的，这是本质的差距。 除了查问题外，更厉害的程序员是在写代码的过程就会很好的去避免问题，大家最容易理解的就是在写代码时处理各种异常情况，但这里通常也是程序员们很大的差距的地方，写一段正向逻辑的代码，大部分情况下即使有差距，也不会太大，但在怎么很好的处理这个过程中有可能出现的异常上，这个时候的功力差距会非常明显，很多时候一段代码里处理异常逻辑的部分都会超过正常逻辑的代码量，我经常说，一个优秀程序员和普通程序员的差距，很多时候压根就不需要看什么满天飞的架构图，而只用show一小段的代码就可以，举一个小case大家感受下，当年有一个严重故障，最后查出的原因是输入的参数里有一个是数组，把这个数组里的值作为参数去查数据库，结果前面输入了一个很大的数组，导致从数据库查了大量的数据，内存溢出了，很多程序员现在看都会明白对入参、出参的保护check，但类似这样的case在我自己排查问题的经历了真的碰到了好多。 在中级这个阶段，我会推荐大家尽可能的多刻意的去培养下自己这两个方面的能力，成为一个能写出高质量代码、有效排查问题的优秀程序员。 \\3. 编程能力高级：懂高级API和原理 就我自己的经历而言，我是在写了多年的Java代码后，才开始真正更细致的学习和掌握Java的一些更高级的API，我相信多数Java程序员也是如此，我算是从2003年开始用Java写商业系统的代码，但直到在2007年加入淘宝后，才开始非常认真的学习Java的IO通信、并发这些部分的API，尽管以前也学过也写过一些这样的代码，但完全就是皮毛，当然，这些通常来说有很大部分的原因会是工作的相关性，多数的写业务系统的程序员可能基本就不需要用到这些，所以导致会很难懂这些相对高级一些的API，但这些API对真正的理解一门编程语言我觉得至关重要，在之前的程序员成长路线的文章里我也讲到了这个部分，在没有场景的情况下，只能靠自己去创造场景来学习好，我觉得只要有足够的兴趣，这个问题还是不大的，毕竟现在有各种开源，这些是可以非常好的帮助自己创造机会学习的，例如学Java NIO，可以自己基于NIO包一个框架，然后对比Netty，看看哪些写的是不如Netty的，这样会非常有助于真正的理解。 在学习高级API的过程中，以及排查问题的过程中，我自己越来越明白懂编程语言的运行原理是非常重要的，因此我到了后面的阶段开始学习Java的编译机制、内存管理、线程机制等，对于我这种非科班出身的而言，学这些会因为缺乏基础更难很多，但这些更原理性的东西学会了后，对自己的编程能力会有质的提升，包括以后学习其他编程语言的能力，学这些原理最好的方法我觉得是先看看一些讲相关知识的书，然后去翻看源码，这样才能真正的更好的掌握，最后是在以后写代码的过程中、查问题的过程中多结合掌握的原理，才能做到即使在N年后也不会忘。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"2021年终总结","slug":"2021年终总结","date":"2021-12-31T13:29:00.000Z","updated":"2022-04-23T12:06:13.070Z","comments":true,"path":"2021/12/31/2021年终总结/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/12/31/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","excerpt":"","text":"2021年终总结开篇 2021年接近尾声了，就这这几天，我竟然感冒了，我记得大学前两年每年都会有一次重感冒。唯一躲过去了上个冬天，今年考研也很注意保暖，但还是在这几天没盖好被子，感冒了，超级难受 。 当考完研，很想写写总结一些这一年来的事，但是每当想开始写的时候，却发现真的无从下手。每至年底，可能留下的最多的是遗憾。也打算今年就让他这么过去吧，不在写什么总结了。但是打开了上一次写的那个大学一部分的复盘，再一次看来，结合这一阵子的经历，又有了一些新的体验，如果说当时没静下心来复盘那些，估计现在记得的也只是零碎的，并不能体会当时的心境了。 这次打算没有粉饰的，也不打算刻意的让某人看到某些内容，不用维护自身的形象，不用光写对自己好的事。静下心来写下所有这一年来的所有事吧，写成一本书，一本只有作者会看到的书叭。 很难说用文字的形式表达出来自己某时某刻某种想法的特定感受， 客观的文字总会映射到读者已知的某些情景上的感受。 我们只是站到父母的肩上，看过他们从未看过的繁华 正文 也不知道到底该如何写，按时间，按发生事的重要程度，还是按…. 那就罗列一些事或者感受出来吧。 是啊，多少人爱着爱着，因为生活的烦恼，时下相处的琐事，触手可及的诱惑，就慢慢忘记了当初在一起的初心。 **独处的时候，孤独是人生的常态。 ** 经过了大二的懵懂，大二的渐渐放开，到大三的浮躁。最后大四考研，又在这浮躁喧嚣的生活里找到了一点点安宁。考研这件事可能和考上相提并论的意义是在于教会我们，要在人生某一个结点，背负着来自过去的遗憾、罪恶感、相互矛盾的经验，往前是看不到尽头的路、压力、没结果、好与坏都是未知。正是在这样的一个结点，越要静下心沉住气的干好当前的事，外面的人怎么看怎么说就由他们去吧，当然这件事自己干的合不合心意估计就是人活一世要让你知道的。 ​ 其实考研那会满孤独的，习惯了一个人吃饭，一个人学习，一个人干一些事。就是这样孤独的状态下，每次都能听到来自心底的呼唤，我来是干什么的，这个问题是我只要一陷入独处就要进行思考的问题，但始终得不到答案。考研这个时间段里，听到的一个关于这个问题的答案是：你来之前什么也没带，走的时候什么也别想带走。高考那只是脑子累一点，考研时脑子和心都累。 最后冲刺的阶段现在看来，真的其实有点难熬。每天做相同的事，一天学十几个小时，几分钟的时间都不想流失，生怕错过了什么重要的知识点，背了又忘的知识点，而且面对着考上和考不上，再一想复习了一整年，然后还有同学朋友父母的期望，有时候无缘无故的失眠，身体的不舒服，夹杂着未来的生活愿景，哈，牛掰。好在，我当时还是些许的平静，到最后上了考场，这感觉和高考有的一拼，考完一门，考完两门，考完三门，最后考完了。当时以为我会大声呼喊，会抱着我哥们大声哭，但是考完之后的我很平静，该玩的该想的其实早在每个失眠的夜里过了好多遍，也接受了考不上的现实是怎样的。 相信在最后冲刺的那种难熬的日子里，大家的感受心情都是一样的，我想我们把这一段宝贵的人生拼搏经历，要把它记在心中，他一定会让我们在未来遇到更多的人生历程的时候会有底气，会有信心的。风雨兼程，与你同行。 爱情是最让人捉摸不透的事，可能真的像那句话说的那样，爱情玩明白的人都是单身，搞不懂才是最好的，搞懂了的就恐怕是爱情里夹杂着太多的理智了。 囚徒困境：这可能正是我这么多年走过来，受过教育，见过了外面的世界，感觉又想回老家，这一种心情正是柏拉图理想国里囚徒困境所形容的。 只有狠才能在考研的路上胜出，这本身就是一个筛选的机制，仅有一小部分人才可以成功。面对这样的筛选，只有狠。当你看向窗外，每一户亮着的窗户的背后是一个家或者一个人，但是在这万家灯火之中，狠的人是少之又少的，所以狠的不要命的拼搏不是大多数人所具备的。而狠的背后是清醒的指导自己的路，是诚实面对自己的渴望，是执着不怕头破血流的走下去，可是清醒就要面对清醒带来的痛，诚实就要面对身边人的指指点点，执着就要为路上的血和泪买单。所以说，如果自己真的不行，但是你还信这份渺茫的希望，这样是危险的。倒不如选一个虽然危险但是适合你的路，热爱能抵岁月漫长。 学习和生活没有界限，应该和在一起。不应该将学习当做一个神圣的行为。其实一天根本学不了太多，所以要接受。 人生的多样性。 不得不承认，在超意兴吃饭的这么长的一段日子里，见到了好多校园里见不到的茶米油盐酱醋茶的生活。有玩手机被妈妈凶的小男孩，有可爱的小女孩每句话都喊着妈妈xxx（哪个小女孩小时候不是父母的小宝贝，以后也不能让遇到我的小女孩受委屈啊），有工地上的人来吃饭，有人穿的特别好看的来吃饭，有一家三口来吃饭，有自己一个人来吃饭，有一个老奶奶不舍得吃饭每顿只吃一碗米饭，有热心的打菜的阿姨和收银员姐姐，有见到一些小孩子的举止像极了当初我小时候的样子，为了博取被人的关注大喊大叫，喜欢装样子，皮的不行；有的人没有了父母。他们也差不多经过各自很长的时间，在所谓的社会上找到了自己的位置，过着各自的生活，或者幸福或者悲伤，但是都各不一样。 关于同理心，害，估计哪有人天生共情力就高，只是他经历过对方正在经历的事，也能明白对方现在所处境地下心情罢了。比如，考完研之后xx来问我，这个考研要怎么复习啊，其实当初并没有人和我说怎么复习，我也没好意思去问一些认识的高年级的学长学姐，然后就自己和另外两个小伙伴摸索着，这大半年来光复习资料啥的也算走了一些弯路，刚开始感觉复习谁的好，后来发现可能更不适合自己，然后就接着换，而且什么时候做什么事也都不太清楚，但也就那样，碰壁的走了过来。对那天xx来问我，要怎么复习，我能体会到现在他复习时迷茫的心情，我大体和他说了说怎么复习，用什么书。 有好多事其实就只能做一次。这一次做的好不好，就已经决定了结局。比如做真题，最后数学真题只做了那么四五套，而且还打算最后能再复习一下这几套，但是最后一点时间也没留出来看。 我可能会成功，也可能给会失败，但过程我一定要开心。 上天安排困难和磨难的出现，不是为了把你打败，是认为你有翻山跃岭的勇气和能力，这是帮你变强的手段而已，上天的用意，不是让你面对困难和磨难时妥协和屈服。如果用意反之的，可以直接神不知鬼不觉的把你否掉，你没有机会见到这些困难和挫折。 黎明之前就是黑暗，放弃就是大笨蛋。虽然我最后的时候有遇到同学说好像可能考不上，打算直接下年再来的，也有见到六级直接旷考的，也有直接就打算抱着不可能的态度去试试而没有拼尽全力的。虽然我可能觉着我可能还没有尽全力，但是当时的决定当时的努力都是你当时认为最好的。我可能大概知道了结局，但是我舍不得放弃。 一定要带着考研时的窘迫去读研究生啊。一定都要带着现在考研的窘迫和心酸去读研究生。 一定要争取所有机会，干完老师的活就学自己的，多发论文，多学习，见识世面，打好谱。 下面这段是我在2020年11月2号给自己的留言，因为当时我好像写错了个材料被收材料的批评了然后自己以为好像入党没希望了，我在写那个入党自传的时候，从中午13点开始，找了找文章，改了改，写了写，一直搞到晚上19点半，然后去交上，又改到9点才完事，后来等了会晚上11点了去二餐吃饭，本来还想着好像这入党也挺顺利的，今天突然好像就要不行了，害，突然感觉到有点不甘，参加了很多培训，很多讲座，我确实真的感受到了党，发现这个组织也挺不容易的，没有党，可能就没有现在的生活，确实很有道理，有着这样一群先进的人士，带领着全中国一起往前走，真的很棒，共产主义的产生就让我很纳闷，这种我可能这辈子都想不出来的理论，可以被一群人正在践行着。 入党这件事，从大一到大三一直在做，有时候真的感觉很难，培训呀，写报告，搞一系列的事，差点就没坚持下来，不过我真的挺想加入到这个组织里来干些什么事的，不过好像也是，不加入也可以为人民服务。加油啦，邹庆志！ ​ 就在今年11月初，我成为了一名共产党员，成为那4000万里的一员。回过头来看看，这一路上写过不知道多少字的报告，思想汇报，申请书，材料，开过好多次会议，上过很多次党课，考过好几次党课考试，最后通过选举，我也加入了党组织。从大一只知道党是政府，到后来的一系列的了解党，到加入党，我真的为我自己能加入到这个组织中，和千千万万的人民站在一起，为中华民族谋幸福，为中华民族谋复兴感到很自豪高兴。 ​ 对了，记得当时交材料，啥的，感觉好正式，感觉有一点点的差错好像就不行，但是走过来之后，其实也感觉到，好多规则是人定的，能变动的地方还是有好多的，规则也都是为了人而制定的，你搞错了某一项，改正过来就好了啊。相比，其实有很多事情就像这个入党的流程一样，比如考研，自己举行一些活动啊什么的，其实就只是一件事而已，不要因为未来没发生的事的结果感到恐惧和焦虑。 马克思主义，考研的时候发现这才是真的真理。我从这里学到了一些看待世界的方法，辩证统一，联系，矛盾，底线思维，历史唯物主义，实践与认识，政治经济学，以及思修里的一些价值观，以及了解到的中国革命史，这才是一个青年人应该掌握的看待世界，看待某些事，分析某些事真正应该掌握的方法。理论结合实际，实事求是，艰苦奋斗，独立自主。 要有点信仰，我找到了，那就是马克思主义。 莫愁千帆过，拂风便是晴。 还有几条看到b站上说的和自己总结的，送给2022年自己的建议吧 1、培养3到五个爱好，在十年之后选两三个来作为陪伴自己的，这可以在你孤独的时候走出阴霾，在你平淡的生活增添乐趣。 2、有积极向上的心态，人生没有弯路，所经历的一切都是值得的，趁年轻，时间和回头路才是你现在拥有的，想干什么就努力去干！要充满好奇心。经历，如乔布斯当时在大学里学艺术字的时候，他并不知道后来设计；苹果的时候能给她带来灵感。 3、经常自省，吾日三省吾身，每天反省是不是照着目标前进，有没有走偏。如遇到某个单词不认识，查一查。 4、学会珍惜对你好的人，很多事都不是理所应当的。 5、少玩游戏多看书 6、人心？如果说要揣测，估计是天下最难的了 7、活在当下 8、两个人在一起磨合可以，但是不要尝试的改变任何一个人！ 9、认识你自己，先认识自己，如何表达自己的需求，学会自己跟自己相处，自己跟自己对话，后认识别人；别把自己太当回。就比如说上台演讲，虽然出丑了，但是别人大多都是关注自己，很少会关注别人，所以说不用太在意别人的说法看法，不要怕出丑。 10、跟陌生人不要交浅言深，跟熟人不要毫无保留，保持好人与人之间的这种距离？。 11、保持自信，总有人要登顶，这人为什么不是你那。这世界有很多不公平，但黑暗里满目自信可能是唯一前进的动力。 自律和欲望值，当该目标的欲望值远大于当前一些诱惑的欲望值的时候，这时候并不会存在自律不自律的问题，比如一个主角为了报杀父之仇，苦练十年，但是他自己并不感觉这十年是在坚持自律。高级欲望战胜低级欲望，这才称为自律。你对目标的理解深度直接决定你在这件事上能走多远，因为遇到困难，这才是动力的根源，比如你要先认识到考研这件事，是为了什么；又比如去健身，是看着别人健身感觉很时髦，还是想获得好身材增加新引力，或者是降低肥胖相关疾病的发生概率，或者工作需要。 避免懒惰和改变远离垃圾人（如那种负面情绪倾覆给你，出了事在别人身上找原因，动不动就发火，跟你抬杠，打击你自信心，贬低你等） 全程自律伴随着间歇性不自律，自律确实反人性，如健身的人的欺骗餐，但是不要紧绷着，不要对做的事产生抵触情绪。这样的自律才不会是反弹的，会融入生活的。自律即自由，长期的自律才能换来选择的自由。 为什么感觉越长大时间过的越快 法国哲学家Paul Janet在1897年提出了人类对时间流逝的心理感受速度的理论。在他的理论中，1年的时间在人的记忆中所占的比重是不一样的。比如，当你1岁的时候，1年就是你生命的全部。当你50岁的时候，1年只是你生命的2%。这样，你的生命越长，1年时间所占的比重就越小。这意味着让一个5岁的小孩为圣诞节等待24天，相当于让一个54岁的的人等待1年。 那些喜欢独来独往的人，他们品行大都很好，他们不喜欢扎堆，不喜欢搬弄是非，也不喜欢追求所谓的社会归属和认同感，他们只喜欢一个人把自己该干的事干好，享受自己干干净净的世界和圈子，这样的人才适合深交。考研的时候经常自己一个人学习，一个人去食堂，一个人走路，这些才是平常的。像是大一大二的，都不是很想自己一个人去食堂，总想着拉着舍友一起或者，但是现在习惯了，蛮喜欢独来独往的，不用和谁商量吃什么，不用等谁去干什么，想去学习就去学习，想玩会就玩一会，想找朋友的时候就去找。 每个人选的道路都是不一样的，比如有些人就是对生活工作不上进，可能做事都不是很积极，但是看到这样的人不要怒其不争，该远离的远离，和合心意的一起，不要为了某些利益或者所谓的好关系，不要为了合群而合群。 人际关系真的是在社会上立足来讲的重要一些的东西。比如你跟女朋友去看风景，结果你对象生气了，但是就算是风景最好，你也不爽，你真的想去看风景嘛，其实你想和你爱的人一起看风景。 原来真的有认知壁垒这样的东西，就比如我大二的时候学java的时候，以为学了一些java基础，然后和springboot，mybatis这样的东西之后，我自以为其实没有更好的技术可以学，然后有些自满，这种自满就是活在了自己认知范围那一点点的东西里，其实到我大四现在做毕设，才发现原来还有springcloud和分布式，mybatisplus，缓存这样的东西。比如以后学一件事或者认知一样东西，可以先搜索这个圈子里的人都干些啥，然后将其分为三个阶段，入门，进阶和高级。然后就顺着把每个阶段列出来，当学到进阶的时候就不会认为自己很自满而没有动力了。 而且天天逛b站，他推荐你看到的东西就是你看到的那些，其实在这之外还有好多东西，那些真的只是冰山一角。 有些事 比如可以不出来租房子，似乎大部分人过得都不是很容易 读书一定要加上思考，而且很多事经过思考之后可能是另一个结果。比如处理好感情和工作，这两个地方都是需要情感的 对于可控的事情，保持谨慎。对于不可控的事，保持乐观。人只能做自己能力范围内的事情。 你的负担将变成礼物，你受的苦将照亮你前行的路，愿你们奔向远方，所有付出都得到应有汇报，愿你走出考场的那一瞬，有将士凯旋归来的飒爽。 增加女生的安全感，可以加强女生在双方关系中的参与度。而且遇到一件事，他们想要的其实不是问题的解决方式，而是分享感受。 oblivion 忘却 就下午的时候和我爸去给我爷爷上坟，那里是一个那种陵园的那种，站在那里，往上看，那么一排一排的，这里就待了附近几个村子的上四五代人吧，也是不能放鞭炮了，很荒凉。看着我爷爷的墓碑，看着烧着的那个纸币，再看着这飘起来的纸灰，想起上小学五年级那会我爷爷就躺在病床上起不来，每次叫我去他家，每次我走的时候都让我带上一包牛奶，再想起来我上两三年级的时候，还能蹦跶的和爷爷去菜园玩泥巴，很难想象也真的很难体会，这世界就是有生老病死，冷暖四季，悲欢离合，草木荣枯。再想起这大半年经历的事，心中更是五味杂陈，而且这一年一年的也差不多长大了，要走出象牙塔，该认真开始挣钱了，要想一想怎么去生活了，我的发小们现在好几个都已经成家有小孩了，剩下的也都在拼搏为家。今年，对我来说是一个突然成长，突然成熟一些，有些坎坷的一年，导致我现在认为只要普普通通，平平淡淡的就是最好的了。到现在，亲戚刚走，我回来一看手机，祝福的人也就只有我大嫂子和邻居家发小，慢慢喜欢这样的状态，不喜欢去问别人是否安好，也不希望别人来问候我，心里就装着父母和几个惦念的兄弟，还有你。新的一年里，不奢望能暴发，不奢望可以有好多好多好多的快乐，但希望 你可以 平平淡淡，普普通通，再撒一把幸运，顺顺利利的就好！我也是。 原来所谓的看开了、佛系。不是知道了世间的险恶而逃避，不是以为自己的能力不能做到某些事进而胆怯找理由；而是真正的了解自己之后的那种理解所见到的事，有着乐观向上发展的积极态度。 自信先从朋友见了面的打招呼开始。 总结：2021年糊里糊涂、可惜、曲折的一年 希望2022，平淡一些，健康一点，不那么曲折，尽力，有些能让人快乐的就更好了。 还有一些对自己想说的话 要有自己的生活状态啊，捡起来以前丢掉的东西，把生活打理得井井有条。虽然学习贯穿整个一生，但是他不是全部。而且还有比这更重要的事，怎么认识自己、过什么样有意义的生活（而不是想着很多人都去追的学历和金钱）。心里有梦想，有行动，多读书！ 生活的意义和好的生活状态，我找不到啊可是。 研究生的生活从来没体验过，也充满着期待和紧张，但很希望老师放养我鸭，本来就是打算搞完老师分配的任务就干自己喜欢的事，虽然也很喜欢计算机哈哈哈。 最近越来越认同的一个观点：有没有一种可能，我们都是造物主手下的一颗棋，所有的事情都是已经安排好的，你遇见什么样的人，谁会看到这篇文章，接下来会发生什么事。所以说，就再大胆一些吧，想要什么就努力去争取，想做什么就加油去干！ 今天突然看到的所长说的：在小数据时代，大道理可能毫无参考价值，比如早睡早起有益身体健康，多运动之类那些能够流传数百上千年的大道理大道理，其实都是经过无数次的抛硬币，最后沉淀下来的统计学经验， 随着年龄增加，阅历增加，接触的样本不断变多，会觉得他们越来越有道理。这也就是为什么我越来越觉着真诚是与人交往中重要的东西。 ​ 而人类很难抗拒，抛几次硬币就开始总结经验这种本能，比如你谈了两次恋爱，如果对象都不靠谱，或者你找的前两份工作老板都不怎么样，那么你很可能就已经对恋爱和求职这两件事产生了自己的经验。没错我就是这样，今天听到这突然顿悟了。应该保持耐心，保持身心健康，多去尝试总结经验这也是反思和复盘的重要性，从贝叶斯公式总结的话就是不断获取新的证据更新先验概率，在迭代过程中让结果更准确。 我们生活中很多的事情根本就没有所谓的大道理来指导，所有人不得不自己去摸索跟这个世界相处的原则。这个时候理解小数据统计的结果可能会大幅偏离大数据结论的道理就非常有必要了。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"idea破解","slug":"idea破解","date":"2021-12-31T13:29:00.000Z","updated":"2022-02-26T03:27:00.255Z","comments":true,"path":"2021/12/31/idea破解/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/12/31/idea%E7%A0%B4%E8%A7%A3/","excerpt":"","text":"https://segmentfault.com/a/1190000040872312?utm_source=sf-similar-article","categories":[{"name":"后端","slug":"后端","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"author":"aoyuehan"},{"title":"使用mybatisPlus时字符编码出现问题","slug":"使用mybatisPlus时字符编码","date":"2021-07-03T14:01:00.000Z","updated":"2022-02-26T03:27:00.503Z","comments":true,"path":"2021/07/03/使用mybatisPlus时字符编码/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/07/03/%E4%BD%BF%E7%94%A8mybatisPlus%E6%97%B6%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/","excerpt":"","text":"一、使用mybatisPlus时字符编码出现问题使用mybatisPlus时字符编码出现问题，导致数据查询不出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 @Test void contextLoads() &#123; QueryWrapper&lt;Course&gt; wrapper=new QueryWrapper&lt;&gt;(); //这里必须得用course_name，而不能用couresName wrapper.like(&quot;course_name&quot;,&quot;数学&quot;); //模糊查询 Page&lt;Course&gt; page = new Page&lt;&gt;(1, 4); System.out.println(courseMapper.selectPage(page,wrapper)); &#125;运行结果为： Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@33a55bd8]Thu Jul 08 20:15:20 CST 2021 WARN: Establishing SSL connection without server&#x27;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn&#x27;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to &#x27;false&#x27;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.com.baomidou.mybatisplus.extension.plugins.pagination.Page@2ed71727Creating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@5261ec9] was not registered for synchronization because synchronization is not activeJDBC Connection [HikariProxyConnection@1706779253 wrapping com.mysql.jdbc.JDBC4Connection@1cd43562] will not be managed by Spring==&gt; Preparing: SELECT id,course_name,course_teacher_name, course_room_num,course_cur_num FROM course WHERE (course_name LIKE &#x27;%数学%&#x27;)==&gt; Parameters: &lt;== Total: 0Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@5261ec9][] 一直显示不了查询结果。 排除了没有在springboot里添加分页查询的bean，导致不能分页的情况。 排除了数据库连接，返回值类型等问题，因为有一个分页查询能查询出来数据。 后来直接运行 SELECT &lt;include refid=&quot;Base_Column_List&quot;&gt;&lt;/include&gt; FROM course WHERE (course_name LIKE &#x27;%数学%&#x27;) 运行这个也不显示结果，但是按理来说应该会查询出来相关的数据的，但是结果不行，问题处在哪呐。 百思不得其解，因为感觉哪地方都对，所以！！！，挨个试哪些地方会出现问题， 比如select后面的东西，表名，条件是不是对。 最后试着运行下面这个 SELECT &lt;include refid=&quot;Base_Column_List&quot;&gt;&lt;/include&gt; FROM course WHERE (course_name LIKE &#x27;%&#x27;) 这个竟然显示结果，进一步猜想是中文有问题，导致从idea将中文传递到mysql数据库的时候，出现了问题，导致查询出来的数据的total都是0 最终猜想 ，是不是中文的问题，检查数据库的中文和连接数据库的url的中文 spring: datasource: url: jdbc:mysql://localhost:3306/shixi_xuanke_system?useUnicode=true&amp;characterEncoding=utf8 username: root password: 1229 driver-class-name: com.mysql.jdbc.Driver 最终，确定bug为没有加useUnicode=true&amp;characterEncoding=utf8 导致最后查询带中文的数据的时候total为0 MySQL 8.0+ 时区问题之前用IDEA进行数据库连接的时候报了一个错 报错[08001] Could not create connection to database server. Attempted reconnect 3 times. Giving up. 后来查到是时区的问题 系统默认的时区与IDEA连接数据库的时区不一致， MySQL默认时区为UTC，我们属于东八区时间，和UTC存在八个小时时差。 所以：降级，使用MySQL 5.7，时区问题是8.0以上版本才有的 方法一：修改java中的时区为东八区 123// serverTimezone可以设置为北京时间GMT%2B8、上海时间Asia/Shanghai或者香港时间Hongkongurl: jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true 方法二：修改MySQL数据库的时区为东八区 1234567// 方法一：使用命令（优点：不需要重启MySQL服务，缺点：一旦MySQL服务被重启，设置就会消失）mysql&gt; set time_zone = &#x27;+8:00&#x27;;mysql&gt; set global time_zone = &#x27;+8:00&#x27;;// 方法二：修改my.ini配置文件（优点：永久保存设置，缺点：需重启MySQL服务）[mysqld]// 设置默认时区default-time_zone=&#x27;+8:00&#x27;","categories":[{"name":"后端","slug":"后端","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"author":"aoyuehan"},{"title":"后端环境","slug":"后端环境搭建","date":"2021-07-03T14:01:00.000Z","updated":"2022-04-03T13:18:45.345Z","comments":true,"path":"2021/07/03/后端环境搭建/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/07/03/%E5%90%8E%E7%AB%AF%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"maven搭建1、下载之后解压缩 2、将maven的配置文件的bin文件夹目录放到环境变量中，然后cmd中输入mvn -v查看maven的版本 3、设置idea使用下载的maven 1234567先 配置settings.xml中的镜像(当然这个可以在某个项目里单独配置也是可以的）：&lt;mirror&gt; &lt;id&gt;aliyunmaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public &lt;/url&gt;&lt;/mirror&gt; 4、配置当前项目的maven设置 5、配置新建项目时候的那个maven设置 设置一下之后，新建新的项目的时候，就会使用自己设置的maven设置。","categories":[{"name":"后端","slug":"后端","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[],"author":"aoyuehan"},{"title":"Shiro权限管理系统项目","slug":"Shiro权限管理系统项目","date":"2021-06-29T14:01:00.000Z","updated":"2022-02-26T03:26:59.540Z","comments":true,"path":"2021/06/29/Shiro权限管理系统项目/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/06/29/Shiro%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"项目搭建","categories":[{"name":"大三实习","slug":"大三实习","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%A4%A7%E4%B8%89%E5%AE%9E%E4%B9%A0/"}],"tags":[],"author":"aoyuehan"},{"title":"vue学习","slug":"vue学习","date":"2021-06-29T14:01:00.000Z","updated":"2022-02-26T04:29:57.893Z","comments":true,"path":"2021/06/29/vue学习/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/06/29/vue%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"安装一、通过script标签引入vue.js 二、通过把脚手架安装到本地的方式 1、Node.js安装 https://nodejs.org/en/download/ 安装好noedeJS然后继续安装下一步 3、执行npm install –global vue-cli ，全局安装vue-cli—-因为默认是从国外服务器下，可以使用阿里巴巴在国内的镜像服务器。 产生通过config命令设置默认下载路径： npm config set registry https://registry.npm.taobao.org 然后再执行： npm install –global vue-cli 4、安装后，检查是否安装成功 vue -V (在此注意V为大写) 5、使用vue建一个项目名叫“my-project”（vue init webpack my-project），注意项目名不能有大写。—-注：vue-cli 的模板包括 webpack 和 webpack-simple,前者是比较复杂专业的项目，他的配置并不全放在根目录下的 webpack.config.js 中。—-webpack-simple 相对简单的，它根目录下才有个 webpack.config.js。 6、注意： 项目建立过程中，有如下选择，选择NO。（该选项为使用ESLint规范你的代码，一个空格错误都将报错，不开启，避免不必要的麻烦）。 后两项为单元测试，可以选择No. 7、安装项目所需依赖，进入项目中： npm install 完成后，会发现项目目录下多出一个node_modules文件夹，里面就是 vue-cli 创建的一个基于 webpack 的 vue.js 项目。 8、使用npm run dev，便可以打开本地服务器实时查看效果（http://localhost:8080） 如果浏览器打开之后，没有加载出页面，有可能是本地的 8080 端口被占用，需要修改一下配置文件 config&gt;index.js 建议将端口号改为不常用的端口。另外我还将 build 的路径前缀修改为 ‘ .&#x2F; ‘（原本为 ‘ &#x2F; ‘），是因为打包之后，外部引入 js 和 css 文件时，如果路径以 ‘ &#x2F; ‘ 开头，在本地是无法找到对应文件的（服务器上没问题）。所以如果需要在本地打开打包后的文件，就得修改文件路径。 9、退出监听，可以直接Ctrl+C，选择Y。 tips：我在安装的时候，运行命令时遇到： 1npm WARN saveError ENOENT: no such file or directory, open &#x27;C:\\Users\\...\\package.json&#x27;问题解决 根据错误提示，是系统没有‘package.json’这个文件导致。这个文件的作用就是管理你本地安装的npm包。 所以我们要生成一个package.json文件，执行命令： 1npm init","categories":[{"name":"前端","slug":"前端","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"aoyuehan"},{"title":"实习心得全程","slug":"实习心得全程","date":"2021-06-29T14:01:00.000Z","updated":"2022-02-26T04:29:58.510Z","comments":true,"path":"2021/06/29/实习心得全程/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/06/29/%E5%AE%9E%E4%B9%A0%E5%BF%83%E5%BE%97%E5%85%A8%E7%A8%8B/","excerpt":"","text":"实习周志1实习周志来到这里的第一个星期，有着很强的新鲜感，来到北科院，已经是下午5点了，吃完晚饭，就忍不住围着校园转了一整圈，得知不能随意出校门，心情当时失落了一半，好像冲出校门啊~。 第二天的时候去了这个学校的图书馆傍边学习，图书馆里虽然不大，但是真的挺好看鸭~，图书馆的管理者不让进，就随便在傍边小位子上学了一会，感觉着学校的学习氛围好像不是非常的强，像是高中的那种管理方式。 然后第三天就开始上课了。授课内容方面，教授的html是大二上学期的比较简单的知识，只是教授了一些简单的html语法、css样式，主要涉及就是html页面、弹性盒子，元素的定位，没有教关于js的内容，最后教授了echart这图表框架的使用，然后周六的时候分小组做了一个模仿爱奇艺h5的界面，没有涉及到数据绑定，只是一个静态的html页面。在做这个h5页面的时候，虽然遇到一些问题，也都解决了，比如说：设置的界面样式没有显示，元素位置不居中，以及将页面打包运行在手机上，照片的位置大小出现变化。最后进行答辩，我作为组长，组织了一下他们的任务，然后汇总起来，我们组的一个组员写的确实很不错，讲的非常细，给他一朵小红花鼓励一下吧。教授风格反面，可能是因为我的问题，比较喜欢自学，看过一些哔哩哔哩上尚硅谷公开的课，感觉还挺棒的，线下风格的话，如果自己跟着老师敲的话，可能会出现一些问题，然后但是老师要照顾到大多数学生的进度，就不会等某一个人，但是我更喜欢自己暂停视频，接着该处bug来，再继续学下去。 总结一下主要的知识点： 1、使用 flex 布局中的 justify-content 属性改变两个div在主轴上的对齐方式 space-between形式为：|a b c| space-around形式为：| a b c | center的形式为：| abc | 2、另外，要注意 在footer&gt;.wode&gt;img 在class为wode的div上加超链接的话，应该 记得在css样式这里写为 footer&gt;a&gt;.wode&gt;img ，这里声明的格式才能生效。 3、移动端多用弹性和来等比例缩放，电脑端多用浮动来调位置。 4、定位的方式（relative、absolu、static）： relative：相对于原来位置移动，元素设置此属性之后仍然处在文档流中， 不影响其他元素的布局 absolute：父相对，子绝对；父不相对的时候，子按浏览器左上角为准 实习周志2第三周开始啦，然后这周主要开始的就是java的教学，首先开始的就是从一个简单的dome开始的，教会怎么用springboot整合spring和Springmvc和mybatis。 服务器开发的工作主要就是写Java代码，研究怎么查询数据库，变成什么样的实体类，封装什么样的http接口，url是什么，请求方式是什么，入参出参分别是什么。 前端开发的主要工作就是写页面，页面的布局，配色，排列，跳转等，每个页面的数据，向服务器请求,请求到数据之后，装配到页面上。 这里的老师都挺厉害的，都是去过公司搞过开发的，然后35岁左右转行来编程培训机构当老师了，都是有很多社会和代码经验的老师，在聊天的时候，老师教导我们说：原话忘记了，大概是这个意思，大四了千万不要脱离社会竞争，不然到毕业，就真的落伍了。 第四周，在实训中，html老师和java老师不是同一个人，先教的html的相关基础知识，然后分组编写了一个类似爱奇艺的影视H5的界面，后来java老师用springBoot整合了spring、springmvc、mybitas，通过查询数据库的数据发送json数据给前端的html界面，前端的html界面将json中的数据显示到界面上。总结一下这整个流程，前后分离的编程方式为：后端查询数据库中的数据，通过json数据的格式传给前端界面，然后前端界面展示出来。前后端对接，需要约定好服务端和前端的接口，对于服务器的http的接口进行说明，不然，前端也不知道服务器的接口应该是什么url，传入什么参数,返回什么参数。 第五周，学的东西都基本上学的差不多了，课下，和老师聊天的时候，老师教导我们说：原话忘记了，大概是这个意思，大四了千万不要脱离社会竞争，不然到毕业，就真的落伍了。 老师在最后几天教导我们说，你们要在大四的时候就好好想一想自己要干什么，如果去就业的话，就认真的学一下专业基础知识，然后去多面试几家公司，和别的就业的人竞争一下，比一比，找一下自己的不足，然后再改进一下，争取在毕业的时候找到一份说的过去的工作；要是考研的话，更能感受到这竞争的激烈了，400万人到最后也就录取100万研究生，这1&#x2F;3的录取率，所有人都削尖了脑袋往里钻，要是不努力的话，就真的很难达到自己的预期，所以都要更加努力啊。 在北科的千峰教育实习的时候，确实涨了不少新的见识，新的事物，新的地方，新的知识还有新的见解。总的来说，这次实习是一次提高我的能力的一次很难得的机会，让我知道了自己以为的会和真正意义上的会之间的差距是真的挺大的。此后，要将理论联系实际，静下心来，有目标，然后付诸于行动。 体会 遇到要解决的事，先注重当前最直接的任务，聚焦当前，然后解决当前需要解决的问题之后，再去解决下一个。 有时候看了一会电脑会比较累，眼睛很累，这时候休息一会。 找项目的时候很难找到，怎么搜索起来最快 文件 一些比较杂的知识点192.168.和10.0.开头的IP、内网IP段、IP简介、分类——（IP观止）在这三类地址中，绝大多数的IP地址都是公有地址，需要向国际互联网信息中心申请注册。但是在IPv4地址协议中预留了3个IP地址段，作为私有地址，供组织机构内部使用。这三个地址段分别位于A、B、C三类地址内：A类地址：10.0.0.0–10.255.255.255B类地址：172.16.0.0–172.31.255.255C类地址：192.168.0.0–192.168.255.255IP地址范围：1.0.0.1——255.255.255.254 在公网（连Internet的）是看不到这些IP的，使用这些IP一定是你在公司或学校内网中，比如公司路由下。这些私有地址在公司（组织）内网中，可重复出现在不同公司组织内部。比如你在公司内部的使用分配到的内网ip192.168.1.12和另一家公司的朋友QQ聊天，碰巧他的内网ip也是192.168.1.12，但是你俩不会ip冲突，因为你们处于不同组织内部，也就是不同公网IP下的内网IP，是可以重复的。不同的是你们俩通过网关对应公网的IP，即不能重复。 NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。 NAT 之内的 PC 联机到 Internet 上面时，他所显示的 IP 是 NAT 主机的公共 IP，所以 Client 端的 PC 当然就具有一定程度的安全了，外界在进行 portscan（端口扫描） 的时候，就侦测不到源Client 端的 PC 。AT的主要作用，是解决IP地址数量紧缺。当大量的内部主机只能使用少量的合法的外部地址，就可以使用NAT把内部地址转化成外部地址。NAT还可以防止外部主机攻击内部主机（或服务器）。","categories":[{"name":"大三实习","slug":"大三实习","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%A4%A7%E4%B8%89%E5%AE%9E%E4%B9%A0/"}],"tags":[],"author":"aoyuehan"},{"title":"移动端H5开发笔记","slug":"移动端H5开发笔记","date":"2021-06-29T14:01:00.000Z","updated":"2022-04-03T13:18:43.043Z","comments":true,"path":"2021/06/29/移动端H5开发笔记/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/06/29/%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一个dome(可以通过这个来看一下最简单的html的编写方法，通过弹性盒子的编写方法)效果图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;font/iconfont.css&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; &lt;!-- &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/personCenter.css&quot; /&gt; --&gt; &lt;style&gt; /* 取消元素默认的pargin和padding的大小 */ * &#123; margin: 0; padding: 0 &#125; /* 取消列表的样式 */ ul&gt;li &#123; list-style: none; &#125; /* 窗口的自适应 */ /* 将页面设置为100%,在屏幕大小变化时,会充满屏幕 */ html, body &#123; width: 100%; height: 100%; &#125; /* 去掉a标签的下划线 */ a &#123; text-decoration: none &#125; a:hover &#123; text-decoration: none &#125; /* 父元素变成弹性盒子 */ body &#123; background-color: #F5F5F5; display: flex; /* flex之后,盒子里的排列方式默认为横向排列， 调整方向 ，让body里面的元素纵向排列*/ flex-direction: column; &#125; /* flex: 1; 确实实现了三个不同内容的 div 平分空间, 所以按我以前的想法来说: flex: 1; === flex: 1 1 auto; */ /* 第一个参数表示: flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大； 第二个参数表示: flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小； 第三个参数表示: flex-basis 给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大 */ /* 一、设置头部的样式 */ header &#123; height: 50px; background-color: #000000; /* 变成弹性盒子 */ display: flex; &#125; header&gt;.wode &#123; font-size: 25px; color: white; width: 80%; /* 文本在该容器内 左右居中,不针对块元素的排列 */ text-align: center; margin-top: 5px; &#125; header&gt;.xiaoxi &#123; margin-top: 3px; /* 这里的height为占比父容器的百分比 */ height: 80%; &#125; header&gt;.fabiao &#123; margin-top: 8px; height: 70%; &#125; /* 二、 搜索区域 */ nav &#123; height: 50px; /* 变成弹性盒子，使得input和img横向排列*/ display: flex; /* 使用 flex 布局中的 justify-content 属性改变两个div在主轴（横轴）上的对齐方式 space-between形式为：|a b c| space-around形式为：| a b c | center的形式为：| abc | */ justify-content: center; /*需要写在父容器中, 将弹性 &lt;div&gt; 元素的所有项目的居中对齐;项目位于容器的中央。 */ align-items: center; &#125; nav&gt;input &#123; text-align: center; /* 取消选中时候的外边线 */ outline: none; height: 30px; /* 不设置input的外边框 */ border: none; width: 80%; /* margin:auto使用的前提：父元素是弹性和，并且父元素里面只有一个子元素 */ /* margin:auto;auto可以占满可用空间或者为0px,可以让 盒子里的元素居中 */ /* 只设置左边的轮廓为圆角 */ border-bottom-left-radius: 15px; border-top-left-radius: 15px; /* inline-block为行内块元素。 block为此元素将显示为块级元素，此元素前后会带有换行符。 flex为弹性盒*/ /* display: inline-block; */ background-color: #E9E9E9; &#125; nav&gt;img &#123; height: 30px; width: 40px; /* display: inline-block; */ /* margin:auto; */ &#125; /* 三、设置主体 */ section &#123; /*除去上下的部分 其余部分撑满页面*/ flex: 1; /* 变成弹性盒子 */ display: flex; /* 在section中声明flex-direction的排列方式,section里面的div才会是纵向排列的 */ flex-direction: column; height: 250px; &#125; /* 3.1 个人中心头像这一小部分 */ .tx-content &#123; padding-top: 10px; display: flex; &#125; .circleImg &#123; border-radius: 30px; width: 60px; height: 60px; &#125; /* 3.1.1 个人中心头像这一部分的左边部分 */ .tx-content&gt;.txleft &#123; padding-left: 10%; display: flex; flex: 55%; &#125; .tx-content&gt;.txleft&gt;.nikname &#123; font-size: medium; font-weight: bold; &#125; .tx-content&gt;.txleft&gt;.txvip &#123; padding: 5px; &#125; /* 3.1.2个人中心头像右边这一部分 */ .tx-content&gt;.txright &#123; flex: 45%; /* padding-right: 10px; */ display: flex; /*在父容器中声明，弹性盒子元素在侧轴（纵轴）方向上的对齐方式*/ align-items: center; /*主轴上居中*/ justify-content: center; &#125; .tx-content&gt;.txright&gt;.zuorenwu &#123; /* border: &lt;border-width&gt; &lt;border-style&gt; &lt;border-color&gt; */ border: 2px solid #DF5000; border-radius: 15px; color: #DF5000; &#125; /* 四、我的VIP会员这一行 */ .vip-content &#123; /* width: 100%; */ /* background-color: antiquewhite; */ height: 15%; /* 在这里声明flex,会让这3小部分会员块 ,按行排列 */ display: flex; /* 这里声明溢出的话,当会员标签超出屏幕的话,就可以用来滑动了 */ overflow: auto; &#125; /* 隐藏滚动条 */ ::-webkit-scrollbar &#123; display: none; &#125; .vip &#123; display: flex; &#125; /* 4.1 第一个vip块 */ .vipone &#123; display: flex; border-radius: 20px; margin: 5px; background-color: rgb(255, 255, 255); width: 250px; align-items: center; /*在父容器中声明，弹性盒子元素在侧轴（纵轴）方向上的对齐方式*/ justify-content: center; /*主轴上居中*/ &#125; .wodevip &#123; padding-right: 20px; &#125; .vip-text &#123; font-size: large; font-weight: bold; color: rgb(226, 193, 142); &#125; .vip-detail &#123; align-items: center; text-align: center; width: 20%; height: 35%; border-radius: 20px; background-color: rgb(233, 233, 233); &#125; /* 4.2 第二个vip块 */ .viptwo &#123; display: flex; border-radius: 20px; margin: 5px; background-color: rgb(255, 255, 255); width: 100px; flex-direction: column; align-items: center; /*在父容器中声明，弹性盒子元素在侧轴（纵轴）方向上的对齐方式*/ justify-content: center; /*主轴上居中*/ &#125; /* 4.3 第三个vip块 */ .vipthree &#123; display: flex; border-radius: 20px; margin: 5px; background-color: rgb(255, 255, 255); width: 100px; flex-direction: column; align-items: center; /*在父容器中声明，弹性盒子元素在侧轴（纵轴）方向上的对齐方式*/ justify-content: center; /*主轴上居中*/ &#125; /* 五、泡泡圈这一部分 */ .paopaoquan &#123; height: 30%; display: flex; flex-direction: column; &#125; /* 5.1 泡泡圈着一小行的标题 */ .pao-title &#123; display: flex; /* background-color: #55A532; */ &#125; /* 5.1.1 泡泡圈的图标 */ .pao-left &#123; display: flex; flex-direction: row; /* background-color: #0086B3; */ flex: 40%; align-items: center; /*在父容器中声明，弹性盒子元素在侧轴（纵轴）方向上的对齐方式*/ /* font-weight: 600; */ &#125; /* 5.1.2 泡泡圈的新动态 */ .pao-right &#123; display: flex; flex-direction: row; align-items: center; /* background-color: #0086B3; */ flex: 60%; &#125; /* 5.2 泡泡圈展示的部分内容 */ .pao-content &#123; display: flex; &#125; /* 泡泡圈展示的这部分内容中的一个item */ .pao-content&gt;.pao-items &#123; display: flex; flex: 50%; align-items: center; /*在父容器中声明，弹性盒子元素在侧轴（纵轴）方向上的对齐方式*/ height: 115px; &#125; .pao-content&gt;.pao-items&gt;.item-img &#123; padding-left: 10%; padding-top: 3%; width: 90px; height: 90px; &#125; .pao-content&gt;.pao-items&gt;.item-text&gt;.item-text-title &#123; font-weight: 600; &#125; .pao-content&gt;.pao-items&gt;.item-text&gt;.item-text-content &#123; font-size: small; color: gray; &#125; /* 六、功能区 这一部分 */ .gongneng &#123; display: flex; /* 排列方式为以行的形式,排满了之后会换行 */ flex-flow: row wrap; &#125; .gongneng&gt;.gn-items &#123; display: flex; /* 每部分功能的块占25%,最后有8个,分为两行 */ flex: 25%; flex-direction: column; align-items: center; /*在父容器中声明，弹性盒子元素在侧轴（纵轴）方向上的对齐方式*/ justify-content: center; /*主轴上居中*/ padding-bottom: 1px; &#125; /* 七、设置尾部 */ footer &#123; height: 50px; /* 上边框 */ border-top: 1px solid lightgray; /* 变成弹性盒子 */ display: flex; /* 调整对其方式 */ justify-content: space-around; &#125; /* 设置尾部 */ footer &#123; bottom: 0px; height: 48px; /* background-color: greenyellow; */ /* 上边框 */ border-top: 1px solid lightgray; /* 变成弹性盒子 */ display: flex; /* 调整对其方式 均分*/ justify-content: space-around; &#125; footer&gt;a&gt;div &#123; font-size: 18px; text-align: center; padding-top: 5px; &#125; footer&gt;a&gt;div&gt;img &#123; width: 60%; height: 60%; &#125; footer&gt;a&gt;div&gt;p &#123; color: #999999; font-size: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 头部 --&gt; &lt;header&gt; &lt;p class=&quot;wode&quot;&gt; 我的 &lt;/p&gt; &lt;a href=&quot;message.html&quot;&gt; &lt;img class=&quot;xiaoxi&quot; src=&quot;img/wode_xiaoxitubiao_42_40.png&quot;&gt; &lt;/a&gt; &lt;img class=&quot;fabiao&quot; src=&quot;img/wode_fabiao_40_30.png&quot;&gt; &lt;/header&gt; &lt;!-- 搜索区域 --&gt; &lt;nav&gt; &lt;input type=&quot;text&quot; placeholder=&quot;于文文中国好声音&quot;&gt; &lt;img src=&quot;img/wode_sousuo_66_40.png&quot; /&gt; &lt;/nav&gt; &lt;section&gt; &lt;div class=&quot;tx-content&quot;&gt; &lt;div class=&quot;txleft&quot;&gt; &lt;img class=&quot;circleImg&quot; src=&quot;./img/wode_touxiang_300_300.png&quot; &gt; &lt;div&gt; &lt;div class=&quot;nikname&quot;&gt;@邹云开&lt;/div&gt; &lt;div class=&quot;txvip&quot;&gt; &lt;img src=&quot;./img/wode_vipfun.png&quot; &gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;txright&quot;&gt; &lt;div class=&quot;zuorenwu&quot;&gt; 做任务领积分 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;vip-content&quot;&gt; &lt;!-- 这里vip里面的div是什么作用 --&gt; &lt;div class=&quot;vip&quot;&gt; &lt;div class=&quot;vipone&quot;&gt; &lt;div class=&quot;vipicon&quot;&gt; &lt;img src=&quot;img/wode_vip_60_40.png&quot; &gt; &lt;/div&gt; &lt;div class=&quot;wodevip&quot;&gt; &lt;div class=&quot;vip-text&quot;&gt; 我的VIP会员 &lt;/div&gt; &lt;div class=&quot;vip-time&quot;&gt; 5天后到期 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;vip-detail&quot;&gt; &lt;p&gt;查看&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;viptwo&quot;&gt; &lt;div class=&quot;wangqiuvip&quot;&gt; &lt;img src=&quot;./img/wode_wangqiuvio_40_40.png&quot; &gt; &lt;/div&gt; &lt;div &gt; &lt;p&gt;网球会员&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;vipthree&quot;&gt; &lt;div class=&quot;wangqiuvip&quot;&gt; &lt;img src=&quot;./img/wode_vipfun.png&quot; &gt; &lt;/div&gt; &lt;div &gt; &lt;p&gt;FUN会员&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;paopaoquan&quot;&gt; &lt;div class=&quot;pao-title&quot;&gt; &lt;div class=&quot;pao-left&quot;&gt; &lt;img src=&quot;img/wode_pao_3232.png&quot; &gt; &lt;div &gt; &lt;span&gt;泡泡圈&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pao-right&quot;&gt; &lt;div&gt; &lt;span&gt;你加入的圈子有新动态了 &lt;/span&gt; &lt;/div&gt; &lt;img src=&quot;./img/wode_xiangyou.png&quot; &gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pao-content&quot;&gt; &lt;div class=&quot;pao-items&quot;&gt; &lt;div class=&quot;item-img&quot;&gt; &lt;img class=&quot;circleImg&quot; src=&quot;./img/wode_pao_oxiang_320_270.png&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;item-text&quot;&gt; &lt;div class=&quot;item-text-title&quot;&gt; 孙艺珍 &lt;/div&gt; &lt;div class=&quot;item-text-content&quot;&gt; 假如爱有天意，82年的金智英,爱的迫降 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;pao-items&quot;&gt; &lt;div class=&quot;item-img&quot;&gt; &lt;img class=&quot;circleImg&quot; src=&quot;./img/wode_pao_oxaing1_140_140.png&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;item-text&quot;&gt; &lt;div class=&quot;item-text-title&quot;&gt; 玄彬 &lt;/div&gt; &lt;div class=&quot;item-text-content&quot;&gt; 我叫金三顺，机智的医生生活，爱的迫降 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;gongneng&quot;&gt; &lt;div class=&quot;gn-items&quot;&gt; &lt;div class=&quot;item-img&quot;&gt; &lt;img src=&quot;./img/wode_lishi.png&quot; &gt; &lt;/div&gt; &lt;div class=&quot;item-subtext&quot;&gt; 观看历史 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;gn-items&quot;&gt; &lt;div class=&quot;item-img&quot;&gt; &lt;img src=&quot;./img/wode_shoucang.png&quot; &gt; &lt;/div&gt; &lt;div class=&quot;item-subtext&quot;&gt; 我的收藏 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;gn-items&quot;&gt; &lt;div class=&quot;item-img&quot;&gt; &lt;img src=&quot;./img/wode_lixiancenter.png&quot; &gt; &lt;/div&gt; &lt;div class=&quot;item-subtext&quot;&gt; 离线中心 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;gn-items&quot;&gt; &lt;div class=&quot;item-img&quot;&gt; &lt;img src=&quot;./img/wode_shangchuan.png&quot; &gt; &lt;/div&gt; &lt;div class=&quot;item-subtext&quot;&gt; 我的上传 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;gn-items&quot;&gt; &lt;div class=&quot;item-img&quot;&gt; &lt;img src=&quot;./img/wode_qianbao.png&quot; &gt; &lt;/div&gt; &lt;div class=&quot;item-subtext&quot;&gt; 我的钱包 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;gn-items&quot;&gt; &lt;div class=&quot;item-img&quot;&gt; &lt;img src=&quot;./img/wode_dingdan.png&quot; &gt; &lt;/div&gt; &lt;div class=&quot;item-subtext&quot;&gt; 我的订单 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;gn-items&quot;&gt; &lt;div class=&quot;item-img&quot;&gt; &lt;img src=&quot;./img/wode_jieqian.png&quot; &gt; &lt;/div&gt; &lt;div class=&quot;item-subtext&quot;&gt; 借钱 &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;gn-items&quot;&gt; &lt;div class=&quot;item-img&quot;&gt; &lt;img src=&quot;./img/wode_mianliuliang.png&quot; &gt; &lt;/div&gt; &lt;div class=&quot;item-subtext&quot;&gt; 免费看视频 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;footer&gt; &lt;a href=&quot;index.html&quot;&gt; &lt;div&gt; &lt;img src=&quot;./img/wode_tuijian40_40.png&quot;&gt; &lt;p&gt;推荐&lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;a href=&quot;Hotpoint.html&quot;&gt; &lt;div&gt; &lt;img src=&quot;./img/wode_redian_40_40.png&quot;&gt; &lt;p&gt;热点&lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;a href=&quot;viphuiyuan.html&quot;&gt; &lt;div&gt; &lt;img src=&quot;./img/wode_wushuang_100_42.png&quot;&gt; &lt;p&gt;VIP会员&lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;a href=&quot;PersonCenter.html&quot;&gt; &lt;div&gt; &lt;img src=&quot;./img/wode_wode_40_40.png&quot;&gt; &lt;p&gt;我的&lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;a href=&quot;message.html&quot;&gt; &lt;div&gt; &lt;img src=&quot;./img/wode_paopao_50_66.png&quot;&gt; &lt;p&gt;泡泡&lt;/p&gt; &lt;/div&gt; &lt;/a&gt; &lt;/footer&gt; &lt;!-- 确定iphone567====dor=2 dpr=物理像素/CSS像素 CSS像素=物理像素/dpr --&gt; &lt;/body&gt;&lt;/html&gt; day03-视图 什么是像素： 像素，又称画素，是图像显示的基本单位，译自英文“pixel”，pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel，故“像素”表示“图像元素”之意，有时亦被称为pel(picture element) 像素是网页布局的基础。一个像素就是计算机能够显示一种特定颜色的最小区域。当设备尺寸相同但像素变得更密集时，屏幕能显示的画面的过渡更细致，网站看起来更明快。 ppi是指屏幕上每英寸可以显示的像素点的数量，即屏幕像素密度 分类： 实际上像素分为两种：设备像素和CSS像素 1、设备像素(device independent pixels): 设备屏幕的物理像素，任何设备的物理像素的数量都是固定的 2、CSS像素(CSS pixels): 又称为逻辑像素，是为web开发者创造的，在CSS和javascript中使用的一个抽象的层 每一个CSS声明和几乎所有的javascript属性都使用CSS像素，因此实际上从来用不上设备像素 ，唯一的例外是screen.width&#x2F;height 在桌面端，css的1个像素往往都是对应着电脑屏幕的1个物理像素。 而在手机端，由于屏幕尺寸的限制，缩放是经常性的操作。 有时候，当用户进行缩小操作时，一个设备像素覆盖了多个CSS像素 ；当用户进行放大操作时，一个CSS像素覆盖了多个设备像素 。不论我们进行缩小或放大操作，元素设置的CSS像素(如width:300px)是始终不变的，而一个CSS像素对应多少个设备像素是根据当前的缩放比例来决定的 ppk把移动设备上的viewport分为layout viewport 、 visual viewport 和 ideal viewport 三类，其中的 ideal viewport 是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。 移动设备默认的viewport是layout viewport，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。 我们在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我们的head标签中： 该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让viewport的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。 弹性盒子1、Flex布局是什么？ Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局。 Webkit内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari，其实只需要下一行就好了，有这样一行是为了适配Webkit的浏览器 */ display: flex;&#125; 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 2、基本概念 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。 flex-direction属性 flex-direction属性决定主轴的方向（即项目的排列方向）。 1234567.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。 123456.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125;（1）nowrap（默认）：不换行。（2）wrap：换行，第一行在上方。（3）wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 12345678910.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端靠两边，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 https://www.runoob.com/w3cnote/flex-grammar.html","categories":[{"name":"前端","slug":"前端","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"aoyuehan"},{"title":"2021蓝桥杯备战","slug":"2021蓝桥杯备战","date":"2021-04-11T14:01:00.000Z","updated":"2022-04-03T13:18:46.613Z","comments":true,"path":"2021/04/11/2021蓝桥杯备战/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/04/11/2021%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%A4%87%E6%88%98/","excerpt":"","text":"贪心方面遇到最小，最什么的，最优解的想到贪心 首先说要大胆猜想，然后写写出来公式,把几个变量写出来，然后进行推导出大小关系，进行简单的推导，画图等方式来找到解题的思路。利用一些性质来进行解题：排序，中位数最优，性价比高的，大胆猜想。局部最优&#x3D;&#x3D;&#x3D;》全局最优。 区间贪心： 1、区间不相交问题:排序之后，从后往前 遍历左端点 2、区间选点问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354422 校门外的树 算法2(区间合并) O(MlogM)先求出所有移动树木的操作的区间的并集，那么马路上剩余部分即为最终剩下树木的部分。求所有区间的并集可以使用区间合并算法，可以参考 [AcWing 803](https://www.acwing.com/solution/content/2615/). 区间合并。时间复杂度分析区间合并算法的时间复杂度是 O(MlogM)，其中 M 是区间数量。 #include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 110;int n, m;PII seg[N];int main()&#123; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; seg[i].first &gt;&gt; seg[i].second; sort(seg, seg + n); int res = m + 1; int st = seg[0].first, ed = seg[0].second; for (int i = 1; i &lt; n; i ++ ) //遍历从1到n-1，n拿出来进行特判 //从1枚举到n，一共枚举了n-1次，一共n个结果 if (seg[i].first &lt;= ed) ed = max(seg[i].second, ed); else &#123; res -= ed - st + 1; //累加结果 st = seg[i].first, ed = seg[i].second; &#125; res -= ed - st + 1; //单独计算最后一段 cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; poj3617 字典序最小问题的贪心题意：输入一个整数n，后面跟着n行大写字母，现要求对这些字母进行排序，要求字典序最小，每80个字母一行且字母只能从两端任取一个。根据上面的信息我们不难想到若使字典序最小则只需从两端选取最小的字母即可。不过聪明的读者也一定注意到了，如果两个字母大小一样怎么办？没关系，我们继续往里找就可以了。如果左边的字母最先出现小的则选左边的，反之亦然。当所有字母一样大小也即对称时任选一个即可。 模拟方面 分情况讨论问题！！！ 从前往后找答案，从后往前推答案。 比如区间合并中，[1,4] 和[2,3 与 [1,4],[2,5]是两种不同的情况 模拟科学计数法 注意什么时候while，for里面需要特判然后break的情况，什么时候不需要特判 某个if判断中应该做什么操作，别忘了，如双指针中，后一个指针++了之后，需不需要再累加新的变量等。 小的注意点 输入输出的yes和YES的区别，复制题目中给的 做完一题一定要验证答案，验证两遍，通过不同的做法来验证答案的正确性，别光想着一遍就是对的，可能有一些点你自己没有注意到。 如果越做越感到很麻烦，不要继续做，停下来想一想是不是有什么等价的，巧妙的做法。 打表 debug！！！！多组样例来测试！！！ cc150解题金字塔1、举例法：具体例子，到一般规则 2、模式匹配法：相似问题，到现有问题 3、简化推广法：从简化版，到复杂版 4、简单构造法：从n&#x3D;1开始（递推或递归） 5、数据结构头脑风暴法：链表？数组？堆？栈？队列？二叉树？set 技巧性 如蛇形矩阵中可以通过方向向量来遍历打印的序列 二分答案区间 。浮点数二分的时候double mid &#x3D; (l + r)&#x2F;2; 这里不能用移位运算来计算除2的结果 set&#x2F;map 来 映射 该值是否出现过，结果为几 sort排序 双指针扫描某个区间，可以同时往前走，也可以一个走一个等，或者同时向内走 multiset 找到出现k次的数 如果要找到数在总的枚举个数中占少数，而且枚举每种可能需要很大的复杂度，符合要求的解可以构造出来，那么就直接先构造出来在某个区间的所有的解，然后再判断这些构造出来的解是否符合答案的要求 如回文日期 由于只有八位数，而且回文串左右对称，因此可以只枚举左半边，这样只需枚举 0∼9999 先懂了样例，然后枚举暴力求解，然后再想怎么优化 如果需要枚举三个变量a，b，c。可以先枚举b，然后在枚举符合要求的a和c的个数。枚举的时候一定别忘记去重（可以放入set中去重。因为多种情况下可能会重复，但是答案输出的时候认为是同一个ans），注意边界条件，注意各种枚举的情况，注意枚举变量之间的相互制约关系等等 注意枚举的条件和枚举知否会重复，枚举的顺序，如 1234for(int i=1;i&lt;2019;i++)&#123; for(int j=i+1;j&lt;2019;j++)&#123; //这里j直接从i的下一位开始枚举就行，因为这里要求的是三个不相同的数 for(int k=j+1;k&lt;2019;k++)&#123; if((i+j+k)==2019&amp;&amp;check(i,j,k))&#123; 统计某个区间中值的总和，出现次数总和，一个技巧就是cnt[a[i]]++ STL注意点 void nth_element() a[9]&#x3D;{4,7,6,9,1,8,2,3,5}; nth_element(a,a+2,a+9)，没有返回值，意思：将下标为2，也就是第3个数放在正确的位置，求的是第3小的数a[2]。（下标从零开始） algorithm下的有用的函数 max，min abs（int x）。要用浮点数的绝对值的时候，用cmath下的fabs（double x） swap（x，y）交换x和y的值 reverse（a，a+4）将a【0】到a【3】数组进行反转 do{ }next_permutation(a,a+3)； 全排列 fill（a，a+3，4) 用4进行填充数组，二维数组时为：fill（a[0]，a[0]+N*N，4) sort算子： lowebound： cmath下的函数 fabs（double x） floor（double x） 向下取整，ceil（double x） 向上取整；数轴上来说向上就是向两边 pow（double r，double p） r^p sqrt（double x），log（double x）以自然对数为底 round（double x）返回double类型四舍五入之后的整数值。scanf的%.1f 为四舍六入五成双 递归1234567891011121314151617181920/*找重复： 1，找到一种划分方法（划分子问题） 2，找到递推公式或者等价代换找变化的量： 变化的量通常作为参数（如果递归起来比较费劲，或者难想，那么有可能是该参数找的不对）找出口： 依照边界，找到问题的出口*//*f1(n):求n的阶乘*找重复：n*(n-1)的阶乘，求n-1的阶乘是原问题的重复(规模更小)，即子问题*找变化：变化的量应该作为参数*找边界：根据参数的变化趋势，对边界进行控制，适时终止递归 */int f1(int n)&#123; if(n==1)return 1; return n*f1(n-1);&#125; 递归实现指数型枚举（枚举每个数的状态） 递归搜索树，选和不选 需要考虑两个问题：（1)当前考虑的是第几个数u，（2)前面的数有没有选，即怎么存下前面已经选了的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748枚举选和不选两种方式： 方法一：//#include&lt;iostream&gt;//using namespace std;//const int maxx=17;//bool a[maxx];//int n;//void dfs(int u)&#123;// if(u&gt;n)&#123;// for(int i=1;i&lt;=n;i++)&#123;// if(a[i]==true)cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;// &#125;// cout&lt;&lt;endl;// return ;// &#125;// a[u]=true; //当前节点选还是不选 // dfs(u+1); // 进行下一个节点的选择 // a[u]=false; // 当前节点选完之后，该标志位清零，然后走该节点的另一个分支 // dfs(u+1);//&#125; ////int main()&#123;// // cin&gt;&gt;n;// dfs(1);//从1开始，往下走二叉遍历树 ；这里从1开始，dfs中就要if(u&gt;n),而不是u==n来判断是否到达叶子结点//&#125; 方法2：#include&lt;iostream&gt;using namespace std;int n;void dfs(int u,int state)&#123; if(u==n)&#123; for(int i=0;i&lt;n;i++)&#123; //判断最低位，倒数第一位，倒数第二位... if(state&gt;&gt;i&amp;1)cout&lt;&lt;i+1&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl; return ; &#125; dfs(u+1,state); //不选这一位，因为标志位被当做形参传入方法中，所以不用将标志位清0 dfs(u+1,state|1&lt;&lt;u); // 选这一位 ,将该位的二进制表示变为1 &#125; int main()&#123; cin&gt;&gt;n; //n的下标从1开始 dfs(0,0); //u从0变为1进行了一次选和不选，从1变为2进行了一次选和不选&#125; 递归实现排列型枚举（这里是枚举每个坑的状态，这和选它和不选它有点区别的） 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int n;vector&lt;int&gt;path; //这里的path就是用来存放每个坑的信息void dfs(int u,int state)&#123; if(u==n)&#123;// for(vector&lt;int&gt;::const_iterator iter = path.begin(); iter != path.end(); iter++) for(auto x:path)cout&lt;&lt;x&lt;&lt;&#x27; &#x27;; //将记录的排列输出出来 cout&lt;&lt;endl; return ; 按理来说这里应该写return，让他不在继续执行下面的for循环了 &#125; for(int i=0;i&lt;n;i++)&#123; //针对n个坑来遍历每一个参与排列的数 if(!(state&gt;&gt;i&amp;1))&#123; //state用来存放n个数是否被选中了 path.push_back(i+1); dfs(u+1,state|1&lt;&lt;i); path.pop_back(); //这里需要在path中弹出这个数，这里是用state来存放数有没有被选的信息，但是也用了path来存选了的结点的信息，即每个坑的信息 &#125; &#125; &#125;int main()&#123; cin&gt;&gt;n; dfs(0,0); return 0;&#125; 递归实现组合型枚举 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int n,m;void dfs(int u,int sum,int state)&#123; //u表示第几层，sum表示当前选了第几个数，state表示n个数选的状态 //这里增加一个sum的形参，就可以来选择sum个，而不用非得选择n个节点了 if(sum+n-u&lt;m)return ; //剪枝 if(sum==m)&#123; //选中m个数进行组合排列了 for(int i=0;i&lt;n;i++)&#123; if(state&gt;&gt;i&amp;1)&#123; cout&lt;&lt;i+1&lt;&lt;&#x27; &#x27;; &#125; &#125; cout&lt;&lt;endl; return ; &#125; dfs(u+1,sum+1,state|1&lt;&lt;u); //选的放在不选的上面，然后能按字典序输出 dfs(u+1,sum,state); &#125; int main()&#123; cin&gt;&gt;n&gt;&gt;m; dfs(0,0,0); return 0;&#125; 如数字三角形从最后叶子节点，累加答案到根节点的记忆化搜索： 1234567891011121314151617using namespace std; int main() &#123; int n; cin&gt;&gt;n; int a[n+1][n+1]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) cin&gt;&gt;a[i][j]; for(int i=n-1;i&gt;0;i--) for(int j=1;j&lt;=i;j++) if(a[i+1][j]&gt;a[i+1][j+1])a[i][j]+=a[i+1][j]; else a[i][j]+=a[i+1][j+1]; cout&lt;&lt;a[1][1]; return 0;&#125;另外：f[i][j]=max(f[i+1][j],f[i+1][j+1])+f[i][j]; //状态转移方程 但是 双指针12345678910111213141516171819202122232425262728293031321532. 找硬币 算法2 双指针 O(nlogn) 双指针向内走的类型#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int w[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]); sort(w, w + n); for (int i = 0, j = n - 1; i &lt; j; i ++ ) //两指针相撞的时候为结束状态 &#123; while (i &lt; j &amp;&amp; w[i] + w[j] &gt; m) j -- ; if (i &lt; j &amp;&amp; w[i] + w[j] == m) &#123; printf(&quot;%d %d\\n&quot;, w[i], w[j]); return 0; &#125; &#125; puts(&quot;No Solution&quot;); return 0;&#125; 单调队列、单调栈树状数组二分 整数二分 二分要求 区间有二段性（二段性就是大于等于某个数有什么性质，小于某个数有什么性质）（有的也具有单调性也可以解题 整数二分的步骤 1.找一个区间[L,R] ，使得答案一定在该区间中。2.找一个判断条件，使得该判断条件具有二段性，并且该答案一定是二段性的分界点。3.分析中点M在该判断条件下是否成立，如果成立，考虑答案是在哪个区间；如果不成立，考虑答案在哪个区间。4.如果更新方式是R&#x3D;MID，则不用做任何处理；如果更新方式是L&#x3D;MID，则需要在计算MId的时候加上1，（l&#x3D;mid时加1的原因在于： int mid &#x3D; l + r &gt;&gt; 1;是向下取整的，加上1的原因是为了让r取mid-1之后也能让l继续逼近上线r，不至于出现死循环的现象）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;int&gt;v;int n,q,k,temp;int main()&#123; cin&gt;&gt;n&gt;&gt;q; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;temp; v.push_back(temp); &#125; while(q--)&#123; cin&gt;&gt;k; int l=0,r=v.size()-1; // 1、确定区间范围 **闭区间** //二分找结果区间的左端点，找第一个大于等于k的位置 while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(v[mid]&gt;=k)r=mid;//2、找到分段点 else l=mid+1; &#125; if(v[l]==k)&#123;//找到第一个值等于k的位置，这里也可以传入[0,n],然后判断while之后，l的结果是不是等于n来判断，找到的第一个大于等于k的位置在什么地方 cout&lt;&lt;l&lt;&lt;&#x27; &#x27;; r=v.size()-1; //二分找结果区间的右端点，找最后一个小于等于k的位置 while(l&lt;r)&#123; int mid=l+r+1&gt;&gt;1;//找右端点的时候才需要向上取整 ,如l=1，r=1，然后就会出现死循环 //// 因为写的是l = mid，所以需要补上1 if(v[mid]&lt;=k)l=mid; //找小于等于k的点，所以这里为小于等于 else r=mid-1; &#125; if(v[l]==k)&#123; cout&lt;&lt;l&lt;&lt;endl; &#125; &#125;else&#123; //当二分左区间跳出while时，l一定等于r cout&lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl; &#125; &#125; return 0;&#125; tips：//二分找结果区间的左端点，找第一个大于k的位置 while(l&lt;r)&#123; int mid=l+r&gt;&gt;1;//这里不需要+1，不需要向上取整 if(v[mid]&gt;k)r=mid; //找大于k的点，当v[mid]大于k的时候，r=mid else l=mid+1; &#125; tips:lower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找的。#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+10;const int INF=2*int(1e9)+10;#define LL long longint cmd(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int num[6]=&#123;1,2,4,7,15,34&#125;; sort(num,num+6); //按从小到大排序 int pos1=lower_bound(num,num+6,7)-num; //返回数组中第一个大于或等于被查数的下标 int pos2=upper_bound(num,num+6,7)-num; //返回数组中第一个大于被查数的下标 cout&lt;&lt;pos1&lt;&lt;&quot; &quot;&lt;&lt;num[pos1]&lt;&lt;endl; cout&lt;&lt;pos2&lt;&lt;&quot; &quot;&lt;&lt;num[pos2]&lt;&lt;endl; sort(num,num+6,cmd); //按从大到小排序 int pos3=lower_bound(num,num+6,7,greater&lt;int&gt;())-num; //返回数组中第一个小于或等于被查数的值 int pos4=upper_bound(num,num+6,7,greater&lt;int&gt;())-num; //返回数组中第一个小于被查数的值 cout&lt;&lt;pos3&lt;&lt;&quot; &quot;&lt;&lt;num[pos3]&lt;&lt;endl; cout&lt;&lt;pos4&lt;&lt;&quot; &quot;&lt;&lt;num[pos4]&lt;&lt;endl; return 0; &#125; AcWing 790. 数的三次方根（浮点数二分） 12345678910111213141516171819202122#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; double x; cin &gt;&gt; x; double l = -10000, r = 10000; while (r - l &gt; 1e-8) //这里缩小了两个数量级 &#123; double mid = (l + r) / 2; if (mid * mid * mid &gt;= x) r = mid; //判断mid和所要求的x之间的关系，这里没有整数二分中的+1还是-1的问题 else l = mid; &#125; printf(&quot;%lf\\n&quot;, l); return 0;&#125; AcWing 730. 机器人跳跃问题(二分答案) 出现最大值最小值的问题中，一般枚举答案，先二分，dfs，dp，贪心 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n;int h[N];bool check(int e)&#123; for (int i = 1; i &lt;= n; i ++ ) &#123; e = e * 2 - h[i]; if (e &gt;= 1e5) return true; if (e &lt; 0) return false; &#125; return true;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]); int l = 0, r = 1e5; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; printf(&quot;%d\\n&quot;, r); return 0;&#125; 二分 变题 1234567891011121314151617181920212223242526272829303132333435363738391227. 分巧克力 (二分的变题) 这个和二分找数组区间内 ，第一个大于x的位置，第一个大于等于x的元素的位置有点区别，因为这里大于等于x，之后改变的l和r的值不同，因为这里的区间单调性不同。#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 100010;int n, m;int h[N], w[N];bool check(int mid)&#123; LL res = 0; for (int i = 0; i &lt; n; i ++ ) &#123; res += (LL)h[i] / mid * (w[i] / mid); if (res &gt;= m) return true; &#125; return false;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d%d&quot;, &amp;h[i], &amp;w[i]); int l = 1, r = 1e5; while (l &lt; r) &#123; int mid = l + r +1 &gt;&gt; 1; //此时满足条件之后需要改变l=mid,所以此时计算mid的时候要加上1 if (check(mid)) l = mid; else r = mid - 1; &#125; printf(&quot;%d\\n&quot;, r); return 0;&#125; 素数最大公约数排列C快速幂KMPflod最短路 哈夫曼树排序 AcWing 788.逆序对的数量（归并排序） 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;typedef long long ll;const int N=1e6+10;int tem[N],q[N];ll res=0; //res为全局变量，这样子只能计算一次 //因为总的逆序对的数量是n-1,n-2,..1的总和（即序列逆序）；//即(n-1)*(n-2)/2，n=1e6的时候res会爆int ;//2^32-1=4 294 967 296（42亿）=4e9,但是分为正负的话，int的范围就是-2e9~2e9void merge(int l,int mid,int r)&#123; //闭区间[l,r] for(int i=l;i&lt;=r;i++)tem[i]=q[i]; //将数组a（即要排序的那个数组）中的数放入临时数组b中 int k=l,i=l,j=mid+1; while(i&lt;=mid&amp;&amp;j&lt;=r) &#123; //i 和j两个指针分别遍历临时b数组 if(tem[i]&lt;=tem[j])q[k++]=tem[i++];//比较临时b数组的左右两段中的元素，将较小值重新放回数组q else &#123; res+=mid-i+1; //统计逆序对的数量 q[k++]=tem[j++]; //这里别忘了j++ &#125; &#125; while(i&lt;=mid)q[k++]=tem[i++]; //当数组b中左右两段中有一段的下标超出其对应的表长的时候，将另一段的剩余部分直接复制到a数组中 while(j&lt;=r)q[k++]=tem[j++];//扫尾 &#125;void merge_sort(int l,int r)&#123;//返回的就是这段区间中的 if(l&gt;=r)return ;//或者if(l==r)return 0; int mid=l+r&gt;&gt;1; merge_sort(l,mid); //分治的思想，左边排完序，右边排序，然后用merge合并起来 merge_sort(mid+1,r); merge(l,mid,r); &#125; int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)cin&gt;&gt;q[i]; merge_sort(0,n-1);//这里传入的是区间[0,n-1] 都是闭区间，相比数组q[0..n]来说的 cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; map 、hash映射思想123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081422 校门外的树算法1 (模拟,数组遍历) O(ML)定义一个长度为 L+1的布尔数组，表示每棵树的状态。true 表示已经被移走；false 表示未被移走；#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int n, m;bool st[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;m, &amp;n); while (n -- ) &#123; int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); for (int i = l; i &lt;= r; i ++ ) st[i] = true; &#125; int res = 0; for (int i = 0; i &lt;= m; i ++ ) if (!st[i]) res ++ ; printf(&quot;%d\\n&quot;, res); return 0;&#125; 1532 找硬币算法1 哈希表 O(n) 巧妙思想#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;unordered_set&gt;using namespace std;const int INF = 10000;int main()&#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); unordered_set&lt;int&gt; hash; int v1 = INF, v2; for (int i = 0; i &lt; n; i ++ ) &#123; int a, b; scanf(&quot;%d&quot;, &amp;a); b = m - a; if (hash.count(b)!=0) //等价if (hash.find(key) != hash.end()) &#123; hash.insert(a); if (a &gt; b) swap(a, b); if (a &lt; v1) v1 = a, v2 = b; &#125; else hash.insert(a); &#125; if (v1 == INF) puts(&quot;No Solution&quot;); else printf(&quot;%d %d\\n&quot;, v1, v2); return 0;&#125;tips:if (hash.count(key)) 是判断hash表中是否存在关键字key；if (hash[key]) 是判断key对应的value值是否是真，如果key在hash表中不存在，则会先为其创建默认值，比如int的默认值是0，vector&lt;int&gt;的默认值是vector&lt;int&gt;()； 差分思想12345678910111213141516171819202122232425int a[7];a[0]=1;a[1]=2;a[2]=4;a[3]=5;a[4]=12a[5]=34;a[6]=123;a[7]=3;int d[7]; //差分数组d[0]=a[0]; //规定for(int i=1;i&lt;=7;i++)&#123; d[i]=a[i]-a[i-1];&#125;则有： a[0]=d[0]; a[1]=d[1]+d[0]; a[2]=d[2]+d[1]+d[0];区间修改 如果现在要让区间a[0]-a[4] 都加上1，只需要把d[0]+1（所有的a都有d[0]的元素)，然后把d[5]-1(a[5]及以后的数字都有d[5]的元素）a[0]=d[0]a[1]=d[1]+d[0]+1a[2]=d[2]+d[1]+d[0]+1a[3]=d[3]+…+d[0]+1a[4]=d[4]+…+d[0]+1a[5]=d[5]-1+…+d[0]+1a[6]=d[6]+d[5]-1+…+d[0]+1a[5]=d[7]+d[6]+d[5]-1+…+d[0]+1————————————————版权声明：本文为CSDN博主「johnwayne0317」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/johnwayne0317/article/details/84928568 前缀和 求某段区间的和123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;const int N = 100010;int a[N], s[N];int main() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); //scanf的时候别忘记了&amp; s[i] = s[i-1] + a[i]; //特殊规定：s[0]=0 &#125; while (m--) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; printf(&quot;%d\\n&quot;, s[r] - s[l - 1]); //当l=r=1的时候，s[l-1]=s[0]，边界也是可以的 &#125; return 0;&#125; 数学知识 1&lt;&lt;n&#x3D;2^n ； n&lt;&lt;1&#x3D;2*n ；左移一位就相当于乘2； 典型例题 bfs+方向向量 &#x3D;&#x3D;&#x3D;&gt;最短距离 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859AcWing 1102. 移动骑士#include&lt;iostream&gt;#include&lt;algorithm&gt; //fill 在这里，尽量不要用memset#include&lt;queue&gt;#include&lt;map&gt; //pair在这里面#include&lt;cstring&gt; //memset在这个头文件中using namespace std;const int N=310;int d[N][N];const int dx[8]=&#123;2,1,-1,-2,-2,-1, 1, 2&#125;; //八个方向const int dy[8]=&#123;1,2,2 ,1, -1,-2,-2,-1&#125;;int sizee,x1,x2,y1,y2;int bfs( )&#123; //memset(d,-1,sizeof(d)); // d[N] 一维数组的赋值方式：fill(d,d+N,-1); // 将a[0]到a[N-1]均赋值 -1 fill(d[0],d[0]+N*N,-1); //这样才能给二维数组赋值，d[0]才是二维数组的首地址 queue&lt;pair&lt;int,int&gt;&gt;q; q.push( &#123;x1,y1&#125; ); // 把（x1,y1）这个点放到队列中 d[x1][y1]=0; // d数组不仅存放，有没有 **入过队列**，也存放走到这地方需要的最小步数 pair&lt;int,int&gt;temp; while(!q.empty())&#123; temp=q.front(); //队列不为空，从队头取一个元素出来 q.pop(); // if( temp.first==x2&amp;&amp;temp.second==y2)&#123; //当队首就是这个点的时候，退出；这样写是可以的；；这一句也没用，因为判断过d[x][y]==-1了// return d[x2][y2];// &#125; for(int i=0;i&lt;8;i++)&#123; int x=temp.first+dx[i]; //取出来的该坐标，加上方向向量之后，判断该位置是否有效 int y=temp.second+dy[i]; if(x&gt;=0&amp;&amp;x&lt;sizee&amp;&amp;y&gt;=0&amp;&amp;y&lt;sizee&amp;&amp;d[x][y]==-1)&#123; //没有越界 可以走 没有走过 d[x][y]=d[temp.first][temp.second]+1; //修改d数组中的步数 q.push(&#123;x,y&#125;); //一个位置只入队一次 &#125; &#125; &#125; return d[x2][y2]; &#125;int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;sizee; cin&gt;&gt;x1&gt;&gt;y1; cin&gt;&gt;x2&gt;&gt;y2; cout&lt;&lt;bfs( )&lt;&lt;endl;//for(int i=0;i&lt;sizee;i++)&#123; //出错的时候打表发现错误 // for(int j=0;j&lt;sizee;j++)&#123;// cout&lt;&lt;d[i][j]&lt;&lt;&quot; &quot;;// &#125;// cout&lt;&lt;endl;// &#125; &#125; return 0;&#125; dfs 搜索（洪水灌溉，求某一个连通块中的个数） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;const int N = 25;int n, m;char g[N][N];int dx[] = &#123;-1, 0, 1, 0&#125;, dy[] = &#123;0, 1, 0, -1&#125;;int dfs(int x, int y)&#123; int res = 1; g[x][y] = &#x27;#&#x27;; //刚进来的时候这地方就要标记一下 ，将.变为#，就代表这地方走过去了，下一次不能走这地方了 for (int i = 0; i &lt; 4; i ++ ) &#123; int a = x + dx[i], b = y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m &amp;&amp; g[a][b] == &#x27;.&#x27;) res += dfs(a, b); //搜索(a,b)这地方的格子 ；这地方一定要+= //这里回溯的时候不需要复原现场 &#125; return res;&#125;int main()&#123; while (cin &gt;&gt; m &gt;&gt; n, n || m) &#123; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; g[i]; int x, y; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) if (g[i][j] == &#x27;@&#x27;) &#123; x = i; y = j; &#125; cout &lt;&lt; dfs(x, y) &lt;&lt; endl; &#125; return 0;&#125;/*知道要到达的层数的dfs模板 int check(参数)&#123; if(满足条件) return 1; return 0;&#125;void dfs(int step)&#123; 判断step数值的大小，判断边界 &#123; 相应操作 &#125; 尝试每一种可能 &#123; 满足check条件， **剪枝操作** 标记！！！！！ 继续下一步dfs(step+1) 恢复初始状态（用来回溯）//有些时候如state，或者状态存在形参中的时候就可以不用回溯 &#125;&#125;*/ 进制转换 12345678910111213141516171819202122232425262728293031323334353637383940414243444546十进制转化成其他进制：短除法其他进制转化成十进制：秦九韶算法其他进制转化成其他进制(1) 用十进制过渡(2) 短除法 （见下图）(3) 扩展题：AcWing 124. 数的进制转换#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;char get(int x) //获取该位数的表示&#123; if (x &lt;= 9) return x + &#x27;0&#x27;; return x - 10 + &#x27;A&#x27;;&#125;string base(int n, int b) //将十进制数n变为b进制数，返回该数的b进制表示&#123; string num; while (n) num += get(n % b), n /= b; reverse(num.begin(), num.end()); //如十进制转换为2进制：除2取余，倒着写 return num;&#125;bool check(string num) //判断回文&#123; for (int i = 0, j = num.size() - 1; i &lt; j; i ++, j -- ) if (num[i] != num[j]) return false; return true;&#125;int main()&#123; int b; cin &gt;&gt; b; for (int i = 1; i &lt;= 300; i ++ ) &#123; auto num = base(i * i, b); if (check(num)) cout &lt;&lt; base(i, b) &lt;&lt; &#x27; &#x27; &lt;&lt; num &lt;&lt; endl; &#125; return 0;&#125; 多关键字排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152531、重载小于号写法struct Person&#123; int chinese, math, english; int total; int id; bool operator&lt; (const Person&amp; W)const //这种写法固定 &#123; if (total != W.total) return total &gt; W.total; if (chinese != W.chinese) return chinese &gt; W.chinese; return id &lt; W.id; &#125;&#125;person[N];2、定义函数的方式来实现比较#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 310;struct Person&#123; int chinese, math, english; int total; int id; &#125;person[N];int cmp(Person &amp;p1,Person &amp;p2)&#123; //需要加引用，这样会更快，返回值int和bool都可以 if(p1.total!=p2.total)return p1.total&gt;p2.total; //从大到小排 if(p1.chinese!=p2.chinese)return p1.chinese&gt;p2.chinese; return p1.id&lt;p2.id;//从小到大排&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) &#123; int chinese, math, english; scanf(&quot;%d%d%d&quot;, &amp;chinese, &amp;math, &amp;english); int total = chinese + math + english; person[i] = &#123;chinese, math, english, total, i&#125;; &#125; sort(person + 1, person + 1 + n,cmp); //注意sort里面数组下标 for (int i = 1; i &lt;= 5; i ++ ) printf(&quot;%d %d\\n&quot;, person[i].id, person[i].total); return 0;&#125; ​ - 蓝桥杯中和计算机相关的知识 补码：正数的补码和原码相同；负数的补码为符号位不变，剩余位取反再加1. 我们都知道取反操作是将二进制0和1互换，但是计算时容易出错，这是由于计算机中数值是以二进制补码形式存储的。补码：正数的补码和原码相同；负数的补码为符号位不变，剩余位取反再加1.一定要时刻记住补码的表现形式。eg1：int a &#x3D; 77;cout&lt;&lt;a&lt;&lt;endl;答：77的原码为01001101，在计算机中存储形式（补码）为01001101，77运行以后得到二进制10110010，这是补码存储形式，其原码为1101110，所以输出为-78eg2：int a &#x3D; -2;cout&lt;&lt;a&lt;&lt;endl;答：**-2的原码为10000010，在计算机中存储形式为11111110，取反以后得到00000001，这是正数的补码，其原码为其本身，所以输出为1.（通过原码的补码得到取反后的补码，然后通过补码得到原码，这就是结果）**其他二进制逻辑操作（&amp;，|，^等）原理相同。 构成三角形的条件：一个三角形内三条边任意两条的和都大于另外一条的长度,任意两条边长度的差小于另一条边. 代码板子 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt; #include&lt;string&gt;#include&lt;cstdio&gt; //sscanf在此#include&lt;algorithm&gt;#include&lt;map&gt; //pair在此using namespace std; int main() &#123; //获取一行的输入 int n,m; cin&gt;&gt;n&gt;&gt;m; getchar(); string ss; getline(cin,ss); cout&lt;&lt;ss&lt;&lt;endl; sscanf(ss.c_str(),&quot;%d:%d&quot;,&amp;n,&amp;m); //输入输出流重定向到文件中 freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout); int a,b; for(int i=0;i&lt;3;i++)&#123; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;a+b&lt;&lt;endl; &#125; return 0; &#125; 字符串和数字的互换方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;using namespace std;const int MaxN = 10000;int line;int data[MaxN];void s2i(string &amp;str, int &amp;num) &#123;//s2i是str to int的意思 stringstream ss; //stringstream可以从string对象中读入和输出 ss &lt;&lt; str; ss &gt;&gt; num; //这样可以实现string转为int类型&#125;int main(int argc, const char *argv[]) &#123; scanf(&quot;%d&quot;, &amp;line); getchar(); //c语言中的输入函数不会吸收回车，当遇到getline的时候，需要手动吸收一下回车，不然就会被getline获取到 int index = 0; for (int i = 0; i &lt; line; ++i) &#123; string s; getline(cin, s); istringstream iss(s); //从string对象中读取到iss中 string tmp; while (getline(iss, tmp, &#x27; &#x27;)) &#123; s2i(tmp, data[index++]); &#125; /* 其中while循环也可以这么写 while(iss&gt;&gt;tmp)&#123; s2i(tmp, data[index++]); &#125; */ &#125;// 最终index就是数据的个数// cout &lt;&lt; index &lt;&lt; endl;//排序 sort(data, data + index); int a, b; for (int i = 1; i &lt; index; ++i) &#123; if (data[i] == data[i - 1] + 2)a = data[i] - 1;//printf(&quot;%d &quot;, data[i] - 1); if (data[i] == data[i - 1]) b = data[i];//printf(&quot;%d&quot;, data[i]); &#125; printf(&quot;%d %d&quot;, a, b); return 0;&#125; 树状数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647树状数组的写法#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int a[N], tr[N]; int lowbit(int x) //lowbit(x)是取出x的最低位1&#123; return x &amp; -x;&#125;void add(int x, int v)&#123; for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += v;&#125;int query(int x)&#123; int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);//必须从下标1开始存放 for (int i = 1; i &lt;= n; i ++ ) add(i, a[i]); while (m -- ) &#123; int k, x, y; scanf(&quot;%d%d%d&quot;, &amp;k, &amp;x, &amp;y); if (k == 0) printf(&quot;%d\\n&quot;, query(y) - query(x - 1)); //这里求区间[a,b]，得用query(b)-query(a-1)，这样求出来的才是区间[a,b]之间值的总和大小 else add(x, y); &#125; return 0;&#125; 并查集 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#define MAXN 5005int fa[MAXN], rank[MAXN];inline void init(int n)&#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; //初始化 让每个节点都指向自己 rank[i] = 1; &#125;&#125;int find(int x)&#123; return x == fa[x] ? x : (fa[x] = find(fa[x])); //这里用的路径压缩，让所有节点都直接指向根节点&#125;inline void merge(int i, int j)&#123; int x = find(i), y = find(j); if (rank[x] &lt;= rank[y]) //按秩的大小 来合并，rank数组就是存放 秩的大小 fa[x] = y; else fa[y] = x; if (rank[x] == rank[y] &amp;&amp; x != y) rank[y]++;&#125;int main()&#123; int n, m, p, x, y; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p); init(n); for (int i = 0; i &lt; m; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); merge(x, y); &#125; for (int i = 0; i &lt; p; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); printf(&quot;%s\\n&quot;, find(x) == find(y) ? &quot;Yes&quot; : &quot;No&quot;); &#125; return 0;&#125; 算法很美云课上的一个讲解题 人物相关性分析 求同时出现alice和bob出现的位置 我们可以想到用双层for循环，分别枚举alice和bob的位置。会超时 优化思想：我们可以只枚举一个变量，然后另一个量可以不通过枚举而是通过某种方式来得到，或者减少要枚举的范围，比如用二分查找出来或者用map、hash表直接找到 所以本题可以用双指针来优化窗口移动 子串分值 https://www.acwing.com/solution/content/41386/ 子串分值和 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;set&gt;#define IOS ios::sync_with_stdio(false), cin.tie(0)using namespace std;typedef long long ll;ll pre[30];string s; int main()&#123; IOS; cin&gt;&gt;s; ll len=s.length(); s=&quot;0&quot;+s;//下标从1开始 ll ans=0; for(ll i=1;i&lt;=len;i++)&#123; ans+=(i-pre[s[i]-&#x27;a&#x27;])*(len-i+1); pre[s[i]-&#x27;a&#x27;]=i; &#125; cout&lt;&lt;ans&lt;&lt;endl; getchar(); getchar(); return 0;&#125;————————————————版权声明：本文为CSDN博主「搬砖的小孩有肉吃」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_43746332/article/details/109385747 修改数组 或者用并查集来做？？？？？","categories":[{"name":"acwing","slug":"acwing","permalink":"https://zouyunkai.github.io/myblog/categories/acwing/"}],"tags":[],"author":"aoyuehan"},{"title":"2021 蓝桥杯最后几天刷题","slug":"2021蓝桥杯最后几天刷题","date":"2021-04-11T14:01:00.000Z","updated":"2022-02-26T03:27:00.469Z","comments":true,"path":"2021/04/11/2021蓝桥杯最后几天刷题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/04/11/2021%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%9C%80%E5%90%8E%E5%87%A0%E5%A4%A9%E5%88%B7%E9%A2%98/","excerpt":"","text":"acwing 2067走方格注意矩阵输入的时候为第一行 ，第二行…第n行输入的，所以对应着n行m列的二维矩阵，就是从上往下输入，左上角为坐标原点，所以遍历的时候注意下面的坐标比上面的坐标值大，这一题中坐标（x，y）到右下角的时候应该等于（m，n），即x到达了第m列，y到达了第n行。注意：矩阵的xy坐标表示（x，y）和矩阵的n行m列的[n，m]表示不同,移动的时候多用前者，访问的时候多用后者。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748超时的写法：#include&lt;iostream&gt;using namespace std;int dx[2]=&#123;1,0&#125;,dy[2]=&#123;0,1&#125;;//这里左上方为零点int ans=0;int n,m;void dfs(int x,int y)&#123; //cout&lt;&lt;&quot;current dfs:&quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;endl; if(x==m&amp;&amp;y==n)&#123; //这里误写为x==n&amp;&amp;y==m了！！！ ans++; return; &#125; for(int i=0;i&lt;2;i++)&#123; int newx=x+dx[i],newy=y+dy[i]; if((newx%2==0)&amp;&amp;(newy%2==0))continue; if(newx&lt;=m&amp;&amp;newy&lt;=n)&#123; dfs(newx,newy); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; dfs(1,1); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 记忆化递归：#include&lt;iostream&gt;using namespace std;int f[40][40];int n,m;int main()&#123; cin&gt;&gt;n&gt;&gt;m; f[1][1]=1; for(int i=1;i&lt;=n;i++)&#123; //表示矩阵的第i行，第m列 【i，j】 for(int j=1;j&lt;=m;j++)&#123; //这里的for不能从2开始，不然的话会遗漏(1,2)和(2,1)两个格子 if(i&amp;1||j&amp;1)f[i][j]=f[i][j]+f[i-1][j]+f[i][j-1]; //f[i-1][j]在xy坐标中表示y-1，即本格上方的那个格子 else f[i][j]=0; &#125; &#125; cout&lt;&lt;f[n][m]&lt;&lt;endl; return 0;&#125; 蛇形序列（十一届真题）1234567891011121314#include&lt;iostream&gt;using namespace std;int main()&#123; int step=4; int ans=1; for(int i=0;i&lt;19;i++)&#123; ans+=step; //模拟数列求和，这里累加每一步之间的长度的时候，ans+=要在step上面 step+=4;//因为第一次进入for循环没有改变step的时候ans就要先加上一次step &#125; cout&lt;&lt;ans&lt;&lt;endl; //或者直接通过等差数列求和 来算答案 return 0;&#125; 跑步训练1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;int ryue[13]=&#123;0,31,29,31,30,31,30,31,31,30,31,30,31&#125;;int byue[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int get(int a)&#123; if(a%4==0&amp;&amp;a%100!=0||a%400==0)return 1; else return 0;&#125;int ans=0;int main()&#123; int year=2000,m=1,d=1,dd=6; while(true)&#123; if(year==2020&amp;&amp;m==10&amp;&amp;d==2)break; if(d==1||dd==1)ans+=2; else ans+=1; dd+=1; dd%=7; if(get(year))&#123; //是闰年 if(ryue[m]==d)&#123; d=1; m++; &#125;else&#123; d++; &#125; if(m==13)&#123; year++; m=1; &#125; &#125;else&#123; if(byue[m]==d)&#123; d=1; m++; &#125;else&#123; d++; &#125; if(m==13)&#123; year++; m=1; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; ans=8879 原码, 反码, 补码的基础概念和计算方法.1、源码 原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制: [+1]原 &#x3D; 0000 0001 [-1]原 &#x3D; 1000 0001 2、反码的表示方法是: 正数的反码是其本身 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反. [+1] &#x3D; [00000001]原 &#x3D; [00000001]反 [-1] &#x3D; [10000001]原 &#x3D; [11111110]反 3、补码的表示方法是: 正数的补码就是其本身 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) [+1] &#x3D; [00000001]原 &#x3D; [00000001]反 &#x3D; [00000001]补 [-1] &#x3D; [10000001]原 &#x3D; [11111110]反 &#x3D; [11111111]补 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 &#x3D; 1 + (-1) &#x3D; 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了. 例：[x]原&#x3D;+1101,[y]原&#x3D;-1010, [x]原+[y]原&#x3D; 数值位做减法运算，[y]数值位求补，得0110,与1101做加法。 0110+1101&#x3D;1,0011，最高数值位产生了进位，因此结果正确，符号位取[x]原的符号，得+0011。 当发现自己的做法肯定是对的，但是和题目的结果不同的时候，想是不是自己忽略了啥问题如：数值序列这题 123456789101112131415#include&lt;iostream&gt;using namespace std;int main()&#123; long long a=1,b=1,c=1,d=0; for(long long i=4;i&lt;=20190324;i++)&#123; d=a+b+c; a=b;a%=10000; b=c;b%=10000; c=d;c%=10000; d%=10000; //我忽略了数值会爆long long，溢出这一点，所以要每次加之前都取模一下 &#125; cout&lt;&lt;d&lt;&lt;&quot; &quot;&lt;&lt;endl; return 0;&#125; 数的分解这里我忘记了 i，j，k不能算2,4这几种情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;set&lt;vector&lt;int&gt; &gt;st;bool check(int x, int y, int z) &#123; //判断三个正整数中是否含2或4 int res = 0; while (x) &#123; res = x % 10; if (res == 2 || res == 4) return false; x /= 10; &#125; while (y) &#123; res = y % 10; if (res == 2 || res == 4) return false; y /= 10; &#125; while (z) &#123; res = z % 10; if (res == 2 || res == 4) return false; z /= 10; &#125; return true;&#125;int main()&#123;// struct node node1,node2; for(int i=1;i&lt;2019;i++)&#123; for(int j=i+1;j&lt;2019;j++)&#123; //这里j直接从i的下一位开始枚举就行，因为这里要求的是三个不相同的数 for(int k=j+1;k&lt;2019;k++)&#123; if((i+j+k)==2019&amp;&amp;check(i,j,k))&#123; //注意枚举的条件 vector&lt;int&gt;vt1; vt1.push_back(i); vt1.push_back(j); vt1.push_back(k); st.insert(vt1); &#125; &#125; &#125; &#125; cout&lt;&lt;st.size(); return 0;&#125;","categories":[{"name":"acwing","slug":"acwing","permalink":"https://zouyunkai.github.io/myblog/categories/acwing/"}],"tags":[],"author":"aoyuehan"},{"title":"travel in shanghai","slug":"上海之旅","date":"2021-03-27T14:01:00.000Z","updated":"2022-04-03T13:18:46.514Z","comments":true,"path":"2021/03/27/上海之旅/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/03/27/%E4%B8%8A%E6%B5%B7%E4%B9%8B%E6%97%85/","excerpt":"","text":"关于交通 去的时候做了400一趟的高铁，哇 是真的快 也很舒服，从北京开去上海的复兴号，三个小时就到了，而且周围的人都好有气质的，好像处处都是成功人士，xx总，xx经理，哈哈哈。回去的时候座了一次硬卧，十几五个小时 ，在最上铺 还有点吓人嘞 晃来晃去。 整个卧铺车厢就我一个二十岁的小伙子，别的都是大叔大婶，座48个小时才到哈尔滨。原来这是真的，以前记得听我妈说我发小的妈妈去内蒙，然后座了好几天才到。 座了这个卧铺，大一大二的时候，还会去做学生票27.5的火车 五个小时才到，走的时候我妈有时候会让我带这带那，但是我都闲沉，不带。刚一上车的时候这里的大叔阿姨都开始吃东西，我这次本来想着到上海南站附近买点东西带着的，但是一下了地铁就进了上海南，没来的急买东西，但是也突然好想吃鸭 哈哈哈。 但是真的突然想找到一个那样的姑娘，知道最后没有很多资金了，但是会受苦一点，会陪着我座这样超级慢超级慢的绿皮火车，不会很做作，估计很难找到吧 另外一个关于上海的地铁，是真的牛，多少条线我没数，但是去哪都能坐地铁，去了这几天一次公交也没做过，听说是全世界运行总里程最长的地铁线嘞 关于旅行 本来资金不是很充裕，然后打算去的，但是领走的那早上突然决定，还是去吧，最近不管是啥，都没有好运气，一系列的事的打击，但回来之后发现好像 有些事也都开始慢慢变好了，可能也是心态或者想法变好了吧。 去的时候没有做任何计划，心情也不是非常好，来到随便住了个地方，然后第一天好累鸭，睡了一中午，然后下午去吃了个小笼包，哇 这灌汤包绝了，一尝 满满的肉。第二天去了豫园，外滩，南京路步行街，吃了面，炸猪排。第三天早起来吃了上海早餐四大金刚，咸豆浆我是没喝管，可能我比较喜欢甜的吧，粢饭糕和粢饭团真的是一般般，就是炸米饭。不过如此，就是咱家里的炸黏米一样的，葱油饼也是，和家里的没啥区别，然后去了豫园，武康路，田子坊，可能是因为外地的原因，感觉到挺新鲜，挺热闹的。 其实有些时候说旅行之前一定要做好攻略啥的，但是好像不用刻意的去做啥计划，想起来去哪，搜一下地图，随心去就好了。 在田子坊遇到一对年近花甲的爷爷奶奶，是真的好好好好好羡慕，人家腿脚还算利索，但是头发全都白了，爷爷搀扶着奶奶到处逛，好羡慕啊。 此处省略一张图片（由于看到他们，我呆住了，忘记了拍照） 好像来上海逛的都是些比较中年的人，没有很多的小情侣 小青年的。 关于人生 原来 最无解的是人一个人想些什么 ，真正的想法是啥，这真的真的好难搞懂！！！ 在卧铺的时候发现，好像人生可能就是这样，这就算是人生百态吧 而且还有好多 座硬座的，熬通宵座一晚上 我表姐这个选择 好困难，但是到底是上科大联培还是二战，贪心选择。还是考的分数再多一点，就不会像现在一样。对了选择真的好像是比努力重要那么一丢丢。 情感 别人怎么对你，你就怎么对别人。不管是对男生也好，对女生也罢，以前一个跟着一个舍友去相亲的时候，对方问我的舍友这个人是一个什么样的人，我当时记得他跟我说过他的为人处世，就是别人对我好，我就会还他好几分，比人对我不好，我也不会给他好脸色看。当时我没回答出来，但是后来舍友又一次告诉了我，我但是是真的还没理解过来，现在，一年半之后，我也领悟到了。 对，就应该这样。别人不理我，别人不主动找我，我也不会主动找别人，害。 看开一些事，好像发现其实好多事看开了，心里会好受很多，但是好像一直在了解着周围的人、周围的事，但是不管怎么了解，好像还是看不透人生看不透周围的人或事，真的是太难了。 有些事，在大一的时候是一个想法，可是现在大三了，因为见过一些事，那时的想法变了，是真的变了，但是我当初认为那些都是不会变的事，哎。终于懂了一点点。 旅行中一直在思考的一个问题：你想成为什么样的人 优秀的人 某一方面能力特别强 读书，培养一份才艺坚持好几年的那种","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"大数据Hadoop的介绍","slug":"大数据Hadoop的介绍","date":"2021-03-21T14:01:00.000Z","updated":"2022-02-26T03:26:59.606Z","comments":true,"path":"2021/03/21/大数据Hadoop的介绍/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/03/21/%E5%A4%A7%E6%95%B0%E6%8D%AEHadoop%E7%9A%84%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"1. 叙述hadoop1.x、hadoop2.x、hadoop3.x的区别。1、hadoop1.x主要有MapReduce（计算+资源调度）、HDFS(数据存储）主要模块，后来因为hdfs中namenode存在单点故障，压力过大；mapReduce访问压力大（同时处理计算和资源调度）等问题，研发了一套全新架构的hadoop2.x。 2、hadoop2.x由HDFS、MapReduce和YARN（资源调度）三个分支构成。其中HDFS由NN Federation（联邦）、HA（只支持两个节点，3.0实现一主多从）；MapReduce运行在YARN上的MR，离线计算，基于I&#x2F;O计算；YARN资源管理系统。hadoop各个版本的介绍 Hadoop1.x是一个namenode一个scondarynamenode,到了hadoop2.x版本取消了scondarynamenode,但是增加了一个namenode,有两个namenode一主一备由于部署了两个NameNode，并且仅仅允许一台（ActiveNode）对外提供服务，另一台（StandByNode）在NameNode不可用的时候切换过去，这样就要保证StandBy数据是最新的。 3、hadoop3.x相对于2.x来说，支持多余2个以上的NameNodes。引入了一些重要的功能和优化，包括HDFS 可擦除编码、多Namenode支持、MR Native Task优化、YARN基于cgroup的内存和磁盘IO隔离、YARN container resizing等 2. 请详细说明hadoop的特性。 Hadoop是一个能对大量数据进行分布式处理的软件框架，并且是以一种可靠、高效、可伸缩的方式进行处理的，它具有以下几个方面的特性。 ·高可靠性 采用冗余数据存储方式，即使一个副本发生故障，其他副本也可以保证正常对外提供服务。 ·高效性 作为并行分布式计算平台，Hadoop采用分布式存储和分布式处理两大核心技术，能够高效的处 理PB级数据。 ·高可扩展性 Hadoop的设计目标是可以高效稳定地运行在廉价的计算机集群上，可以扩展到数以千计的计算 机节点上。 ·高容错性 采用冗余数据存储方式，自动保存数据的多个副本，并且能够自动将失败的任务进行重新分配。 ·成本低 Hadoop采用廉价的计算机集群，成本比较低，普通用户也很容易用自己的PC搭建Hadoop运 行环境。 ·运行在Linux平台上 Hadoop是基于Java语言开发的，可以较好地运行在Linux平台上。 ·支持多种编程语言 Hadoop上的应用程序也可以使用其他语言编写，如C++。 3. 简述Hadoop在各领域应用情况。其中，hadoop主要应用于： 在线旅游：在线旅游的预订服务，客户感兴趣的旅游景点的推送。 移动数据：通过无线方式存储和处理移动数据，以及有关市场份额的数学可以帮助他们锁定客户。 电子商务：从大量数据中分析出用户的购物行为，提供更好的客户服务，动态定价和特价优惠，供应链管理，预测分析等方面有着重要的作用。 能源发现：采用Hadoop来对数据进行排序和整理，而这些数据全部来自从海洋深处地震时产生的数据，从而发现以前没有发现的能源。 能源节省：通过对用户能源数据、气象与人口方面的公共急死人数据、历史信息，地理数据及其他数据的分析，尽量为用户节省在资源方面的投入。 基础设施管理：各个公司使用Hadoop处理和分析从服务器、交换机及其他IT设备商收集到的数据，以及对设备日志的管理等。 图像处理：如利用Hadoop来存储和处理高来自卫星捕捉的高分辨率图像，并尝试将这些信息及图像与地理格局的变化相对应。 欺诈检测：在金融服务机构和情报机构中，利用Hadoop来存储所有数据，并对客户交易和现货异常进行判断，对可能存在欺诈行为提前预警的。 IT安全和医疗保健等领域： 如基础设施管理一样，企业通过使用Hadoop来处理机器产生的数据，以识别恶意软件和网络攻击模式；在医学中可以通过hadoop来迅速了解病人相关病史，或者设计一些应用来防治流行病（如新冠中用大数据对新冠流行做出精准预测）。 4. 概括Hadoop生态系统中有哪些主要组件，描述其功能。 1、HDFS HDFS具有处理超大数据、流式处理、可以运行在廉价商用服务器上等优点。HDFS在设计之初就是要运行在廉价的大型服务器集群上，因此在设计上就把硬件故障作为一种常态来考虑，可以保证在部分硬件发生故障的情况下仍然能够保证文件系统的整体可用性和可靠性。 2、HBase HBase是一个提供高可靠性、高性能、可伸缩、实时读写、分布式的列式数据库，一般采用HDFS作为其底层数据存储。具有良好的横向扩展能力，可以通过不断增加廉价的商用服务器来增加存储能力。 3、MapReduce MapReduce是一种编程模型，用于大规模数据集（大于1TB)的并行运算，它将复杂的、运行于大规模集群上的并行计算过程高度地抽象到了两个函数一一Map和Reduce上，并且允许用户在不了解分布式系统底层细节的情况下开发并行应用程序，并将其运行于廉价计算机集群上，完成海量数据的处理。通俗地说MapReduce的核心思想就是“分而治之”。 4、Hive Hive是—个基于Hadoop的数据仓库工具，可以用于对Hadoop文件中的数据集进行数据整理、特殊查询和分析存储。 5、Pig Pig是一种数据流语言和运行环境，适合于使用HadooP和MapReduce平台来查询大型半结构化数据集。 6、Mahout Mahout包含许多实现，包括聚类、分类、推荐过滤、频繁子项挖掘。 7、Zookeeper 是高效和可靠的协同工作系统，提供分布式锁之类的基本服务，用于构建分布式应用，减轻分布式应用程序所承担的协调任务。 8、Flume Flume支持在日志系统中定制各类数据发送方，用于数据收集；同时，Flume提供对数据进行简单处理并写到各种数据接受方的能力。 9、Sqoop 主要用来在Hadoop和关系数据库之间交换数据的互操作性。通过Sqoop可以方便地将数据从MySQL、Oracle.PostgreSQL等关系数据库中导人Hadoop(可以导人HDFS、HBase或Hive)，或者将数据从Hadoop导出到关系数据库，使得传统关系数据库和Hadoop之间的数据迁移变得非常方便 10、Ambari ApacheAmbari是一种基于Web的工具，支持ApacheHadoop集群的安装、部署、配置和管理。 5. 试列举单机模式和伪分布模式的异同点？ 相同点： 1、运行机器数相同：单机(非分布式)模式与伪分布式都是在一台单机上运行。 不同点： 1、分布式文件系统不同 1）单机(非分布式)模式，没有分布式文件系统，而是直接读写本地操作系统的文件系统。 2）伪分布式用不同的Java进程模仿分布式运行中的各类结点: (NameNode,DataNode,JobTracker,TaskTracker,SecondaryNameNode)。 2、启动进程不同 1）、单机(非分布式)模式下，Hadoop不会启动NameNode、DataNode、JobTracker、TaskTracker等守护进程，Map()和Reduce()任务作为同一个进程的不同部分来执行的。 2）、伪分布式模式下，Hadoop启动NameNode、DataNode、JobTracker、TaskTracker这些守护进程都在同一台机器上运行，是相互独立的Java进程。 6. 尝试采用伪分布模式在自己的机器上安装hadoop3.2.2，请描述安装过程，遇到的困难及如何解决的。7. 简述Hadoop 3.0中HDFS新功能与特性.1、Java最低版本要求从Java7更改成Java8。 2、HDFS支持纠删码，将原本3倍的存储消耗降低到1.4倍。 在原始数据中加入新的校验数据，使得各个部分的数据产生关联性。 在一定范围的数据出错情况下，通过纠删码技术都可以进行恢复。 既耗网络又耗CPU,适用于冷数据集群。 3、Hadoop的Shell脚本被重写。 4、MapReduce任务级本地优化。 MapReduce添加了Map输出collector的本地实现。对于shuffle密集型的作业来说，这将会有30%以上的性能提升。 5、支持多于2个的NameNode。 6、多个服务的默认端口被改变。 7、提供了单节个磁盘存储不均的情况的解决方案。 8、重写守护进程以及任务的堆内存管理。","categories":[{"name":"云计算与大数据","slug":"云计算与大数据","permalink":"https://zouyunkai.github.io/myblog/categories/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[],"author":"aoyuehan"},{"title":"使用vagrant和virtualbox来配置hadoop环境","slug":"使用vagrant和virtualbox来配置hadoop环境","date":"2021-03-15T14:01:00.000Z","updated":"2022-04-03T13:18:46.393Z","comments":true,"path":"2021/03/15/使用vagrant和virtualbox来配置hadoop环境/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/03/15/%E4%BD%BF%E7%94%A8vagrant%E5%92%8Cvirtualbox%E6%9D%A5%E9%85%8D%E7%BD%AEhadoop%E7%8E%AF%E5%A2%83/","excerpt":"","text":"一、前言本次题解会教你如何通过vagrant安装好ubuntu系统，并配置好和hadoop相关的环境。 署名 ：软工18-1 邹庆志 前置知识： 何为vagrant vagrant是一个工具，用于简化创建和部署虚拟化开发环境。 拿VirtualBox举例，VirtualBox会开放一个创建虚拟机的接口，Vagrant会利用这个接口创建虚拟机，并且通过Vagrant来管理，配置和自动安装虚拟机。 何为VirtualBox VirtualBox 是一款开源虚拟机软件。VirtualBox 是由德国 Innotek 公司开发，由Sun Microsystems公司出品的软件，使用Qt编写，在 Sun 被 Oracle 收购后正式更名成 Oracle VM VirtualBox。 何为hadoop Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。 二、环境搭建 安装vagrant和virtualBox1、vagrant一定要安装在系统盘中，不然好像不能使用的，vagrant的安装包：https://download.csdn.net/download/aoyuehanzhi/12643794?spm=1001.2014.3001.5501。 2、virtualBox可以安装在非系统盘，然后记得初始化virtualBox镜像存在的位置，这样镜像就不会存在系统盘里了，如下图所示： 这里我用的virtualbox的版本是6.0，是可以适配的 三、通过vagrant安装ubuntu系统vagrant的相关语法介绍：https://blog.csdn.net/qq_38423105/article/details/85253829?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control Vagrant 常用命令清单 vagrant box add 添加box vagrant init 初始化 box vagrant up 启动虚拟机 vagrant ssh 登录虚拟机 vagrant box list 列出 Vagrant 当前 box 列表 vagrant box remove 删除相应的 box vagrant destroy 停止当前正在运行的虚拟机并销毁所有创建的资源 vagrant halt 关机 vagrant package 把当前的运行的虚拟机环境进行打包为 box 文件 vagrant plugin 安装卸载插件 vagrant reload 重新启动虚拟机，重新载入配置文件 vagrant resume 恢复被挂起的状态 vagrant status 获取当前虚拟机的状态 vagrant suspend 挂起当前的虚拟机 vagrant global-status 查看当前 vagrant 管理的所有 vm 信息 1、第一步 在C:\\Users\\aoyuehan下创建一个名为Vagrantfile的文件（没有后缀名），然后该系统相关的信息 12345678910111213141516171819202122232425262728293031323334353637383940Vagrant.configure(&quot;2&quot;) do |config| config.vm.define :centos do |centos| centos.vm.provider &quot;virtualbox&quot; do |v| v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;centos&quot;, &quot;--memory&quot;, &quot;1024&quot;] end centos.vm.box = &quot;centos/7&quot; centos.vm.hostname = &quot;centos&quot; centos.vm.network :private_network, ip: &quot;192.168.56.10&quot; centos.vm.synced_folder &quot;./MyVagrantSyncFolder&quot;, &quot;/vagrant&quot;, type: &quot;rsync&quot; end config.vm.define :ubuntu , autostart: false do |ubuntu| ubuntu.vm.provider &quot;virtualbox&quot; do |v| v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;ubuntu&quot;, &quot;--memory&quot;, &quot;1024&quot;] end ubuntu.vm.box = &quot;ubuntu/trusty64&quot; ubuntu.vm.hostname = &quot;ubuntu&quot; ubuntu.vm.network :private_network, ip: &quot;192.168.56.11&quot; ubuntu.vm.synced_folder &quot;./MyVagrantSyncFolder&quot;, &quot;/vagrant&quot;, type: &quot;rsync&quot; endend=======注解：1、vm.synced_folder &quot;./MyVagrantSyncFolder&quot;, &quot;/vagrant&quot;, type: &quot;rsync&quot;这句话的意思是将C:\\Users\\aoyuehan\\MyVagrantSyncFolder文件夹同步到虚拟机中的/vagrant目录下，不然的话会同步整个用户文件夹，导致虚拟机磁盘直接被填满，这是我遇到的一个血坑！！！！2、这里我是多系统环境，安装了centos7和ubuntu两个环境，如果只想安装ubuntu系统可以使用下面的配置：Vagrant.configure(&quot;2&quot;) do |config| config.vm.define :ubuntu , autostart: false do |ubuntu| ubuntu.vm.provider &quot;virtualbox&quot; do |v| v.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;ubuntu&quot;, &quot;--memory&quot;, &quot;1024&quot;] end ubuntu.vm.box = &quot;ubuntu/trusty64&quot; ubuntu.vm.hostname = &quot;ubuntu&quot; ubuntu.vm.network :private_network, ip: &quot;192.168.56.11&quot; ubuntu.vm.synced_folder &quot;./MyVagrantSyncFolder&quot;, &quot;/vagrant&quot;, type: &quot;rsync&quot; endend 2、通过Vagrantfile文件配置安装虚拟机到virtualBox中 输入vagrant up ubuntu来初始化虚拟机，如下图： 3、连接到虚拟机 命令行中输入vagrant ssh ubuntu，通过ssh连接到虚拟机 除了通过windows的shell来连接虚拟机之外，也可以通过xshell等工具来连接 虚拟机的用户名密码默都为vagrant，主机地址就是配置文件中ubuntu.vm.network :private_network, ip: “192.168.56.11” 指定的值。 4、关机 通过virtualBox中的正常关机即可以关机，下一次再想启动虚拟机的时候，可以直接打开virtualBox来选择要启动的虚拟机即可，可以不用vagrant命令来启动。 安装hadoop教程：Hadoop安装教程_单机&#x2F;伪分布式配置_Hadoop2.6.0(2.7.1)&#x2F;Ubuntu14.04(16.04)_厦大数据库实验室博客 安装SSH、配置SSH无密码登陆集群、单节点模式都需要用到 SSH 登陆（类似于远程登陆，你可以登录某台 Linux 主机，并且在上面运行命令），Ubuntu 默认已安装了 SSH client，此外还需要安装 SSH server： 1234567891011sudo apt-get install openssh-server安装后，可以使用如下命令登陆本机：ssh localhost此时会有如下提示(SSH首次登陆提示)，输入 yes 。然后按提示输入密码 hadoop，这样就登陆到本机了。但这样登陆是需要每次输入密码的，我们需要配置成SSH无密码登陆比较方便。首先退出刚才的 ssh，就回到了我们原先的终端窗口，然后利用 ssh-keygen 生成密钥，并将密钥加入到授权中：exit # 退出刚才的 ssh localhostcd ~/.ssh/ # 若没有该目录，请先执行一次ssh localhostssh-keygen -t rsa # 会有提示，都按回车就可以cat ./id_rsa.pub &gt;&gt; ./authorized_keys # 加入授权 tips: ~的含义 在 Linux 系统中，~ 代表的是用户的主文件夹，即 “&#x2F;home&#x2F;用户名” 这个目录，如你的用户名为 hadoop，则 ~ 就代表 “&#x2F;home&#x2F;hadoop&#x2F;”。 此外，命令中的 # 后面的文字是注释，只需要输入前面命令即可。 安装jdk（1）第1种安装JDK方式（手动安装，推荐采用本方式） 下载好linux的jdk安装包，然后通过ssh，用filezip上传到ubuntu中， 1234567891011121314151617181920212223242526步骤一：cd /usr/libsudo mkdir jvm #创建/usr/lib/jvm目录用来存放JDK文件cd ~ #进入vagrant用户的主目录cd Downloads #注意区分大小写字母，刚才已经通过FTP软件把JDK安装包jdk-8u162-linux-x64.tar.gz上传到该目录下sudo tar -zxvf ./jdk-8u162-linux-x64.tar.gz -C /usr/lib/jvm #把JDK文件解压到/usr/lib/jvm目录下步骤二：cd /usr/lib/jvm #JDK文件解压缩以后，可以执行如下命令到/usr/lib/jvm目录查看一下：ls步骤三：#下面继续执行如下命令，设置环境变量：cd ~vim ~/.bashrc#上面命令使用vim编辑器（查看vim编辑器使用方法）打开了vagrant这个用户的环境变量配置文件，请在这个文件的开头位置，添加如下几行内容：export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_162export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH#保存.bashrc文件并退出vim编辑器。然后，继续执行如下命令让.bashrc文件的配置立即生效：source ~/.bashrc#这时，可以使用如下命令查看是否安装成功：java -version 安装hadoop下载好hadoop的安装包，然后传输到虚拟机中 1234567891011步骤一：我们选择将 Hadoop 安装至 /usr/local/ 中：sudo tar -zxf ~/下载/hadoop-2.6.0.tar.gz -C /usr/local # 解压到/usr/local中cd /usr/local/sudo mv ./hadoop-2.6.0/ ./hadoop # 将文件夹名改为hadoopsudo chown -R hadoop ./hadoop # 修改文件权限步骤二：Hadoop 解压后即可使用。输入如下命令来检查 Hadoop 是否可用，成功则会显示 Hadoop 版本信息：cd /usr/local/hadoop./bin/hadoop version Hadoop伪分布式配置Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。 Hadoop 的配置文件位于 &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;etc&#x2F;hadoop&#x2F; 中，伪分布式需要修改2个配置文件 core-site.xml 和 hdfs-site.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。 修改配置文件 core-site.xml (通过 gedit 编辑会比较方便: gedit ./etc/hadoop/core-site.xml)，将其修改为： 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 同样的，修改配置文件 hdfs-site.xml： 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 12345678910配置完成后，执行 NameNode 的格式化:cd /usr/local/hadoop./bin/hdfs namenode -format成功的话，会看到 “successfully formatted” 和 “Exitting with status 0” 的提示，若为 “Exitting with status 1” 则是出错。接着开启 NameNode 和 DataNode 守护进程。cd /usr/local/hadoop./sbin/start-dfs.sh #start-dfs.sh是个完整的可执行文件，中间没有空格启动时可能会出现如下 WARN 提示：WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicable WARN 提示可以忽略，并不会影响正常使用。 启动完成后，可以通过命令 jps 来判断是否成功启动，若成功启动则会列出如下进程: “NameNode”、”DataNode” 和 “SecondaryNameNode”（如果 SecondaryNameNode 没有启动，请运行 sbin&#x2F;stop-dfs.sh 关闭进程，然后再次尝试启动尝试）。如果没有 NameNode 或 DataNode ，那就是配置不成功，请仔细检查之前步骤，或通过查看启动日志排查原因。 tips: 启动 Hadoop 时提示 Could not resolve hostname 如果启动 Hadoop 时遇到输出非常多“ssh: Could not resolve hostname xxx”的异常情况,这个并不是 ssh 的问题，可通过设置 Hadoop 环境变量来解决。 Hadoop配置文件说明* Hadoop 的运行方式是由配置文件决定的（运行 Hadoop 时会读取配置文件），因此如果需要从伪分布式模式切换回非分布式模式，需要删除 core-site.xml 中的配置项。 此外，伪分布式虽然只需要配置 fs.defaultFS 和 dfs.replication 就可以运行（官方教程如此），不过若没有配置 hadoop.tmp.dir 参数，则默认使用的临时目录为 &#x2F;tmp&#x2F;hadoo-hadoop，而这个目录在重启时有可能被系统清理掉，导致必须重新执行 format 才行。所以我们进行了设置，同时也指定 dfs.namenode.name.dir 和 dfs.datanode.data.dir，否则在接下来的步骤中可能会出错。 运行Hadoop伪分布式实例上面的单机模式，grep 例子读取的是本地数据，伪分布式读取的则是 HDFS 上的数据。要使用 HDFS，首先需要在 HDFS 中创建用户目录： 123456789101112131415161718192021222324252627./bin/hdfs dfs -mkdir -p /user/vagrant长度接着将 ./etc/hadoop 中的 xml 文件作为输入文件复制到分布式文件系统中，即将 /usr/local/hadoop/etc/hadoop 复制到分布式文件系统中的 /user/vagrant/input 中。我们使用的是 vagrant 用户，并且已创建相应的用户目录 /user/vagrant ，因此在命令中就可以使用相对路径如 input，其对应的绝对路径就是 /user/vagrant/input:./bin/hdfs dfs -mkdir input./bin/hdfs dfs -put ./etc/hadoop/*.xml input复制完成后，可以通过如下命令查看文件列表：./bin/hdfs dfs -ls input伪分布式运行 MapReduce 作业的方式跟单机模式相同，区别在于伪分布式读取的是HDFS中的文件（可以将单机步骤中创建的本地 input 文件夹，输出结果 output 文件夹都删掉来验证这一点）。./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output &#x27;dfs[a-z.]+&#x27;查看运行结果的命令（查看的是位于 HDFS 中的输出结果）：./bin/hdfs dfs -cat output/*我们也可以将运行结果取回到本地：rm -r ./output # 先删除本地的 output 文件夹（如果存在）./bin/hdfs dfs -get output ./output # 将 HDFS 上的 output 文件夹拷贝到本机cat ./output/*Hadoop 运行程序时，输出目录不能存在，否则会提示错误 “org.apache.hadoop.mapred.FileAlreadyExistsException: Output directory hdfs://localhost:9000/user/hadoop/output already exists” ，因此若要再次执行，需要执行如下命令删除 output 文件夹:./bin/hdfs dfs -rm -r output # 删除 output 文件夹若要关闭 Hadoop，则运行./sbin/stop-dfs.sh 通过.&#x2F;share&#x2F;hadoop&#x2F;mapreduce&#x2F;hadoop-mapreduce-examples-*.jar 来计算input文件夹下文件中单词以dfs开头的单词，运行截图如下： 遇到的问题如下： 通过在hadoop的安装目录下运行.&#x2F;bin&#x2F;hdfs dfs 等命令的时候 都是调用hadoop上的hdfs命令；如果使用rm -r .&#x2F;output命令删除本地的文件夹output。 12345671. hadoop fs2. hadoop dfs3. hdfs dfshadoop fs适用于任何不同的文件系统，比如本地文件系统和HDFS文件系统hadoop dfs只能适用于HDFS文件系统hdfs dfs跟hadoop dfs的命令作用一样，也只能适用于HDFS文件系统 在安装hadoop的时候，我先是安装了open-7-jdk，安装了hadoop3.x.x的，结果当我配置好hadoop后，运行 cd &#x2F;usr&#x2F;local&#x2F;hadoop.&#x2F;sbin&#x2F;start-dfs.sh #start-dfs.sh是个完整的可执行文件，中间没有空格 时，出现一个错误， 1234567891011121314151617低版本jdk无法执行高版本jdk编译出的class文件# java WriteLogException in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: WriteLog : Unsupported major.minor version 52.0 at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:800) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) at java.net.URLClassLoader.defineClass(URLClassLoader.java:449) at java.net.URLClassLoader.access$100(URLClassLoader.java:71) at java.net.URLClassLoader$1.run(URLClassLoader.java:361) at java.net.URLClassLoader$1.run(URLClassLoader.java:355) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:354) at java.lang.ClassLoader.loadClass(ClassLoader.java:425) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) at java.lang.ClassLoader.loadClass(ClassLoader.java:358) at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:482) 所以将jdk换位jdk1.8的，然后就不出现该错误了。 当配置好伪分布模式的hadoop时，DataNode，NameNode等进程也存在，但是localhost:50070无法访问 1# netstat -tunlp //查看终端端口号的占用 经过查看并没有50070这个端口号，我猜想是不是我的电脑换了端口号了，所以我就尝试电脑里的其他端口号（从后往前一个一个试），结果9868端口号可以使用。","categories":[{"name":"大数据","slug":"大数据","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"}],"tags":[],"author":"aoyuehan"},{"title":"寒假每日一题week2","slug":"寒假每日一题week2","date":"2021-01-19T14:01:00.000Z","updated":"2022-04-03T13:18:46.796Z","comments":true,"path":"2021/01/19/寒假每日一题week2/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/01/19/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week2/","excerpt":"","text":"756蛇形矩阵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122模拟题 方法1： #include&lt;iostream&gt;using namespace std;int matrix[110][110];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; int ur=1,dr=n,lc=1,rc=m; //取四个变量分别代表最上面一行，最下面一行，最左边一列，最右边一列 int cnt=1; while(ur&lt;dr&amp;&amp;lc&lt;rc)&#123; //不打印行相等，或者列相等的那种情况 for(int i=lc;i&lt;=rc;i++)&#123;//打印最上面一行 matrix[ur][i]=cnt++; &#125; ur++; if(ur==dr)break; //****特判 减完加完 判断 是不是行列相等 了，如果行列相等，应该退出while for(int i=ur;i&lt;=dr;i++)&#123; matrix[i][rc]=cnt++; &#125; rc--; if(lc==rc)break; for(int i=rc;i&gt;=lc;i--)&#123; matrix[dr][i]=cnt++; &#125; dr--; if(ur==dr)break; for(int i=dr;i&gt;=ur;i--)&#123; matrix[i][lc]=cnt++; &#125; lc++; if(lc==rc)break; &#125; if(ur==dr)&#123; //如果行相等 if(n%2)&#123; //奇数行，从左往右打印最后一行 for(int i=lc;i&lt;=rc;i++)&#123; matrix[ur][i]=cnt++; &#125; &#125;else&#123; //从右往左打印最后一行 for(int i=rc;i&gt;=lc;i--)&#123; matrix[ur][i]=cnt++; &#125; &#125; &#125;else&#123; //列的两个变量相等 if(m%2)&#123; //为奇数列 ，从上往下打印最后一列 for(int i=ur;i&lt;=dr;i++)&#123; matrix[i][lc]=cnt++; &#125; &#125;else&#123;//为偶数列 ，从下往上打印最后一列 for(int i=dr;i&gt;=ur;i--)&#123; matrix[i][lc]=cnt++; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cout&lt;&lt;matrix[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125; ////3 2;//1 2//6 3//5 4////5 3;//1 2 3//12 13 4//11 14 5//10 15 6//9 8 7 //9 8 7 方法2： #include&lt;iostream&gt;using namespace std;int matrix[110][110];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; int cntt=n*m; //计算总的打印个数 int ur=1,dr=n,lc=1,rc=m; int cnt=1; while(ur&lt;=dr&amp;&amp;lc&lt;=rc )&#123; for(int i=lc;i&lt;=rc;i++)&#123;//打印最上面一行 if(cnt&gt;cntt)break; //因为当3 5,5 3这种例子的时候就会出现多打印的问题，所以这里特判 matrix[ur][i]=cnt++; &#125; ur++; if(cnt&gt;cntt)break; for(int i=ur;i&lt;=dr;i++)&#123; matrix[i][rc]=cnt++; if(cnt&gt;cntt)break; &#125; rc--; if(cnt&gt;cntt)break; for(int i=rc;i&gt;=lc;i--)&#123; matrix[dr][i]=cnt++; if(cnt&gt;cntt)break; &#125; dr--; if(cnt&gt;cntt)break; for(int i=dr;i&gt;=ur;i--)&#123; matrix[i][lc]=cnt++; if(cnt&gt;cntt)break; &#125; lc++; if(cnt&gt;cntt)break; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cout&lt;&lt;matrix[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125; 方法3 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;const int N = 110;int n, m;int q[N][N];int main()&#123; cin &gt;&gt; n &gt;&gt; m; int dx[] = &#123;-1, 0, 1, 0&#125;, dy[] = &#123;0, 1, 0, -1&#125;; int x = 0, y = 0, d = 1; for (int i = 1; i &lt;= n * m; i ++ ) //总共循环所有的格子数 &#123; q[x][y] = i; //当前格子填入数i，（这个地方直接用a，b作为下标也是可以的） int a = x + dx[d], b = y + dy[d]; //更新一下下一次要走的坐标，然后进行判断下一步是否满足条件 if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m || q[a][b]) //如果碰壁，q[a][b]表示格子已经走过 &#123; d = (d + 1) % 4; //换一个方向，继续打印 a = x + dx[d], b = y + dy[d]; //因为换了方向，所以重新更新一下 下一次要走的坐标的值 &#125; x = a, y = b; //将下一次要走的地方赋值给（x,y） &#125; for (int i = 0; i &lt; n; i ++ ) &#123; for (int j = 0; j &lt; m; j ++ ) cout &lt;&lt; q[i][j] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; &#125; return 0;&#125; https://www.acwing.com/activity/content/code/content/682933/ AcWing 844. 走迷宫 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt; //memset在这个头文件中using namespace std;const int N=110;int f[N][N],d[N][N];int dx[4]=&#123;0,1,0,-1&#125;,dy[4]=&#123;1,0,-1,0&#125;; //就是上下左右四个方向 int bfs(int n,int m)&#123; memset(d,-1,sizeof(d)); queue&lt;pair&lt;int,int&gt;&gt;q; q.push(&#123;1,1&#125;); //把（1,1）这个点放到队列中 d[1][1]=0; //d数组不仅存放，有没有**进入过队列**，也存放走到这地方需要的最小步数 pair&lt;int,int&gt;temp; while(!q.empty())&#123; temp=q.front(); //队列不为空，从队头取一个元素出来 q.pop(); for(int i=0;i&lt;4;i++)&#123; int x=temp.first+dx[i]; //取出来的该坐标，加上方向向量之后，判断该位置是否有效 int y=temp.second+dy[i]; if(x&gt;=1&amp;&amp;x&lt;=n&amp;&amp;y&gt;=1&amp;&amp;y&lt;=m&amp;&amp;f[x][y]==0&amp;&amp;d[x][y]==-1)&#123; //没有越界 可以走 没有走过 d[x][y]=d[temp.first][temp.second]+1; //修改d数组中的步数 q.push(&#123;x,y&#125;); //一个位置只入队一次 &#125; &#125; &#125; return d[n][m]; //返回到达右下角 最终的步数 &#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; //当时手贱，这里j也小于m了，然后debug之后才发现写错了 cin&gt;&gt;f[i][j]; &#125; &#125; //出错的时候打表发现错误 cout&lt;&lt;bfs(n,m); return 0;&#125; AcWing 1102. 移动骑士 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;cstring&gt; //memset在这个头文件中using namespace std;const int N=310;int d[N][N];const int dx[8]=&#123;2,1,-1,-2,-2,-1, 1, 2&#125;; //八个方向const int dy[8]=&#123;1,2,2 ,1, -1,-2,-2,-1&#125;;int sizee,x1,x2,y1,y2;int bfs( )&#123; memset(d,-1,sizeof(d)); queue&lt;pair&lt;int,int&gt;&gt;q; q.push(&#123;x1,y1&#125;); //把（x1,y1）这个点放到队列中 d[x1][y1]=0; //d数组不仅存放，有没有走过，也存放走到这地方需要的最小步数 pair&lt;int,int&gt;temp; while(!q.empty())&#123; temp=q.front(); //队列不为空，从队头取一个元素出来 q.pop(); // if( temp.first==x2&amp;&amp;temp.second==y2)&#123; //当队首就是这个点的时候，退出；；；这一句也没用，因为判断过d[x][y]==-1了// return d[x2][y2];// &#125; for(int i=0;i&lt;8;i++)&#123; int x=temp.first+dx[i]; //取出来的该坐标，加上方向向量之后，判断该位置是否有效 int y=temp.second+dy[i]; if(x&gt;=0&amp;&amp;x&lt;sizee&amp;&amp;y&gt;=0&amp;&amp;y&lt;sizee&amp;&amp;d[x][y]==-1)&#123; //没有越界 可以走 没有走过 d[x][y]=d[temp.first][temp.second]+1; //修改d数组中的步数 q.push(&#123;x,y&#125;); //一个位置只入队一次 &#125; &#125; &#125; return d[x2][y2]; &#125;int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;sizee; cin&gt;&gt;x1&gt;&gt;y1; cin&gt;&gt;x2&gt;&gt;y2; cout&lt;&lt;bfs( )&lt;&lt;endl;//for(int i=0;i&lt;sizee;i++)&#123; //出错的时候打表发现错误 // for(int j=0;j&lt;sizee;j++)&#123;// cout&lt;&lt;d[i][j]&lt;&lt;&quot; &quot;;// &#125;// cout&lt;&lt;endl;// &#125; &#125; return 0;&#125; AcWing 1421. 威斯康星方形牧场 1113. 红与黑 （洪水灌溉算法 flood fill）方法1:宽搜，bfs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 25;int n, m;char g[N][N];int bfs(int sx, int sy)&#123; queue&lt;PII&gt; q; q.push(&#123;sx, sy&#125;); g[sx][sy] = &#x27;#&#x27;; int res = 0; int dx[] = &#123;-1, 0, 1, 0&#125;, dy[] = &#123;0, 1, 0, -1&#125;; while (q.size()) //队列不为空，遍历队头的相邻格子 &#123; auto t = q.front(); q.pop(); res ++ ; //从队头取一个格子，取到的都是黑瓷砖，所以相应的结果++ for (int i = 0; i &lt; 4; i ++ ) &#123; int x = t.x + dx[i], y = t.y + dy[i]; if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || g[x][y] != &#x27;.&#x27;) continue; g[x][y] = &#x27;#&#x27;; //把黑瓷砖标记为已访问，这里标记为红瓷砖就可以 q.push(&#123;x, y&#125;); //黑瓷砖入栈 ，等待遍历该黑瓷砖的相邻格子 &#125; &#125; return res;&#125;int main()&#123; while (cin &gt;&gt; m &gt;&gt; n, n || m) &#123; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; g[i]; int x, y; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) if (g[i][j] == &#x27;@&#x27;) &#123; x = i; y = j; &#125; cout &lt;&lt; bfs(x, y) &lt;&lt; endl; &#125; return 0;&#125; 方法2：dfs回溯 （更适合机器的思想） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;const int N = 25;int n, m;char g[N][N];int dx[] = &#123;-1, 0, 1, 0&#125;, dy[] = &#123;0, 1, 0, -1&#125;;int dfs(int x, int y)&#123; int res = 1; g[x][y] = &#x27;#&#x27;; //刚进来的时候这地方就要标记一下 ，将.变为#，就代表这地方走过去了，下一次不能走这地方了 for (int i = 0; i &lt; 4; i ++ ) &#123; int a = x + dx[i], b = y + dy[i]; if (a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m &amp;&amp; g[a][b] == &#x27;.&#x27;) res += dfs(a, b); //搜索(a,b)这地方的格子 ；这地方一定要+= //这里回溯的时候不需要复原现场 &#125; return res;&#125;int main()&#123; while (cin &gt;&gt; m &gt;&gt; n, n || m) &#123; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; g[i]; int x, y; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) if (g[i][j] == &#x27;@&#x27;) &#123; x = i; y = j; &#125; cout &lt;&lt; dfs(x, y) &lt;&lt; endl; &#125; return 0;&#125;/*知道要到达的层数的dfs模板 int check(参数)&#123; if(满足条件) return 1; return 0;&#125;void dfs(int step)&#123; 判断step数值的大小，判断边界 &#123; 相应操作 &#125; 尝试每一种可能 &#123; 满足check条件 标记！！！！！ 继续下一步dfs(step+1) 恢复初始状态（用来回溯）//有些时候如state，或者状态存在形参中的时候就可以不用回溯 &#125;&#125;*/ 1346 回文平方 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647十进制转化成其他进制：短除法其他进制转化成十进制：秦九韶算法其他进制转化成其他进制(1) 用十进制过渡(2) 短除法 （见下图）(3) 扩展题：AcWing 124. 数的进制转换#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;char get(int x) //获取该位数的表示&#123; if (x &lt;= 9) return x + &#x27;0&#x27;; return x - 10 + &#x27;A&#x27;;&#125;string base(int n, int b) //将十进制数n变为b进制数，返回该数的b进制表示&#123; string num; while (n) num += get(n % b), n /= b; reverse(num.begin(), num.end()); return num;&#125;bool check(string num) //判断回文&#123; for (int i = 0, j = num.size() - 1; i &lt; j; i ++, j -- ) if (num[i] != num[j]) return false; return true;&#125;int main()&#123; int b; cin &gt;&gt; b; for (int i = 1; i &lt;= 300; i ++ ) &#123; auto num = base(i * i, b); if (check(num)) cout &lt;&lt; base(i, b) &lt;&lt; &#x27; &#x27; &lt;&lt; num &lt;&lt; endl; &#125; return 0;&#125; 680. 剪绳子 （浮点数 二分答案）本来是让我们求可以裁成m段绳子的最长（即最优解）是多少，但这样比较难求，但是给我们m段绳子的长度为x，我们可以很容易的判断这个x是不是符合要求，所以将求最优解问题转换为判断问题，这就简化了问题 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;const int N = 100010;int a[N];int n,m;bool check(double len)//剪长度为 len 的绳字是否能到 m 根&#123; int res = 0; for (int i = 0; i &lt; n; i++) &#123; res += a[i] / len;//一根绳子能剪出多少长度为 len 的绳子 if (res &gt;= m) return true; &#125; return false;&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; double l = 0, r = 1e9; while (r - l &gt; 1e-4)//二分法 ，这地方也可以for(int i=0;i&lt;100;i++) 用10^7/check的复杂度得到100，所以迭代100次就差不多了 &#123; double mid = (l + r)/2; //模板一 ，这地方两个double类型的数不能用&gt;&gt;进行移位运算 if (check(mid)) l = mid;//若能剪出 mid 长度的 else r = mid; &#125; printf(&quot;%.2f&quot;, l);&#125; tips：由数据范围反推算法时间复杂度以及算法内容 1227. 分巧克力 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;typedef long long LL;const int N = 100010;int n, m;int h[N], w[N];bool check(int mid)&#123; LL res = 0; for (int i = 0; i &lt; n; i ++ ) &#123; res += (LL)h[i] / mid * (w[i] / mid); if (res &gt;= m) return true; &#125; return false;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d%d&quot;, &amp;h[i], &amp;w[i]); int l = 1, r = 1e5; while (l &lt; r) &#123; int mid = l + r +1 &gt;&gt; 1; //模板二 if (check(mid)) l = mid; else r = mid - 1; &#125; printf(&quot;%d\\n&quot;, r); return 0;&#125; tips:二分查找算法模板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283整数二分法，要考虑边界问题 (计算mid的时候加法溢出，把l变为longlong类型即可) 第一种（当mid输入左区间的话，就得必须计算mid的时候不需要+1 int bsearch_1(int l, int r) &#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; return l; &#125; #include &lt;stdio.h&gt; int bsearch_1(int l, int r,int arr[],int NumberToFind) &#123; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (arr[mid] &gt;= NumberToFind) r = mid; else l = mid + 1; &#125; printf(&quot;%d&quot;,l); return l; &#125; int main() &#123; int arr[5] = &#123;0,1,3,4,5&#125;; bsearch_1(0,4,arr,2); return 0; &#125; bsearch_1(0,4,arr,2); 这里寻找的是2， 元素不在数组里，则会找到从左往右数第一个 &gt;= NumberToFind的元素位置，就是arr[2] bsearch_1(0,4,arr,-10); 如果这里寻找-10,元素不在数组里，则会找到从左往右数第一个 &gt;= NumberToFind的元素位置，就是arr[0] bsearch_1(0,4,arr,20); 如果这里寻找20,元素不在数组里,会找到arr[4] 第二种类（当mid输入右区间的话，就得必须计算mid的时候+1 当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。 int bsearch_2(int l, int r) &#123; while (l &lt; r) //都是l和r相等的时候才会结束while &#123; int mid = l + r + 1 &gt;&gt; 1; //+法运算优先级高于&gt;&gt;,这里+1，是因为防止l一直小于r，造成死循环 if (check(mid)) l = mid; else r = mid - 1; &#125; return l; &#125; #include &lt;stdio.h&gt; int bsearch_1(int l, int r,int arr[],int NumberToFind) &#123; while (l &lt; r) &#123; int mid = l + r + 1&gt;&gt; 1; if (arr[mid] &lt;= NumberToFind) l = mid; else r = mid - 1; &#125; printf(&quot;%d&quot;,l); return l; &#125; int main() &#123; int arr[5] = &#123;0,1,3,4,5&#125;; bsearch_1(0,4,arr,4); return 0; &#125; 则会找到第一个从右往左数 &lt;= NumberToFind的元素位置! 422 校门外的树算法1(模拟,数组遍历) O(ML) 定义一个长度为 L+1 的布尔数组，表示每棵树的状态。 true 表示已经被移走；false 表示未被移走； 对于每次移动树木的操作 [Li,Ri]，直接循环一遍，将布尔数组中从 Li，到 Ri 这段赋值为true。 最后统计值为 false 的数量即可。时间复杂度分析 对于每次移动树木的操作，最坏情况下区间长度是 O(L)，因此计算量是 O(L)，一共有 M 次操作，因此总时间复杂度是 O(ML)&#x3D;100×10000&#x3D;106。 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int n, m;bool st[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;m, &amp;n); while (n -- ) &#123; int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); for (int i = l; i &lt;= r; i ++ ) st[i] = true; &#125; int res = 0; for (int i = 0; i &lt;= m; i ++ ) if (!st[i]) res ++ ; printf(&quot;%d\\n&quot;, res); return 0;&#125; 算法2(区间合并) O(MlogM) 先求出所有移动树木的操作的区间的并集，那么马路上剩余部分即为最终剩下树木的部分。 求所有区间的并集可以使用区间合并算法，可以参考 AcWing 803. 区间合并。时间复杂度分析 区间合并算法的时间复杂度是 O(MlogM)，其中 M 是区间数量。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 110;int n, m;PII seg[N];int main()&#123; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; seg[i].first &gt;&gt; seg[i].second; sort(seg, seg + n); int res = m + 1; int st = seg[0].first, ed = seg[0].second; for (int i = 1; i &lt; n; i ++ ) //遍历从1到n-1，n拿出来进行特判 if (seg[i].first &lt;= ed) ed = max(seg[i].second, ed); else &#123; res -= ed - st + 1; //累加结果 st = seg[i].first, ed = seg[i].second; &#125; res -= ed - st + 1; //单独计算最后一段 cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 算法3：线段树 算法4：差分思想 1234567891011121314151617int main() &#123; cin &gt;&gt; n &gt;&gt; m; int l, r; while (m --) &#123; cin &gt;&gt; l &gt;&gt; r; f[l] --; f[r + 1] ++; &#125; int val = 1, res = 0; for (int i = 0; i &lt;= n; i ++) &#123; val += f[i]; res += (val &gt;= 1); &#125; cout &lt;&lt; res; return 0;&#125; 429 奖学金（多关键字排序）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980811、重载小于号写法 #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 310;struct Person&#123; int chinese, math, english; int total; int id; bool operator&lt; (const Person&amp; W)const //这种写法固定 &#123; if (total != W.total) return total &gt; W.total; if (chinese != W.chinese) return chinese &gt; W.chinese; return id &lt; W.id; &#125;&#125;person[N];int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) &#123; int chinese, math, english; scanf(&quot;%d%d%d&quot;, &amp;chinese, &amp;math, &amp;english); int total = chinese + math + english; person[i] = &#123;chinese, math, english, total, i&#125;; &#125; sort(person + 1, person + 1 + n); for (int i = 1; i &lt;= 5; i ++ ) printf(&quot;%d %d\\n&quot;, person[i].id, person[i].total); return 0;&#125; 2、定义函数的方式来实现比较 #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 310;struct Person&#123; int chinese, math, english; int total; int id; &#125;person[N];bool cmp(Person &amp;p1,Person &amp;p2)&#123; //需要加引用 if(p1.total!=p2.total)return p1.total&gt;p2.total; //从大到小排 if(p1.chinese!=p2.chinese)return p1.chinese&gt;p2.chinese; return p1.id&lt;p2.id;//从小到大排&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) &#123; int chinese, math, english; scanf(&quot;%d%d%d&quot;, &amp;chinese, &amp;math, &amp;english); int total = chinese + math + english; person[i] = &#123;chinese, math, english, total, i&#125;; &#125; sort(person + 1, person + 1 + n,cmp); for (int i = 1; i &lt;= 5; i ++ ) printf(&quot;%d %d\\n&quot;, person[i].id, person[i].total); return 0;&#125;","categories":[{"name":"acwing","slug":"acwing","permalink":"https://zouyunkai.github.io/myblog/categories/acwing/"}],"tags":[],"author":"aoyuehan"},{"title":"编译原理综述","slug":"Compilers Principles","date":"2021-01-11T14:01:00.000Z","updated":"2022-02-26T04:29:56.908Z","comments":true,"path":"2021/01/11/Compilers Principles/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/01/11/Compilers%20Principles/","excerpt":"","text":"","categories":[{"name":"编译原理","slug":"编译原理","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"tags":[],"author":"aoyuehan"},{"title":"寒假每日一题week1","slug":"寒假每日一题week1","date":"2021-01-11T14:01:00.000Z","updated":"2022-04-03T13:18:46.047Z","comments":true,"path":"2021/01/11/寒假每日一题week1/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/01/11/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week1/","excerpt":"","text":"复杂度为10万，应该控制到nlogn 104仓库选址 （中位数最优解、贪心 ） 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;const int maxn=1e5+10; int a[maxn];int main()&#123; int n,ans=0 ; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); //nlgn级别 //nth_element(a,a+n/2,a+n); 求中位数，o(n)级别 for(int i=0;i&lt;n;i++)&#123; ans+=abs(a[i]-a[n/2]); // a[n/2]就是取中位数；累加仓库和商店之间的距离 &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; tips:nth_element() https://blog.csdn.net/sugarbliss/article/details/88050145 C++的STL库中的nth_element()方法，默认是求区间第k小的（划重点）。 举个栗子求第3小，对于 a[9]&#x3D;{4,7,6,9,1,8,2,3,5}; nth_element(a,a+2,a+9)，将下标为2，也就是第3个数放在正确的位置，求的是第3小的数a[2]。（下标从零开始） nth_element(a,a+k,a+n)，函数只是把下标为k的元素放在了正确位置，对其它元素并没有排序，当然k左边元素都小于等于它，右边元素都大于等于它，所以可以利用这个函数快速定位某个元素。 那求第k大时呢？我们可以转化成求第n-k+1小，此时下标应该是n - k。 nth_element(a,a+n-k,a+n)，将下标为n-k，也就是第n-k+1个数放在正确的位置，求的是第k大的数a[n-k]。 当然也可以把要处理的序列全变成负值，那样求得第k小就是第k大了。 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;bool cmp(int a, int b)&#123; return a &gt; b;&#125;int main()&#123; int a[9] = &#123;4,7,6,9,1,8,2,3,5&#125;; int b[9] = &#123;4,7,6,9,1,8,2,3,5&#125;; int c[9] = &#123;4,7,6,9,1,8,2,3,5&#125;; nth_element(a,a+2,a+9); //将下标为2，也就是第3个数放在正确的位置 //也就是求的是第3小 cout &lt;&lt;&quot;第3小是：&quot;&lt;&lt; a[2] &lt;&lt; endl; for(int i = 0; i &lt; 9; i++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; puts(&quot;&quot;);//注意下标是从0開始计数的 //那么求第3大，就是求第9-3+1小,即第7小 //也就是将下标为6的第7个数，放在正确的位置 nth_element(b,b+6,b+9); cout &lt;&lt;&quot;第3大是：&quot;&lt;&lt; b[6] &lt;&lt; endl; for(int i = 0; i &lt; 9; i++) cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;; puts(&quot;&quot;);//注意下标是从0開始计数的 nth_element(c,c+2,c+9,cmp);//第一种方法 //nth_element(c,c+2,c+9,greater&lt;int&gt;()); //第二种方法 cout &lt;&lt;&quot;第3大是：&quot;&lt;&lt; c[2] &lt;&lt; endl; for(int i = 0; i &lt; 9; i++) cout &lt;&lt; c[i] &lt;&lt; &quot; &quot;; //注意下标是从0開始计数的&#125; 拓展 3167 星星还是树 (一维拓展成二维 ) 模拟退火 [模拟退火的题解](POJ2420 模拟退火算法_Dog_dream的博客-CSDN博客) 898. 数字三角形 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//从下往上的一个写法 //比从上往下要好些一些，不用考虑一些特判 #include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;const int maxn=510; int shuzu[maxn][maxn];int main()&#123; int n,temp; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;=i;j++)&#123; cin&gt;&gt;shuzu[i][j]; &#125; &#125; for(int i=n-1;i&gt;0;i--)&#123;//从下往上来得到最优的ans for(int j=0;j&lt;i;j++)&#123; temp=max(shuzu[i][j],shuzu[i][j+1]); shuzu[i-1][j]+=temp; &#125; /* wa了一次，因为这地方i和j的下标不对 for(int i=n;i&gt;0;i--)&#123;//从下往上来得到最优的ans for(int j=0;j&lt;i-1;j++)&#123; temp=max(shuzu[i][j],shuzu[i][j+1]); shuzu[i-1][j]+=temp; &#125; &#125; */ //打印数组 // for(int i=0;i&lt;n;i++)&#123; // for(int j=0;j&lt;=i;j++)&#123; // cout&lt;&lt;shuzu[i][j]&lt;&lt;&quot; &quot;; // &#125; // cout&lt;&lt;endl; // &#125; &#125; cout&lt;&lt;shuzu[0][0] &lt;&lt;endl;&#125; 方法2：#include&lt;bits/stdc++.h&gt;using namespace std;const int N=510;int f[N][N];int n;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; cin&gt;&gt;f[i][j]; &#125; &#125; for(int i=n;i&gt;=1;i--)&#123; for(int j=i;j&gt;=1;j--)&#123; f[i][j]=max(f[i+1][j],f[i+1][j+1])+f[i][j]; //状态转移方程 &#125; &#125; cout&lt;&lt;f[1][1]&lt;&lt;endl;&#125;","categories":[{"name":"acwing","slug":"acwing","permalink":"https://zouyunkai.github.io/myblog/categories/acwing/"}],"tags":[],"author":"aoyuehan"},{"title":"寒假每日一题week3","slug":"寒假每日一题week3","date":"2021-01-11T14:01:00.000Z","updated":"2022-02-26T04:29:56.855Z","comments":true,"path":"2021/01/11/寒假每日一题week3/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/01/11/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week3/","excerpt":"","text":"1208. 翻硬币可以找到连个规律，1、操作的顺序对结果没有影响，2、对一个位置的改变只有一次，两次操作就会复原这个位置 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 310;string a, b;void turn(int i)&#123; if (a[i] == &#x27;*&#x27;) a[i] = &#x27;o&#x27;; else a[i] = &#x27;*&#x27;;&#125;int main()&#123; cin &gt;&gt; a &gt;&gt; b; int res = 0; for (int i = 0; i + 1 &lt; a.size(); i ++ ) if (a[i] != b[i]) &#123; res ++ ; turn(i), turn(i + 1); &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 1532 找硬币12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576算法1 哈希表 O(n)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;unordered_set&gt;using namespace std;const int INF = 10000;int main()&#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); unordered_set&lt;int&gt; hash; int v1 = INF, v2; for (int i = 0; i &lt; n; i ++ ) &#123; int a, b; scanf(&quot;%d&quot;, &amp;a); b = m - a; if (hash.count(b)!=0) //等价if (hash.find(key) != hash.end()) &#123; hash.insert(a); if (a &gt; b) swap(a, b); if (a &lt; v1) v1 = a, v2 = b; &#125; else hash.insert(a); &#125; if (v1 == INF) puts(&quot;No Solution&quot;); else printf(&quot;%d %d\\n&quot;, v1, v2); return 0;&#125;tips:if (hash.count(key)) 是判断hash表中是否存在关键字key；if (hash[key]) 是判断key对应的value值是否是真，如果key在hash表中不存在，则会先为其创建默认值，比如int的默认值是0，vector&lt;int&gt;的默认值是vector&lt;int&gt;()；算法2 双指针 O(nlogn)#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int w[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]); sort(w, w + n); for (int i = 0, j = n - 1; i &lt; j; i ++ ) &#123; while (i &lt; j &amp;&amp; w[i] + w[j] &gt; m) j -- ; if (i &lt; j &amp;&amp; w[i] + w[j] == m) &#123; printf(&quot;%d %d\\n&quot;, w[i], w[j]); return 0; &#125; &#125; puts(&quot;No Solution&quot;); return 0;&#125;","categories":[{"name":"acwing","slug":"acwing","permalink":"https://zouyunkai.github.io/myblog/categories/acwing/"}],"tags":[],"author":"aoyuehan"},{"title":"寒假每日一题week4","slug":"寒假每日一题week4","date":"2021-01-11T14:01:00.000Z","updated":"2022-02-26T03:26:59.493Z","comments":true,"path":"2021/01/11/寒假每日一题week4/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/01/11/%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week4/","excerpt":"","text":"","categories":[{"name":"acwing","slug":"acwing","permalink":"https://zouyunkai.github.io/myblog/categories/acwing/"}],"tags":[],"author":"aoyuehan"},{"title":"acwing蓝桥杯ab辅导课第一章  递归与递推","slug":"蓝桥杯ab辅导课第一章","date":"2021-01-11T14:01:00.000Z","updated":"2022-04-03T13:18:45.265Z","comments":true,"path":"2021/01/11/蓝桥杯ab辅导课第一章/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/01/11/%E8%93%9D%E6%A1%A5%E6%9D%AFab%E8%BE%85%E5%AF%BC%E8%AF%BE%E7%AC%AC%E4%B8%80%E7%AB%A0/","excerpt":"","text":"AcWing 92. 递归实现指数型枚举（枚举每个数的状态）递归搜索树，选和不选 需要考虑两个问题：（1)当前考虑的是第几个数u，（2)前面的数有没有选，即怎么存下前面已经选了的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748枚举选和不选两种方式： 方法一：//#include&lt;iostream&gt;//using namespace std;//const int maxx=17;//bool a[maxx];//int n;//void dfs(int u)&#123;// if(u&gt;n)&#123;// for(int i=1;i&lt;=n;i++)&#123;// if(a[i]==true)cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;// &#125;// cout&lt;&lt;endl;// return ;// &#125;// a[u]=true; //当前节点选还是不选 // dfs(u+1); // 进行下一个节点的选择 // a[u]=false; // 当前节点选完之后，该标志位清零，然后走该节点的另一个分支 // dfs(u+1);//&#125; ////int main()&#123;// // cin&gt;&gt;n;// dfs(1);//从1开始，往下走二叉遍历树 ；这里从1开始，dfs中就要if(u&gt;n),而不是u==n来判断是否到达叶子结点//&#125; 方法2：#include&lt;iostream&gt;using namespace std;int n;void dfs(int u,int state)&#123; if(u==n)&#123; for(int i=0;i&lt;n;i++)&#123; //判断最低位，倒数第一位，倒数第二位... if(state&gt;&gt;i&amp;1)cout&lt;&lt;i+1&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl; return ; &#125; dfs(u+1,state); //不选这一位，因为标志位被当做形参传入方法中，所以不用将标志位清0 dfs(u+1,state|1&lt;&lt;u); // 选这一位 ,将该位的二进制表示变为1 &#125; int main()&#123; cin&gt;&gt;n; //n的下标从1开始 dfs(0,0); //u从0变为1进行了一次选和不选，从1变为2进行了一次选和不选&#125; AcWing 94. 递归实现排列型枚举（这里是枚举每个坑的状态，这和选它和不选它有点区别的）在使用auto的时候出现编译错误，那么应该在编译器的编译选项中加入-std&#x3D;c++11 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int n;vector&lt;int&gt;path; //这里的path就是用来存放每个坑的信息void dfs(int u,int state)&#123; if(u==n)&#123;// for(vector&lt;int&gt;::const_iterator iter = path.begin(); iter != path.end(); iter++) for(auto x:path)cout&lt;&lt;x&lt;&lt;&#x27; &#x27;; //将记录的排列输出出来 cout&lt;&lt;endl; return ; 按理来说这里应该写return，让他不在继续执行下面的for循环了 &#125; for(int i=0;i&lt;n;i++)&#123; //针对n个坑来遍历每一个参与排列的数 if(!(state&gt;&gt;i&amp;1))&#123; //state用来存放n个数是否被选中了 path.push_back(i+1); dfs(u+1,state|1&lt;&lt;i); path.pop_back(); //这里需要在path中弹出这个数，这里是用state来存放数有没有被选的信息，但是也用了path来存选了的结点的信息，即每个坑的信息 &#125; &#125; &#125;int main()&#123; cin&gt;&gt;n; dfs(0,0); return 0;&#125; AcWing 717. 简单斐波那契12345678910111213141516171819#include&lt;stdio.h&gt;long long n,a,b=1,c;int main()&#123; scanf(&quot;%d&quot;,&amp;n); while(n--)&#123; printf(&quot;%d &quot;,a); //递推的方式 c=a+b; //先把a,b的值取出来，然后赋值给c a=b,b=c; //再把b的值给a，c的值给b，然后这样只保存要求的数的前两位数 &#125;&#125; //递归函数的写法int fun(int x)&#123; if(x == 1)return 1; if(x == 2) return 1; return fun(x-1) + fun(x-2);&#125; AcWing 95. 费解的开关123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 6;char g[N][N], backup[N][N];int dx[5] = &#123;-1, 0, 1, 0, 0&#125;, dy[5] = &#123;0, 1, 0, -1, 0&#125;;void turn(int x, int y)&#123; for (int i = 0; i &lt; 5; i ++ ) &#123; int a = x + dx[i], b = y + dy[i]; if (a &lt; 0 || a &gt;= 5 || b &lt; 0 || b &gt;= 5) continue; // 在边界外，直接忽略即可 g[a][b] ^= 1; &#125;&#125;int main()&#123; int T; cin &gt;&gt; T; while (T -- ) &#123; for (int i = 0; i &lt; 5; i ++ ) cin &gt;&gt; g[i]; int res = 10; for (int op = 0; op &lt; 32; op ++ ) //采用递推的方式，枚举第一行的所有的状态，（32中状态） &#123; memcpy(backup, g, sizeof g); //因为以后要枚举很多次，所以这里要备份一下，然后进行下一次枚举的时候再还原回去 int step = 0; for (int i = 0; i &lt; 5; i ++ ) if (op &gt;&gt; i &amp; 1) &#123; step ++ ; turn(0, i); &#125; for (int i = 0; i &lt; 4; i ++ ) for (int j = 0; j &lt; 5; j ++ ) if (g[i][j] == &#x27;0&#x27;) &#123; step ++ ; turn(i + 1, j); &#125; bool dark = false; for (int i = 0; i &lt; 5; i ++ ) if (g[4][i] == &#x27;0&#x27;) &#123; dark = true; break; &#125; if (!dark) res = min(res, step); memcpy(g, backup, sizeof g); &#125; if (res &gt; 6) res = -1; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; dfs直接暴力#include &lt;bits/stdc++.h&gt; using namespace std;int G[30][30],d[5]=&#123;0,0,1,0,-1&#125;,ans; void Rever(int r,int c)//翻转&#123; for(int i=0;i&lt;5;i++) G[r+d[i]][c+d[(i+1)%5]]^=1;&#125; void resdfs(int r,int c,int cnt)//从第二行翻转，使得上一行全为1&#123; if(cnt&gt;6) return; else if(r==6) &#123; for(int i=1;i&lt;=5;i++) if(!G[5][i]) return; ans=min(ans,cnt); return; &#125; if(c==6) &#123; resdfs(r+1,1,cnt); return; &#125; if(!G[r-1][c]) &#123; Rever(r,c); resdfs(r,c+1,cnt+1); Rever(r,c); &#125; else resdfs(r,c+1,cnt);&#125; void dfs(int c,int cnt)//枚举第一行所有的翻转可能&#123; if(c&gt;5) return; Rever(1,c); dfs(c+1,cnt+1); resdfs(2,1,cnt+1); Rever(1,c); dfs(c+1,cnt); resdfs(2,1,cnt);&#125; int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; for(int i=1;i&lt;=5;i++) for(int j=1;j&lt;=5;j++) scanf(&quot;%1d&quot;,&amp;G[i][j]); ans=7; dfs(1,0); if(ans&gt;6) ans=-1; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;————————————————版权声明：本文为CSDN博主「「已注销」」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/m0_43456754/article/details/107129787 异或运算符”∧”也称XOR运算符。它的规则是若参加运算的两个二进位同号，则结果为0（假）；异号则为1（真）。即 0∧0＝0，0∧1＝1， 1^0&#x3D;1，1∧1＝0。运算 说明0 ^ 0&#x3D;0,0 ^ 1&#x3D;1 0异或任何数，其结果&#x3D;任何数1 ^ 0&#x3D;1,1 ^ 1&#x3D;0 1异或任何数，其结果&#x3D;任何数取反x ^ x&#x3D;0 任何数异或自己，等于把自己置0————————————————版权声明：本文为CSDN博主「霁风AI」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/wwt18811707971/article/details/78291490 AcWing 93. 递归实现组合型枚举1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int n,m;void dfs(int u,int sum,int state)&#123; //u表示第几层，sum表示当前选了第几个数，state表示n个数选的状态 //这里增加一个sum的形参，就可以来选择sum个，而不用非得选择n个节点了 if(sum+n-u&lt;m)return ; //剪枝 if(sum==m)&#123; //选中m个数进行组合排列了 for(int i=0;i&lt;n;i++)&#123; if(state&gt;&gt;i&amp;1)&#123; cout&lt;&lt;i+1&lt;&lt;&#x27; &#x27;; &#125; &#125; cout&lt;&lt;endl; return ; &#125; dfs(u+1,sum+1,state|1&lt;&lt;u); //选的放在不选的上面，然后能按字典序输出 dfs(u+1,sum,state); &#125; int main()&#123; cin&gt;&gt;n&gt;&gt;m; dfs(0,0,0); return 0;&#125; dfs相关类型的总结 dfs实现指数型枚举 每个搜索树中的节点都有选和不选两种状态，void dfs(int u,int state){，样例如： 输入样例：13 输出样例：1234567322 311 31 21 2 3 dfs实现排列型枚举（排列是有顺序的，组合是没有顺序的） 枚举的是每个坑填什么数，是这些数的一个全排列 vectorpath; &#x2F;&#x2F;这里的path就是用来存放每个坑的信息void dfs(int u,int state){ 这里需要dfs一层之后从path中删掉进入path中的数 } 输入样例：13 输出样例：1234561 2 31 3 22 1 32 3 13 1 23 2 1 dfs实现组合型枚举 是n个数里选m个数进行排列，void dfs(int u,int sum,int state){ &#x2F;&#x2F;u表示第几层，sum表示当前选了第几个数，state表示n个数选的状态 输入样例：15 3 输出样例：123456789101 2 3 1 2 4 1 2 5 1 3 4 1 3 5 1 4 5 2 3 4 2 3 5 2 4 5 3 4 5","categories":[{"name":"acwing蓝桥","slug":"acwing蓝桥","permalink":"https://zouyunkai.github.io/myblog/categories/acwing%E8%93%9D%E6%A1%A5/"}],"tags":[],"author":"aoyuehan"},{"title":"","slug":"蓝桥杯ab辅导课第三章","date":"2021-01-11T14:01:00.000Z","updated":"2022-04-03T13:18:45.874Z","comments":true,"path":"2021/01/11/蓝桥杯ab辅导课第三章/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/01/11/%E8%93%9D%E6%A1%A5%E6%9D%AFab%E8%BE%85%E5%AF%BC%E8%AF%BE%E7%AC%AC%E4%B8%89%E7%AB%A0/","excerpt":"","text":"AcWing 1205. 买不到的数目数学公式不知道的时候 1、先尽力分析 2、打表找规律 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354引理：给定a，b，若d=gcd(a,b)&gt;1 ,则一定不能凑出最大数结论：如果 a,b均是正整数且互质，那么由 ax+by,x≥0,y≥0 不能凑出的最大数是 (a−1)(b−1)−1。打表找规律方法:（纯摘抄y总的笔记）#include &lt;iostream&gt;using namespace std;//给定一个m，是否能用p和q凑出来bool dfs(int m,int p,int q)&#123; if(m == 0) return true; if(m &gt;= p &amp;&amp; dfs(m - p,p,q)) return true; if(m &gt;= q &amp;&amp; dfs(m - q,p,q)) return true; return false;&#125;int main()&#123; int p,q; cin &gt;&gt; p &gt;&gt; q; int res = 0; for(int i = 1; i &lt;= 1000;i ++) &#123; if(!dfs(i,p,q)) res = i; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;解法：#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;int main()&#123; LL a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a * b - a - b &lt;&lt; endl; return 0;&#125; 回文日期(枚举,模拟) O(104) 由于只有八位数，而且回文串左右对称，因此可以只枚举左半边，这样只需枚举 0∼9999 总共一万个数，然后判断：整个八位数构成的日期是否合法；是否在范围内 时间复杂度 一共枚举 104个数，判断每个数是否合法的计算量是常数级别的，因此总计算量是 O(104)。 如果找到的数在总的枚举个数中占少数，而且枚举每种可能需要很大的复杂度，符合要求的解可以构造出来，那么就直接先构造出来符合要求的解，然后再判断这些构造出来的解是否符合情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int months[13] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;bool check(int date)&#123; int year = date / 10000; int month = date % 10000 / 100; int day = date % 100; if (!month || month &gt; 13 || !day) return false; if (month != 2 &amp;&amp; day &gt; months[month]) return false; if (month == 2) &#123; bool leap = year % 4 == 0 &amp;&amp; year % 100 || year % 400 == 0; if (day &gt; 28 + leap) return false; &#125; return true;&#125;int main()&#123; int date1, date2; cin &gt;&gt; date1 &gt;&gt; date2; int res = 0; for (int i = 0; i &lt; 10000; i ++ ) &#123; int x = i, r = i; for (int j = 0; j &lt; 4; j ++ ) r = r * 10 + x % 10, x /= 10; if (r &gt;= date1 &amp;&amp; r &lt;= date2 &amp;&amp; check(r)) res ++ ; &#125; printf(&quot;%d\\n&quot;, res); return 0;&#125; AcWing 1210. 连号区间数先懂了样例，然后枚举暴力求解，然后再想怎么优化 123456789101112131415161718192021222324252627282930313233#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010, INF = 100000000;int n;int a[N];int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++ ) cin &gt;&gt; a[i]; int res = 0; for (int i = 0; i &lt; n; i ++ ) // 枚举区间左端点 &#123; int minv = INF, maxv = -INF; for (int j = i; j &lt; n; j ++ ) // 枚举区间右端点 &#123; minv = min(minv, a[j]); maxv = max(maxv, a[j]); if (maxv - minv == j - i) res ++ ; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; AcWing 1236. 递增三元组考虑枚举的顺序，然后考虑怎么优化 当枚举a的时候，在枚举b的时候，但是b和c之间有限制关系，所以不能用符合要求的b的数量和符合要求的c的数量两者相乘。 当枚举b的时候，可以直接满足要求的a的数量和满足要求的c的数量两者相乘。 然后考虑到如何快速的在a中找到小于bj的数的个数，用二分 有哪些优化的方法、？？？总结 前缀和（某一个区间中总个数的问题）、二分（某一个区间中快速找到某一类或者某一个数）、排序（排序后容易操作）、双指针（优化区间问题、双指针同向，双指针相向）、桶排序（1e5）、map、cnt[a[i]]++、某些性质（如连号区间中区间最大值-最小值&#x3D;区间个数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384纯暴力做法：O（n^3)#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=1e5+10;int a[N],b[N],c[N];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;b[i]); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;c[i]); sort(a,a+n); sort(b,b+n); sort(c,c+n); int ans=0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(a[i]&lt;b[j])&#123; for(int k=0;k&lt;n;k++)&#123; if(b[j]&lt;c[k])&#123; ans+=(n-k); break; &#125;else&#123; continue; &#125; &#125; &#125;else&#123; continue; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;枚举bj的思想，用前缀和进行优化 #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 100010;int n;int a[N], b[N], c[N];int as[N]; // as[i]表示在A[]中有多少个数小于b[i]int cs[N]; // cs[i]表示在C[]中有多少个数大于b[i]int cnt[N], s[N];int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]), a[i] ++ ; for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;b[i]), b[i] ++ ; for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;c[i]), c[i] ++ ; // 求as[] for (int i = 0; i &lt; n; i ++ ) cnt[a[i]] ++ ; for (int i = 1; i &lt; N; i ++ ) s[i] = s[i - 1] + cnt[i]; // 求cnt[]的前缀和 for (int i = 0; i &lt; n; i ++ ) as[i] = s[b[i] - 1]; // 求cs[] memset(cnt, 0, sizeof cnt); memset(s, 0, sizeof s); for (int i = 0; i &lt; n; i ++ ) cnt[c[i]] ++ ; for (int i = 1; i &lt; N; i ++ ) s[i] = s[i - 1] + cnt[i]; for (int i = 0; i &lt; n; i ++ ) cs[i] = s[N - 1] - s[b[i]]; // 枚举每个b[i] LL res = 0; for (int i = 0; i &lt; n; i ++ ) res += (LL)as[i] * cs[i]; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 前缀和主要用在什么地方？ 统计某个区间中值的总和，一个技巧就是cnt[a[i]]++ AcWing 1229. 日期问题日期之间不是三个数abc的组合，而且还需要 判断每个月多少天，每年是不是闰年等等的限制关系。 枚举的时候一定别忘记去重（因为多种情况下可能会重复，但是答案输出的时候认为是同一个ans），注意边界条件，注意各种枚举的情况，注意枚举变量之间的相互制约关系等等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197手动去重的方式：#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef struct &#123; int year; int mon; int day;&#125; node;bool cmp( node node1, node node2) &#123; if(node1.year!=node2.year)return node1.year&lt;node2.year; if(node1.mon!=node2.mon)return node1.mon&lt;node2.mon; return node1.day&lt;node2.day;&#125;int a,b,c;vector&lt;node&gt;n; int isrunnian(int a) &#123; //判断闰年 if(a%4==0&amp;&amp;a%100!=0||a%400==0)return 1; else return 0;&#125;int yeartemp;int d[13]= &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int check(int a,int b,int c) &#123; //处理年份 if((a/10)==0) &#123; //a只有一位数 a=2000+a; &#125; else &#123; if(a&lt;=59) &#123; a=2000+a; &#125; else &#123; a=1900+a; &#125; &#125; yeartemp=a; //在方法中通过全局变量想main函数中传值 if(isrunnian(a)) &#123; //是闰年 if(b==0||b&gt;12)return 0; //b 和c都要判断边界！！！！ if(b==2) &#123; //闰年的2月特殊判断 if(c==0||c&gt;d[b]+1)return 0; &#125; else &#123; if(c==0||c&gt;d[b])return 0; &#125; return 1; &#125; else &#123; if(b==0||b&gt;12)return 0; if(c==0||c&gt;d[b])return 0; return 1; &#125;&#125;int main() &#123; scanf(&quot;%d/%d/%d&quot;,&amp;a,&amp;b,&amp;c); if(a==c) &#123; //如果年份相等 if(a==b) &#123; //a==b=c if(check(a,b,c)) &#123; n.push_back(&#123;yeartemp,b,c&#125;); &#125; &#125; else &#123; //a==c!=b if(check(a,b,c)) &#123; n.push_back(&#123;yeartemp,b,c&#125;); &#125; if(check(c,a,b)) &#123; n.push_back(&#123;yeartemp,a,b&#125;); &#125; if(check(c,b,a)) &#123; n.push_back(&#123;yeartemp,b,a&#125;); &#125; &#125; &#125; else &#123; if(a==b) &#123; //a==b，but，a！=c if(check(a,b,c)) &#123; n.push_back(&#123;yeartemp,b,c&#125;); &#125; if(check(c,a,b)) &#123; n.push_back(&#123;yeartemp,a,b&#125;); &#125; &#125; else &#123; //三者都不相等 if(check(a,b,c)) &#123; n.push_back(&#123;yeartemp,b,c&#125;); &#125; if(check(c,a,b)) &#123; n.push_back(&#123;yeartemp,a,b&#125;); &#125; if(check(c,b,a)) &#123; n.push_back(&#123;yeartemp,b,a&#125;); &#125; &#125; &#125; //下面这样就不和题意了，题意 采用年/月/日的，有采用月/日/年的，还有采用日/月/年的// for(int i=0;i&lt;3;i++)&#123;// for(int j=0;j&lt;3;j++)&#123;// for(int k=0;k&lt;3;k++)&#123;// if(i!=j&amp;&amp;i!=k&amp;&amp;j!=k)&#123;// if(check(a[i],a[j],a[k]))&#123;// n.push_back(&#123;yeartemp,a[j],a[k]&#125;);// &#125;// &#125;// &#125;// &#125;// &#125; sort(n.begin(),n.end(),cmp); for(auto x:n) &#123; printf(&quot;%d-%02d-%02d\\n&quot;,x.year,x.mon,x.day);// cout&lt;&lt;x.year&lt;&lt;&quot;-&quot;&lt;&lt;x.mon&lt;&lt;&quot;-&quot;&lt;&lt;x.day&lt;&lt;endl; &#125; return 0;&#125;对vector进行去重的方法：#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef struct &#123; int year; int mon; int day;&#125; node;//第二种方式bool operator&lt;(const node &amp;node1,const node &amp;node2) &#123; if(node1.year!=node2.year)return node1.year&lt;node2.year; if(node1.mon!=node2.mon)return node1.mon&lt;node2.mon; return node1.day&lt;node2.day;&#125;bool operator==(const node &amp;node1,const node &amp;node2) &#123; if(node1.year==node2.year&amp;&amp;node1.mon==node2.mon&amp;&amp;node1.day==node2.day)return true; return false;&#125;int a,b,c;vector&lt;node&gt;n;int isrunnian(int a) &#123; //判断闰年 if(a%4==0&amp;&amp;a%100!=0||a%400==0)return 1; else return 0;&#125;int yeartemp;int d[13]= &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int check(int a,int b,int c) &#123; //处理年份 if((a/10)==0) &#123; //a只有一位数 a=2000+a; &#125; else &#123; if(a&lt;=59) &#123; a=2000+a; &#125; else &#123; a=1900+a; &#125; &#125; yeartemp=a; //在方法中通过全局变量想main函数中传值 if(isrunnian(a)) &#123; //是闰年 if(b==0||b&gt;12)return 0; //b 和c都要判断边界！！！！ if(b==2) &#123; //闰年的2月特殊判断 if(c==0||c&gt;d[b]+1)return 0; &#125; else &#123; if(c==0||c&gt;d[b])return 0; &#125; return 1; &#125; else &#123; if(b==0||b&gt;12)return 0; if(c==0||c&gt;d[b])return 0; return 1; &#125;&#125;int main() &#123; scanf(&quot;%d/%d/%d&quot;,&amp;a,&amp;b,&amp;c); if(check(a,b,c)) &#123; n.push_back(&#123;yeartemp,b,c&#125;); &#125; if(check(c,a,b)) &#123; n.push_back(&#123;yeartemp,a,b&#125;); &#125; if(check(c,b,a)) &#123; n.push_back(&#123;yeartemp,b,a&#125;); &#125; sort(n.begin(),n.end()); //枚举了这三种情况，有可能会遇到重复的情况 set&lt;node&gt;s(n.begin(), n.end()); n.assign(s.begin(), s.end()); //STL中不同容器之间是不能直接赋值的，assign（）可以实现不同容器但相容的类型赋值 //方法二：n.erase(unique(n.begin(), n.end()), n.end()); for(auto x:n) &#123; printf(&quot;%d-%02d-%02d\\n&quot;,x.year,x.mon,x.day); &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int days[13] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;bool check_valid(int year, int month, int day)&#123; if (month == 0 || month &gt; 12) return false; if (day == 0) return false; if (month != 2) &#123; if (day &gt; days[month]) return false; &#125; else &#123; int leap = year % 100 &amp;&amp; year % 4 == 0 || year % 400 == 0; if (day &gt; 28 + leap) return false; &#125; return true;&#125;int main()&#123; int a, b, c; scanf(&quot;%d/%d/%d&quot;, &amp;a, &amp;b, &amp;c); for (int date = 19600101; date &lt;= 20591231; date ++ ) &#123; int year = date / 10000, month = date % 10000 / 100, day = date % 100; if (check_valid(year, month, day)) &#123; //这样可以不用去重 if (year % 100 == a &amp;&amp; month == b &amp;&amp; day == c || // 年/月/日 month == a &amp;&amp; day == b &amp;&amp; year % 100 == c || // 月/日/年 day == a &amp;&amp; month == b &amp;&amp;year % 100 == c) // 日/月/年 printf(&quot;%d-%02d-%02d\\n&quot;, year, month, day); &#125; &#125; return 0;&#125; 1231航班问题 (流水行船的问题)12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int get_seconds(int h,int m,int s)&#123; return h*3600+m*60+s;&#125;int get_time()&#123; string line;// cin&gt;&gt;line; 这样只能获取一个字符串，不是一整行 getline(cin,line); if(line.back()!=&#x27;)&#x27;)line.append(&quot; (+0)&quot;); int h1,m1,s1,h2,m2,s2,d; sscanf(line.c_str(),&quot;%d:%d:%d %d:%d:%d (+%d)&quot;,&amp;h1,&amp;m1,&amp;s1,&amp;h2,&amp;m2,&amp;s2,&amp;d);// cout&lt;&lt;line&lt;&lt;endl; //sscanf在cstdio中 return get_seconds(h2,m2,s2)-get_seconds(h1,m1,s1)+d*24*3600; /* sscanf是c语言的函数，不能直接传入字符串；需要c_str将string转为char* strcpy( dtm, &quot;Saturday March 25 1989&quot; ); sscanf( dtm, &quot;%s %s %d %d&quot;, weekday, month, &amp;day, &amp;year ); */&#125;int main()&#123; int n; cin&gt;&gt;n; //scanf不会吸收行末的回车的 ，可以格式化输入；但scanf一个数之后，如要getline，这俩之间还是得吸收回车的 getchar(); //cin 不会丢弃回车符，会跳过回车符 while(n--)&#123; int time=(get_time()+get_time())/2; int hour=time/3600; int minute=time%3600/60,second=time%60;//这里不知道是/还是%的话，就带一个例子进去试一试 printf(&quot;%02d:%02d:%02d\\n&quot;,hour,minute,second); &#125; return 0;&#125; 字符串和数字的互换方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;using namespace std;const int MaxN = 10000;int line;int data[MaxN];void s2i(string &amp;str, int &amp;num) &#123;//s2i是str to int的意思 stringstream ss; //stringstream可以从string对象中读入和输出 ss &lt;&lt; str; ss &gt;&gt; num; //这样可以实现string转为int类型&#125;int main(int argc, const char *argv[]) &#123; scanf(&quot;%d&quot;, &amp;line); getchar(); //c语言中的输入函数不会吸收回车，当遇到getline的时候，需要手动吸收一下回车，不然就会被getline获取到 int index = 0; for (int i = 0; i &lt; line; ++i) &#123; string s; getline(cin, s); istringstream iss(s); //从string对象中读取到iss中 string tmp; while (getline(iss, tmp, &#x27; &#x27;)) &#123; s2i(tmp, data[index++]); &#125; /* 其中while循环也可以这么写 while(iss&gt;&gt;tmp)&#123; s2i(tmp, data[index++]); &#125; */ &#125;// 最终index就是数据的个数// cout &lt;&lt; index &lt;&lt; endl;//排序 sort(data, data + index); int a, b; for (int i = 1; i &lt; index; ++i) &#123; if (data[i] == data[i - 1] + 2)a = data[i] - 1;//printf(&quot;%d &quot;, data[i] - 1); if (data[i] == data[i - 1]) b = data[i];//printf(&quot;%d&quot;, data[i]); &#125; printf(&quot;%d %d&quot;, a, b); return 0;&#125;方式2：#include &lt;iostream&gt; #include &lt;sstream&gt; //用到stringstream时必须引入的头文件using namespace std; int main() &#123; istringstream istr(&quot;1 56.7&quot;); //str()：使istringstream对象返回一个string字符串 cout&lt;&lt;istr.str()&lt;&lt;endl;//直接输出字符串的数据 &quot;1 56.7&quot; string str = istr.str();//函数str()返回一个字符串 cout&lt;&lt;str&lt;&lt;endl; int n; double d; //以空格为界，把istringstream中数据取出，应进行类型转换 istr&gt;&gt;n;//第一个数为整型数据，输出1 istr&gt;&gt;d;//第二个数位浮点数，输出56.7 //假设换下存储类型 istr&gt;&gt;d;//istringstream第一个数要自动变成浮点型，输出仍为1 istr&gt;&gt;n;//istringstream第二个数要自动变成整型，有数字的阶段，输出为56 //测试输出 cout&lt;&lt;d&lt;&lt;endl; cout&lt;&lt;n&lt;&lt;endl; system(&quot;pause&quot;); return 1; &#125; /*字符串变基本数据类型*/ #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; using namespace std; int main() &#123; /*字符串 变 double*/ double n; string str = &quot;12.5&quot;; stringstream stream; stream &lt;&lt; str; stream &gt;&gt; n; cout&lt;&lt;n&lt;&lt;endl; stream.clear();//多次使用stringstream，要先清空下,不能使用stream.str(&quot;&quot;);,claer()它并不清空任何内容，它只是重置了流的状态标志而已 /*string 变 char* */ string str1 = &quot;china&quot;; char cStr[10]; stream &lt;&lt; str1; stream &gt;&gt; cStr; cout&lt;&lt;cStr&lt;&lt;endl;//输出china system(&quot;pause&quot;); return 1; &#125;","categories":[{"name":"acwing蓝桥","slug":"acwing蓝桥","permalink":"https://zouyunkai.github.io/myblog/categories/acwing%E8%93%9D%E6%A1%A5/"}],"tags":[],"author":"aoyuehan"},{"title":"acwing蓝桥杯ab辅导课第二章  二分与前缀和","slug":"蓝桥杯ab辅导课第二章","date":"2021-01-11T14:01:00.000Z","updated":"2022-04-03T13:18:43.009Z","comments":true,"path":"2021/01/11/蓝桥杯ab辅导课第二章/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/01/11/%E8%93%9D%E6%A1%A5%E6%9D%AFab%E8%BE%85%E5%AF%BC%E8%AF%BE%E7%AC%AC%E4%BA%8C%E7%AB%A0/","excerpt":"","text":"AcWing 789. 数的范围（整数二分）二分要求 区间有二段性（二段性就是大于等于某个数有什么性质，小于某个数有什么性质）（有的也具有单调性也可以解题 整数二分的步骤 1.找一个区间[L,R] ，使得答案一定在该区间中。2.找一个判断条件，使得该判断条件具有二段性，并且该答案一定是二段性的分界点。3.分析中点M在该判断条件下是否成立，如果成立，考虑答案是在哪个区间；如果不成立，考虑答案在哪个区间。4.如果更新方式是R&#x3D;MID，则不用做任何处理；如果更新方式是L&#x3D;MID，则需要在计算MId的时候加上1，（l&#x3D;mid时加1的原因在于： int mid &#x3D; l + r &gt;&gt; 1;是向下取整的，加上1的原因是为了让r取mid-1之后也能让l继续逼近上线r，不至于出现死循环的现象）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;int&gt;v;int n,q,k,temp;int main()&#123; cin&gt;&gt;n&gt;&gt;q; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;temp; v.push_back(temp); &#125; while(q--)&#123; cin&gt;&gt;k; int l=0,r=v.size()-1; // 1、确定区间范围 //二分找结果区间的左端点，找第一个大于等于k的位置 while(l&lt;r)&#123; int mid=l+r&gt;&gt;1; if(v[mid]&gt;=k)r=mid;//2、找到分段点 else l=mid+1; &#125; if(v[l]==k)&#123;//找到第一个值等于k的位置，这里也可以传入[0,n],然后判断while之后，l的结果是不是等于n来判断，找到的第一个大于等于k的位置在什么地方 cout&lt;&lt;l&lt;&lt;&#x27; &#x27;; r=v.size()-1; //二分找结果区间的右端点，找最后一个小于等于k的位置 while(l&lt;r)&#123; int mid=l+r+1&gt;&gt;1;//找右端点的时候才需要向上取整 ,如l=1，r=1，然后就会出现死循环 //// 因为写的是l = mid，所以需要补上1 if(v[mid]&lt;=k)l=mid; //找小于等于k的点，所以这里为小于等于 else r=mid-1; &#125; if(v[l]==k)&#123; cout&lt;&lt;l&lt;&lt;endl; &#125; &#125;else&#123; //当二分左区间跳出while时，l一定等于r cout&lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl; &#125; &#125; return 0;&#125; tips：//二分找结果区间的左端点，找第一个大于k的位置 while(l&lt;r)&#123; int mid=l+r&gt;&gt;1;//这里不需要+1，不需要向上取整 if(v[mid]&gt;k)r=mid; //找大于k的点，当v[mid]大于k的时候，r=mid else l=mid+1; &#125; lower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找的。在从小到大的排序数组中， lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 在从大到小的排序数组中，重载lower_bound()和upper_bound() lower_bound( begin,end,num,greater() ):从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 upper_bound( begin,end,num,greater() ):从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100000+10;const int INF=2*int(1e9)+10;#define LL long longint cmd(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; int num[6]=&#123;1,2,4,7,15,34&#125;; sort(num,num+6); //按从小到大排序 int pos1=lower_bound(num,num+6,7)-num; //返回数组中第一个大于或等于被查数的值 int pos2=upper_bound(num,num+6,7)-num; //返回数组中第一个大于被查数的值 cout&lt;&lt;pos1&lt;&lt;&quot; &quot;&lt;&lt;num[pos1]&lt;&lt;endl; cout&lt;&lt;pos2&lt;&lt;&quot; &quot;&lt;&lt;num[pos2]&lt;&lt;endl; sort(num,num+6,cmd); //按从大到小排序 int pos3=lower_bound(num,num+6,7,greater&lt;int&gt;())-num; //返回数组中第一个小于或等于被查数的值 int pos4=upper_bound(num,num+6,7,greater&lt;int&gt;())-num; //返回数组中第一个小于被查数的值 cout&lt;&lt;pos3&lt;&lt;&quot; &quot;&lt;&lt;num[pos3]&lt;&lt;endl; cout&lt;&lt;pos4&lt;&lt;&quot; &quot;&lt;&lt;num[pos4]&lt;&lt;endl; return 0; &#125; ————————————————版权声明：本文为CSDN博主「brandong」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_40160605/article/details/80150252 前缀和树状数组和线段树的复杂度为logn级别的，但可以动态查询，而前缀和只能处理静态数组。 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;const int N = 100010;int a[N], s[N];int main() &#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); //scanf的时候别忘记了&amp; s[i] = s[i-1] + a[i]; //特殊规定：s[0]=0 &#125; while (m--) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; printf(&quot;%d\\n&quot;, s[r] - s[l - 1]); //当l=r=1的时候，s[l-1]=s[0]，边界也是可以的 &#125; return 0;&#125; AcWing 790. 数的三次方根（浮点数二分）12345678910111213141516171819202122#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; double x; cin &gt;&gt; x; double l = -10000, r = 10000; while (r - l &gt; 1e-8) //这里缩小了两个数量级 &#123; double mid = (l + r) / 2; if (mid * mid * mid &gt;= x) r = mid; //判断mid和所要求的x之间的关系，这里没有整数二分中的+1还是-1的问题 else l = mid; &#125; printf(&quot;%lf\\n&quot;, l); return 0;&#125; AcWing 1221. 四平方和#include 没导入，但是导入algorithm库能用sqrt，但是acwing上会报错，本地能编译通过 cpu一秒钟大约处理10e8 我第一次做的时候没有注意到字典序最小的这个问题，直接从最大的开始往前找的，所以就错了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132暴力做法O(N3)超时#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 2500010;int n;int main()&#123; cin &gt;&gt; n; for (int a = 0; a * a &lt;= n; a ++ ) for (int b = a; a * a + b * b &lt;= n; b ++ ) for (int c = b; a * a + b * b + c * c &lt;= n; c ++ ) &#123; int t = n - a * a - b * b - c * c; int d = sqrt(t); //这里可以少一层for循环，d可以直接通过t来求得 if (d * d == t) &#123; printf(&quot;%d %d %d %d\\n&quot;, a, b, c, d); return 0; &#125; &#125;&#125;通过二分进行优化三层for循环O(N2logN)#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int N = 2500010;struct Sum&#123; int s, c, d; bool operator&lt; (const Sum &amp;t)const &#123; if (s != t.s) return s &lt; t.s; if (c != t.c) return c &lt; t.c; return d &lt; t.d; &#125;&#125;sum[N];int n, m;int main()&#123; cin &gt;&gt; n; for (int c = 0; c * c &lt;= n; c ++ ) for (int d = c; c * c + d * d &lt;= n; d ++ ) sum[m ++ ] = &#123;c * c + d * d, c, d&#125;; sort(sum, sum + m); //sum数组具有二段性和单调性，假设我们要找的c * c + d * d等于summid，那么当我们取大于summid的值的时候，结果会大于 n - a * a - b * b，当我们取小于summid的值的时候，结果会小于 n - a * a - b * b，所以能通过二分找到最符合要求的那一个 for (int a = 0; a * a &lt;= n; a ++ ) for (int b = 0; a * a + b * b &lt;= n; b ++ ) &#123; int t = n - a * a - b * b; int l = 0, r = m - 1; while (l &lt; r) //找到最合适的那一个c * c + d * d的值 &#123; int mid = l + r &gt;&gt; 1; if (sum[mid].s &gt;= t) r = mid; else l = mid + 1; &#125; if (sum[l].s == t) &#123; printf(&quot;%d %d %d %d\\n&quot;, a, b, sum[l].c, sum[l].d); return 0; &#125; &#125; return 0;&#125;哈希表O(N2)超时#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 2500010;int n, m;unordered_map&lt;int, PII&gt; S;int main()&#123; cin &gt;&gt; n; for (int c = 0; c * c &lt;= n; c ++ ) for (int d = c; c * c + d * d &lt;= n; d ++ ) &#123; int t = c * c + d * d; if (S.count(t) == 0) S[t] = &#123;c, d&#125;; &#125; for (int a = 0; a * a &lt;= n; a ++ ) for (int b = 0; a * a + b * b &lt;= n; b ++ ) &#123; int t = n - a * a - b * b; if (S.count(t)) &#123; printf(&quot;%d %d %d %d\\n&quot;, a, b, S[t].x, S[t].y); return 0; &#125; &#125; return 0;&#125; AcWing 730. 机器人跳跃问题(二分答案)出现最大值最小值的问题中，一般枚举答案，先二分，dfs，dp，贪心 假如E0是初始值，然后当E取大于E0的时候，这些初始值都是符合要求的，所以该题具有二段性。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n;int h[N];bool check(int e)&#123; for (int i = 1; i &lt;= n; i ++ ) &#123; e = e * 2 - h[i]; if (e &gt;= 1e5) return true; if (e &lt; 0) return false; &#125; return true;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]); int l = 0, r = 1e5; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; else l = mid + 1; &#125; printf(&quot;%d\\n&quot;, r); return 0;&#125; 1236. 递增三元组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=1e5+10;int a[N],b[N],c[N];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;b[i]); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;c[i]); sort(a,a+n); sort(b,b+n); sort(c,c+n); long long ans=0; for(int i=0;i&lt;n;i++)&#123; int tem1=(lower_bound(a,a+n,b[i])-a); int tem2=n-(upper_bound(c,c+n,b[i])-c);// cout&lt;&lt;tem1&lt;&lt;&quot; &quot;&lt;&lt;tem2&lt;&lt;endl; ans+=(long long)tem1*tem2; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;手写lower_bound(),找第一个大于等于k的位置 #include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=1e5+10;int a[N],b[N],c[N];int lower_bound(int l,int r,int k)&#123; while(l+1&lt;r)&#123; int mid=(l+r)&gt;&gt;1; if(a[mid]&gt;=k)r=mid; else l=mid; &#125; return r;&#125; int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;b[i]); for(int i=0;i&lt;n;i++)scanf(&quot;%d&quot;,&amp;c[i]); sort(a,a+n); sort(b,b+n); sort(c,c+n); long long ans=0; for(int i=0;i&lt;n;i++)&#123;// int tem1=(lower_bound(a,a+n,b[i])-a); int tem1=lower_bound(-1,n,b[i]); int tem2=n-(upper_bound(c,c+n,b[i])-c); // cout&lt;&lt;tem1&lt;&lt;&quot; &quot;&lt;&lt;tem2&lt;&lt;endl; ans+=(long long)tem1*tem2; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"acwing蓝桥","slug":"acwing蓝桥","permalink":"https://zouyunkai.github.io/myblog/categories/acwing%E8%93%9D%E6%A1%A5/"}],"tags":[],"author":"aoyuehan"},{"title":"acwing蓝桥杯ab辅导课第十章 疑难杂题","slug":"蓝桥杯ab辅导课第五章","date":"2021-01-11T14:01:00.000Z","updated":"2022-04-03T13:18:44.771Z","comments":true,"path":"2021/01/11/蓝桥杯ab辅导课第五章/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/01/11/%E8%93%9D%E6%A1%A5%E6%9D%AFab%E8%BE%85%E5%AF%BC%E8%AF%BE%E7%AC%AC%E4%BA%94%E7%AB%A0/","excerpt":"","text":"AcWing 1242. 修改数组12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;const int N = 1100010;int p[N];int find(int x)&#123; if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; N; i ++ ) p[i] = i; for (int i = 1; i &lt;= n; i ++ ) &#123; int x; scanf(&quot;%d&quot;, &amp;x); x = find(x); printf(&quot;%d &quot;, x); p[x] = x + 1; &#125; return 0;&#125;作者：yxc链接：https://www.acwing.com/activity/content/code/content/212363/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 洛谷p1551 并查集并查集讲解 知乎 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#define MAXN 5005int fa[MAXN], rank[MAXN];inline void init(int n)&#123; for (int i = 1; i &lt;= n; ++i) &#123; fa[i] = i; //初始化 让每个节点都指向自己 rank[i] = 1; &#125;&#125;int find(int x)&#123; return x == fa[x] ? x : (fa[x] = find(fa[x])); //这里用的路径压缩，让所有节点都直接指向根节点&#125;inline void merge(int i, int j)&#123; int x = find(i), y = find(j); if (rank[x] &lt;= rank[y]) //按秩的大小 来合并，rank数组就是存放 秩的大小 fa[x] = y; else fa[y] = x; if (rank[x] == rank[y] &amp;&amp; x != y) rank[y]++;&#125;int main()&#123; int n, m, p, x, y; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;p); init(n); for (int i = 0; i &lt; m; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); merge(x, y); &#125; for (int i = 0; i &lt; p; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); printf(&quot;%s\\n&quot;, find(x) == find(y) ? &quot;Yes&quot; : &quot;No&quot;); &#125; return 0;&#125; AcWing 1264. 动态求连续区间和树状数组： 更新过程是每次加了个二进制的低位1(101+1 -&gt;110, 110 + 10 -&gt; 1000, 1000 + 1000 -&gt; 10000) 查询过程每次就是去掉了二进制中的低位1(1111 - 1 -&gt; 1110, 1110 - 10 -&gt; 1100, 1100 - 100 -&gt; 1000) 标记为灰色的节点实际已被上层覆盖,不占据空间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128树状数组的写法#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int a[N], tr[N]; int lowbit(int x) //lowbit(x)是取出x的最低位1&#123; return x &amp; -x;&#125;void add(int x, int v)&#123; for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += v;&#125;int query(int x)&#123; int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);//必须从下标1开始存放 for (int i = 1; i &lt;= n; i ++ ) add(i, a[i]); while (m -- ) &#123; int k, x, y; scanf(&quot;%d%d%d&quot;, &amp;k, &amp;x, &amp;y); if (k == 0) printf(&quot;%d\\n&quot;, query(y) - query(x - 1)); //这里求区间[a,b]，得用query(b)-query(a-1)，这样求出来的才是区间[a,b]之间值的总和大小 else add(x, y); &#125; return 0;&#125; 线段树的写法#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int n, m;int w[N];struct Node&#123; int l, r; int sum;&#125;tr[N * 4];void pushup(int u)&#123; tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;&#125;void build(int u, int l, int r)&#123; if (l == r) tr[u] = &#123;l, r, w[r]&#125;; else &#123; tr[u] = &#123;l, r&#125;; int mid = l + r &gt;&gt; 1; build(u &lt;&lt; 1, l, mid), build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); &#125;&#125;int query(int u, int l, int r)&#123; if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum; int mid = tr[u].l + tr[u].r &gt;&gt; 1; int sum = 0; if (l &lt;= mid) sum = query(u &lt;&lt; 1, l, r); if (r &gt; mid) sum += query(u &lt;&lt; 1 | 1, l, r); return sum;&#125;void modify(int u, int x, int v)&#123; if (tr[u].l == tr[u].r) tr[u].sum += v; else &#123; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if (x &lt;= mid) modify(u &lt;&lt; 1, x, v); else modify(u &lt;&lt; 1 | 1, x, v); pushup(u); &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;w[i]); build(1, 1, n); int k, a, b; while (m -- ) &#123; scanf(&quot;%d%d%d&quot;, &amp;k, &amp;a, &amp;b); if (k == 0) printf(&quot;%d\\n&quot;, query(1l, a, b)); else modify(1, a, b); &#125; return 0;&#125;作者：yxc链接：https://www.acwing.com/activity/content/code/content/168768/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 AcWing 1215. 小朋友排队1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N = 1000010;int n;int h[N], tr[N]; //按照数值的大小开一个树状数组，然后每统计一个数的k1，k2的时候，就把该数加入到树状数组中，然后之后再统计//其他前面比小朋友高的人的人数，后面比小朋友矮的的人的个数int sum[N];int lowbit(int x)&#123; return x &amp; -x;&#125;void add(int x, int v)&#123; for (int i = x; i &lt; N; i += lowbit(i)) tr[i] += v;&#125;int query(int x)&#123; int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;h[i]), h[i] ++ ; // 求每个数前面有多少个数比它大 for (int i = 0; i &lt; n; i ++ ) &#123; sum[i] = query(N - 1) - query(h[i]); add(h[i], 1); &#125; // 每个数后面有多少个数比它小 memset(tr, 0, sizeof tr); for (int i = n - 1; i &gt;= 0; i -- ) &#123; sum[i] += query(h[i] - 1); add(h[i], 1); &#125; LL res = 0; for (int i = 0; i &lt; n; i ++ ) res += (LL)sum[i] * (sum[i] + 1) / 2; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","categories":[{"name":"acwing蓝桥","slug":"acwing蓝桥","permalink":"https://zouyunkai.github.io/myblog/categories/acwing%E8%93%9D%E6%A1%A5/"}],"tags":[],"author":"aoyuehan"},{"title":"acwing蓝桥杯ab辅导课第六章 双指针、BFS与图论","slug":"蓝桥杯ab辅导课第六章","date":"2021-01-11T14:01:00.000Z","updated":"2022-04-03T13:18:46.056Z","comments":true,"path":"2021/01/11/蓝桥杯ab辅导课第六章/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/01/11/%E8%93%9D%E6%A1%A5%E6%9D%AFab%E8%BE%85%E5%AF%BC%E8%AF%BE%E7%AC%AC%E5%85%AD%E7%AB%A0/","excerpt":"","text":"AcWing 1238. 日志统计纯暴力做法：枚举每个时间段，复杂度为1e9 因为第一个时间段这地方优化不了，但是内层for循环可以进行优化 因为上一个时间段和下一个时间段之间有重复的部分，即下一段时间比上一段时间少了开头的一个，多了结尾的一个，所以可以通过双指针思想优化这种区间问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N = 100010;int n, d, k;PII logs[N];int cnt[N];bool st[N]; // 记录每个帖子是否是热帖int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;d, &amp;k); for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d%d&quot;, &amp;logs[i].x, &amp;logs[i].y); sort(logs, logs + n); for (int i = 0, j = 0; i &lt; n; i ++ ) &#123; //i在前，j在后 双指针，j往后走一个，i就往后走一个 int id = logs[i].y; cnt[id] ++ ; while (logs[i].x - logs[j].x &gt;= d) //因为[T,T+D)为半开区间 &#123; cnt[logs[j].y] -- ; //大小为d的区间向后移动一位，进行处理 j ++ ; &#125; if (cnt[id] &gt;= k) st[id] = true; //如果该区间的最左端点的出现次数大于k，则标记为热帖 &#125; for (int i = 0; i &lt;= 100000; i ++ ) if (st[i]) printf(&quot;%d\\n&quot;, i); return 0;&#125; AcWing 1101. 献给阿尔吉侬的花束求最短路的题 bfs floodfill bfs和dfs都可以做，此时不需要最短路的求解，这三种都可以求是否可以同起点一直走到终点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int,int&gt;PII;const int N=210;int dist[N][N];char g[N][N];int t,r,c;int bfs(PII start,PII end)&#123; queue&lt;PII&gt;q; memset(dist,-1,sizeof(dist)); //如果需要多次搜索的话，每一次搜索之前要将dist数组（判断图中节点被遍历时候的最小步数）清0 dist[start.x][start.y]=0; q.push(start);// int dx[4]=&#123;0,1,0,-1&#125;,dy[4]=&#123;1,0,-1,0&#125;; int dx[4] = &#123;-1, 0, 1, 0&#125;, dy[4] = &#123;0, 1, 0, -1&#125;; while(!q.empty())&#123; auto t=q.front(); q.pop(); for(int i=0;i&lt;4;i++)&#123; //选择队头元素，遍历队头元素的各个方向 int x=t.x+dx[i],y=t.y+dy[i]; if(x&lt;0||x&gt;=r||y&lt;0||y&gt;=c||g[x][y]==&#x27;#&#x27;||dist[x][y]!=-1)continue; //获取新的位置，然后判断是否越界 //是否越界、能走、并且没有走过 //这里的x一定要大于r，不是大于c dist[x][y]=dist[t.x][t.y]+1; //记录走到该节点的最小步数 if(end==make_pair(x,y))return dist[x][y]; //如果终点进队，则返回该节点的最小步数 q.push(&#123;x,y&#125;); //将新的节点加入到队尾 &#125; &#125; return -1;&#125;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;r&gt;&gt;c; PII start,end; for(int i=0;i&lt;r;i++)&#123; for(int j=0;j&lt;c;j++)&#123; cin&gt;&gt;g[i][j]; if(g[i][j]==&#x27;S&#x27;)start=&#123;i,j&#125;; else if(g[i][j]==&#x27;E&#x27;)end=&#123;i,j&#125;; &#125; &#125;// for(int i=0;i&lt;r;i++)&#123;// // for(int j=0;j&lt;c;j++)&#123;// cout&lt;&lt;g[i][j]&lt;&lt;&#x27; &#x27; ;// &#125;// cout&lt;&lt;endl;// &#125; int distance=bfs(start,end); if(distance==-1) puts(&quot;oop!&quot;); //要输出的东西一定要复制题目给你的，不然会手打错了 else printf(&quot;%d\\n&quot;,distance); &#125; return 0;&#125; AcWing 1113. 红与黑（寒假每日一题week2）","categories":[{"name":"acwing蓝桥","slug":"acwing蓝桥","permalink":"https://zouyunkai.github.io/myblog/categories/acwing%E8%93%9D%E6%A1%A5/"}],"tags":[],"author":"aoyuehan"},{"title":"acwing蓝桥杯ab辅导课第十章 疑难杂题","slug":"蓝桥杯ab辅导课第十章","date":"2021-01-11T14:01:00.000Z","updated":"2022-02-26T03:27:00.438Z","comments":true,"path":"2021/01/11/蓝桥杯ab辅导课第十章/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/01/11/%E8%93%9D%E6%A1%A5%E6%9D%AFab%E8%BE%85%E5%AF%BC%E8%AF%BE%E7%AC%AC%E5%8D%81%E7%AB%A0/","excerpt":"","text":"AcWing 1242. 修改数组12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;const int N = 1100010;int p[N];int find(int x)&#123; if (p[x] != x) p[x] = find(p[x]); return p[x];&#125;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; N; i ++ ) p[i] = i; for (int i = 1; i &lt;= n; i ++ ) &#123; int x; scanf(&quot;%d&quot;, &amp;x); x = find(x); printf(&quot;%d &quot;, x); p[x] = x + 1; &#125; return 0;&#125;作者：yxc链接：https://www.acwing.com/activity/content/code/content/212363/来源：AcWing著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"acwing蓝桥","slug":"acwing蓝桥","permalink":"https://zouyunkai.github.io/myblog/categories/acwing%E8%93%9D%E6%A1%A5/"}],"tags":[],"author":"aoyuehan"},{"title":"acwing蓝桥杯ab辅导课第二章","slug":"蓝桥杯ab辅导课第四章","date":"2021-01-11T14:01:00.000Z","updated":"2022-04-03T13:18:43.018Z","comments":true,"path":"2021/01/11/蓝桥杯ab辅导课第四章/","link":"","permalink":"https://zouyunkai.github.io/myblog/2021/01/11/%E8%93%9D%E6%A1%A5%E6%9D%AFab%E8%BE%85%E5%AF%BC%E8%AF%BE%E7%AC%AC%E5%9B%9B%E7%AB%A0/","excerpt":"","text":"求第k个数AcWing 788.逆序对的数量（归并排序）123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;typedef long long ll;const int N=1e6+10;int tem[N],q[N];ll res=0; //res为全局变量，这样子只能计算一次 //因为总的逆序对的数量是n-1,n-2,..1的总和（即序列逆序）；//即(n-1)*(n-2)/2，n=1e6的时候res会爆int ;//2^32-1=4 294 967 296（42亿）=4e9,但是分为正负的话，int的范围就是-2e9~2e9void merge(int l,int mid,int r)&#123; //闭区间[l,r] for(int i=l;i&lt;=r;i++)tem[i]=q[i]; //将数组a（即要排序的那个数组）中的数放入临时数组b中 int k=l,i=l,j=mid+1; while(i&lt;=mid&amp;&amp;j&lt;=r) &#123; //i 和j两个指针分别遍历临时b数组 if(tem[i]&lt;=tem[j])q[k++]=tem[i++];//比较临时b数组的左右两段中的元素，将较小值重新放回数组q else &#123; res+=mid-i+1; //统计逆序对的数量 q[k++]=tem[j++]; //这里别忘了j++ &#125; &#125; while(i&lt;=mid)q[k++]=tem[i++]; //当数组b中左右两段中有一段的下标超出其对应的表长的时候，将另一段的剩余部分直接复制到a数组中 while(j&lt;=r)q[k++]=tem[j++];//扫尾 &#125;void merge_sort(int l,int r)&#123;//返回的就是这段区间中的 if(l&gt;=r)return ;//或者if(l==r)return 0; int mid=l+r&gt;&gt;1; merge_sort(l,mid); //分治的思想，左边排完序，右边排序，然后用merge合并起来 merge_sort(mid+1,r); merge(l,mid,r); &#125; int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)cin&gt;&gt;q[i]; merge_sort(0,n-1);//这里传入的是区间[0,n-1] 都是闭区间，相比数组q[0..n]来说的 cout&lt;&lt;res&lt;&lt;endl; return 0;&#125; AcWing 1245. 特别数的和特判一个数的每一位数值是啥 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int res = 0; for (int i = 1; i &lt;= n; i ++ ) &#123; int x = i; while (x) &#123; int t = x % 10; // 取出x的个位 x /= 10; // 删掉x的个位 if (t == 2 || t == 0 || t == 1 || t == 9) &#123; res += i; break; //只是统计包含2 ，0， 1， 9数的个数，所以说，该位符合要求了，直接res++即可，一定不要忘记了break &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; https://www.acwing.com/video/659/ 数的三次方根a前缀和子矩阵的和差分差分矩阵数学基础的时候（6月中旬之前必须过一遍基础）： 高数：我的是汤家凤（比较简单）的基础为主，然后张宇（比较难一点点）的高数基础为辅。我同学也有跟武忠祥的高数的，听说武忠祥的难度中等。 书的话，就是汤家凤的高数辅导讲义（百度云网盘里的视频讲义）、汤家凤的高数1800题；张宇的基础三十讲和300题 线代：李永乐，我还没开始 英语的话（四月之前过一遍语法和单词，五月开始阅读） 语法：田静老师的 句句真研（这个22年的还刚发售，看电子版的） 单词的话：马天艺的单词之间（我刚要买还没买来这，打算现在去背这本书），朱伟的真题5500词（就叫恋恋有词，黄皮的，我看了一遍，发现初期用这本书有点难懂，后期看好像还可以）；还有就是可以百词斩和墨墨背单词app来背单词","categories":[{"name":"acwing蓝桥","slug":"acwing蓝桥","permalink":"https://zouyunkai.github.io/myblog/categories/acwing%E8%93%9D%E6%A1%A5/"}],"tags":[],"author":"aoyuehan"},{"title":"《我的恋爱观》","slug":"恋爱观恋爱","date":"2020-12-04T06:13:00.000Z","updated":"2022-04-23T12:08:27.170Z","comments":true,"path":"2020/12/04/恋爱观恋爱/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/12/04/%E6%81%8B%E7%88%B1%E8%A7%82%E6%81%8B%E7%88%B1/","excerpt":"","text":"个人大学有关感情方面的一些思想见解如何让自己变得更好 超越同龄人的一些技能 男孩子，要阳光、大气、干净利落、办事靠谱、高情商、会共情、大格局、人前不唯唯诺诺 下面说的这男生的可以吸引女孩子更喜欢的特质（是来自是叫你恋爱的喵喵呀@bili）主要是up说的跟我对待喜欢的人的有些动作，找到了一些解释理由。 硬 ‘你得听我的’，刚交往的时候不要怕对方不开心，吃饭出去玩，不用什么都得请示一下，知道了有没有什么忌口或者特别在意的地方就好，然后约吃饭的话，就下点功夫找一下比较好的餐厅，说我定了xx餐厅的xx，晚上和你一起去。别问，问就是没主见，问就是没担当。再着说，情侣吵架，吵的时候说，男方说我们冷静一下吧，等女方真的冷静下来的时候，就真的凉了。直接按在墙上亲，亲到她双腿发软，，，。 奶 说白了就是会撒娇，硬完之后才有奶，硬是常态，奶是偶尔的甜点，男生撒起娇来，女生是顶不住的，女生有把你当妈的感觉，那就要小心了。 奶不是温柔，温柔的前提是包容，就代表这你默认把自己放到了更高的位置上，但奶喝撒娇就不一样，你把对方当成了包容你的人，就给对方一种需要照顾你，保护你的感觉。 贱 “嘴贱”+“手贱”，这里的贱是不能带有侮辱性质的，不管是男生女生都吃这一套，但是你得学会控制分寸，但凡关系好点的，没事你就跑去，给她捣乱，闹腾，藏他杯子，摸她头发，没事你就损她，偶尔你有一次认真，他会觉着你也有认真的一面。但也别太过火，不然就处成了兄弟。只有自己能贱，但凡别人给她没事找事的时候，一律出手给她解决了。 作 作就是作死，不仅要带着自己作，去玩一些好玩的地方。还要带着她一起作。吊桥效应。带着女生玩开！哪有女生不喜欢能带她玩还能保护自己的呐。 如何让恋爱更长久（算是我两年半来的体会叭） 答应好对方的事要上心 对方可能因为你记得他随口说的一句小事，随口答应的一件事，会感到很幸福。不起眼的小事都要好好记下来，比如说因为帮你什么事，约定好说给你买几个小蛋糕，不要说完之后就没有下文了。 学会磨掉自己的棱角 两个人活在不一样的家庭，过了好几十年不一样的生活，总会有一些让对方都感觉到不太舒服的地方，那怎么办？ 这时候双方要坐下来谈一谈，怎么让自己过的还挺舒服，同时也让对方过得也挺舒服，磨掉自己的一些个性，培养一些共性。 遇到问题肯定也不是一个人的错，不能感觉都是对方的错，这时应该先反思自己，在从对方找道一些问题，然后双方达成共识，以后就不会再出现这样的问题了。 比如：遇到一件让自己生气的事，先找个东西发泄一下自己（合理的方式），然后不要想着自己没错，自己没有问题。 一方生气的时候，另一方一定更要稳住 摆平心态 如果一方生气的话，另一方更不能火上浇油，如果没猜对对方是怎么想的，某一件是是怎么做的，为什么这样做， 那千万不要说出自己胡乱猜测的观点（站在自己角度上的想法，并不一定是对方想的），让对方自己说出来自己内心的想法。 有矛盾了，双方都不要冷战，静下心来好好谈谈，但是都冷静下来好好谈，这一点真的很难做到。 学会反思 学会定期的反思自己有什么地方做的不太好，有什么地方没有做到，是不是用心了。对方什么地方让自己感觉到不是很舒服的时候要及时说出来，不要自己憋在心理，时间长了，这些一点点的失望积累起来就是冲破堤坝的那最后一击。 在乎与偏爱 怎么让对方感觉到你在乎他，可能就是早起来的那一句早安，睡前的那一句晚安，可能不起眼，但是谁闲的没事干，给不重要的人问一声早。或者是自己挣钱了拉着对方去吃好吃的。 还有可能就是事事有回应，件件有着落。事事放在心上，不论什么事，你的优先级都是最高的那种。 让对方感觉到你在乎他，而不是一次次的让对方失望。 男孩子不要吝啬自己的宠爱，女孩子也不要当对方的爱是理所当然 什么事都是男孩子做，这不理所当然吗，这样对嘛，如果女生想不平等的对待男方，那么就不要去抱怨 社会上女性的不平等。什么时候做什么事，如果你角色互换一下，然后在自己的角度上看对方做这件事是不是合适，如果自己都不想做这件事，为什么要让对方做。 角色互换！ 互相尊重的限度在哪 可以互看手机吗，可以干一些什么事，有度吗？如果两个人事先约定一些事，那么可以在遇到某些事的时候可能会好一些。比如有一方喜欢吵架摔东西就走，不处理问题。那么可以约定两个人可以吵架，但是要在一个房间里，谁也不须在吵架的时候走开。 性格 性格是一个人对现实的稳定的态度，以及与这种态度相应的，习惯化了的行为方式中表现出来的人格特征。性格一经形成便比较稳定，但是并非一成不变，而是可塑性的。 在心理学上，性格被分解为态度特征、意志特征、情绪特征和理智特征四个组成成分。 性格没有好坏，但是真的可以改，如果对方感觉能改一下，让对方和自己都变得很舒服的话，就相互体谅一下吧。 打游戏要不要停下游戏回复对方 看中外人感受，但是不看重最重要的人的感受 怎么才能让别人感觉你是最在乎他的，坐座位，去答辩进屋应该先想到去找他，或者给她发个消息说我在干什么了，我要做自己要干的事了。 实例 然后你说了这我做错了什么了吗，发现你每次和我吵架也好，干啥事也好，都是先分析对错，还记得上次那数据结构课坐座位的时候，还是上次整闺蜜那次，还是那次啥凭成绩算奖学金那次，都先来说 我做错了什么吗，那这样有啥意思，分对错，你没有错的话，那错误不就在另一个人身上了，痛苦和伤心都让另一个承受，而且另一个人就一定做错了吗，我们俩当中的一个错了，那个错的人都不好受，我们俩不应该是一个整体的嘛，我要是难受了，你不应该会心疼我嘛，不分对错，一个人做的不好的时候就多一点体谅，坏坏的事也都不要记在心里，像我，我只会把不开心开心的都记在日记里，然后心里只装下开心的事，不开心的事随风 和女人吵架是吵不赢的，这句话有理有理，青春期叛逆那，会跟我妈吵架也是，从来没赢过 不要自以为是的认为都是对方的错！！！ 和异性相处，但让对方感觉最舒服的那种模式，不和异性搞暧昧 在我看来，隔三差五的联系就已经很不正常了 要注意到一些思维差异，比如男生总是在出了事或者出了问题的时候会下意识的去想怎么解决问题。而女生会先去考虑情感情绪。如果当两个人走往自己的方向走，那么就很容易走入死胡同。因此比如男生可以先照顾一下女生的情绪，然后在去解决处理问题。 不要以自我为中心，其后果就可能是你生气的来源之一。比如你认为x是对的，然后如果客观的看，站在别人的角度上看，这件事其实并不如你自己想的那样，不一定就是对的。 如何哄人，如何避免误解加深？ 首先就是先树立起哄的心态！！！ 1、把事情的经过叙述一遍，是什么情况 2、自己当时为什么那样做，心路历程说一下 3、以后应该怎样做 要素说清楚：时间地点人物，是什么为什么怎么做，+小礼物 另外，防患于未然，又不舒服的地方一定要直说，直说！！！ 双方都要有自己的主见，不要迁就另一方 比如有一方爱熬夜，另一方要按时睡觉早起，这时候早睡的那一方如果说了想睡觉，但是另一方会不会因为不陪他了而会生气呐，这时候的解决方式。 平常的小事要注意到对方之后的感受 比如出去吃饭玩，还是AA的好，界限不用太刻意，毕竟也花不了多少钱，但要有着这样的想法。毕竟时间久了，容易让另一方感觉到另一方做的事都是理所当然，会越来越冲破另一方，让对方乱想，他是不是爱我，爱我为什么不会给我花钱，为什么不会把我放心上。 就算对方在怎么宠你，到最后，也会因为找不到说服自己的理由想要离开你了。 互相了解对方的方式 立个规矩吧，以后有啥不想说或者说不出来的就去对方留言板留言，或者给我写小纸条，这样的交流能让自己说不出来或者不想说的想法也能让对方知道。 懂对方的心思，不仅要会猜，也要猜对（不要猜，别人让你猜，你就反问） 不要站在自己的立场想对方的行为，如果对方的这种行为是自己理解不了的话，那就会出现矛盾，应该站在对方的立场想问题，学会多一点理解和包容。 钱钟书说，如果你爱一个人，那就和她去旅行，如果旅行过后你们仍旧相爱，那就结婚吧。 《围城》中，钱钟书借赵辛楣之口说的原话是这样的：“旅行时最劳顿、最麻烦、叫人本相毕现的时候，经过长期苦行而彼此不讨厌的人，才可以结交朋友……结婚以后的蜜月旅行是次序颠倒的，应该先同旅行一个月，一个月舟车仆仆以后，双方还没有彼此看破，彼此厌恶，还没有吵嘴翻脸，还要维持原来的婚约，这种夫妇保证不会离婚 不要让对方和自己都受委屈，委屈了的时候要说出来，这个不想面对面说出来，可以通过留言写小纸条等方式。 喜欢的一首歌 我曾经问母亲，这些年和父亲总是吵架，却又能相濡以沫的一起走过二十几年的秘诀，母亲长叹了口气，看着我语重心长的说道：“以前啊，我们买东西放到家里用，用坏了我们只是想着将它修补好，而现在的人用坏了的东西不是想着修好，而是丢掉，买新的。没啥别的诀窍，就是找到问题解决，包容对方的小毛病，而爱的意义就是包容，付出，两个人之间只有相互包容，磨合才可以走到最后……” 听完母亲的话，我想起和她的过往，其实很多感情，只要坚持一下，体谅一下，就会有不同的结局了，就好像克里斯这样，爱情就是包容，付出 这首歌的名字叫what are words？(什么是诺言) 讲道理？错！冷静？大错！和她争执？大错特错！正解答案！！大吼一声！你漂亮、温柔、善良、可爱 网上有个问题：什么情况下，你才更懂得伴侣的重要性？ 有个高赞的回答说：在升职后踌躇满志却无人倾诉时，在良辰美景却无人分享时，在生病了急需一杯温开水时，在人生低谷最需要陪伴和鼓励时。 其实，即使你的另一半再完美，生活中都会有许多矛盾，需要互相包容、理解和体谅。 于大多数人而言，婚姻是一种风雨同舟的承担，是一份有福同享、有难同当的承诺，也是一种有人问你粥可温、有人与你立黄昏的平淡相守。 看过这样一句话：“婚姻的纽带，不是孩子，不是金钱，而是精神的共同成长。” 喜欢的人要有点孩子气 https://kuaibao.qq.com/s/20190826AZMPD500?refer=spider 三观是看待某件事的三观，有自己的什么想法 想要啥，想干啥，要直说 爱情不是1+1&#x3D;2 而是0.5+0.5&#x3D;1 即 两人各削去一半自己的个性和缺点 ，发挥出来1+1大于2的效果 一定不要真的去相信一个人能改正一些你看不惯的或者你不接受不了的行为，这种人真的很难很难改变的，而且很多人都很难真的懂得现在所做的事、所做的改变都是为了更好的两个人。 20210709 突然看到，补充一些这段时间的所见所感吧 现在想来，可能当初应该早一点分开会更好。估计当初有次吵架之后，就已经埋下了最后会分开的决定吧，每次吵架，都是我来认错，我来道歉，我来求着她一样，真的有点让我走不下去了，一次次的这样，可能 是我第一次学怎么爱别人的原因吧，谦让了好多，（其实，以前并没有感觉到委屈是什么样的，其实后来体会到了好多），也好不想放弃。虽然最后她还是没有谦让我，还是会说，不要改变我，好多事她自己心里憋着，有着自己的想法也还是不告诉我，最后两个人也是谁也不让谁。其实，现在想想，我变的成熟了好多，也成长了好多，不会再像以前那么太小孩子气，介意好多好多，也会理解好多事，可能这就像是，那句话说的那样，我可能就像是一锅排骨汤，可能她只是走到这个锅前的看一眼的人吧。她可能再也不会看到这些文字，可能除了我也不会有谁再看见这个我心里的自述。最后一眼，大体记得是在寒假放假的时候吧，当初，不知道竟然真的就是最后一眼，那一眼，我已经模糊了，在那一眼里，已经和她过完了一生，以后可能也不会想起，也不会想念。 要走的人可能早有预谋，可能不是说出来的那时候就是想走的那时候了。 现在想起来以前看到的一句话，人确实不是一个长情的动物，一般来说,多巴胺的浓度高峰可以持续6个月到4年左右的时间,平均不到30个月(约两年半)，所以，一段恋爱的长度可能就只有两年半吧，再往后，靠的就是爱了，是这一个人的性格、做事态度、情绪管理能力、有没有责任感、以及一些需要花很长时间培养起来的爱好、以及一些伦理道德方面的三观吧。而这些，不像是几句情话，一段时间的突然对你好，而这些都是很难装的，而且，恐怕是没有几年也了解不了一个人是不是那样一个人。 然而活着就是一个不断的纠错的过程，不加意志支撑而顺其自然得过活，得到的必然是堕落与平庸； 至死不渝的路上，不管是爱情，工作还是别的一些事情，都有太多的诱惑和无力，如果我顺其自然，累了就不予理睬，烦了就乱发脾气，厌倦了就寻找新欢，那可能永远都逃不过新鲜的死循环。 听过一句话说的是：长情靠的是修炼。被打磨的是洪荒初始的我自己，在爱一个人的路上，我要会学会克制、担当、明辨是非，我会学会发声，为爱发声，为真实自我发声，我会在平凡中制造美好，平添滋味……我会学会奉献，不仔汲汲于无穷私欲，为了你我他，为了信仰，一路守护。我不喜欢野蛮的天性，长情爱人让我们变成更好的自己。 虽然，我不在相信人是长情的，但我会不去理睬外界的诱惑（比如，遇到了比当前更好，更合适的人，要不是抛弃当前这个，其实我肯定不会抛弃当前这个人的！ 虽然这法律可能没规定这条，但社会道德告诉我，如果选择了后来的人，我可能这辈子都可能过意不去），若，我喜欢上了一个人，就会只对一个人好，我做的都是为了能一直一直走下去的，就算我可能被别人先抛弃，但我也不会先去抛弃爱我的人。 我越想，其实我好像离最后的的那一碗浓浓的排骨汤还很远。两个人遇到了事想到的不应该是不合适，而应该是怎么去解决问题，不是回避，而是想怎么和对方一起走下去。可以吵架，但不要冷冰冰。 20几岁的男生，这时候可能什么都没有，但是如果有个姑娘能在我身边，我知道一生很短，而且以后你也都会在我身边，两个人一起慢慢变好，相互陪伴一生，这是多美好的事啊。 有时候，帮她干一些事，能让你丧失你想干而又不能干的事，比如计划执行不完，一次次的颓废，但是，我好像看到了一个很好的例子，就是舍友樊雯昊，有一次，我跟着他一起去学习，他到了教室就跟他对象说去学习了，然后就关掉手机，啥也不想，就很认真的学习，然后中午学完，问他对象要不要一起去吃饭，他那种学习就好好学习，找对象玩就好好玩的态度就是我看来比较好的那种。 熬 熬出头 修炼本事 明白自己的择偶标准 20181001的一条 找对象标准能和我一块孝顺你我的父母，能把我父母当她亲生父母对待的有什么事别太傲娇行不，一起心平气和的商量着来什么事都别骗我，即使有错都能包容一下什么事都别发火在我宠的住的范围内别太懒就行能耐的下心，人好。 就算是有了对象之后也不要放弃自己喜欢的的人生目标和生活2022.1.3看到这个标题，这是我一两年前根本不认同的观点，当时认为喜欢一个人，在一起了，应该合二为一，可以为了对方放弃掉自己喜欢的一些事，要把自己全部的心思都用在对方身上。 可是现在的我有一些私心了，可能是因为知道不知道面前的这个人是不是最后一个，就先现在，当她不在我身旁之后我发现，我发现我什么也没有了，不管是付出的真心或者是别的什么，自己以前想做的事也是，自私一些把自己的时间精力都没有给自己留一点点。 另外在某个文章里看到的（也只能说仁者见仁吧）有人说在爱情里面女人容易被爱情冲昏头脑，不仅女人是这样，男人也有相同的表现，因为情商低显得非常没有层次，一般不会得到女人的芳心。 从恋爱心理学的角度出发，一个男人层次越低，越喜欢做这6件事，看看你男朋友是不是这样。 1.总喜欢斤斤计较 恋爱的时候，男人为了给女人留下良好的印象，总会隐藏真实的自己。但是时间久了，就会暴露自己的本性，比如男人总喜欢斤斤计较，喜欢较真，让女人非常心寒。当女人花钱买了一件喜欢的衣服，虽然有点贵，但是自己很喜欢，也就无所谓了，但是男人开始唠叨，嫌女人不会过日子，乱花钱，最后两个人矛盾越来越多，女人也就有了分手的念头。 2.不为被人考虑 俗话说：“江山易改本性难移。”男人不管谈了多少次恋爱， 永远像一个长不大的孩子，因为性子过于直接，常常惹女人生气。男人从来学不会替别人考虑，只想让别人接受真实的自己，不愿自己做出改变，非常倔强。 3.总是提起前任 一个男人层次越低，越喜欢提起自己的前任，不知道是不是真实的，他会把过往的经历当成向别人炫耀的资本。更要命的是，他还会拿前任和现任进行对比，根本不知道女人这个时候其实已经火冒三丈。虽然自己说的很舒服，但是严重伤害了女人的自尊心。 4.情商低 很多男人被称为“钢铁直男”，就是因为他们的情商低，不懂女人的心思，让女人很抓狂。这些低情商的男人不懂得人情世故，说出的话经常会伤害到别人的，但是自己却一无所知。就好像女人大姨妈来，他只会提醒女人多喝白开水，殊不知女人想要的其实是他可以陪伴在自己身边。 5.冲女人发脾气 一个男人层次越低，越喜欢向自己最爱的人发火，有时候还会动手打女人，这样的男人简直就是顶级渣男，女人一定要远离。这是一个男人最没出息的表现，尤其是将自己的负面情绪带给自己最爱的女人。真正高层次的男人首先是一个懂得尊重女人的人，知道如何控制自己的脾气，学会排解负面情绪，不给周围人带来负能量。 6.劈腿或者出轨 现在很多男人动不动就劈腿或者出轨，一次又一次伤害女人的心，这种男人比较花心，对自己所做的事情不会负责任。对于这样的男人，希望所有女人都不要遇到。 什么样的词可以用来赞美她？ 心理学上有实验专门对两套词汇列表分别找不同的被试进行测试，测试结果发现最受欢迎的和最不受欢迎的词汇列表分别如下： 受欢迎的词汇比如：爱，幸福，快乐，舒服，金钱，安全，新鲜，容易，利益，值得，真实，健康，漂亮，活泼…… 不受欢迎的词汇比如：悲伤，困难，成本，辛苦，损害，死亡，破坏，合约，责任，义务，失败，压力，价格…… 从这两组词汇中可以得出这样的结论：当你想去说服一个人喜欢你、接纳你、赞同你，那你就该学着用积极的方式去感染他。 tips：这好像是她的闺蜜发给我的一句话说出来可能话有些难听，我感觉你就像是被分手的不甘心，之前发生的事情我差不多也知道，你俩因为那件事其实也吵过很多次了，并且也没有任何的解决方法，其实这已经很说明问题了 我感觉叭，生活也并非只有爱情，你想好以后的人生规划了嘛？ 但是，最后我记得，这个人没有保守说我不想让她知道的事。解决方法那就是都往后退一步，重新思考，可是我推步的时候只看见你一直往前。其实，当时不应该和她闺蜜讨论说我和她的事，虽然，但是两个人的事应该让两个人来决定，其他的人都是局外人，其他人不应该成为决定你和对方关系的一个变量，而且女生更不应该和闺蜜吐槽或者一起去揣测男生的想法，直接面对面问对方不就好了。揣测的越多，猜忌，乱想，某个点都被无限的放大。 而且这不甘心 我是第一次听说，后来看过好多关于感情方面的文章或者故事，我才知道当时我自己的心情可能是不甘心就这样子在一起这么久，然后我也把你打算在未来里了，但是我们好像没有未来了这样的不甘心占了35%，然后剩下的65%是我心疼你，那可能就是love的含义，我这一世不能陪着你守护你，我以前也是把你放在了父母的地位之上。 可能并不是因为钱，而是因为看得见的在乎和偏爱；男生女生追求被爱安全感的时候好像都一样，任何男女矛盾的最底层我认为就是：无非是对方做的不符合自己的预期，或者在其他异性眼里，自己失去了特殊性。 2022 年元旦看到这篇文章再补充一些吧 我承认在考研的这段时间有一段时间想起来她，因为住的地方前面有一个公园，她以前开车带我去过，那地方还有个大厦，上面有四个字，叫平安xx，还有。。。，有时候没有把自己逼的很紧迫的时候，还是会晚上突然一下想到她，满心的愧疚感夹杂着伤心，但是也会想到她的态度我们肯定也是回不去的，对就是那种复杂的心情，有时候到凌晨难以入睡，有时候一想，胸前一阵汗，胳膊窝也是一阵汗，翻来覆去，回忆起好多，有好多事真的不像是学过的知识，真的想忘也忘不掉，确实蛮痛苦的，也吃过一个来月的助眠的药，但还好在一遍遍的之后，自己在想起来，心里的波澜不像以前那么大了，后来的日子也算是步入了一点点正轨。即使以后走不同的路，陪你走过一段路也属实荣幸。 我在很平常的一天放弃了一个很重要的人，虽然有点舍不得，但当时的我也是满心欢喜，也该告一段落了。 现在的我，哎，有些事真的很难忘记，比如一想起来198开头的手机号，总会下意识的想起来她的手机号。随着时间的推移，有些事情真的也在慢慢的淡忘，有些细节已经想不起来了。虽然刚开始是我脾气不好，后来生气了，我第一次找她复合，后来他说了一句话，说那这些事我也不能视而不见啊，我知道他的态度，也可能是双方都走向了猜忌最不好的那一个方向，之后两个人都没有挽留。也大概是我也知道可能就现在这样子这状态，我在心里也默默的对自己说，好像也走不下去了，好像也没有未来了。最后啥也都删了，希望我再也不要来打扰你了，就当彼此在彼此世界里没了吧。现在的我也不相信男女之间有纯洁的友谊。 站在过去是为了更好的未来，其实我也不是很想要更好的未来，可能出于自暴自弃，或者麻木了，或者，这方面我没认清我自己。 现在也终于能接受两个互相走在一起的人然后分开这样的事实，以前一点也不相信，但现在信了。 其实，也不能因为以前遇到过啥就麻木了，就不干在收起以前去接纳新的人。 但是我可能到了些许成熟，也还留着些孩子气，也不是麻木，也还信一点点的爱情。在《90后婚介所》上听到一句话说，为什么有个女孩说，如果你可以选择，你最希望你是你男朋友的第几次恋爱，有个很赞同的观点就是：第一次可能因为不成熟，第二次可能因为年轻走向了极端，所以第三次更成熟一些，更。。。 我好像也是，再来一次，我可能会好很多，没有太大的大男孩子气，成熟一些，稳重一些，也有一些能力，也见过一点点的世面，也更了解我自己。但是好像不是特别想去寻找，有就有，没有，我还是特别想把父母放在第一位上。 因为现代社会的信息爆炸式增长，每个人又被自己所在的信息茧房所包围，使得他们一直接受同质化极其严重的各类信息。由此很容易就形成“认知闭合效应”。这背后反映出的也是大学生在校园生活中最容易、也最不愿意接受的命题与事实。–高校大学生恋爱行为逻辑以及分手原因分析 刘昱含，井然 懂得接纳，善于沟通，可以共情，习惯感恩。 现在看来，其实最好的分手或者对某些人道别方式就是，就是互删再也不见，哪怕有着很多的事牵扯着，或者….。周围的人没有一个人知道你的联系方式，各自走在人海里再也不会相遇，再也不会知道关于你的事，从此，我可能会再想起来这个人，或许也是想念，但仅仅只是那样，再也不会惦念这个人，不管这个人过得好与坏，我也不会为她感到高兴或者难受，就当这世间我在这，但你不在了。 新鲜感是和旧的人体验新的事，而不是和新的人体验旧的事。恋爱不应该出现包容，而应该是接纳，出现包容，然后下意识的多去付出，然后这天平就歪了，最后就会是付出多了，凭什么和付出了很多但是得到的很少。就应该是当你得到的很多的时候，你很满，这时候多给予对方一些，然后当自己缺少的时候，对自己的爱多一些，然后当自己的能量多起来的时候，就能多分给对方一些。 意难平。我动了离开你的念头。不是因为你不好，也不是因为不爱了。而是你对我的态度，让我觉得你的世界并不缺我。问题的本质不是给不给我发早安，不是因为在乎某些物质金钱（我能回忆起来跟你最深刻的时候就是我打工一个月，给了奶奶几百块，剩下的我都给你买了礼物），是我想要看的见的在乎。我们的感情就在几段潦草的文字中结束了，分的好匆匆，我也没有提起面子去找你，哪怕再送你一束花，一起吃一顿好吃的。可能男生想要的所谓的安全感不是说你不能和异性说话，不是说你的列表里不能有任何一个异性，而是你永远无条件无理由的偏向他，是你永远不会否定他，是你一直在奔向他，并坚定不移的选择他，不管别人说什么，你都会感觉他在放屁呐，我男朋友全世界最好，是你无论吃饭睡觉上厕所都会跟他说一声，而不是让他一味地去猜，你今天一天都干了什么，真正爱一个人也不过如此了。 我熬过了所有的苦难，我已经不期待和谁在一起了。以后我可能不会刻意等谁。只是后来喜欢不上别人了。 最招人喜欢的两类女生，一种是像失足妇女一样的良家妇女；另一种是像良家妇女一样的失足妇女。像流氓一样的君子，像君子一样的流氓。你不该咫尺含羞，爱不是没碰到就缩回的手，你是一场明天无凡事的烈酒，我举杯不是为了消愁，爱是过瘾且自由。 当荷尔蒙用光了，激情褪去了，那爱情是什么？悲观的答案是：是怨声载道，是互相抬杠，是失去所有的面纱、光环之后，看到的另一个赤裸裸的躯体。是拿去情感、学识、教养跟静读后，看到的另一只穿衣服的猴子。 而积极的答案是：是两个互相迁就的灵魂，在同一时空互换见识，分享观点。是两个独立精神的换位思考与推己及人，是两种不同人格的自我克制与迁就。 在一段关系里 最重要的可能是接纳和真诚。而在这之下打基础的是自信、大方、眼里有光、阳光、积极、心细、共情等等…..真诚就是你不用撒谎，你不用装作你没有的样子。不要成为一个爱情里被反复忽略牺牲的人。 昨晚上一直没睡着，就想着如果对方一天没给我发消息,然后想起了以前，对，就是那种感觉就是和你关系好的人或者在乎你的人，一天不跟给发消息，我就回感觉到被冷落了。但是现在因为好多事，我竟然变了，反而感觉到每天刻意的说着早安晚安倒不是现在最想要的，好的关系 emm 结伴同行 不用说话也可以。 确实 女生还是要经济恋爱人格都独立一点点，就那种不是特别依赖谁，有着那种辩证性观点。以前我都自己认为女朋友只要依赖我就好，啥都听我的。但是现在其实认为女生有着自己那种独立一些对女生好一些，不管有没有这个男生 ，这个女生都可以有底气的干自己想干的事，这可能就是真的为对方好，哪怕最后陪在女生身边的不是那个男生。 一些其他的 就是有一个人，她去占了我在教室里占的一个考研的位子，然后我加她心思跟她说一声，我搬走了，你可以搬些书放在那里。后来她一直没同意，到了放假了好久之后，我都忘记这会事儿了，她那个小号同意了，然后我跟她说我搬走了，然后我很单纯的好奇的问了一下考什么的，然后她回答了之后说，我还有男朋友，我不能跟你聊很多。哇啊，我当时直接，我认为太好了这女孩，我记得当时我前女友，可能可能不会这样子，而且当时我还因为这样的事和她吵过好多次，而且分手的原因了这个估计也能占一部分。什么时候陪在我身边的姑娘这样一个人，知道我会胡思乱想，而且不会跟我说和别的男生聊天这很正常啊这样的话，那真的很幸运吧 大学生恋爱适应与关系满意度的纵向研究（曾美红 李霞）：此外，研究表明T1男性恋爱适应可正向预测T2男女双方恋爱适应及恋爱满意度，且这种影响在T2至T3时持续存在，但T1至T2、T2至T3女性的恋爱适应并未对男性的恋爱适应及双方满意度产生影响。这说明男性的恋爱适应行为不仅有利于提高当下的女性关系满意度，也更有力地促进未来彼此更好的适应及关系满意度。相比于男性，女性更具情感反应性和表达力，更有效地处理情感信息，因而女性更容易意识到男性的恋爱适应行为，进而有利于提高女性的恋爱满意度。男性对关系的敏感程度低于女性，而且对关系没有太多的要求，因而可能较少觉察到女性的恋爱适应行为。这些因素都可能导致男性的恋爱适应行为对一段长期关系的影响可能大于女性的恋爱适应行为。此外，交叉滞后分析还发现T1男性的恋爱满意度负向预测T2女性的恋爱适应及其恋爱满意度。这可能因为男性在一段关系中认为找到了理想伴侣，对关系自我感觉良好，便较少期待对方做出改变。 此外，男性多采用以问题为中心的思维模式，没有问题就不会进行改变。男性也更容易忽视关系问题，而女性对于另一半的契合程度要求更高，因而可能慢慢造成女性关系满意度的降低。然而，TI女性的恋爱满意度显著正向预测T2男女双方的恋爱适应及彼此的恋爱满意度，这表明女性的恋爱满意度对一段关系质量的重要性。相比于男性，女性更注重关系的未来发展，在亲密关系中会做出更多的关系维护行为。当她们对一段关系感到满意时，可能提供一种心理环境，激发伴侣引发相应的行为，来强化自己的初始满意度，进而导致男性做出更多的恋爱适应行为。而且女性更感性，更情绪化，更容易表现出更强烈的爱、喜欢、快乐和满足，因而对关系感到满意的女性可能容易把积极情感体验传递给男性，从而提高男性的恋爱满意度。但是T2男女恋爱满意度均未对T3男女恋爱适应及恋爱满意度产生影响，这可能因为本研究的被试还处于恋爱阶段，关系存在较多不稳定的因素，容易受日常生活事件的影响，个体恋爱满意度也容易发生变化。总之，男女思维模式、关系需求和情感表达方式等导致男女恋爱适应与恋爱满意度的功能差异。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"十一届蓝桥杯省赛c++ b组十月份","slug":"十一届蓝桥杯省赛c++b组十月份","date":"2020-11-22T14:01:00.000Z","updated":"2022-04-03T13:18:42.997Z","comments":true,"path":"2020/11/22/十一届蓝桥杯省赛c++b组十月份/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/11/22/%E5%8D%81%E4%B8%80%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9Bc++b%E7%BB%84%E5%8D%81%E6%9C%88%E4%BB%BD/","excerpt":"","text":"A 门牌制作 【问题描述】 小蓝要为一条街的住户制作门牌号. 这条街一共有 2020 位住户,门牌号从 1 到 2020 编号. 小蓝制作门牌的方法是先制作 0 到 9 这几个数字字符,最后根据需要将字符粘贴到门牌上,例如门牌 1017 需要依次粘贴字符 1、 0、 1、 7,即需要 1 个字符 0, 2 个字符 1, 1 个字符 7. 请问要制作所有的 1 到 2020 号门牌,总共需要多少个字符 2? 【答案提交】 这是一道结果填空的题,你只需要算出结果后提交即可.本题的结果为一个整数,在提交答案时只填写这个整数,填写多余的内容将无法得分. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;using namespace std;typedef long long ll;int main(void)&#123; int sum = 0; for(int i = 1;i&lt;=2020;i++)&#123; int n = i; while(n)&#123; if(n%10==2)&#123; //直接用余数来做就好 sum++; &#125; n/=10; &#125; &#125; printf(&quot;%d\\n&quot;,sum);&#125;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;map&gt;using namespace std;typedef long long ll;int get2(int a)&#123; int ans=0; /* while(a)&#123; if((a%10)==2)ans++; a=a/10; &#125; */ stringstream ss; ss&lt;&lt;a; string s; ss&gt;&gt;s;for(int i=0;i&lt;s.length();i++)&#123; if((s[i]-&#x27;0&#x27;)==2)ans++; &#125; return ans;&#125;int main()&#123; int ans=0; for(int i=1;i&lt;=2020;i++)ans+=get2(i); cout&lt;&lt;ans; return 0;&#125; B 既约分数 【问题描述】 如果一个分数的分子和分母的最大公约数是 1,这个分数称为既约分数.例如,3&#x2F;4 ,5&#x2F;2 ,1&#x2F;8 ,7&#x2F;1 都是既约分数.请问,有多少个既约分数,分子和分母都是 1 到 2020 之间的整数(（包括 1 和 2020)? 1234567891011121314151617181920212223242526272829303132别想太多，直接暴力就行#include&lt;iostream&gt;using namespace std;typedef long long ll;//求最大公约数int gcd(int a,int b)&#123; return b==0?a:gcd(b,a%b);&#125;int main(void)&#123; ll sum = 0; for(int i = 1;i &lt;= 2020;i++)&#123; for(int j = 1;j &lt;= 2020;j++)&#123; //两数相等直接跳过(1/1的情况一会在加上) if(i == j)&#123; continue; &#125; if(gcd(i,j) == 1)&#123; sum++; &#125; &#125; &#125; //1/1的情况 sum+=1; printf(&quot;%ld\\n&quot;,sum);&#125;自己的做法，当时数1~2020之间有319个质数，然后319*319得到质数之间所有的组和，后来一想，有些质数和不是质数的组合也是符合题意的，只能暴力n^2来求 C 蛇形序列 容易看出矩阵第二行第二列中的数是 5。请你计算矩阵中第 20 行第 20 列的数是多少？ 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;typedef long long ll; int main()&#123; int ans=1; int temp=4; for(int i=1;i&lt;=19;i++)&#123; //初始化的时候为第一行第一列，然后每加一次就算多一行多一列 ans+=temp;temp+=4; //从第一行第一列到第2行第二列+4；然后到(3,3)加8，到(4,4)加12 cout&lt;&lt;temp&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt; &#x27; &#x27;&lt;&lt;endl; &#125; return 0;&#125;由图可见,n 行 n 列的值为该斜行首尾值的一半(5 = (4+6)/2 ; 13 = (11+15)/2)其具体的对应关系为:2 行 2 列 —&gt; (3 行 1 列 + 1 行 3 列)3 行 3 列 —&gt; (5 行 1 列 + 1 行 5 列)…n 行 n 列 —&gt; (2n-1 行 1 列 + 1 行 2n-1 列)为求 20 行 20 列的值,只需找出第 39 行的首尾值即可 int a[41][41];int main(void)&#123; int k = 0; for(int i = 1;i&lt;=39;i++)&#123; for(int j = 1;j&lt;=i;j++)&#123; a[i][j] = k++; &#125; &#125; for(int i = 1;i&lt;=39;i++)&#123; for(int j = 1;j&lt;=i;j++)&#123; cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125;答案为761 D 跑步训练 【问题描述】 小蓝每天都锻炼身体。 正常情况下,小蓝每天跑 1 千米。如果某天是周一或者月初（1 日）,为了激励自己,小蓝要跑 2 千米。如果同时是周一或月初,小蓝也是跑 2 千米。 小蓝跑步已经坚持了很长时间,从 2000 年 1 月 1 日周六（含）到 2020 年 10 月 1 日周四（含）。请问这段时间小蓝总共跑步多少千米？ 【答案提交】 这是一道结果填空的题,你只需要算出结果后提交即可。本题的结果为一 个整数,在提交答案时只填写这个整数,填写多余的内容将无法得分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;typedef long long ll;int ryue[13]=&#123;0,31,29,31,30,31,30,31,31,30,31,30,31&#125;;int byue[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;int getyear(int a)&#123; if(a%4==0&amp;&amp;a%100!=0||a%400==0)return 1; else return 0;&#125; int main()&#123; ll ans=0; //这里的ans初始值应该为0，当时我写的是1，所以这里错了 int cn=2000,cy=1,cd=1; int zhou=5; while(1)&#123; if(cd==1||zhou==0)ans+=2; else ans+=1; if(cn==2020&amp;&amp;cy==10&amp;&amp;cd==1)&#123; break; &#125; cd++;zhou++; zhou=zhou%7; if(getyear(cn))&#123; //是闰年 if(cd==(ryue[cy]+1))&#123; cd=1;cy++; &#125; if(cy==13)&#123; cn++;cy=1; &#125; &#125;else&#123; if(cd==(byue[cy]+1))&#123; cd=1;cy++; &#125; if(cy==13)&#123; cn++;cy=1; &#125; &#125; &#125; cout&lt;&lt;ans; return 0;&#125;//答案：8879 E F 成绩统计 【问题描述】 小蓝给学生们组织了一场考试，卷面总分为 100 分，每个学生的得分都是 一个 0 到 100 的整数。 如果得分至少是 60 分，则称为及格。如果得分至少为 85 分，则称为优秀。 请计算及格率和优秀率，用百分数表示，百分号前的部分四舍五入保留整 数。 【输入格式】 输入的第一行包含一个整数 n，表示考试人数。 接下来 n 行，每行包含一个 0 至 100 的整数，表示一个学生的得分。 【输出格式】 输出两行，每行一个百分数，分别表示及格率和优秀率。百分号前的部分 四舍五入保留整数。 【样例输入】 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;typedef long long ll; int main()&#123; double n,hnum=0,ynum=0; cin&gt;&gt;n;int temp; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;temp; if(temp&gt;=85)&#123;//及格的人不一定优秀 //所以判断是否优秀及格应该这样写 ynum++; &#125; if(temp&gt;=60)&#123; //优秀的人一定及格 hnum++; &#125; &#125; //cout&lt;&lt;hnum&lt;&lt;&quot; &quot;&lt;&lt;ynum&lt;&lt;endl; double hl= (hnum*1.0/n)*100; double yl=((ynum*1.0/n)*100); printf(&quot;%.0lf%&quot;,hl); //printf会自动四舍五入 printf(&quot;%.0lf&quot;,yl); cout&lt;&lt;&quot;%&quot;&lt;&lt;endl; return 0;//double aa=0.55;//double bb=0.44;//printf(&quot;%.0f\\n&quot;,aa); //1//printf(&quot;%.f\\n&quot;,aa); //1//printf(&quot;%.1f&quot;,bb); //0.4&#125; G 回文日期 【问题描述】 2020 年春节期间，有一个特殊的日期引起了大家的注意：2020 年 2 月 2 日。因为如果将这个日期按“yyyymmdd”的格式写 成一个 8 位数是 20200202，恰好是一个回文数。我们称这样的日期是回文日期。有人表示 20200202 是“千年一遇”的特殊日子。对此小明很不认同，因为不到 2 年之后就是下一个回文日期：20211202 即 2021 年 12 月 2 日。也有人表示 20200202 并不仅仅是一个回文日期，还是一个 ABABBABA 型的回文日期。对此小明也不认同，因为大约 100 年后就能遇到下一个 ABABBABA 型的回文日期：21211212 即 2121 年 12 月 12 日。算不上“千年一遇”，顶多算“千年两遇”。给定一个 8 位数的日期，请你计算该日期之后下一个回文日期和下一个 ABABBABA 型的回文日期各是哪一天。 【输入格式】 输入包含一个八位整数 N，表示日期。 【输出格式】 输出两行，每行 1 个八位数。第一行表示下一个回文日期，第二行表示下一个 ABABBABA 型的回文日期。 【样例输入】 20200202 【样例输出】 20211202 21211212 【评测用例规模与约定】对于所有评测用例，10000101 &lt;&#x3D; N &lt;&#x3D; 89991231，保证 N 是一个合法日期的 8 位数表示。 这里的AB类型的数字应该不同才对 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128方法一：#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;typedef long long ll;int get(int a)&#123; stringstream ss; //stringstream 数字字符转换 //用int类型的转换的时候，直接对某位取余得到某一位 ss&lt;&lt;a; string str; ss&gt;&gt;str; int flag=0; for(int i=0;i&lt;str.size()/2;i++)&#123; if(str[i]!=str[str.size()-i-1])&#123; //第一位和最后一位判断相等,第二位和倒数第二位判断 flag=1;break; //剪枝 &#125; &#125; if(flag==1)return 0; //如果不是回文，则直接返回0，不用接着判断是否是abab类型 if(str[0]==str[2]&amp;&amp;str[1]==str[3]&amp;&amp;str[0]!=str[1])return 2; //判断是ababbaba类型的字符串 else return 1; //判断是一个回文字符串 //string strr=re&#125;int main()&#123; int a=0; cin&gt;&gt;a;a++; int flag1=0;//判断是否输出过回文日期 int temp=0; //存函数返回值 //cout&lt;&lt;a&lt;&lt;endl; for(int i=a;i&lt;=89991231;i++)&#123; //日期没超1e9，直接遍历 temp=get(i); //cout&lt;&lt;temp&lt;&lt;endl; if(temp==1&amp;&amp;flag1==0)&#123; cout&lt;&lt;i&lt;&lt;endl;flag1=1; &#125; if(temp==2)&#123; //输出ababbaba类型日期 cout&lt;&lt;i&lt;&lt;endl; break; //及时跳出for，剪枝 &#125; &#125; return 0;&#125;方法二（不用数字转为字符串，直接处理数字）： #include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int m[13] = &#123;-1,31,28,31,30,31,30,31,31,30,31,30,31&#125;;//判断是不是闰年bool isYear(int year)&#123; return year%400 == 0 || (year%4==0 &amp;&amp; year%100!=0);&#125;//判断该日期只有有效bool judgeDate(int year,int month,int day)&#123; if(month&gt;12)&#123; return false; &#125; //日期特判:闰年的二月份 if(isYear(year) &amp;&amp; month == 2)&#123; return day &lt;=29; &#125; return day &lt;= m[month];&#125;int main()&#123; bool flag = false; int n; scanf(&quot;%d&quot;,&amp;n); //scanf一定别忘了&amp; ，不然报错 for(int i = n+1;i&lt;=89991231;i++)&#123; int a[8]; for(int j = 7,m=i;j&gt;=0;j--,m/=10)&#123; a[j] = m%10; //把每位的数字通过取余的方式存起来 &#125; int year = a[0]*1000+a[1]*100+a[2]*10+a[3]; int month = a[4]*10+a[5]; int day = a[6]*10+a[7]; if(!judgeDate(year,month,day))&#123; continue; &#125; //回文 if(a[0] == a[7] &amp;&amp; a[1] == a[6] &amp;&amp;a[2] == a[5] &amp;&amp;a[3] == a[4] )&#123; if(flag == false)&#123; cout&lt;&lt;i&lt;&lt;endl; flag = true; &#125; //abab形式 if(a[0] == a[2] &amp;&amp; a[1] == a[3] &amp;&amp; a[0]!=a[1])&#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; &#125; return 0;&#125; 回文判断方法总结：#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;int main()&#123; //判断回文方法1 string aa ; string bb; while(cin&gt;&gt;aa)&#123; //abcd bb=aa; reverse(aa.begin(),aa.end()); //字符串反转的方法，不是reserve（预定，保留，储量） cout&lt;&lt;aa&lt;&lt;endl; //dcba cout&lt;&lt;bb; //abcd if(aa==bb) &#123; cout&lt;&lt;&quot;同&quot;; &#125;else&#123; cout&lt;&lt;&quot;不同&quot;; &#125; &#125;//判断回文方法2 ：利用栈的性质，序列先进栈，然后再逆序出栈，相比较//数组中逆序判断回文 &#125; H I","categories":[{"name":"acwing蓝桥","slug":"acwing蓝桥","permalink":"https://zouyunkai.github.io/myblog/categories/acwing%E8%93%9D%E6%A1%A5/"}],"tags":[],"author":"aoyuehan"},{"title":"pat甲级训练题续4","slug":"pat甲级训练题续4","date":"2020-09-09T14:01:00.000Z","updated":"2022-02-26T03:27:00.345Z","comments":true,"path":"2020/09/09/pat甲级训练题续4/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/09/09/pat%E7%94%B2%E7%BA%A7%E8%AE%AD%E7%BB%83%E9%A2%98%E7%BB%AD4/","excerpt":"","text":"1014 Waiting in Line (queue的应用)题目大意：n个窗口，每个窗口可以排队m人。有k位用户需要服务，给出了每位用户需要的minute数，所有客户在8点开始服务，如果有窗口还没排满就入队，否则就在黄线外等候。如果有某一列有一个用户走了服务完毕了，黄线外的人就进来一个。如果同时就选窗口数小的。求q个人的服务结束时间。如果一个客户在17:00以及以后还没有开始服务（此处不是结束服务是开始17:00）就不再服务输出sorry；如果这个服务已经开始了，无论时间多长都要等他服务完毕。 分析：设立结构体，里面包含poptime为队首的人出队（结束）的时间，和endtime为队尾的人结束的时间。poptime是为了让黄线外的人可以计算出哪一个队列先空出人来（poptime最小的那个先有人服务完毕），endtime是为了入队后加上自己本身的服务所需时间可以计算出自己多久才能被服务完毕～且前一个人的endtime可以得知自己是不是需要被Sorry（如果前一个人服务结束时间超过17:00，自己当前入队的人就是sorry），还有一个queue表示所有当前该窗口的排队队列。对于前m*n个人，也就是排的下的情况下，所有人依次到窗口前面排队。对于m*n之后的人，当前人选择poptime最短的入队，让队伍的第一个人出列），如果前面一个人导致的endtime超过17点就标记自己的sorry为true 计算时间的时候按照分钟计算，最后再考虑08点开始和转换为小时分钟的形式会比较简便～ 详细见这 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;struct node &#123; int poptime, endtime; queue&lt;int&gt; q;&#125;;int main() &#123; int n, m, k, q, index = 1; scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;q); vector&lt;int&gt; time(k + 1), result(k + 1); for(int i = 1; i &lt;= k; i++) &#123; scanf(&quot;%d&quot;, &amp;time[i]); &#125; vector&lt;node&gt; window(n + 1); vector&lt;bool&gt; sorry(k + 1, false); for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(index &lt;= k) &#123; window[j].q.push(time[index]); if(window[j].endtime &gt;= 540) sorry[index] = true; window[j].endtime += time[index]; if(i == 1) window[j].poptime = window[j].endtime; result[index] = window[j].endtime; index++; &#125; &#125; &#125; while(index &lt;= k) &#123; int tempmin = window[1].poptime, tempwindow = 1; for(int i = 2; i &lt;= n; i++) &#123; if(window[i].poptime &lt; tempmin) &#123; tempwindow = i; tempmin = window[i].poptime; &#125; &#125; window[tempwindow].q.pop(); window[tempwindow].q.push(time[index]); window[tempwindow].poptime += window[tempwindow].q.front(); if(window[tempwindow].endtime &gt;= 540) sorry[index] = true; window[tempwindow].endtime += time[index]; result[index] = window[tempwindow].endtime; index++; &#125; for(int i = 1; i &lt;= q; i++) &#123; int query, minute; scanf(&quot;%d&quot;, &amp;query); minute = result[query]; if(sorry[query] == true) &#123; printf(&quot;Sorry\\n&quot;); &#125; else &#123; printf(&quot;%02d:%02d\\n&quot;,(minute + 480) / 60, (minute + 480) % 60); &#125; &#125; return 0;&#125; 1015 Reversible Primes (20分)题意：给你两个数字N和D，题目要求，当N是素数且N以D为基数时也是素数，就输出Yes，否则输出No； 思路：(1).先判断N是否是素数，不是素数，直接输出No；是素数进行第(2)步； (2).把十进制的N，转换成以D为基数的数字； (3).把转换后的数字再反转后再转换成十进制的数字； (4).判断反转后的数字是否是素数； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;iostream&gt;using namespace std;const int maxn=1e6+1000; //prime[maxn]是不存在的 int prime[maxn]; //prime[i]==0则为素数 void init()&#123; for(int i=2;i&lt;maxn;i++)&#123; //都是小于maxn if(prime[i]==0)&#123; for(int j=i+i;j&lt;maxn;j+=i)&#123; prime[j]=1; &#125; &#125; &#125;&#125; int main()&#123; init(); int N; int D,ans_d=0,tmp=0; while(cin&gt;&gt;N)&#123; if(N&lt;0)&#123; break; &#125;else&#123; cin&gt;&gt;D; if(prime[N]==0)&#123; while(N)&#123; tmp=N%D; N=N/D; ans_d=ans_d*10+tmp; &#125; if(prime[ans_d]==0)&#123; //如果转换之后的数为素数 cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; &#125;else&#123; cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; &#125; &#125;&#125; 上面不对；下面对的： #include &lt;bits/stdc++.h&gt;using namespace std;int n,d;bool isprime(int x)&#123; for(int i=2;i*i&lt;=x;i++) if(x%i==0) return false; return true;&#125;string trans(int x,int d)&#123; stack&lt;int&gt;st; while(x) &#123; st.push(x%d); x /= d; &#125; string s = &quot;&quot;; while(st.size()) &#123; s += (char)(&#x27;0&#x27;+st.top()); st.pop(); &#125; return s;&#125;int qpow(int a,int b)&#123; int base = a,ans = 1; while(b) &#123; if(b&amp;1) &#123; ans *= base; &#125; base *= base; b&gt;&gt;=1; &#125; return ans;&#125;int get(string s,int d)&#123; int len = s.size(); int ans = 0 ,cnt=0; for(int i=len-1;i&gt;=0;i--) ans += qpow(d,cnt)*(s[i]-&#x27;0&#x27;),cnt++; return ans;&#125;int main()&#123;// cout&lt;&lt;trans(16,2);// cout&lt;&lt;get(&quot;11111&quot;,2); while(cin&gt;&gt;n &amp;&amp; n&gt;=0) &#123; cin&gt;&gt;d; if(n==1) &#123; cout&lt;&lt;&quot;No\\n&quot;; continue; &#125; else if(n==2) &#123; if(d==2) &#123; cout&lt;&lt;&quot;No\\n&quot;; continue; &#125; else &#123; cout&lt;&lt;&quot;Yes\\n&quot;; continue; &#125; &#125; if(!isprime(n)) &#123; cout&lt;&lt;&quot;No\\n&quot;; continue; &#125; string s = trans(n,d); reverse(s.begin(),s.end()); int now = get(s,d); if(isprime(now)) &#123; cout&lt;&lt;&quot;Yes\\n&quot;; &#125; else &#123; cout&lt;&lt;&quot;No\\n&quot;; &#125; &#125;&#125; 1088 Rational Arithmetic (20分) 分数计算思路：分数计算 注意：输出初始的分数的时候也要化成最简形式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;using namespace std;#define _for(i,lo,hi) for(int i=(lo);i&lt;(hi);i++)typedef long long ll;struct frac&#123; ll a,b;//分子分母 frac(ll aa,ll bb):a(aa),b(bb)&#123;&#125; frac()&#123;&#125;&#125;;int gcd(ll x,ll y)&#123; return y==0?x:gcd(y,x%y);&#125;void reduce(frac&amp; c)&#123; if(c.a==0)&#123;c.b=1;return;&#125; if(c.b==0)&#123;c.a=1;return;&#125; if(c.b&lt;0)&#123;c.a=-c.a;c.b=-c.b;&#125; //把负号加到分子上 int r; if(c.a&gt;0)r=gcd(c.a,c.b); //用来化简 else r=gcd(-c.a,c.b); c.a/=r; //分子，分母同时除最小公倍数 c.b/=r;&#125;frac _add(frac f1,frac f2)&#123; frac ans; ans.a=f1.a*f2.b+f1.b*f2.a; ans.b=f1.b*f2.b; reduce(ans); return ans;&#125;frac _minus(frac f1,frac f2)&#123; f2.a=-f2.a; return _add(f1,f2);&#125;frac _prod(frac f1,frac f2)&#123; frac ans; ans.a=f1.a*f2.a; ans.b=f1.b*f2.b; reduce(ans); return ans;&#125;frac _divi(frac f1,frac f2)&#123; swap(f2.a,f2.b); return _prod(f1,f2);&#125;void printnode(frac f)&#123; if(f.b==0)&#123;printf(&quot;Inf&quot;);return;&#125; if(f.a==0)&#123;printf(&quot;0&quot;);return;&#125; int flag=0; if(f.a&lt;0)&#123;flag=1;f.a=-f.a;printf(&quot;(-&quot;);&#125; if(f.a&gt;=f.b)&#123; printf(&quot;%lld&quot;,f.a/f.b);f.a%=f.b; if(f.a!=0)printf(&quot; %lld/%lld&quot;,f.a,f.b); &#125;else&#123; printf(&quot;%lld/%lld&quot;,f.a,f.b); &#125; if(flag)printf(&quot;)&quot;);&#125;int main()&#123; //freopen(&quot;d:\\\\input.txt&quot;,&quot;r&quot;,stdin); ll a,b,c,d; scanf(&quot;%lld/%lld %lld/%lld&quot;,&amp;a,&amp;b,&amp;c,&amp;d); //srand(time(NULL)); a=rand()%13-6;b=abs(rand()%10-5)+1;c=rand()%10-5;d=abs(rand()%10-5)+1; //printf(&quot;%lld %lld %lld %lld\\n&quot;,a,b,c,d); frac f1=frac(a,b),f2=frac(c,d); reduce(f1);reduce(f2); printnode(f1);printf(&quot; + &quot;);printnode(f2);printf(&quot; = &quot;);printnode(_add(f1,f2));printf(&quot;\\n&quot;); printnode(f1);printf(&quot; - &quot;);printnode(f2);printf(&quot; = &quot;);printnode(_minus(f1,f2));printf(&quot;\\n&quot;); printnode(f1);printf(&quot; * &quot;);printnode(f2);printf(&quot; = &quot;);printnode(_prod(f1,f2));printf(&quot;\\n&quot;); printnode(f1);printf(&quot; / &quot;);printnode(f2);printf(&quot; = &quot;);printnode(_divi(f1,f2));printf(&quot;\\n&quot;); return 0; &#125;","categories":[{"name":"pat","slug":"pat","permalink":"https://zouyunkai.github.io/myblog/categories/pat/"}],"tags":[],"author":"aoyuehan"},{"title":"20210826关于前阵子的简介和打算","slug":"20210826关于前阵子的见解和打算","date":"2020-08-26T06:13:00.000Z","updated":"2022-02-26T03:27:00.159Z","comments":true,"path":"2020/08/26/20210826关于前阵子的见解和打算/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/08/26/20210826%E5%85%B3%E4%BA%8E%E5%89%8D%E9%98%B5%E5%AD%90%E7%9A%84%E8%A7%81%E8%A7%A3%E5%92%8C%E6%89%93%E7%AE%97/","excerpt":"","text":"20210826关于前阵子的简介和打算六级 跪了跪了，四次都没过，这也太打击人了吧，我佩服我自己的复习心态了。可能这不是关于实力的问题，而是关于你对这个考试的态度问题，自从大二开始，有好多事就做不成了，一次次的碰壁，让我懂得，原来成败的比例真的在1:6。 最近的2021年上半年的这次考试，我应该是在100多天就时候就已经开始复习了，复习到最后的结果就是近三年的题也就做了一年半真题吧，然后听力的话，听了三四套吧（考虫的！！！下次复习再看这家的），最后考了380，害，怎么夸夸你自己呐，比上一次有提高，记得有一次应该是考了320，这一次提高了一丢丢。 有些选择是不对的前阵子遇到好多抉择，做的选择好像相比来说 都不是很对，比如，都不是很对，哎。可能现在的想法和以前不一样了，可能看问题的角度更加深入，透彻了。当时做决定的时候还是感觉我那么做是对的，局限在当时，事情都是发展的联系的。 关于复习 最近总是好多事牵连着我，总是静不下心来复习。现在好在可以真的静下心来学习了。 树立信心。 刚才去看了我当时当时软件设计大赛的那篇文章，现在，就到了当时我三四天睡不着觉做决定的时候，对，太像了，现在也是，到底是放弃还是本校还是试试东林。如果拿着当时我完成了比赛的那种心情去看当时做决定的时候，我真的谢谢当时一咬牙坚持下去的我。所以可以用以后考上的那种心态看现在，然后坚持下去。 效率 规避一些坑，比如 关于打算 今天这一个打击，哎， 虽然对比来申请优秀生源考本校一下子就能考上，接着去省科学院工作，好像是很不错的，但我冥冥之中还是想试一下这个东北这个学校，就是想试一下，没有很多理由。可能这就像是那种博弈的心态吧，就是有时候知道可能买一个彩票中奖的几率已经趋于不可能了，但还是想试一下，又像是以前喜欢谁一样，就是说不出来为什么。可能现在看来我认为是对的选择，等几个月之后，可能我就后悔现在这么选了。 不过我不想在济南待着了（不是我喜欢的城市），我想着去东北混三年，若能拿着这东林211的计算机文凭，到青岛去，感觉无论青岛的哪家互联网公司肯定都能去，小米等我，然后我爸给我买个房子，就待在那里混吃等死吧，希望我这个就去过一次就想定居的城市你可不要让我失望，收留收留我啊。【希望四年后我看到这篇日记的时候能实现啊，求求老天爷】 2022年1月3日补充 emm，东北也没去，qlu也估计一下没考上，2021下半年的六级估计也没过。 苦笑啊 哈哈哈哈哈","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"pat甲级训练题续3","slug":"pat甲级训练题续3","date":"2020-08-09T14:01:00.000Z","updated":"2022-02-26T03:27:00.472Z","comments":true,"path":"2020/08/09/pat甲级训练题续3/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/08/09/pat%E7%94%B2%E7%BA%A7%E8%AE%AD%E7%BB%83%E9%A2%98%E7%BB%AD3/","excerpt":"","text":"1037 Magic Coupon (排序贪心)题意： 给出两个集合，从这两个集合里面选出数量相同的元素进行一对一相乘，求能够得到的最大乘积之和。 题解： 对每个集合，将正数和负数分开考虑，将每个集合里的整数从大到小排序；将每个集合里的负数从小到大排序，然后同位置的正数与正数相乘，负数与负数相乘。 注意点： 输入为0的不要管，直接忽略，否则测试点1过不去 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll na[100005];ll pa[100005];ll nb[100005];ll pb[100005];int kna=0,kpa=0,knb=0,kpb=0;int n1,n2;bool cmp(ll x, ll y)&#123; return x&gt;y;&#125;ll s=0;int main()&#123; cin&gt;&gt;n1; ll x; for(int i=1;i&lt;=n1;i++)&#123; cin&gt;&gt;x; if(x&gt;0)&#123; pa[++kpa]=x; &#125;else if(x&lt;0)&#123;//=0的不要管 na[++kna]=x; &#125; &#125; cin&gt;&gt;n2; for(int i=1;i&lt;=n2;i++)&#123; cin&gt;&gt;x; if(x&gt;0)&#123; pb[++kpb]=x; &#125;else if(x&lt;0)&#123;//=0的不要管 nb[++knb]=x; &#125; &#125; sort(pa+1,pa+1+kpa,cmp); sort(pb+1,pb+1+kpb,cmp); sort(na+1,na+1+kna); sort(nb+1,nb+1+knb); int min_l=min(kpa,kpb); for(int i=1;i&lt;=min_l;i++)&#123; s+=pa[i]*pb[i]; &#125; min_l=min(kna,knb); for(int i=1;i&lt;=min_l;i++)&#123; s+=na[i]*nb[i]; &#125; cout&lt;&lt;s&lt;&lt;endl; return 0;&#125;或者： #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std;const int maxn = 100100;int coupons[maxn];int values[maxn];bool cmp(const int a, const int b)&#123; return a &gt; b;&#125;int main()&#123; int c,p; long long ans = 0; scanf(&quot;%d&quot;,&amp;c); for(int i = 0; i &lt; c; i++)&#123; scanf(&quot;%d&quot;,&amp;coupons[i]); &#125; scanf(&quot;%d&quot;,&amp;p); for(int i = 0; i &lt; p; i++)&#123; scanf(&quot;%d&quot;,&amp;values[i]); &#125; sort(coupons, coupons + c); //从小到排 ，此时负数在前 sort(values, values + p); for(int i = 0; i &lt; c &amp;&amp; i &lt; p; i++)&#123; if(coupons[i] * values[i] &lt; 0) break;//一正一负相乘的情况 if(coupons[i] &gt; 0 &amp;&amp; values[i] &gt; 0) break; //开始计算负数的乘积的时候，两者都大于0的时候退出 if(coupons[i] * values[i] &gt;= 0)ans += coupons[i] * values[i]; //累加答案 &#125; sort(coupons, coupons + c, cmp);//从大到小排 ，此时正数在前 sort(values, values + p, cmp); for(int i = 0; i &lt; c &amp;&amp; i &lt; p; i++)&#123; if(coupons[i] * values[i] &lt; 0) break; //一正一负相乘的情况 ，此时不应该再计算下去了 if(coupons[i] &lt; 0 &amp;&amp; coupons[i] &lt; 0) break; ans += coupons[i] * values[i]; &#125; printf(&quot;%lld&quot;,ans); return 0;&#125; 1024 Palindromic Number (回文串、大数加法)给定数字判断回文，是就输出0次，不是就一直翻转相加，超过给定次数，输出给定次数翻转相加后的结果并输出给定次数，在给定次数内找到了，输出该数和次数。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;string s; //用来存一次加法之后的结果void add(string t)&#123; //模拟加法 int flag=0; for(int i=t.length()-1;i&gt;=0;i--)&#123; s[i]=s[i]+t[i]+flag-&#x27;0&#x27;; flag=0; if(s[i]&gt;&#x27;9&#x27;)&#123; //注意这里 s[i]-=10; flag=1; &#125; &#125; if(flag) s=&#x27;1&#x27;+s;&#125;int main()&#123; int k,i; cin&gt;&gt;s&gt;&gt;k; for(i=0;i&lt;k;i++)&#123; string t=s; reverse(t.begin(),t.end()); if(s==t) break; //如果一次运算的结果和他的翻转相同，那么该串就是回文串了 add(t); &#125; cout&lt;&lt;s&lt;&lt;endl&lt;&lt;i; return 0;&#125; 1027 Colors in Mars (进制转换)12345678910111213#include&lt;cstdio&gt;char RGB[13] =&#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;,&#x27;8&#x27;, &#x27;9&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;&#125;;int main(int argc, char const *argv[])&#123; int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c); printf(&quot;#&quot;); printf(&quot;%c%c&quot;, RGB[a / 13], RGB[a % 13]); printf(&quot;%c%c&quot;, RGB[b / 13], RGB[b % 13]); printf(&quot;%c%c\\n&quot;, RGB[c / 13], RGB[c % 13]); return 0;&#125; 1074 Reversing Linked List (链表按照某个大小进行翻转)123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1e5 + 10;struct Node &#123; int add, data, next;&#125;node[maxn];void init()&#123; for (int i = 0; i &lt; maxn; i++)node[i].add = i;&#125;int head, n, k;vector&lt;Node&gt;list;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;head, &amp;n, &amp;k); init(); for (int i = 0; i &lt; n; i++) &#123; int address; scanf(&quot;%d&quot;, &amp;address); scanf(&quot;%d%d&quot;, &amp;node[address].data, &amp;node[address].next); &#125; int p = head; //将链表存到vector中，然后翻转数组 while (p != -1) &#123; list.push_back(node[p]); p = node[p].next; &#125; int group = list.size() / k; for (int i = 0; i &lt; group; i++) &#123; reverse(list.begin() + i*k, list.begin() + i*k + k); &#125; for (int i = 0; i &lt; list.size(); i++) &#123; printf(&quot;%05d %d &quot;, list[i].add, list[i].data); if (i != list.size() - 1)printf(&quot;%05d&quot;, list[i + 1].add); else printf(&quot;-1&quot;); printf(&quot;\\n&quot;); &#125; return 0;&#125; 1010 Radix (二分搜索答案)大意：给出两个正整数，给出其中一个正整数的基底，求另外一个正整数的基底，使得这两个正整数在各自的基底的十进制数相等思路：convert函数：给定一个数值和一个进制，将它转化为10进制。转化过程中可能产生溢出****find_radix函数：找到令两个数值相等的进制数。在查找的过程中，需要使用二分查找算法，如果使用当前进制转化得到数值比另一个大或者小于0，说明这个进制太大～1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long int ll ;ll convert( string a , ll radix )&#123; ll sum = 0; for( int i=0;i&lt;a.length() ;i++)&#123; sum*=radix; sum = sum + ( isdigit( a[i] ) ? a[i] - &#x27;0&#x27; : a[i] - &#x27;a&#x27; + 10 ); &#125; return sum;&#125;ll maxx( ll a ,ll b )&#123; if( a &gt; b ) return a; return b ;&#125;ll find( string a , ll b )&#123; ll low = 0 , high ; for( int i = 0; i &lt; a.length() ;i++ )&#123; if( isdigit( a[i] ) ) low = maxx( low , a[i] - &#x27;0&#x27; ); else low = maxx( low , a[i] - &#x27;a&#x27; + 10 ); &#125; low++; high = maxx( b , low ); while( low &lt;= high)&#123; ll mid = ( low + high ) / 2; ll t = convert( a ,mid ); if( t &lt; 0 || t &gt; b ) high = mid-1; else if( t == b ) return mid; else low = mid + 1 ; &#125; return -1;&#125;int main(void)&#123; string n1,n2,tag; ll radix ,ans; cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;tag&gt;&gt;radix; ans = tag==&quot;1&quot;? find( n2 , convert( n1 ,radix) ) : find( n1 , convert( n2 ,radix) ); if( ans == -1 ) cout&lt;&lt;&quot;Impossible&quot;&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 1089 Insert or Merge (插入排序归并排序)题目大意：现给定原始序列和由某排序算法产生的中间序列，请你判断该算法是插入算法还是归并算法。首先在第1行中输出“Insertion Sort”表示插入排序、或“Merge Sort”表示归并排序；然后在第2行中输出用该排序算法再迭代一轮的结果序列 分析：先将i指向中间序列中满足从左到右是从小到大顺序的最后一个下标，再将j指向从i+1开始，第一个不满足a[j] &#x3D;&#x3D; b[j]的下标，****如果j顺利到达了下标n，说明是插入排序，再下一次的序列是sort(a, a+i+2);否则说明是归并排序。归并排序就别考虑中间序列了，直接对原来的序列进行模拟归并时候的归并过程，i从0到n&#x2F;k，每次一段段得sort(a + i * k, a + (i + 1) * k);最后别忘记还有最后剩余部分的sort(a + n &#x2F; k * k, a + n);这样是一次归并的过程。直到有一次发现a的顺序和b的顺序相同，则再归并一次，然后退出循环～ 注意：一开始第三个测试点一直不过，天真的我以为可以模拟一遍归并的过程然后在过程中判断下一步是什么。。然而真正的归并算法它是一个递归过程。。也就是先排左边一半，把左边的完全排列成正确的顺序之后，再排右边一半的。。而不是左右两边一起排列的。。后来改了自己的归并部分判断的代码就过了。。。｡｡ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n, a[100], b[100], i, j; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i]; for (int i = 0; i &lt; n; i++) cin &gt;&gt; b[i]; for (i = 0; i &lt; n - 1 &amp;&amp; b[i] &lt;= b[i + 1]; i++); for (j = i + 1; a[j] == b[j] &amp;&amp; j &lt; n; j++); if (j == n) &#123; cout &lt;&lt; &quot;Insertion Sort&quot; &lt;&lt; endl; sort(a, a + i + 2); &#125; else &#123; cout &lt;&lt; &quot;Merge Sort&quot; &lt;&lt; endl; int k = 1, flag = 1; while(flag) &#123; flag = 0; for (i = 0; i &lt; n; i++) &#123; if (a[i] != b[i]) flag = 1; &#125; k = k * 2; for (i = 0; i &lt; n / k; i++) sort(a + i * k, a + (i + 1) * k); sort(a + n / k * k, a + n); &#125; &#125; for (j = 0; j &lt; n; j++) &#123; if (j != 0) printf(&quot; &quot;); printf(&quot;%d&quot;, a[j]); &#125; return 0;&#125; 1128 N Queens Puzzle (n皇后回溯)12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int n,k; cin &gt;&gt; k; for(int i = 0; i &lt; k; i++)&#123; cin &gt;&gt; n; vector&lt;int&gt; v(n+2); bool flag = true; for(int j = 1; j &lt;= n; j++)&#123; cin &gt;&gt; v[j]; for(int t = 1; t &lt; j; t++)&#123; //for写在这更高效一点，只需要这一个的前面比较就可以了 if(v[t] == v[j] || abs(j-t) == abs(v[j] - v[t]))&#123; //因为先说明了不在同一列，所以只判断行或者对角线就行了 flag = false; break; &#125; &#125; &#125; cout &lt;&lt; (flag == true ? &quot;YES\\n&quot;:&quot;NO\\n&quot;); &#125; return 0;&#125; 1008 Elevator (模拟楼梯)123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;stack&gt;typedef long long ll;using namespace std;int main()&#123; int N; cin&gt;&gt;N;int sum=0; int start=0;int endd=0; for(int i=1;i&lt;=N;i++) &#123; cin&gt;&gt;endd; if(endd&gt;start)&#123; //上楼 sum=sum+(endd-start)*6+5; start=endd; &#125; else if(endd&lt;start)&#123; //下楼 sum=sum+(start-endd)*4+5; start=endd; &#125; else&#123; sum+=5;start=endd; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl;&#125; 1059 Prime Factors (素数 数学问题)12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100010; //求出小于sqrt(N)的素数表 int prime[maxn],pNum=0;bool pr[maxn]= &#123;false&#125;;struct factor &#123; //质因子数组 int x,cnt;&#125; fac[10];void Find_Prime(int n) &#123; //筛法 得到素数表 for(int i=2; i&lt;=n; i++) &#123; if(pr[i]==false) &#123; prime[pNum++]=i; for(int j=i+i; j&lt;=n; j+=i)pr[j]=true; &#125; &#125;&#125;int main() &#123; int N,num=0,n; scanf(&quot;%d&quot;,&amp;N); int sqr=(int)sqrt(1.0*N); Find_Prime(sqr); n=N; for(int i=0; i&lt;pNum; i++) &#123; if(prime[i]&gt;sqr)break; //当质数表大于sqr时停止 if(n%prime[i]==0) &#123; fac[num].x=prime[i]; fac[num].cnt=0; while(n%prime[i]==0) &#123; //这一部就是看改质因子的个数的，别忘了除 fac[num].cnt++; n/=prime[i]; &#125; num++; &#125; &#125; if(num==0) &#123; //因为判断的是质数的平方大于sqr，是对称着的，所以只判断一半就行，而他自己本身没有判断N本身是质数的情况 fac[num].x=N; fac[num++].cnt=1; &#125; printf(&quot;%d=&quot;,N); for(int i=0; i&lt;num; i++) &#123; if(i!=0)printf(&quot;*&quot;); if(fac[i].cnt&gt;1)printf(&quot;%d^%d&quot;,fac[i].x,fac[i].cnt); else printf(&quot;%d&quot;,fac[i].x); &#125;&#125;","categories":[{"name":"pat","slug":"pat","permalink":"https://zouyunkai.github.io/myblog/categories/pat/"}],"tags":[],"author":"aoyuehan"},{"title":"app开发","slug":"基于生活服务的app的开发记录","date":"2020-08-09T14:01:00.000Z","updated":"2022-04-03T13:18:45.385Z","comments":true,"path":"2020/08/09/基于生活服务的app的开发记录/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/08/09/%E5%9F%BA%E4%BA%8E%E7%94%9F%E6%B4%BB%E6%9C%8D%E5%8A%A1%E7%9A%84app%E7%9A%84%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"开发记录环境准备android studio下载 汉化教程教程2：https://blog.csdn.net/qq_42813491/article/details/89177309汉化的时候resources_en.jar，resources_cn.jar都需要保存进lib目录 tips:android studio已经内嵌了android SDK，所以不用额外安装sdk。 项目搭建解决Android Studio Gradle Sync同步慢问题 目录 java：我们写Java代码的地方，业务功能都在这里实现 res：存放我们各种资源文件的地方，有图 片，字符串，动画，音频等，还有各种形式的XML文件 图片资源： drawable：存放各种位图文件，(.png，.jpg，.9png，.gif等)除此之外可能是一些其他的drawable类型的XML文件 mipmap-hdpi：高分辨率，一般我们把图片丢这里 mipmap-mdpi：中等分辨率，很少，除非兼容的的手机很旧 mipmap-xhdpi：超高分辨率，手机屏幕材质越来越好，以后估计会慢慢往这里过渡 mipmap-xxhdpi：超超高分辨率，这个在高端机上有所体现 布局资源： layout：该目录下存放的就是我们的布局文件，另外在一些特定的机型上，我们做屏幕适配，比如480*320这样的手机，我们会另外创建一套布局，就行：layout-480x320这样的文件夹！ values目录： demens.xml：定义尺寸资源 string.xml：定义字符串资源 styles.xml：定义样式资源 colors.xml：定义颜色资源 arrays.xml：定义数组资源 attrs.xml：自定义控件时用的较多，自定义控件的属性！ theme主题文件，和styles很相似，但是会对整个应用中的Actvitiy或指定Activity起作用，一般是改变窗口外观的！ MainActivity.java：布局文件：activity_main.xml： AndroidManifest.xml配置文件: 布局 到manifest中声明activity 选中类名，按住“Alt”+”Enter”，选择“add activity to maniefest”。 网状布局https://www.runoob.com/w3cnote/android-tutorial-gridview.html Intent之复杂数据的传递https://www.runoob.com/w3cnote/android-tutorial-intent-pass-data.html 星级评分条https://www.runoob.com/w3cnote/android-tutorial-ratingbar.html Activity：表示当前手机的整个界面（一页） 12345678910111213OnCreate( ): 当页面被创建时被activity回调，方法中常加入初始化实现onStart( ):当页面显示时被activity回调onRestart( ):重新启动activity时被回调，总是在onStart（）之后执行onPause( ):快速暂停activityonResume( ):当Activity由暂停状态恢复为活动状态时被回调onStop( ):当页面被隐藏时被activity回调onDestory( ):销毁activity时被回调 Intent：activity之间跳转的桥梁，直接通过putExtra( )传递&#x2F;回传数据；还可以利用Bundle先对有用的数据加工， 再利用putExtra( )传递数据。（Bundle对象可以包含所有putEextra()传递的数据） （注：Activity和Intent具体可查阅android官方文档https://developer.android.google.cn/guide/components/intents-filters） Mob短信验证码：http://wiki.mob.com/sdk-sms-android-3-0-0/ 官方文档教学，主要用到mob自身封装的回调机制 （注意在清单xml中添加相应的权限，不然是收不到短信验证信息的） java.lang.NoClassDefFoundError: Failed resolution of: Lokio&#x2F;Buffer 错误原因： 没有引入OKio.jar，OKio和OKHttp是同一个公司提供的框架，OKio主要底层IO操作，OKHttp引用了OKio 解决方式： 在build.gradle(Module: app)文件的dependencies中引入okio包2.6.0的版本和okhttp版本不兼容，所以要换2.2.2版本的okio ；否则会报以下内容java.lang.NoClassDefFoundError: Failed resolution of: Lkotlin&#x2F;jvm&#x2F;internal&#x2F;Intrinsics; 监听器123456789101112131415161718192021button.setOnClickListener() 需要传入的是 OnClickListener 类型的实例（如 下文的MainActivity这个类）。 //方式一 public MainActivity extends Activity implements OnClickListener&#123; …… @Override protected void onCreate(Bundle savedInstanceState) &#123; …… button.setOnClickListener(this); &#125; @Override public void onClick(View view) &#123; //view就是点击的对象 //此时 MainActivity 作为 OnClickListener 作用 &#125; &#125;此时是把 MainActivity 作为 OnClickListener 类型传入，但是 MainActivity 是继承 Activity 的，不是 OnClickListener 类型，那么此时可以让 MainActivity 实现了 OnClickListener 接口，将 onClick 方法重写，那么此时就可以作为 OnClickListener 类型。 适配器 W&#x2F;System.err: java.io.IOException: Cleartext HTTP traffic to **** not permitted https://blog.csdn.net/weixin_43526279/article/details/100574799 不允许在主线程中访问网络,要单独写一个线程来访问网络W&#x2F;System.err: android.os.NetworkOnMainThreadExceptionW&#x2F;System.err: at android.os.StrictMode$AndroidBlockGuardPolicy.onNetwork(StrictMode.java:1571) 目前Android版本强制规定用线程来使用数据库（增删改查等），防止界面线程被卡死。 D&#x2F;NetworkSecurityConfig: No Network Security Config specified, using platform default https://blog.csdn.net/weixin_30700977/article/details/101363436 intelij idea java.lang.ClassNotFoundException 在idea中创建项目，调试时提示这个异常，导致这个异常的情况有很多种，这次比较特殊，处理也比较简单。File &gt; Project Structure &gt; Artifacts &gt; 在右侧Output Layout右击项目名&gt; 选择Put into Output Root fastJson使用 User user &#x3D; JSON.parseObject(jsonStr1, User.class);String ListUserJson &#x3D; JSON.toJSONString(users); -okhttp的异步请求不能改变静态成员变量，因为有可能请求还没执行完，就返回了 1234567891011121314151617181920212223242526 MediaType mediaType = MediaType.parse(&quot;application/json&quot;); //使用JSONObject封装参数 JSONObject jsonObject = new JSONObject(); try &#123; jsonObject.put(&quot;参数名&quot;,&quot;参数值&quot;); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; //创建RequestBody对象，将参数按照指定的MediaType封装 RequestBody requestBody = RequestBody.create(mediaType,jsonObject.toString()); Request request = new Request .Builder() .post(requestBody)//Post请求的参数传递 .url(Config.POST_URL) .build(); try &#123; Response response = okHttpClient.newCall(request).execute(); String result = response.body().string(); Log.d(&quot;androixx.cn&quot;,result); response.body().close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;————————————————版权声明：本文为CSDN博主「Javen2016」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/muyi_amen/article/details/58586605 子线程不能修改ui线程中的数据OkHttp是一个类似HttpUrlConnection的一个框架。OkHttp是一个可以在Java项目和Android项目中使用的框架。所以其内部并没有Handler类来完成线程间的通信。所以，对于android而言，其返回的结果都是在子线程中。需要程序人自己写Handler完成数据传递。OkHttp的Post和Get请求都有2中方式：同步和异步。其中同步请求不能直接在UI线程中进行。————————————————版权声明：本文为CSDN博主「Javen2016」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/muyi_amen/article/details/58586605 在学习中，难免有一些坑，每次遇到坑我就和大家分享一下，在okhttp中我们成功的访问后台，然后从onResponse中获得了返回的json数据（安卓和后台一般用json格式做数据交互），然后你会发现这个返回的数据你只能在onResponse方法内调用，放到方法外，这个数据就不好用，也不是不好用就是你弄不出去，追根揭底就是okhttp是异步请求，你没办法将异步请求的结果放到主线程中使用，这时就要用handler来发挥作用啦————————————————版权声明：本文为CSDN博主「课么多巨蜥」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_36005199/article/details/79966761 端口占用https://blog.csdn.net/l_mloveforever/article/details/88365379 采坑1、拖进来的文件不能用中文名，你没用放里面都不行2、 btn_2&#x3D;findViewById(R.id.btn_2);不能放在oncreate外面！！！，不然闪退3、RelativeLayout(相对布局)中没有tools:context&#x3D;”.MainActivity”，但是普通的androidx.constraintlayout.widget.ConstraintLayout里面得写上这一句。4、现在httpclient已被弃用，google鼓励使用HttpURLConnection；若使用第三方的包Android-async-http，那么要下载android-async-http-1.4.8.jar和httpcore-4.4.5.jar；其中android-async-http-1.4.9.jar版本会报错。AsyncHttpResponseHandler类使用报错，找不到org.apache.http.Header 5、https://blog.csdn.net/qq_38233258/article/details/890769566、模块加错了位置https://blog.csdn.net/haijie_liu/article/details/90896111 7、在 Android 中，只有主线程才能操作 UI，但是主线程不能进行耗时操作，否则会阻塞线程，产生 ANR 异常，所以常常把耗时操作放到其它子线程进行。如果在子线程中需要更新 UI，一般是通过 Handler 发送消息，主线程接受消息并且进行相应的逻辑处理。除了直接使用 Handler，还可以通过 View 的 post 方法以及 Activity 的 runOnUiThread 方法来更新 UI，它们内部也是利用了 Handler 。Message可携带的数据 &#x2F;&#x2F;通常作标志位，作区分message.what;（int） &#x2F;&#x2F;携带简单数据message.arg1;（int）message.arg2;（int） &#x2F;&#x2F;携带object数据类型message.obj;（object） 8、mdpi的图像和别的xdpi有区别，如果出现xml文件报错的时候要换一下图片试试，64 ＊64的图是可以缩放限制其大小的https://blog.csdn.net/lantiankongmo/article/details/50549128?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2https://www.cnblogs.com/bhlsheji/p/5042360.html 9、两个activity传送数据https://www.jianshu.com/p/4b5f1289f645 10、handlerhttps://blog.csdn.net/qq_37321098/article/details/81535449http://www.imooc.com/article/20194https://www.jianshu.com/p/50ec129109a1 11、android Q(10) 在读写文件时引入的权限问题经过一天的查找，发现，android Q对于文件读写引入了新特性，在这个版本中，READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE均受到了限制，无法再像之前的版本直接获取到文件。如果希望恢复之前的权限逻辑，可以在manifest文件中设置： android:requestLegacyExternalStorage&#x3D;”true” https://blog.csdn.net/Anhe0901/article/details/103018915?utm_source=app 12、base64编码在传输的时候出现空格，导致照片不能显示；将空格变为+，照片就能显示了。13、适配器问题，不能给item中的某个控件添加点击事件，因为获取不到这个对象的属性，所以要给整个item添加点击事件。 android app程序闪退原因分析 1.xml布局不合理，导致程序难以绘制界面，从而闪退，例如：中放入导致布局不合理2.activity没有在manifest中申明3.相应的 代码放置的位置不正确,4.相关activity，fragment中类的引用不对 123456789101112131415161718192021222324252627282930313233343536373839404142DoGET方式接受数据，用response传送json回去package com.learn.servlet;import java.io.IOException;import java.io.OutputStream;import java.util.Date;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.alibaba.fastjson.JSON;public class JsonServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; private User buildUserDO()&#123; User user = new User(); user.setName(&quot;张三&quot;); user.setPassword(&quot;123&quot;); user.setAge(11); user.setBirthDay(new Date()); return user; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;application/json; charset=utf-8&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); String userJson = JSON.toJSONString(buildUserDO()); OutputStream out = response.getOutputStream(); out.write(userJson.getBytes(&quot;UTF-8&quot;)); out.flush(); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; &#125;&#125; 12345678910111213141516171819202122232425262728public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //字符流 //response.getWriter().write(&quot;helloworld&quot;); //字节流 response.getOutputStream().write(&quot;helloworld&quot;.getBytes()); &#125;问题1：什么时候使用字节流，什么时候使用字符流？如果是纯文本使用字符流，如果二进制文件，使用字节流。如果只是得到信息，原样不动，不进行修改操作，例如文件上传和下载，这时就使用字节流。文件上传：在服务器端把浏览器端信息提取出来。文件下载：把服务器端内容写给浏览器端。如果要操作的是自定义信息，这时使用字符流。问题2：通过response获取的输出流它的真实类型时什么？ServletOutputStream response.getOutputStream();PrintWriter response.getWriter();ServletOutputStream由于使用字节流多数是原样复制，所以使用write方法，而不是print方法。PrintWriter:打印流，两个特点：1.可以设置自动刷新。2.可以将信息原样输出。————————————————版权声明：本文为CSDN博主「海边拾贝seebit」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/Ada_yangyang/article/details/82191865 上拉加载、下拉刷新时显示数据出现错误解决 出现这个问题的主要原因还是因为不能在主线程中访问网络的问题，因为开启了一个新的线程，然后等待某个方法进行返回数据，但是用while阻挡某个线程的时候，发现线程已经被阻塞了，此时就不能就绪往下运行了，所以将访问数据的线程和主线程放在一个类中，省略一个方法的返回。 就是这个文章中的：Android ListView图文并排+下拉刷新+上拉加载更多_清山博客-CSDN博客 learncloud的聊天工能 小组计划","categories":[{"name":"android开发","slug":"android开发","permalink":"https://zouyunkai.github.io/myblog/categories/android%E5%BC%80%E5%8F%91/"}],"tags":[],"author":"aoyuehan"},{"title":"pat甲级训练题续2","slug":"pat甲级训练题续2","date":"2020-07-29T14:01:00.000Z","updated":"2022-02-26T03:26:59.654Z","comments":true,"path":"2020/07/29/pat甲级训练题续2/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/07/29/pat%E7%94%B2%E7%BA%A7%E8%AE%AD%E7%BB%83%E9%A2%98%E7%BB%AD2/","excerpt":"","text":"1113 Integer Set Partition (排序分两边)123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int maxn = 100001;int a[maxn];int main()&#123; int n,s1 = 0,s2 = 0; cin &gt;&gt; n; for(int i = 0;i &lt; n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; sort(a,a+n); // 分两个集合累加最后的结果 for(int i = 0;i &lt; n;i++)&#123; if(i&lt;n/2) s1 += a[i]; else s2 += a[i]; &#125; cout &lt;&lt; n%2 &lt;&lt; &#x27; &#x27; &lt;&lt; s2-s1 &lt;&lt; endl; return 0;&#125; 1038 Recover the Smallest Number (字典序问题) 一道看起来很简单，写起来有点痛苦，最后解法比较有趣的题目。据说是一道面试题的改编。 题目给你一些数字的片段（number segments），所以应当用string存储而不是int,希望拼接之后能拼出的最小的数字，这是一道很神奇的题目，我分类讨论分了很多，最后突然发现它的最终解法无比简洁。 其实就是一个序的关系，所有的组合有n!种，（像”所谓组出最小数其实是获得字典序最小的拼接方式”这种废话我就不说了）。假设我们获得了其中的一个组合，然后又两个相邻的数字片段a,b。然后我们就要想，把a和b交换能不能使整个序列变小呢？这个问题的其实等价于b+a 是否小于a+b（此处”+”为连接符）,也就是说对于这样一个序列，如果某两个相邻的元素之间发生交换可以使得整个序列的值变小，我们就应该坚决的交换啊，所以这里定义一个新的序，用&lt;&lt;来表示，若a+b &lt; b + a 则a应当在b前面，即a &lt;&lt; b。然后呢，这种序是满足传递性的若a&lt;&lt;b ,b &lt;&lt; c，则a&lt;&lt;c，所以迭代到最后，我们就会获得一个任何两个相邻元素都不能交换的局面，也就是所谓的答案。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt; using namespace std; const int _size = 10000; string num[_size]; bool cmp(const string&amp; a,const string&amp; b)&#123;return a + b&lt; b + a;&#125; int main() &#123; int n,i; cin &gt;&gt; n; for (i=0;i&lt;n;i++) cin &gt;&gt; num[i]; sort(num,num+n,cmp); //按照排序规则进行排序 string out; for (i=0;i&lt;n;i++) out += num[i]; //拼接数字字符 for (i=0;i&lt;out.size()&amp;&amp;out[i]==&#x27;0&#x27;;i++); //略过开头 打头的0 if (i==out.size()) printf(&quot;0&quot;); //如果组合之后的结果全都是0 else printf(&quot;%s&quot;,out.c_str()+i); //打印开头是0之外的那些数字 printf(&quot;\\n&quot;); return 0; &#125; 1118 Birds in Forest (并查集 看给出的两个鸟是不是在一个树上)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;cmath&gt;using namespace std;const int maxn=10010;vector&lt;int&gt; father(maxn,-1);int findFather(int n)&#123;//找爸爸 if(father[n]==-1) return n; //这算是一个小小的优化 else&#123; int f=findFather(father[n]); father[n]=f; return f; &#125;&#125;void uni(int a,int b)&#123; int fa=findFather(a); int fb=findFather(b); if(fa!=fb) father[fa]=fb;//把a放到b里面&#125;int main()&#123; int n,k,b1,b2,maxb=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;k&gt;&gt;b1; maxb=max(b1,maxb); for(int j=0;j&lt;k-1;j++)&#123; cin&gt;&gt;b2; maxb=max(b2,maxb); uni(b1, b2); &#125; &#125; int cnt=0; for(int i=1;i&lt;=maxb;i++)&#123; if(father[i]==-1) cnt++; &#125; cout&lt;&lt;cnt&lt;&lt;&quot; &quot;&lt;&lt;maxb&lt;&lt;endl; int q; cin&gt;&gt;q; for(int i=0;i&lt;q;i++)&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; if(findFather(a)==findFather(b)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125; 1106 Lowest Price in Supply Chain (树的遍历)题目大意供应链由零销商、经销商、供应商组成，从供应商开始，供应链上的每个人在购买货物的时候需要支付比原价格多r%的费用，供应链上不存在环，本题要求求出顾客为购买货物支付的最少费用，并且求出最低价格的供应链存在的条数 分析本题涉及树的遍历，可以采用深度优先遍历或者广度优先遍历，本题采用深度优先遍历，在遍历的过程中记录节点的层数，当遇到叶子节点时，判断当前的叶子节点是否符合题目要求，若层数level小于当前记录的层数minlevel，则更新milevel并且设置count为1（当前符合路径的数目），若层数level等于当前记录的层数milevel，则说明有找到了一条符合题意的路径，则自加1 其中注意在输入的时候，id是从0开始计数的，其中id&#x3D;0的为根销售节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116dfs遍历：#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1e5 + 10;struct node &#123; double p; vector&lt;int&gt;child;&#125;Node[maxn];double minp = 1e10 + 10;int cnt = 0;int n;double p, r;void DFS(int root)&#123; if (Node[root].child.size() == 0) &#123; if (Node[root].p &lt; minp)minp = Node[root].p, cnt = 1; else if (Node[root].p == minp)cnt++; return; &#125; for (int i = 0; i &lt; Node[root].child.size(); i++) &#123; int child = Node[root].child[i]; Node[child].p = Node[root].p*(1 + r); DFS(child); &#125;&#125;int main()&#123; scanf(&quot;%d%lf%lf&quot;, &amp;n, &amp;p, &amp;r); r /= 100; for (int i = 0; i &lt; n; i++) &#123; int k, x; scanf(&quot;%d&quot;, &amp;k); while (k--) &#123; scanf(&quot;%d&quot;, &amp;x); Node[i].child.push_back(x); &#125; &#125; Node[0].p = p; DFS(0); printf(&quot;%.4f %d&quot;, minp, cnt); return 0;&#125;bfs遍历： void BFS(int root)&#123; queue&lt;int&gt;q; q.push(root); while (!q.empty()) &#123; int top = q.front(); q.pop(); if (Node[top].child.size()) &#123; for (int i = 0; i &lt; Node[top].child.size(); i++) &#123; int child = Node[top].child[i]; Node[child].p = Node[top].p*(1 + r); q.push(child); &#125; &#125; else &#123; if (Node[top].p &lt; minp)minp = Node[top].p, cnt = 1; else if (Node[top].p == minp)cnt++; &#125; &#125;&#125;另外用二维数组表示一棵树： #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e5+10;vector&lt;int&gt;a[maxn];int n;double P,r;int minheight=maxn,ans;void DFS(int v,int height)&#123; if(a[v].size()==0) &#123; if(height&lt;minheight)minheight=height,ans=1; else if(height==minheight)ans++; &#125; for(int i=0;i&lt;a[v].size();i++) &#123; int u=a[v][i]; DFS(u,height+1); &#125;&#125;int main()&#123; scanf(&quot;%d%lf%lf&quot;,&amp;n,&amp;P,&amp;r); r/=100; for(int i=0;i&lt;n;i++) &#123; int k,x; scanf(&quot;%d&quot;,&amp;k); while(k--) &#123; scanf(&quot;%d&quot;,&amp;x); a[i].push_back(x); &#125; &#125; DFS(0,1); printf(&quot;%.4f %d&quot;,P*pow(1+r,minheight-1),ans); return 0;&#125; 1087 All Roads Lead to Rome (Dijkstra维护最大价值最少节点的最短路，最短路的条数)https://blog.csdn.net/qq_40531479/article/details/104188442 1126 Eulerian Path (欧拉图)简介 题目大意：判断一个图是欧拉图、半欧拉图还是非欧拉图, 如果一个连通图的所有结点的度都是偶数，那么它就是Eulerian，如果除了两个结点的度是奇数其他都是偶数，那么它就是Semi-Eulerian，否则就是Non-Eulerian～ 分析：用邻接表存储图，判断每个结点的度【也就是每个结点i的v[i].size()】是多少即可得到最终结果～注意：图必须是连通图，所以要用一个深搜判断一下连通性，从结点1开始深搜，如果最后发现统计的连通结点个数cnt !&#x3D; n说明是不是连通图，要输出Non-Eulerian～ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt; &gt; v;vector&lt;bool&gt; visit;int cnt = 0;void dfs(int index) &#123; //dfs判断图的连通性 visit[index] = true; cnt++; for (int i = 0; i &lt; v[index].size(); i++) if (visit[v[index][i]] == false) dfs(v[index][i]);&#125;int main() &#123; int n, m, a, b, even = 0; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); //图中的n个点m条边 v.resize(n + 1); visit.resize(n + 1); for (int i = 0; i &lt; m; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); //这地方边的标号是从1开始的，所以点的标号要从1开始 v[a].push_back(b); v[b].push_back(a); &#125; for (int i = 1; i &lt;= n; i++) &#123; //从顶点1开始找 if (i != 1) printf(&quot; &quot;); printf(&quot;%d&quot;, v[i].size()); if (v[i].size() % 2 == 0) even++; //判断图中该点的度数 &#125; printf(&quot;\\n&quot;); dfs(1); if (even == n &amp;&amp; cnt == n) printf(&quot;Eulerian&quot;); else if(even == n - 2 &amp;&amp; cnt == n) printf(&quot;Semi-Eulerian&quot;); else printf(&quot;Non-Eulerian&quot;); return 0;&#125;","categories":[{"name":"pat","slug":"pat","permalink":"https://zouyunkai.github.io/myblog/categories/pat/"}],"tags":[],"author":"aoyuehan"},{"title":"pat甲级训练题续1","slug":"pat甲级训练题续1","date":"2020-07-19T14:01:00.000Z","updated":"2022-02-26T03:26:59.594Z","comments":true,"path":"2020/07/19/pat甲级训练题续1/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/07/19/pat%E7%94%B2%E7%BA%A7%E8%AE%AD%E7%BB%83%E9%A2%98%E7%BB%AD1/","excerpt":"","text":"1039 Course List for Student (字符串hash)给出学校的总的学生数和课程数，然后给出每个课程的编号和学生数，下一行给出该课程的所有学生编号，然后最后一行给出要查询的学生的编号，查询结果第一个是该学生的姓名，第二个是该学生选课总数，第三个是该学生选课的课程编号。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687方法一，用c语言自带的map #include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;iterator&gt;#include&lt;unordered_map&gt;using namespace std;int main()&#123; std::ios::sync_with_stdio(false); //关闭流同步 int N, K; cin &gt;&gt; N &gt;&gt; K; unordered_map&lt;string, vector&lt;int&gt;&gt; hash; for (int i = 0; i &lt; K; i++) &#123; int classindex, student; cin &gt;&gt; classindex &gt;&gt; student; string input; for (int i = 0; i &lt; student; i++) &#123; cin &gt;&gt; input; auto it = hash.find(input); //if (it == hash.end()) 可以不用判断是否学生选过该课程 // hash[input] = vector&lt;int&gt;&#123; classindex &#125;; //else hash[input].push_back(classindex); &#125; &#125; string query; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; query; auto&amp; data = hash[query]; //为auto&amp; cout &lt;&lt; query &lt;&lt; &quot; &quot; &lt;&lt; data.size(); sort(data.begin(), data.end()); for (auto x : data) cout &lt;&lt; &quot; &quot; &lt;&lt; x; cout &lt;&lt; endl; &#125;&#125; 方法二：用自己写的hash函数#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int Max = 26*26*26*10;using namespace std;vector&lt;int&gt;course[Max]; //以学生的id为下标的course的vector数组就是存放改学生的所有课程记录//也就是个二维数组int name2Id(char s[])&#123; int num = 0; for(int i = 0; i &lt; 3;i++) &#123; num = num * 26 + s[i]-&#x27;A&#x27;; &#125; num = num * 10 + s[3]-&#x27;0&#x27;; return num;&#125;int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; char s[5]; for(int i = 0; i &lt; k; i ++) &#123; int p,m; scanf(&quot;%d %d&quot;,&amp;p,&amp;m); for(int j = 0; j &lt; m; ++j) &#123; scanf(&quot;%s&quot;,s); int id = name2Id(s); course[id].push_back(p); //向这个vecotr中添加课程数据 &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf(&quot;%s&quot;,s); int id = name2Id(s); printf(&quot;%s %d&quot;,s,course[id].size()); sort(course[id].begin(),course[id].end()); for(int j = 0; j &lt; course[id].size(); ++j) &#123; printf(&quot; %d&quot;,course[id][j]); //打印这个学生的所有选课记录 &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 1084 Broken Keyboard ( 散列)给出两行字符串，输出第一行中没有在第二行出现的字符 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; char s[81],r[81]; bool map[200]=&#123;0&#125;; //将字母当做map的参数值 cin&gt;&gt;s&gt;&gt;r; for(int i=0;s[i]!=&#x27;\\0&#x27;;i++)&#123; if(s[i]&gt;=&#x27;a&#x27;&amp;&amp;s[i]&lt;=&#x27;z&#x27;)s[i]=s[i]-32; //如果是小写 转换为大写来统一比较 if(map[s[i]]==false)&#123; //第一行中的字母在总的字母串中标记出来 map[s[i]]=true; &#125; &#125; for(int i=0;r[i]!=&#x27;\\0&#x27;;i++)&#123; if(r[i]&gt;=&#x27;a&#x27;&amp;&amp;r[i]&lt;=&#x27;z&#x27;)r[i]=r[i]-32; if(map[r[i]]==true)&#123; //第二行中出现的字母在第一行中取消标记 map[r[i]]=false; &#125; &#125; for(int i=0;s[i]!=&#x27;\\0&#x27;;i++)&#123; if(map[s[i]]==true)&#123; //输出第一行中被第一次标记的那些字符 map[s[i]]=false; cout&lt;&lt;s[i]; &#125; &#125; return 0;&#125; 1051 Pop Sequence （栈模拟）​ 题目大意： 有一个栈，大小为M，数字1~N依次入栈，给出K个出栈序列，判断该序列是否满足出栈要求。 方法一 解题思路： 入栈顺序是确定的，我们只需要模拟这个过程，从1到N入栈，如果遇到题目所给序列，那么即刻出栈，遍历到最后的结果应该是空栈空序列，刚好满足。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stack&gt; #include&lt;vector&gt;using namespace std;int main()&#123; int M,N,K; while(cin&gt;&gt;M&gt;&gt;N&gt;&gt;K)&#123; vector&lt;int&gt; seq(N); for(int i=0;i&lt;K;i++)&#123; //有K个要验证的栈序列 for(int j=0;j&lt;N;j++)&#123; cin&gt;&gt;seq[j]; &#125; bool isStack = true; stack&lt;int&gt; st; int index = 0; for(int j=1;j&lt;=N;j++)&#123; st.push(j); if(st.size()&gt;M)&#123; //如果该模拟栈已经超出了题目中要求的最大值M，标识结果为false isStack = false; break; &#125; while(!st.empty()&amp;&amp;st.top()==seq[index])&#123; //只要栈不空，并且栈顶元素等于要出栈的那个序列的值 st.pop(); //让栈中的元素出栈 index++; &#125; &#125; if(!st.empty())&#123; isStack = false; //当栈不为空的时候该序列不是栈序列 &#125; cout&lt;&lt;(isStack?&quot;YES&quot;:&quot;NO&quot;)&lt;&lt;endl; &#125; &#125; return 0;&#125; 方法二 结论法：出栈序列中每个元素的后面的所有比它小的元素，一定可以组成一个递减序列并且该序列中的元素个数一定小于栈的最大容量。 假设栈的容量M为5，N为7(入栈顺序是1,2,3,4,5,6,7)。 1.出栈序列为 3 2 1 7 5 6 4。 因为元素7 后面所有比它小的元素5 6 4不是一个递减序列，所以出栈序列不合法。 2.出栈序列为7 6 5 4 3 2 1. 虽然元素7后面所有比它小的元素 6 5 4 3 2 1是一个递 减序列，但是该序列的元素个数是6，大于栈的容量5，所以出栈序列不合法。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;int a[1010] = &#123;0&#125;;int main() &#123; int m,n,k; scanf(&quot;%d%d%d&quot;,&amp;m,&amp;n,&amp;k); while(k--) &#123; for(int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;,&amp;a[i]); bool flag = true; for(int i = 0; i &lt; n &amp;&amp; flag == true; ++i) &#123; if(a[i] &gt; 2) &#123; flag = true; int min = a[i],cnt = 0; for(int j = i+1; j &lt; n &amp;&amp; flag == true; ++j) &#123; if(a[j] &lt; a[i]) &#123; //取递减序列的那些数出来进行比较 if(min &gt; a[j]) &#123; //递减序列的最小元素与要加入序列的元素比较 min = a[j]; cnt++;//统计递减序列的元素个数 if(cnt == m) flag = false; &#125; else flag = false; &#125; &#125; &#125; &#125; if(flag == false) printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n&quot;); &#125; return 0;&#125; 1031 Hello World for U （模拟）要求：n1&#x3D;n3&lt;&#x3D;n2而且n1尽可能大 **思路： ** n1+n2+n3-2&#x3D;len &#x3D;&gt; n2&#x3D;len+2-2n1 n2&gt;&#x3D;n1 &#x3D;&gt; n1&lt;&#x3D;(len+2)&#x2F;3 对于非最后一行(n1-1行)：p指向首，q指向尾，先输出a[p]，再输出n2-2个空格，再输出a[q] 对于最后一行：从p遍历到q，依次输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char a[85]; scanf(&quot;%s&quot;,a); int len = strlen(a); int n1, n2; n1 = (len+2)/3;//向下取整 n2 = len-2*n1+2; int p=0, q=len-1; for( int i=0; i&lt;n1-1; i++)&#123; printf(&quot;%c&quot;,a[p]); for(int j=0; j&lt;n2-2; j++)&#123; printf(&quot; &quot;); &#125; printf(&quot;%c\\n&quot;,a[q]); p++; q--; &#125; for( int i=p; i&lt;=q; i++)&#123; printf(&quot;%c&quot;,a[i]); &#125; return 0;&#125;方法二：填数组 #include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char a[85],ans[40][40]; scanf(&quot;%s&quot;,a); int len = strlen(a); int n1, n2; n1 = (len+2)/3;//向下取整 n2 = len-2*n1+2; for( int i=0; i&lt;n1; i++)&#123;//初始化ans数组为空格 for( int j=0; j&lt;n2; j++)&#123; ans[i][j] = &#x27; &#x27;; &#125; &#125; int pos = 0;//用来遍历a for( int i =0; i&lt;n1; i++)&#123;//n1 ans[i][0] = a[pos++]; &#125; for( int i =1; i&lt;n2; i++)&#123;//n2 ans[n1-1][i] = a[pos++]; &#125; for(int i=n1-2; i&gt;=0; i--)&#123;//n3 ans[i][n2-1] = a[pos++]; &#125; for( int i=0; i&lt;n1; i++)&#123;//输出 for( int j=0; j&lt;n2; j++)&#123; printf(&quot;%c&quot;,ans[i][j]); &#125; if(i&lt;n1-1) printf(&quot;\\n&quot;); &#125; return 0;&#125;————————————————版权声明：本文为CSDN博主「dulongxiang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/dulongxiang/java/article/details/98454843 1069 The Black Hole of Numbers (数学问题) 6174数学黑洞问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt; using namespace std; bool cmp(const char &amp;ch1,const char &amp;ch2 )&#123; return ch1 &gt; ch2;&#125; void myitostr(int n,char str1[])&#123; int i=3; while(n)&#123; str1[i] = n%10+&#x27;0&#x27;; n /=10; i--; &#125; for(;i&gt;=0;i--) str1[i]=&#x27;0&#x27;; str1[4] = &#x27;\\0&#x27;;&#125; int main()&#123; int n; char str1[6]; char str2[6]; char res[6]; cin &gt;&gt;n; myitostr(n,str1); strcpy(str2,str1); sort(str1,str1+4); sort(str2,str2+4,cmp); int num1=atoi(str1); int num2=atoi(str2); n=num2-num1; if(n==0)&#123; cout &lt;&lt;str2 &lt;&lt;&quot; - &quot; &lt;&lt;str1 &lt;&lt;&quot; = &quot;; myitostr(n,res); cout &lt;&lt;res &lt;&lt;endl; return 0; &#125; while(1)&#123; cout &lt;&lt;str2 &lt;&lt;&quot; - &quot; &lt;&lt;str1 &lt;&lt;&quot; = &quot;; myitostr(n,res); cout &lt;&lt;res &lt;&lt;endl; if(n==6174) return 0; myitostr(n,str1); strcpy(str2,str1); sort(str1,str1+4); sort(str2,str2+4,cmp); num1=atoi(str1); num2=atoi(str2); n=num2-num1; &#125;&#125; 方法二： 思路：核心是找到数值与字符串互相转化的方法，还要考虑高位补0。cstdio中天然有一个利器，那就是sprintf()和sscanf()两个函数。数值有4位，转换时，字符数组大小要定为5，因为要接收最后的 ‘\\0’，否则提交后会出现运行时错误。 #include &lt;cstdio&gt;#include &lt;algorithm&gt;int num_to_dec(int a);int num_to_inc(int a);bool cmp_dec(char a, char b);bool cmp_inc(char a, char b);int main()&#123; int num; scanf(&quot;%d&quot;, &amp;num); while(true)&#123; int num_dec = num_to_dec(num); int num_inc = num_to_inc(num); num = num_dec - num_inc; printf(&quot;%04d - %04d = %04d\\n&quot;, num_dec, num_inc, num); if(num==0 || num==6174) break; &#125; return 0;&#125;int num_to_dec(int a)&#123; char n[5]; sprintf(n, &quot;%04d&quot;, a); //字符串格式化命令 将a的值按照格式转换到字符数组n中 std::sort(n, n+4, cmp_dec); int value=0; for(int i=0; i&lt;4; i++)&#123; value = value*10+(n[i]-&#x27;0&#x27;); &#125; return value;&#125;int num_to_inc(int a)&#123; char n[5]; sprintf(n, &quot;%04d&quot;, a); std::sort(n, n+4, cmp_inc); int value=0; for(int i=0; i&lt;4; i++)&#123; value = value*10+(n[i]-&#x27;0&#x27;); &#125; return value;&#125;bool cmp_dec(char a, char b)&#123; return (int)a&gt;(int)b;&#125;bool cmp_inc(char a, char b)&#123; return (int)a&lt;(int)b;&#125; 1060 Are They Equal (科学计数法 模拟) 简析：这道题主要是将数字进行固定小数位的科学表示法，如果两个表示法一样就输出YES和对应的表示法，不然输出NO，然后输出各自的表示。 虽然表面是数字，但是它会给出过界的数字，所以需要通过字符串来操作，不然会出错。主要就是算出主要的部分，把无关的0和小数点去掉。最后输出的时候再加上“0.”，多退少补‘0’。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cmath&gt;using namespace std;string cntl(string s,int&amp; n,int m)&#123; int k = 0; while(s.length() &gt; 0 &amp;&amp; s[0] == &#x27;0&#x27;) s.erase(s.begin()); if(s[0] == &#x27;.&#x27;) &#123; s.erase(s.begin()); while (s.length() &gt; 0 &amp;&amp; s[0] == &#x27;0&#x27;) &#123; s.erase(s.begin()); n--; &#125; &#125;else&#123; while(k &lt; s.length() &amp;&amp; s[k] != &#x27;.&#x27;) &#123; k++; n++; &#125; if(k &lt; s.length()) s.erase(s.begin() + k); &#125; if(s.length() == 0) n = 0; int num = 0; k = 0; string res; while(num &lt; m) //统计前m位精度 &#123; if(s.length() &gt; k) res += s[k++]; else res += &#x27;0&#x27;; num++; &#125; return res; //返回 这个数的0.之后的那些不为0的数&#125;int main()&#123; string s1, s2, s3, s4; int n, e1 = 0, e2 = 0; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2; s3 = cntl(s1, e1, n); s4 = cntl(s2, e2, n); if(s3 == s4 &amp;&amp; e1 == e2) cout &lt;&lt; &quot;YES 0.&quot; &lt;&lt; s3 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1 &lt;&lt; endl; else cout &lt;&lt; &quot;NO 0.&quot; &lt;&lt; s3 &lt;&lt; &quot;*10^&quot; &lt;&lt; e1 &lt;&lt; &quot; 0.&quot; &lt;&lt; s4 &lt;&lt; &quot;*10^&quot; &lt;&lt; e2 ; return 0;&#125;","categories":[{"name":"pat","slug":"pat","permalink":"https://zouyunkai.github.io/myblog/categories/pat/"}],"tags":[],"author":"aoyuehan"},{"title":"javaweb项目配置","slug":"javaweb项目配置","date":"2020-07-17T14:01:00.000Z","updated":"2022-04-03T13:18:45.393Z","comments":true,"path":"2020/07/17/javaweb项目配置/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/07/17/javaweb%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/","excerpt":"","text":"javaweb项目在idea中的配置1、导入项目之后 选中项目，按alt+shifit+ctrl+S，进入该项目的Project Structure，对本项目进行一些配置 2、然后在Modules目录中配置web模块，添加web模块之后，配置web模块web.xml依赖介绍和web目录文件夹。 其中对整个模块的配置如下： 其中Dependencies下可以配置以idea的方式存放项目设置还是以eclipse的方式存放项目配置 3、在Libraries目录下配置jar包的依赖 4、Facets目录下也要配置好相应的web模块 5、配置tomcat eclipse配置javaweb项目1、 2、项目构件的配置（项目的web模块支持） 3、运行环境tomcat的配置 3、java 构建路径的配置 普通的java项目的配置 就只配置好javajdk就可以直接运行main主类就可以运行的","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://zouyunkai.github.io/myblog/categories/JAVA/"}],"tags":[],"author":"aoyuehan"},{"title":"mybtas面向接口编程","slug":"mybtas面向接口编程步骤","date":"2020-07-13T14:01:00.000Z","updated":"2022-02-26T03:26:59.806Z","comments":true,"path":"2020/07/13/mybtas面向接口编程步骤/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/07/13/mybtas%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%E6%AD%A5%E9%AA%A4/","excerpt":"","text":"mybtas面向接口编程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184 1、mybtas-config.xml配置文档 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/manage?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;rewriteBatchedStatements=true&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;1229&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 将我们写好的sql映射文件（ThtableMapper.xml）一定要注册到全局配置文件（mybatis-config.xml）中 --&gt; &lt;mappers&gt; &lt;mapper resource=&quot;ThtableMapper.xml&quot; /&gt; &lt;mapper resource=&quot;QcgoodskucunMapper.xml&quot; /&gt; &lt;/mappers&gt; &lt;/configuration&gt; 这里在配置日志的时候遇到settings键值对 不知道该放在哪里？？？？？？？？？？ 2、首先是实体类： public class Thtable &#123; int id; String thgongyin; String thchangjia; String thname; Integer thshuliang; String thdate; geter、seter 构造器等 &#125; 3、该类的接口(也就是mapper) public interface ThtableMapper &#123; int deleteByPrimaryKey(Integer id); int insert(Thtable record); int insertSelective(Thtable record); Thtable selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(Thtable record); int updateByPrimaryKey(Thtable record); Integer getallcount(); List&lt;Thtable&gt; queryForPageItems(@Param(&quot;begin&quot;) int begin, @Param(&quot;pageSize&quot;) int pageSize); //这里在方法参数上加Param注解的原因是，这样就可以在sql语句中，用#&#123;注解值&#125;来用方法形参的值了，否则只能按param1、param2、param3.....方式调用方法的多个形数 //而且这里的方法名就是sql语句中的id的值 &#125; 4、接口的xml文件 XXXmapper.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.aoyue.pojo.ThtableMapper&quot;&gt; &lt;!-- 接口式编程，mapper标签中的namespace值为该实体类相应的接口的全路径--&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.aoyue.pojo.Thtable&quot;&gt; &lt;!--type为实体类的路径--&gt; &lt;id column=&quot;id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;thGongyin&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;thgongyin&quot; /&gt; &lt;result column=&quot;thChangjia&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;thchangjia&quot; /&gt; &lt;result column=&quot;thName&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;thname&quot; /&gt; &lt;result column=&quot;thShuliang&quot; jdbcType=&quot;INTEGER&quot; property=&quot;thshuliang&quot; /&gt; &lt;result column=&quot;thDate&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;thdate&quot; /&gt; &lt;/resultMap&gt; &lt;sql id=&quot;Base_Column_List&quot;&gt; &lt;!--这里声明一个静态块，用来引用--&gt; id, thGongyin, thChangjia, thName, thShuliang, thDate &lt;/sql&gt; &lt;select id=&quot;queryForPageItems&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from thtable limit #&#123;begin&#125;,#&#123;pageSize&#125; &lt;/select&gt; &lt;select id=&quot;selectByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from thtable where id = #&#123;id&#125; &lt;/select&gt; &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from thtable where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id=&quot;insertSelective&quot; keyColumn=&quot;id&quot; keyProperty=&quot;id&quot; parameterType=&quot;com.aoyue.pojo.Thtable&quot; useGeneratedKeys=&quot;true&quot;&gt; insert into thtable &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;!-- suffixOverrides:指定去除多余的后缀内容，如：suffixOverrides=&quot;,&quot;，去除trim标签内sql语句多余的后缀&quot;,&quot;。 prefixOverrides:指定去除多余的前缀内容 useGeneratedKeys 参数只针对 insert 语句生效，默认为 false。当设置为 true 时，表示如果插入的表以自增列为主键，则允许 JDBC 支持自动生成主键，并可将自动生成的主键返回。 有时候在开发中需要向表中插入自增ID，这个时候领域模型如果想要获取该ID的值，就需要在相应的mapper文件中添加useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;。 而keyProperty的含义就是，你插入之后，可以通过传进来的Thtable对象.getId()来获取插入之后的id。 --&gt; &lt;if test=&quot;thgongyin != null&quot;&gt; thGongyin, &lt;/if&gt; &lt;if test=&quot;thchangjia != null&quot;&gt; thChangjia, &lt;/if&gt; &lt;if test=&quot;thname != null&quot;&gt; thName, &lt;/if&gt; &lt;if test=&quot;thshuliang != null&quot;&gt; thShuliang, &lt;/if&gt; &lt;if test=&quot;thdate != null&quot;&gt; thDate, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix=&quot;values (&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;thgongyin != null&quot;&gt; #&#123;thgongyin,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;thchangjia != null&quot;&gt; #&#123;thchangjia,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;thname != null&quot;&gt; #&#123;thname,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;thshuliang != null&quot;&gt; #&#123;thshuliang,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test=&quot;thdate != null&quot;&gt; #&#123;thdate,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id=&quot;updateByPrimaryKeySelective&quot; parameterType=&quot;com.aoyue.pojo.Thtable&quot;&gt; update thtable &lt;set&gt; &lt;if test=&quot;thgongyin != null&quot;&gt; thGongyin = #&#123;thgongyin,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;thchangjia != null&quot;&gt; thChangjia = #&#123;thchangjia,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;thname != null&quot;&gt; thName = #&#123;thname,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test=&quot;thshuliang != null&quot;&gt; thShuliang = #&#123;thshuliang,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test=&quot;thdate != null&quot;&gt; thDate = #&#123;thdate,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;/mapper&gt; 5、使用方式 public SqlSessionFactory getSqlSessionFactory() throws IOException &#123; String resource = &quot;mybitas-config.xml&quot;; //这个文件要放到src根目录才能这样写 资源文件夹的时候怎么写？？ InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream); &#125; // 1、获取sqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); // 2、获取sqlSession对象 SqlSession openSession = sqlSessionFactory.openSession(); //这地方传ture时表示自动提交 try &#123; // 3、获取接口的实现类对象 //会为接口自动的创建一个代理对象，代理对象去执行增删改查方法 ThtableDao mapper = openSession.getMapper(ThtableDao.class); int aa= mapper.insertSelective(item); // 添加记录 //插入成功之后aa为1 //主键为id，如果用了useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;后，item.getId()会返回插入数据得到的自增的主键值 openSession.commit(); //在mapper中添加语句之后 openSession调用进行提交 &#125; finally &#123; openSession.close(); &#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://zouyunkai.github.io/myblog/categories/JAVA/"}],"tags":[],"author":"aoyuehan"},{"title":"layer弹出层使用","slug":"layui和layer弹出层dome","date":"2020-07-12T14:01:00.000Z","updated":"2022-02-26T04:29:56.850Z","comments":true,"path":"2020/07/12/layui和layer弹出层dome/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/07/12/layui%E5%92%8Clayer%E5%BC%B9%E5%87%BA%E5%B1%82dome/","excerpt":"","text":"","categories":[{"name":"前端项目总结","slug":"前端项目总结","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"}],"tags":[],"author":"aoyuehan"},{"title":"在进销存管理系统中使用mybtas","slug":"在进销存管理系统中使用mybitas笔记","date":"2020-07-12T14:01:00.000Z","updated":"2022-02-26T03:26:59.860Z","comments":true,"path":"2020/07/12/在进销存管理系统中使用mybitas笔记/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/07/12/%E5%9C%A8%E8%BF%9B%E9%94%80%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8mybitas%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一、用mybatis中的insert方法插入数据，返回值为1，但数据库却没有数据 mybitas的自动提交，学的时候还记得，用的时候就忘了，debug了20多次，明明mapper执行insert的返回值为1了，但是就是没插到数据库中。 解决方案： 1、排除数据库中表设置错误 使用show variables like &#39;%autocommit%&#39;;查看表是否设置自动提交 2、看代码 123456789101112131415161718192021222324252627282930public SqlSessionFactory getSqlSessionFactory() throws IOException &#123; //读取文件获取SqlSessionFactory对象 String resource = &quot;mybitas.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream);&#125;protected void add(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; int pageNo = WebUtils.parseInt(req.getParameter(&quot;pageNo&quot;), 0); pageNo+=1; //这地方用来分页，但是用的主键自增，这地方只是为了添加之后跳到添加物品的那一页 Thtable item = WebUtils.copyParamToBean(req.getParameterMap(),new Thtable()); // 1、获取sqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); // 2、获取sqlSession对象 SqlSession openSession = sqlSessionFactory.openSession(); try &#123; // 3、获取接口的实现类对象 //会为接口自动的创建一个代理对象，代理对象去执行增删改查方法 ThtableDao mapper = openSession.getMapper(ThtableDao.class); int aa= mapper.insertSelective(item); // 添加记录 System.out.println(aa); //aa的返回值一直为1，但是数据库没数据 openSession.commit(); //因为insert不是自动提交的，这里调用commit进行提交 //或者在2步中 这样写 SqlSession openSession = sqlSessionFactory.openSession(true); &#125; finally &#123; openSession.close(); &#125; resp.sendRedirect(req.getContextPath() + &quot;/ThtableServlet?action=page&quot; ); &#125; 实际上，只有select会自动提交，insert、update、delete并不会自动提交，所以问题在于代码 二、mybatis Example 使用方法 1、mapper接口中的方法解析 mapper接口中的函数及方法方法 功能说明int countByExample(UserExample example) thorws SQLException 按条件计数int deleteByPrimaryKey(Integer id) thorws SQLException 按主键删除int deleteByExample(UserExample example) thorws SQLException 按条件查询String&#x2F;Integer insert(User record) thorws SQLException 插入数据（返回值为ID）User selectByPrimaryKey(Integer id) thorws SQLException 按主键查询ListselectByExample(UserExample example) thorws SQLException 按条件查询ListselectByExampleWithBLOGs(UserExample example) thorws SQLException 按条件查询（包括BLOB字段）。只有当数据表中的字段类型有为二进制的才会产生。int updateByPrimaryKey(User record) thorws SQLException 按主键更新int updateByPrimaryKeySelective(User record) thorws SQLException 按主键更新值不为null的字段int updateByExample(User record, UserExample example) thorws SQLException 按条件更新int updateByExampleSelective(User record, UserExample example) thorws SQLException 按条件更新值不为null的字段 2、example实例解析 mybatis的逆向工程中会生成实例及实例对应的example，example用于添加条件，相当where后面的部分xxxExample example &#x3D; new xxxExample();Criteria criteria &#x3D; new Example().createCriteria(); 方法 说明example.setOrderByClause(“字段名 ASC”); 添加升序排列条件，DESC为降序example.setDistinct(false) 去除重复，boolean型，true为选择不重复的记录。criteria.andXxxIsNull 添加字段xxx为null的条件criteria.andXxxIsNotNull 添加字段xxx不为null的条件criteria.andXxxEqualTo(value) 添加xxx字段等于value条件criteria.andXxxNotEqualTo(value) 添加xxx字段不等于value条件criteria.andXxxGreaterThan(value) 添加xxx字段大于value条件criteria.andXxxGreaterThanOrEqualTo(value) 添加xxx字段大于等于value条件criteria.andXxxLessThan(value) 添加xxx字段小于value条件criteria.andXxxLessThanOrEqualTo(value) 添加xxx字段小于等于value条件criteria.andXxxIn(List&lt;？&gt;) 添加xxx字段值在List&lt;？&gt;条件criteria.andXxxNotIn(List&lt;？&gt;) 添加xxx字段值不在List&lt;？&gt;条件criteria.andXxxLike(“%”+value+”%”) 添加xxx字段值为value的模糊查询条件criteria.andXxxNotLike(“%”+value+”%”) 添加xxx字段值不为value的模糊查询条件criteria.andXxxBetween(value1,value2) 添加xxx字段值在value1和value2之间条件criteria.andXxxNotBetween(value1,value2) 添加xxx字段值不在value1和value2之间条件 3、应用举例 selectByExample和selectByExampleWithBLOBs有何区别？ 查询① selectByPrimaryKey() 1User user = XxxMapper.selectByPrimaryKey(100); //相当于select * from user where id = 100 ② selectByExample() 和 selectByExampleWithBLOGs() 1234567UserExample example = new UserExample();Criteria criteria = example.createCriteria();criteria.andUsernameEqualTo(&quot;wyw&quot;);criteria.andUsernameIsNull();example.setOrderByClause(&quot;username asc,email desc&quot;);List&lt;?&gt;list = XxxMapper.selectByExample(example);//相当于：select * from user where username = &#x27;wyw&#x27; and username is null order by username asc,email desc 注：在iBator逆向工程生成的文件XxxExample.java中包含一个static的内部类Criteria，Criteria中的方法是定义SQL 语句where后的查询条件。 插入数据①insert() 1234567User user = new User();user.setId(&quot;dsfgsdfgdsfgds&quot;);user.setUsername(&quot;admin&quot;);user.setPassword(&quot;admin&quot;)user.setEmail(&quot;wyw@163.com&quot;);XxxMapper.insert(user);//相当于：insert into user(ID,username,password,email) values (&#x27;dsfgsdfgdsfgds&#x27;,&#x27;admin&#x27;,&#x27;admin&#x27;,&#x27;wyw@126.com&#x27;); 更新数据①updateByPrimaryKey() 1234567User user =new User();user.setId(&quot;dsfgsdfgdsfgds&quot;);user.setUsername(&quot;wyw&quot;);user.setPassword(&quot;wyw&quot;);user.setEmail(&quot;wyw@163.com&quot;);XxxMapper.updateByPrimaryKey(user);//相当于：update user set username=&#x27;wyw&#x27;, password=&#x27;wyw&#x27;, email=&#x27;wyw@163.com&#x27; where id=&#x27;dsfgsdfgdsfgds&#x27; ②updateByPrimaryKeySelective() &#x2F;&#x2F;只会更新对象中不为null值的那些字段 12345User user = new User();user.setId(&quot;dsfgsdfgdsfgds&quot;);user.setPassword(&quot;wyw&quot;);XxxMapper.updateByPrimaryKey(user);//相当于：update user set password=&#x27;wyw&#x27; where id=&#x27;dsfgsdfgdsfgds&#x27; ③ updateByExample() 和 updateByExampleSelective() 123456789UserExample example = new UserExample();Criteria criteria = example.createCriteria();criteria.andUsernameEqualTo(&quot;admin&quot;);User user = new User();user.setPassword(&quot;wyw&quot;);XxxMapper.updateByPrimaryKeySelective(user,example);//相当于：update user set password=&#x27;wyw&#x27; where username=&#x27;admin&#x27;updateByExample()更新所有的字段，包括字段为null的也更新，建议使用 updateByExampleSelective()更新想更新的字段 删除数据①deleteByPrimaryKey() 1XxxMapper.deleteByPrimaryKey(1); //相当于：delete from user where id=1 ②deleteByExample() 12345UserExample example = new UserExample();Criteria criteria = example.createCriteria();criteria.andUsernameEqualTo(&quot;admin&quot;);XxxMapper.deleteByExample(example);//相当于：delete from user where username=&#x27;admin&#x27; 查询数据数量①countByExample() 12345UserExample example = new UserExample();Criteria criteria = example.createCriteria();criteria.andUsernameEqualTo(&quot;wyw&quot;);int count = XxxMapper.countByExample(example);//相当于：select count(*) from user where username=&#x27;wyw&#x27; 模糊查询 123456789101112131415161718192021222324252627282930313233343536373839404142431、**sql中字符串拼接** qcName为数据库表的字段&lt;if test=&quot;name != null&quot;&gt; and qcName like CONCAT(CONCAT(&#x27;%&#x27;, #&#123;name&#125;), &#x27;%&#x27;) &lt;/if&gt; ##用CONCAT函数进行字符串拼接或者&lt;if test=&quot;name != null&quot;&gt; and qcName like &#x27;%&#x27;||#&#123;name&#125;||&#x27;%&#x27; &lt;/if&gt; 2、 **使用 $&#123;...&#125; 代替 #&#123;...&#125;** #&#123;&#125;是使用预编译（底层使用preparedStatement调用set方法来赋值），会在参数前后加单引号&#x27;而$&#123;&#125;是使用拼接的方式将$&#123;&#125;替换为变量所以mybatis在进行like查询时 &quot;%%&quot;只能使用&quot;%$&#123;&#125;%&quot;，最后会拼接成&quot;%变量%&quot;如：select * from t_travelitem where name like &quot;%巴厘岛%&quot;如果使用&quot;%#&#123;&#125;%&quot;则会被预编译为&quot;%&#x27;变量&#x27;%&quot;如select * from t_travelitem where name like &quot;%&#x27;巴厘岛&#x27;%&quot; （错误的语法）而&quot;%&quot;#&#123;&#125;&quot;%&quot; 则会被预编译为&quot;%&quot;&#x27;变量&#x27;&quot;%&quot;如下select * from t_travelitem where name like &quot;%&quot;&#x27;巴厘岛&#x27;&quot;%&quot;&quot;%&quot;$&#123;&#125;&quot;%&quot; 则会被拼接为 &quot;%&quot;变量&quot;%&quot;如下 如下select * from t_travelitem where name like &quot;%&quot;巴厘岛&quot;%&quot; （错误的语法）3、** 程序中拼接** 我就是使用这种方式： String tmpname=&quot;%&quot;+name+&quot;%&quot;; //然后传递参数进行查询 &lt;select id=&quot;queryForPageItems&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot; /&gt; from qcgoodskucun where 1=1 &lt;if test=&quot;name != null&quot;&gt; and qcName like #&#123;name&#125; &lt;/if&gt; limit #&#123;begin&#125;,#&#123;pageSize&#125; &lt;/select&gt; 4、大小写模糊查询 SELECT * FROM TABLENAME WHERE UPPER(字段名) LIKE &#x27;%&#x27; || UPPER(&#x27;jz&#x27;) || &#x27;%&#x27; 或者 SELECT * FROM TABLENAME WHERE LOWER(字段名) LIKE &#x27;%&#x27; || LOWER(&#x27;jz&#x27;) || &#x27;%&#x27; Mybatis四种分页方式 1、数组分页 123456789101112131415161718192021222324252627282930313233343536数组分页查询出全部数据，然后再list中截取需要的部分。mybatis接口List&lt;Student&gt; queryStudentsByArray();xml配置文件 &lt;select id=&quot;queryStudentsByArray&quot; resultMap=&quot;studentmapper&quot;&gt; select * from student &lt;/select&gt;service层接口List&lt;Student&gt; queryStudentsByArray(int currPage, int pageSize);实现接口 面向接口编程 @Override public List&lt;Student&gt; queryStudentsByArray(int currPage, int pageSize) &#123; //查询全部数据 List&lt;Student&gt; students = studentMapper.queryStudentsByArray(); //从第几条数据开始 int firstIndex = (currPage - 1) * pageSize; //到第几条数据结束 int lastIndex = currPage * pageSize; return students.subList(firstIndex, lastIndex); //直接在list中截取 &#125;controller层 @ResponseBody @RequestMapping(&quot;/student/array/&#123;currPage&#125;/&#123;pageSize&#125;&quot;) public List&lt;Student&gt; getStudentByArray(@PathVariable(&quot;currPage&quot;) int currPage, @PathVariable(&quot;pageSize&quot;) int pageSize) &#123; List&lt;Student&gt; student = StuServiceIml.queryStudentsByArray(currPage, pageSize); return student; &#125; 2、sql分页 12345678910111213141516171819mybatis接口List&lt;Student&gt; queryStudentsBySql(Map&lt;String,Object&gt; data);xml文件&lt;select id=&quot;queryStudentsBySql&quot; parameterType=&quot;map&quot; resultMap=&quot;studentmapper&quot;&gt; select * from student limit #&#123;currIndex&#125; , #&#123;pageSize&#125;&lt;/select&gt;service层接口List&lt;Student&gt; queryStudentsBySql(int currPage, int pageSize);实现类public List&lt;Student&gt; queryStudentsBySql(int currPage, int pageSize) &#123; Map&lt;String, Object&gt; data = new HashedMap(); data.put(&quot;currIndex&quot;, (currPage-1)*pageSize); data.put(&quot;pageSize&quot;, pageSize); return studentMapper.queryStudentsBySql(data);&#125; 3、拦截器分页 1待定 。。。。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://zouyunkai.github.io/myblog/categories/JAVA/"}],"tags":[],"author":"aoyuehan"},{"title":"pat乙级真题练习","slug":"pat乙级真题","date":"2020-07-01T14:01:00.000Z","updated":"2022-02-26T03:27:00.388Z","comments":true,"path":"2020/07/01/pat乙级真题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/07/01/pat%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98/","excerpt":"","text":"A+B和C123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std; int main()&#123; int T,i=0; cin&gt;&gt;T; if (T&gt;10) return 0; double A,B,C; //A,B都在2^31范围内，二者加起来就可能不是了，这里需要注意用double while(i&lt;T) &#123; cin&gt;&gt;A&gt;&gt;B&gt;&gt;C; if (A+B&gt;C) &#123; printf(&quot;Case #%d: true\\n&quot; , i+1); &#125; else &#123; // printf(&quot;Case #%d: false\\n&quot;, i+1); cout&lt;&lt;&quot;Case #&quot;&lt;&lt;i+1&lt;&lt;&quot;: false&quot;&lt;&lt;endl; &#125; i++; &#125; return 0;&#125; int: 4byte &#x3D; 32 bit有符号signed范围：2^31-1 ~ -2^31，1e9级别 ，即：2147483647 ~ -2147483648 float: 4 byte &#x3D; 32 bit范围： 3.40282e+038 ~ 1.17549e-038 float的精度为6~7位有效数字 double: 8 byte &#x3D; 64 bit范围：1.79769e+308 ~ 2.22507e-308 这是范围，但是double的精度为15~16位 long long的最大值：9223372036854775807（&gt;10^18） 这里的精度就是8byte的位数 **（浮点）数值 &#x3D; 尾数 × 底数 ^ 指数，（附加正负号） **","categories":[{"name":"pat","slug":"pat","permalink":"https://zouyunkai.github.io/myblog/categories/pat/"}],"tags":[],"author":"aoyuehan"},{"title":"pat甲级训练题","slug":"pat甲级训练题","date":"2020-07-01T14:01:00.000Z","updated":"2022-04-03T13:18:47.287Z","comments":true,"path":"2020/07/01/pat甲级训练题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/07/01/pat%E7%94%B2%E7%BA%A7%E8%AE%AD%E7%BB%83%E9%A2%98/","excerpt":"","text":"1005 Spell It Right （字符串处理） 给出一个数串，求各个位加起来的和，用英文的形式表示这个和 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt; #include &lt;unordered_set&gt;#include &lt;unordered_map&gt;#include &lt;map&gt;using namespace std;int main()&#123; string str; cin&gt;&gt;str; unordered_map&lt;char, string&gt; mp; //未排序的map，性能比map好点 mp[&#x27;1&#x27;] = &quot;one&quot;; mp[&#x27;2&#x27;] = &quot;two&quot;; mp[&#x27;3&#x27;] = &quot;three&quot;; mp[&#x27;4&#x27;] = &quot;four&quot;; mp[&#x27;5&#x27;] = &quot;five&quot;; mp[&#x27;6&#x27;] = &quot;six&quot;; mp[&#x27;7&#x27;] = &quot;seven&quot;; mp[&#x27;8&#x27;] = &quot;eight&quot;; mp[&#x27;9&#x27;] = &quot;nine&quot;; mp[&#x27;0&#x27;] = &quot;zero&quot;; int sum = 0; for(auto c: str)&#123; //在C语言中使用auto定义的变量可以不予初始化，但在C++中必须初始化 sum += (c -&#x27;0&#x27;); &#125; str = to_string(sum); //这地方换成字符串类型的，要比数值类型的好处理 for(int i = 0; i &lt; str.size(); i++)&#123; char c = str[i]; if(i==0) cout&lt;&lt;mp[c]; else cout&lt;&lt;&quot; &quot;&lt;&lt;mp[c]; &#125; return 0;&#125;样例： in：12345 out：one five 1009 Product of Polynomials （多项式相乘，纯暴力模拟） 给出两个多项式，然后计算得到相乘的结果。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;#define ms(x, n) memset(x,n,sizeof(x));typedef long long LL;const int INF = 1 &lt;&lt; 30;const int MAXN = 1010;double a[MAXN], b[MAXN], c[MAXN*2];int main() &#123; ios::sync_with_stdio(false); //关闭cin流的连接，加快速度 int n, m, x; double y; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; x &gt;&gt; y; a[x] = y; &#125; cin &gt;&gt; m; for(int i = 1; i &lt;= m; ++i)&#123; cin &gt;&gt; x &gt;&gt; y; b[x] = y; &#125; for(int i = 0; i &lt;= 1000; ++i) for(int j = 0; j &lt;= 1000; ++j) c[i+j] += a[i]*b[j]; //多项式相乘的原理，对应系数相乘得到指数相加后的系数 int ans = 0; for(int i = 2000; i &gt;= 0; --i) if(c[i] != 0) ++ans; printf(&quot;%d&quot;,ans); for(int i = 2000; i &gt;= 0; --i) if(c[i] != 0) printf(&quot; %d %.1f&quot;, i, c[i]); return 0;&#125;Sample Input:2 1 2.4 0 3.2 //先给出这个多项式不为0的项数，然后给出一个x的次数，接着是系数2 2 1.5 1 0.5 // ==》1.5*x^2+0.5*x+0=0 Sample Output:3 3 3.6 2 6.0 1 1.6 //输出相乘多项式结果中不为0的项数，然后按上方规则输出结果 1011 World Cup Betting（查找元素） 问题描述：给定三场比赛和每一场的结果的赔率，问怎么下注使利润最大， 解题思路：每一场都选最大的。 因为要利润最大，所以选每场胜率最大的即可 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;double max(double a,double b)&#123; return a&gt;b?a:b;&#125;int main()&#123; double w,t,l,p=1; int i; char c[3]; for(i=0;i&lt;3;i++)&#123; scanf(&quot;%lf %lf %lf&quot;,&amp;w,&amp;t,&amp;l); double m=max(max(w,t),l); //求三者的最大值 p=p*m; if(m==w)c[i]=&#x27;W&#x27;; if(m==t)c[i]=&#x27;T&#x27;; if(m==l)c[i]=&#x27;L&#x27;; &#125; printf(&quot;%c %c %c %.2lf&quot;,c[0],c[1],c[2],(p*0.65-1)*2); //按照规则计算赔率 return 0;&#125;Sample Input:1.1 2.5 1.7 //按照W T L 的顺序给出三个数，然后1.2 3.1 1.64.1 1.2 1.1Sample Output:T T W 39.31 1040 Longest Symmetric String dp思想 12int dp[MAX][MAX]; //dp[ i ][ j ] 表示从i 到 j 的字符串中的最长的回文串 bool dp_b[MAX][MAX];//dp[ i ][ j ] 表示从i 到 j 的字符串是否是回文串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899方法一：dp#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define MAX 1010int dp[MAX][MAX];bool dp_b[MAX][MAX];string s;int main(int argc, char const *argv[])&#123; getline(cin,s); memset(dp,0,sizeof(dp));memset(dp_b,false,sizeof(dp_b)); for(int i=0;i&lt;s.length();i++)&#123; //初始化边界条件 dp[i][i]=1; dp_b[i][i]=true; &#125; for(int j =1;j&lt;s.length();j++)&#123;//状态转移方程 for(int i =j-1;i&gt;=0;i--)&#123; if(s[i]==s[j]&amp;&amp;i+1==j)&#123;//这个处理 当两个连在一起的相同字符 dp_b[i+1][j-1] =true;//这地方一定要要，不然，是没有让两个连续字符串的dp_b成true的 dp_b[i][j]=true; &#125; if(s[i]==s[j]&amp;&amp;dp_b[i+1][j-1])&#123;//两端相等且内部是回文串，因为i和j相差1，这样一运算，i和j就相差3以上了 dp[i][j] =dp[i+1][j-1]+2;//长度加2 dp_b[i][j]=true; &#125; else&#123; dp[i][j] =max(dp[i][j-1],dp[i+1][j]);//两端不会回文串计算 &#125; //左右两个子串 &#125; &#125; cout&lt;&lt;dp[0][s.length()-1];//输出最终结果 return 0;&#125;方法二：暴力+剪枝优化#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;int maxLength = 0;int getLength(string str) //若对称则获取长度，否则若不对称则输出0&#123; int size = str.size(); int length = 0; for (int i = 0; i &lt; size; i++) &#123; if (str[i] == str[size - i - 1]) &#123; length++; &#125; else if(str[i] != str[size - i - 1]) &#123; length = 0; break; &#125; &#125; return length;&#125; void printAllSub(string str) //获取字符串的顺序子串&#123; int size = str.size(); for (int i = 0; i &lt; size; i++) &#123; int flag = 0; for (int j = size - i; j&gt;=1; j--) &#123; if (j &lt;= maxLength) //剪枝 &#123; break; &#125; string tempStr=str.substr(i, j); int temp = getLength(tempStr); if (temp &gt; maxLength) &#123; maxLength = temp; flag++; &#125; if (flag == 1) //剪枝 &#123; break; &#125; &#125; &#125;&#125; int main()&#123; string str; getline(cin,str); printAllSub(str); cout &lt;&lt; maxLength; system(&quot;pause&quot;); return 0;&#125; 1044 Shopping in Mars （二分法） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;using namespace std;typedef long long LL;#define maxn 100010LL rec[maxn] = &#123;0&#125;; //数组全部清0int main()&#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; rec[i]; for(int i = 2; i &lt;= n; i++) rec[i] = rec[i] + rec[i - 1]; int min = rec[n]; //求出满足要求的最小值或者最小的值为题目要支付的费用m for(int i = 1; i &lt;= n; i++)&#123; int pos = lower_bound(rec + i, rec + n + 1, m + rec[i - 1]) - rec; //小于等于 if(pos != n + 1 &amp;&amp; rec[pos] - rec[i - 1] &lt; min) min = rec[pos] - rec[i - 1]; &#125; for(int i = 1; i &lt;= n; i++)&#123; int pos = lower_bound(rec + i, rec + n + 1, m + rec[i-1]) - rec;//lower_bound函数用二分实现的 if(pos != n + 1 &amp;&amp; rec[pos] - rec[i - 1] == min) printf(&quot;%d-%d\\n&quot;, i, pos); //在循环一次求出满足要求的那些解 &#125; return 0;&#125;方法二：#include&lt;iostream&gt;#include&lt;algorithm&gt;#define MAX 100001using namespace std;int diamonds[MAX];int main()&#123; int N,M,input; while(cin&gt;&gt;N&gt;&gt;M)&#123; int minlost = 99999999; int low = 0; bool notFound = true; fill(diamonds,diamonds+MAX,0); for(int i=1;i&lt;=N;i++)&#123; cin&gt;&gt;diamonds[i]; diamonds[i]+=diamonds[i-1]; //在输入的时候进行累加 while(diamonds[i] - diamonds[low]&gt;M)&#123; //如果[low,i]这段区间的值大于了M了，那么就让low++ minlost = min(minlost,diamonds[i] - diamonds[low]); //如果没有区间等于M的话，得找区间和等于minlost的 low++; //low++，找到下一段符合的区间 &#125; if(diamonds[i] - diamonds[low] == M)&#123; //如果这段区间的值符合要求，即等于M，那么直接输出 cout&lt;&lt;low+1&lt;&lt;&quot;-&quot;&lt;&lt;i&lt;&lt;endl; notFound = false; &#125; &#125; if(notFound)&#123; //如果已经找到有一段区间等于M了，那么就不用找区间和大于M的最小的一段了 low = 0; for(int i=1;i&lt;=N;i++)&#123; while(diamonds[i] - diamonds[low]&gt;minlost)&#123; low++; &#125; if(diamonds[i] - diamonds[low]==minlost)&#123; cout&lt;&lt;low+1&lt;&lt;&quot;-&quot;&lt;&lt;i&lt;&lt;endl; &#125; &#125; &#125; &#125; return 0;&#125; ————————————————原文链接：https://blog.csdn.net/CV_Jason/java/article/details/85074263 1085 Perfect Sequence (25分) 给出一个数字序列，然后给出一个正整数p，M，m为这个序列中某段序列的最大最小值，求满足M&lt;&#x3D;m×P 的序列中包含的个数的最大值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn = 100005;int a[maxn];int main()&#123; int n, p; int maxn = 0; scanf(&quot;%d%d&quot;,&amp;n,&amp;p); for(int i = 0; i &lt; n; ++i)&#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; sort(a, a + n); for(int i = 0; i &lt; n; ++i)&#123; //long long num = a[i] * p; int pos = upper_bound(a + i + 1, a + n, (long long)a[i]*p) - a; //这地方a[i]*p会爆int maxn = max(maxn, pos - i); //题目说的是这段序列的最多的个数是多少，不是可选的点的总个数 &#125; printf(&quot;%d&quot;,maxn); return 0;&#125;Sample Input:10 82 3 20 4 5 1 6 7 8 9Sample Output:8 //就是这一段20 4 5 1 6 7 8 9 方法二（双指针）：#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int n,p;vector&lt;int&gt; a;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;p); a.resize(n); for(int i = 0;i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); sort(a.begin(), a.end()); //其实这地方排序之后对原序列不会改变这个性质 int i = 0, j = 0,cnt = 0; while(i &lt; n &amp;&amp; j &lt; n)&#123; while(a[i] * p &gt;= a[j] &amp;&amp; j &lt; n) j++; //先固定i，然后对排序的序列一直往后找符合要求的j cnt = max(cnt , j - i); i++; &#125; printf(&quot;%d&quot;, cnt); //输出满足要求的最大的数 return 0;&#125; 1025 PAT Ranking （排序） 给出几个考场，和考场内的学生数，和他们的成绩，求考生的总排名，考场号，考场内的排名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;struct node&#123; string id; int score,tot_rank,location,loc_rank;&#125;;bool cmp(const node &amp;a, const node &amp;b)&#123; return a.score==b.score ? a.id&lt;b.id : a.score&gt;b.score; //返回值大于0，说明第一个数大，大值优先，所以从大到小排列 //返回值小于0，说明第一个数a的值小，小值优先，从小到大排列&#125;int main()&#123; int n,m,num = 0; scanf(&quot;%d&quot;,&amp;n); struct node v[30001]; for(int i = 1; i &lt;= n; i++)&#123; scanf(&quot;%d&quot;,&amp;m); //该考场的考生人数 for(int j = 0; j &lt; m; j++)&#123; cin &gt;&gt;v[num].id&gt;&gt;v[num].score; v[num].location = i; num++; &#125; sort(v+num-m,v+num,cmp); //先对每个考场进行场内排序 v[num-m].loc_rank = 1; for(int j = 1; j &lt; m; j++)&#123; if(v[num-m+j].score==v[num-m+j-1].score) v[num-m+j].loc_rank = v[num-m+j-1].loc_rank; else v[num-m+j].loc_rank = j+1; &#125; &#125; sort(v,v+num,cmp); //对所有考生进行排序 v[0].tot_rank = 1; for(int i = 1; i &lt; num; i++)&#123; v[i].tot_rank = v[i].score==v[i-1].score ? v[i-1].tot_rank : i+1; //如果本考生的成绩和前面一个考生的成绩一样的话，该考生的排名就和前一考生的排名一样 &#125; printf(&quot;%d\\n&quot;,num); for(int i = 0; i &lt; num; i++)&#123; //输出结果 cout &lt;&lt; v[i].id &lt;&lt; &quot; &quot; &lt;&lt; v[i].tot_rank &lt;&lt; &quot; &quot; &lt;&lt; v[i].location &lt;&lt; &quot; &quot; &lt;&lt; v[i].loc_rank &lt;&lt; endl; &#125; return 0;&#125; 1109 Group Photo （思维） 对排相册的人数进行排列打印 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; using namespace std; const int maxn = 10010; struct People&#123; char name[20]; int h; &#125;peo[maxn]; bool cmp(People a,People b)&#123; //排序cmp return a.h != b.h ? a.h &gt; b.h : strcmp(a.name,b.name) &lt; 0; &#125; void print(int index,int n)&#123; //打印结果，index为peo中下标 int a[n]; a[n/2] = index; //把最高的放中间， int left = n/2 - 1,right = n/2 + 1,i = index+1; while(left &gt;= 0 || right &lt; n)&#123; //左边一个 右边一个，然后放到序列中 if(left &gt;= 0) a[left--] = i++; //先左边在右边，就能保证身高相同时的字典序 这地方有点问题？？ if(right &lt; n) a[right++] = i++; &#125; for(int i = 0; i &lt; n; i++)&#123; printf(&quot;%s&quot;,peo[a[i]].name); //打印结果 if(i &lt; n - 1) printf(&quot; &quot;); &#125; printf(&quot;\\n&quot;); &#125; void svole(int n,int k)&#123; sort(peo,peo+n,cmp); //按照人的身高从大到小排列，身高相同按名字的字母序排列 int num = n/k; print(0,num+n%k); //先打印最后一排 for(int i = num+n%k; i &lt; n; i += num)&#123; //打印前几排 print(i,num); &#125; &#125; int main()&#123; int n,k; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i = 0; i &lt; n; i++)&#123; scanf(&quot;%s %d&quot;,peo[i].name,&amp;peo[i].h); &#125; svole(n,k); return 0;&#125; 1073 Scientific Notation （字符串处理） 科学计数法转换为实际数字 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt; #include&lt;map&gt;#include&lt;vector&gt;#include&lt;queue&gt; using namespace std; //key:注意指数为正时的小数点的移动！！！ 和 是否有多余0的输出 int main()&#123; char str[10010]; cin&gt;&gt;str; int len=strlen(str); if(str[0]==&#x27;-&#x27;) printf(&quot;-&quot;); //如果是负数则输出负号 int pos=0; //pos存放字符串中E的位置 while(str[pos] !=&#x27;E&#x27;)&#123; pos++; &#125; int exp=0; //exp存放指数(先不考虑正负) for(int i=pos+2;i&lt;len;i++)&#123; exp=exp*10+(str[i]-&#x27;0&#x27;); &#125; if(exp==0)&#123; //特判指数为0的情况 for(int i=1;i&lt;pos;i++)&#123; printf(&quot;%c&quot;,str[i]); //直接输出E前数值 &#125; &#125; if(str[pos+1] == &#x27;-&#x27;)&#123; //如果指数为负 printf(&quot;0.&quot;); for(int i=0;i&lt;exp-1;i++)&#123;//输出(exp-1)个0 printf(&quot;0&quot;); &#125; printf(&quot;%c&quot;,str[1]); //输出除了小数点以外的数字 for(int i=3;i&lt;pos;i++)&#123; printf(&quot;%c&quot;,str[i]); &#125; &#125;else&#123; //如果指数为正 for(int i=1;i&lt;pos;i++)&#123; //输出小数点移动之后的数 if(str[i] == &#x27;.&#x27;) continue; //略过小数点 printf(&quot;%c&quot;,str[i]); //输出当前数位 if(i == exp+2&amp;&amp;pos-3!=exp)&#123; //小数点加在位置(exp+2)上 //原小数点和E之间的数字个数(pos-3)不能等于小数点右移位数exp printf(&quot;.&quot;); &#125; &#125; //如果指数exp较大，输出多余的0 for(int i=0;i&lt;exp-(pos-3);i++)&#123; //pos-3是系数部分小数点后到E之间的数的位数 printf(&quot;0&quot;); &#125; &#125; system(&quot;pause&quot;); return 0; &#125; 1036 Boys vs Girls (排序) 题目大意： 给N个学生的成绩、名字、ID和分数，还有性别（gender）。分别找出男孩子分数最低和女孩子分数最高的，打印名字和ID，然后求两者的成绩差，如果某一方不存在，那么打印Absent，分数差值为NA。 解题思路： 使用vector分别存储male和female，然后分别按需用sort排序，求两者第一个元素的分数差值即可，但是要注意是否为空 。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;struct student&#123; string name; char gender; string ID; int grade; &#125;;int main()&#123; int N; while(cin&gt;&gt;N)&#123; student input; vector&lt;student&gt; male; vector&lt;student&gt; female; for(int i=0;i&lt;N;i++)&#123; cin&gt;&gt;input.name&gt;&gt;input.gender&gt;&gt;input.ID&gt;&gt;input.grade; input.gender == &#x27;M&#x27; ? male.push_back(input):female.push_back(input); &#125; sort(male.begin(),male.end(),[](student a,student b)&#123;return a.grade&lt;b.grade;&#125;); sort(female.begin(),female.end(),[](student a,student b)&#123;return a.grade&gt;b.grade;&#125;); if(female.size()==0)&#123; cout&lt;&lt;&quot;Absent&quot;&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;female[0].name&lt;&lt;&quot; &quot;&lt;&lt;female[0].ID&lt;&lt;endl; &#125; if(male.size()==0)&#123; cout&lt;&lt;&quot;Absent&quot;&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;male[0].name&lt;&lt;&quot; &quot;&lt;&lt;male[0].ID&lt;&lt;endl; &#125; if(female.size()==0||male.size()==0)&#123; cout&lt;&lt;&quot;NA&quot;&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;female[0].grade - male[0].grade&lt;&lt;endl; &#125; &#125; return 0;&#125; 1007 Maximum Subsequence Sum (动规 最长字段和) 题目大意：求最大连续子序列和，输出最大的和以及这个子序列的开始值和结束值。如果所有数都小于0，那么认为最大的和为0，并且输出首尾元素～ 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n; scanf(&quot;%d&quot;, &amp;n); vector&lt;int&gt; v(n); int leftindex = 0, rightindex = n - 1, sum = -1, temp = 0, tempindex = 0; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;v[i]); temp = temp + v[i]; if (temp &lt; 0) &#123; temp = 0; tempindex = i + 1; &#125; else if (temp &gt; sum) &#123; //换tempindex和换leftindex 只能两者里面取一个 sum = temp; //将temp中的值 更新到sum中 leftindex = tempindex; //将tempindex更新到leftindex中 rightindex = i; &#125; &#125; if (sum &lt; 0) sum = 0; printf(&quot;%d %d %d&quot;, sum, v[leftindex], v[rightindex]); return 0;&#125;","categories":[{"name":"pat","slug":"pat","permalink":"https://zouyunkai.github.io/myblog/categories/pat/"}],"tags":[],"author":"aoyuehan"},{"title":"vue的简单使用","slug":"vue的简单使用","date":"2020-07-01T14:01:00.000Z","updated":"2022-02-26T03:27:00.515Z","comments":true,"path":"2020/07/01/vue的简单使用/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/07/01/vue%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"node 环境的安装 简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I&#x2F;O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 在安装Vue前要先安装node，下载网址如下： http://nodejs.cn/download/ ​ NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功 vue 安装教程 Vue有三种使用方式，前面的两种适全学习，理解vue思想及各个成员的用法，第3种适合进行快速项目开发。 1） 一种是简单的页面引入方式，又分为两种 - 直接下载到本地使用 ​ - 进行CDN引用 2）使用npm安装使用 命令如下： npm install vue 使用vue cli脚手架 命令如下： npm intall vue-cli -g &#x2F;&#x2F; 3.0以前的版本 npm install @vue&#x2F;cli -g &#x2F;&#x2F; 3.0以后 的版本 cnpm的安装 有时候，npm的速度可能会非常的慢，这时可以考虑安装淘宝镜像中的cnpm,命令如下： npm install -g cnpm –registry&#x3D;https://registry.npm.taobao.org 安装查看版本 cnpm -v 使用cnpm安装vue-cli cnpm install @vue&#x2F;cli -g &#x2F;&#x2F; 3.0以后 的版本 vue 脚手架的安装教程 在命令行进行建项目（管理员身份，不然提示没有权限） 使用Vue UI图形化界面创建项目，这个需要安装vue3.0的版本才能使用 在项目的父目录中，以管理员身份打开控制台，使用如下的命令： vue ui 即可以打开图形化界面来可视化的创建项目","categories":[{"name":"前端","slug":"前端","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[],"author":"aoyuehan"},{"title":"计算机专业行业调查202007","slug":"计算机专业行业调查202007","date":"2020-06-13T01:14:00.000Z","updated":"2022-04-03T13:18:46.039Z","comments":true,"path":"2020/06/13/计算机专业行业调查202007/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/06/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%A1%8C%E4%B8%9A%E8%B0%83%E6%9F%A5202007/","excerpt":"","text":"计算机专业行业调查 产业经济学提出的行业生命周期一个行业的发展趋势为曙光期、朝阳期、成熟期、夕阳期。 进入一个新行业最好的时期，是朝阳期。第一波获得50%溢价，第二波抢到30%溢价，第三波瓜分10%。等到第四波的时候，只有微薄利润，没有太多溢价了。所以成熟期进去某一个行业赚钱少，而且要熬很多的时间。而且行业巨头会赚走90%的钱，剩下的人都是跟风者。这也就是供应需求的问题。信息不对称–&gt;头部效应 未来十年被数字化的趋势人工智能的可替代性 职业类型 面对政府，面对个人，面对公司 网络安全行业完美主义派（有完美的体系）和攻防派曙光期向朝阳期转变，看到朝阳了。 人工智能算法不是最主要的，应该从数据岗位干起，因为数据才是这个行业的基础盘。而且两级分化很严重（挣钱多的特别多），而且数据化很严重，那么未来会被替代化。 年轻的时候树立理财意识如果钱有了一部分了，然后应该怎么考虑钱生钱，但是年轻人来说，不应该考虑激进型投资。","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"mysql使用的问题","slug":"mysql使用的问题","date":"2020-06-12T05:19:00.000Z","updated":"2022-02-26T04:29:57.317Z","comments":true,"path":"2020/06/12/mysql使用的问题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/06/12/mysql%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"用mysql8.0的时候不能用mysql-connector-5.0的，因为版本不匹配","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[],"author":"aoyuehan"},{"title":"acm集训队告别","slug":"acm集训队告别书","date":"2020-06-05T14:01:00.000Z","updated":"2022-04-03T13:18:47.068Z","comments":true,"path":"2020/06/05/acm集训队告别书/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/06/05/acm%E9%9B%86%E8%AE%AD%E9%98%9F%E5%91%8A%E5%88%AB%E4%B9%A6/","excerpt":"","text":"还记得前者子鹿老师在群里发没有兴趣，坚持不下去的赶紧退，这一阵子想了想，还是退了吧，我自知自己水平真的不行，在坚持下去整体的收效甚微，就使劲搞搞蓝桥杯就行了。剩下的时间就去学一点技术，框架啥的，然后怎就准备俩年的考研（笨鸟先飞，不信怎考不上）。 大一的时候，舍友梁延杰就在队里了，那时候我也跟着被熏陶了一阵子，记得当时有时候晚上回宿舍或者中午的时候打开电脑写c语言的程序，然后记得是校赛那一阵，好像当初真的是怂了，竟然和小伙伴们都没去参加比赛，当初技术真的是太菜菜了。现在想了想，要是能重来一次，我肯定当时大一就会进队，然后硬着头皮去坚持一年，就像梁延杰一样（还是挺佩服他的） 就这样，浪荡了大一一整年，最后大二的时候终于和李硕、管超龙一起进队了，从那时候到现在，也算是一整年了吧，这一整年来的晚自习都在机房渡过，我算是尽力学算法了，每次比赛觉着不如别人，我会去写blog然后经常复习。记得有时候想不出一道题都会在去食堂吃饭的路上接着想，用一些零碎时间想。 好在大二是真的没浪费，虽然没学精这东西，感觉现在学的考研和工作中的算法问题应该都够用了吧，大二这一年真的很充实，可能是四年里学知识最多的一年了。就算法来说，从一个连结构体重载运算方法都不会写，递归、搜索写的一团槽，解决问题从不会优化，到现在算是好一点了。 第二次比较清晰的记忆是关于第二次acm校赛，当时进队也就3个月吧，好像做出来了2道不是3道题的，印象很深的是那个cet4的英文题，棒棒哒这题。 说说收获吧 独立解决问题的能力：这一点真的真的把我训练的刚刚的，现在不管在啥方面遇到问题，第一时间想到是怎么解决，是去搜索资料，然后学会，再去解决。这一套方法论下来，恐怕不能解决的问题就在少数了。 沟通能力：这一点也是深有体会呀，有时候和小伙伴讲题，讲了半小时发现人家没听懂你啥意思（哈哈哈哈），还有就是问问题的时候，我们不要急着去问，这样连自己想要解决的问题都说不清楚，我们应该先梳理一遍思路，再总结出来自己对这问题不明白的几个点，然后再去陈述，这样别人才能抓住你问的问题的重点在哪里。 另一个就是编程解决实际问题的能力：到最初的对编程有着恐惧、胆怯的心理，到现在可算是不怕不怕啦，就这么回事。而且从这一年的训练中，动手能力是强了不少，从俩指敲键盘进化到十指敲键盘（成为了十指程序员，哈哈哈哈~）。 对数据结构有了深层次的理解，将理论和实际结合了一次，对这玩意来说不怂了。 未来计划 一定要学会阶段评估呀，不能死干,加油！！","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"aoyuehan"},{"title":"20200529杂记","slug":"20200529杂记","date":"2020-05-29T04:29:00.000Z","updated":"2022-04-03T13:18:44.849Z","comments":true,"path":"2020/05/29/20200529杂记/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/29/20200529%E6%9D%82%E8%AE%B0/","excerpt":"","text":"软件设计有感 谈创新创意 这一次做这个app，真的是对创新有了更深层次的理解了。 以前听过的大众创新，感觉挺对的，但从来就没这么联系实际的体会到，创新的重要性，啥地方可以创新，怎么创新。在哔哩哔哩上看到一个博主，讲思想的，自己也想了想，其实开公司如果成功的话，你得有发现创新，发现商机，这得靠的敏锐洞察力，深刻的思想来支持，像这种人，找到创新之后商用，然后赚走90%的钱，剩下的模仿者只能为了那剩下的10%的钱转悠，这可能也就是现实吧，符合事物发展规律。 而且才发现，怎们读了15年的书，这课本上根本没有教过你这方面的任何思想，这些书只是应付考试，会一些数学运算，然后最后成为被那些有思想的人利用，成为人家获取价值的工具。书本上根本没有教过我们啥叫创新，看来只有当创新和实际的联系起来的时候才会发现这里创新的真正含义。 但是，创新这个东西，不是一般人能看到的；可能那些成功的发现有价值创新点的人，读过数不清的深化思想的书，能看到世物最深层的发展趋势，从不同思维方式进行思考，提出与别人不同的看法。可能，不对，是真的，产品的灵魂真的在于创新创意。 谈审美 哈哈哈，当老师说我找的界面幼稚的时候，我真的笑了，确实，人们只会看到他们想看到的东西，在做的时候，这界面，这图找的都是我当时认为最好的； 其实这也折射了一个问题，审美。其实小学美术就发过一本书，后来可能没看过吧。中学也就没有了美术课，而且这么多年，谁也没跟我讲过审美，也没有人教过我穿衣，色彩搭配，审美鉴赏等等。这只是很简单的一点，但是经过这十几年来的沉淀，可能当初的这很小的一点早已被无限放大。这可能也是导致现在没有树立美的意识的原因吧。 谈未来的方向 这会大二已经意为着结束了吧，两年了，学过网安的一些知识，学过算法的一些知识，学过框架的一点点东西，学过学校里教的这两年的知识，走了一圈，回到原点也真的是没发现啥真正喜爱的东西，而且所有的娱乐时间我可能都用在学上面这些东西上了，剩下的可能没有干啥了。大学前两年收获的东西也就这些了。其实，我还挺羡慕管超龙的，他知道自己想要的就是考研，可能当初怎们没有敌过985,211的那些人，但是如果准备了四年的考研，超过那些原本高考就比怎们高那么100来分的人，我感觉绰绰有余了吧。我现在就挺迷的，考研还是就业，继续学java找工作，还是去考研之后去探索一门顺应潮流的全新领域（ai、机器学习），虽然去就业感觉有点不甘没有顺应历史潮流，去考研，能行吗？我们也都见识到了高考的残酷了，你的那一卷的分数可以决定你后来的学校，后来的学校决定你去啥公司，后来的人生价值，最后如果考研不成功又该何去何从呐。 我一个高职的同学，人家不讲一些乱七八糟的，直接讲语言，学的都是 最切合当下实际的东西，怎们这要编程不如别人，要理论知识也不如别人。想了想，还是要深挖一个点才行。 对了，没事的时候多读书，不是读工具书，而是读那种能给你带来思想的书，工具书只会给我们带来死的知识，我们应该多读开放思维的书，站在大方向上，而不是自己片面的思想上看待问题。 谈差距 大一的时候我也去过这个校赛看过，当时还记了笔记，今年很巧的我也来了，还是我讲，当初我看到有些项目，也感觉他们做的挺low的，今年应该也有人在台下看着我做的挺low的吧，哈哈哈。 这大学两年了，真快呀，在有一年，大学基本上就结束了吧。 这两年，课外的话，就真的是看过acm，可是那，可能实力连省赛的牌子都拿不到，真的是太 low了。不过还好，好歹对编程没了畏惧心，培养了一点点的逻辑思维能力，算法，代码，不过就是那样而且；既然规则在那里，逻辑在那里，错误该出现的时候也就必然会出现。出现了错误，在找到解决的方法解决掉就是了。 在看看比赛的这些人，差距真的就展现了，李阳我知道，当初我去一门心思的学网安的时候，他早就已经把我学过的基本都学了一遍了，现在他都会了神经网络了。还有王灿，大三了，spring全家桶都拿下了，vue也都拿下了，这些东西都拿下，怎么也得一年半载的吧 最后说一下你们吧 我发现了团队的重要性了，以我的价值观，方法论看问题总是看不全面，此时要是有新的想法碰撞，可能会有啥新的想法吧，当初饿了吗就是大学生做出来的，后来美团进行模仿。 这次编程多亏了张鹏，鹏哥哥我真的很喜欢，能耐下心来，一点都不浮躁，很踏实。另外给你们分配任务的时候也都很积极，值得表扬，这比我见过那些说干但是做事拖拉的人好多了；另外就是老师啦，这大方向是老师给的，让我们做决定也很难做出决定，可能没有那天去找老师的话，也不会有下文了。另外的就是管超龙啦，最开始我们俩商量做什么的，后来选了一个多星期吧，啥也没选出来，然后找周老师的前一天，我已经放弃不打算做了（自己是啥也不会，也没有发现啥创新可做），但是他第二天找了周老师，我本来也想着放弃的，但是他说了一句我很有感触：“ 对呀，你现在觉着难，放弃了可能会很轻松，就想考研，你大四的时候每天都做题，学好几本书，那肯定很痛苦呀，你放弃了之后不就会轻松好多嘛，但是坚持的话，可能就会难这一阵子！”。 这个app我也是啥也不会，前前后后啥事没干搞了一个月吧，多亏了大家，虽然得奖是目的，说不期盼这得奖这是假的，可是现实就是很打压人，别人做的就是比你好。听说失败和成功是成对数函数分布的，第五次失败之后成功率才会大大上升，我也了解了这挫折打击的力量，我可能就是那个连第二次都坚持不过的人。 最后，就是现在这大背景下，静下心来沉淀技术和能力，总有一段时间，我们也会成为别人眼中那种厉害的人。加油啦，大家，奔涌吧，后浪！","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[],"author":"aoyuehan"},{"title":"SDNU 0527","slug":"SDNU-0527","date":"2020-05-27T14:01:00.000Z","updated":"2022-02-26T04:29:56.574Z","comments":true,"path":"2020/05/27/SDNU-0527/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/27/SDNU-0527/","excerpt":"","text":"E题意：刚刚开始你有一个能力值r，有n个工作，每个工作有两个属性值a,b，表示只有在能力值大于等于a时，才能执行，执行完之后能力值变为r+b 问是否有一个执行顺序能够做完所有工作。 题解：考虑将工作按照bb属性的正负来分类。对于b&gt;&#x3D;0的工作来说，我们肯定是按照a属性从小到大开始拿。对于b&lt;0的工作来说，我们按照a+b的值从大到小拿。证明：b&gt;&#x3D;0贪心显然，b&lt;0时，因为要使得r+b之后尽量大，而且还能够拿到接下来的a，那么就按照a+b排序。然后先拿b&gt;&#x3D;0的，后拿0b&lt;0的，有一个不能拿就NO最后就YES 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;class JOB&#123;public: int key1,key2;&#125;a[110],b[110];int r; bool cmp1(JOB a,JOB b)&#123; return a.key1&lt;b.key1;&#125;bool cmp2(JOB a,JOB b)&#123; return (a.key1+a.key2)&gt;(b.key1+b.key2);&#125;int main()&#123; int i, m,aa ,bb ; int geshu1=0,geshu2=0; cin&gt;&gt;m&gt;&gt;r; for(i=0;i&lt;m;i++) &#123; cin&gt;&gt;aa ; cin&gt;&gt;bb ; if(bb&gt;0)&#123; a[geshu1].key1=aa; a[geshu1++].key2=bb; &#125;else&#123; b[geshu2].key1=aa; b[geshu2++].key2=bb; &#125; &#125; sort(a,a+geshu1,cmp1); sort(b,b+geshu2,cmp2); //for(int i=0;i&lt;geshu1;i++)cout&lt;&lt;a[i].key1&lt;&lt;&#x27; &#x27;&lt;&lt;a[i].key2&lt;&lt;endl; //for(int i=0;i&lt;geshu2;i++)cout&lt;&lt;b[i].key1&lt;&lt;&#x27; &#x27;&lt;&lt;b[i].key2&lt;&lt;endl; for(int i=0;i&lt;geshu1;i++)&#123; if(r&lt;a[i].key1)&#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0; &#125; r+=a[i].key2; &#125; for(int i=0;i&lt;geshu2;i++)&#123; if(r&lt;b[i].key1)&#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0; &#125; r+=b[i].key2; &#125; if(r&lt;0)cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; //这地方一定要加，判断最后一次 else cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;&#125;","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"aoyuehan"},{"title":"软工 图总结","slug":"软工-图总结","date":"2020-05-27T04:15:00.000Z","updated":"2022-04-03T13:18:46.555Z","comments":true,"path":"2020/05/27/软工-图总结/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/27/%E8%BD%AF%E5%B7%A5-%E5%9B%BE%E6%80%BB%E7%BB%93/","excerpt":"","text":"转载于","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[],"author":"aoyuehan"},{"title":"数据库实验六  完整性","slug":"数据库实验六-完整性","date":"2020-05-27T03:02:00.000Z","updated":"2022-04-03T13:18:44.840Z","comments":true,"path":"2020/05/27/数据库实验六-完整性/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E5%85%AD-%E5%AE%8C%E6%95%B4%E6%80%A7/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667实验六 数据库完整性1．实验目的掌握实体完整性、参照完整性和用户自定义完整性的定义和维护方法2．实验内容（1）定义实体完整性。能够写出两种方式定义实体完整性的SQL语句：创建表时定义实体完整性、创建表后定义实体完整性。设计SQL语句验证完整性约束是否起作用。（2）定义参照完整性，定义参照完整性的违约处理。写出两种方式定义参照完整性的SQL语句：创建表时定义参照完整性、创建表后定义参照完整性。（3）针对具体应用语义，选择NULL/NOT NULL、DEFAULT、UNIQUE、CHECK等，定义属性上的约束条件。3．实验步骤考虑下面的关系模式：研究人员（人员编号，姓名，年龄，职称）项目（项目编号，名称，负责人编号，类别）参与（项目编号，人员编号，工作时间）/*一个研究人员可以参加多个项目，一个项目有多个研究人员参加，工作时间给出某研究人员参加某项目的月数*/（1）在定义表时定义下面的完整性约束：①定义三个关系中的主码、外码、参照完整性；use ts1;CREATE TABLE `研究人员`( `人员编号` CHAR(10), `姓名` CHAR(10) not null, `年龄` INT , `职称` CHAR(8) , PRIMARY KEY(`人员编号`) )USE ts1;CREATE TABLE 项目( 项目编号 CHAR(10), 名称 CHAR(10) NOT NULL, 负责人编号 CHAR(10), 类别 CHAR(8) , PRIMARY KEY(项目编号) )USE ts1;CREATE TABLE 参与( 项目编号 CHAR(10), 人员编号 CHAR(10), 时间 INT, PRIMARY KEY(项目编号,人员编号) )然后用语句额外操作建立项目中负责人为研究人员表中人员编号的外码：alter table 项目 add constraint q11 foreign key(负责人编号) references 研究人员(人员编号)默认操作为拒绝执行，q11为外键名②每个研究人员的年龄不能超过35岁；ALTER TABLE &quot;研究人员&quot; ADD CONSTRAINT CK_Age CHECK(`年龄`&lt;=35)上面这种写法是对的，但是mysql只是check一下，不强制，所以我插入年龄大于35的记录候还是可以的③每个研究人员的职称只能是“讲师”、“副教授”、“教授”；use ts1;alter table 研究人员 add constraint zhiwu check (职称 in(&#x27;讲师&#x27;,&#x27;教授&#x27;,&#x27;副教授&#x27;))上述check语句不起作用，所以用enum的建表方式来指定职称，而且CREATE TABLE `研究人员`( `人员编号` CHAR(10), `姓名` CHAR(10) not null, `年龄` INT CHECK(年龄&lt;35), `职称` enum(&#x27;讲师&#x27;,&#x27;教授&#x27;,&#x27;副教授&#x27;), PRIMARY KEY(`人员编号`) )之后试着插入教师这一属性，发现报错： 123456（2）使用ALTER TABLE ADD CONSTRAINT声明如下完整性约束。①负责人编号参照研究人员的“人员编号”属性，当对“研究人员”更新时，若违反约束则拒绝操作；use ts1;alter table 项目 add constraint q11 foreign key(负责人编号) references 研究人员(人员编号) on update no action;1、然后在项目中执行sql语句插入研究人员中没有的编号： 122、在研究人员中删除一条在项目中的负责人编号存在的记录：报错 123报错说no action②同①，但当违反约束时将负责人编号置为NULL； 123③同①，但当违反约束时将项目中的相应元组删除或修改；use ts1;alter table 项目 add constraint q3 foreign key(负责人编号) references 研究人员(人员编号) on delete cascade; 123456789101112④工作时间在1到12之间；方法一：use TS1;alter table 参与 add constraint q4 check(时间 between 1 and 12);方法二：或者使用enum集合在定义表的时候指明约束 enum(1,2,3,…,11,12)⑤项目名称不能为空。use TS1;alter table 项目 add constraint q5 check(名称 is not null);（3）设计SQL语句验证所定义的完整性约束及违约处理是否起作用。①对于实体完整性，试插入“研究人员”表两条主码“人员编号”的值相同的元组； 1②对于参照完整性，试插入“项目”表一个元组，其外码“负责人编号”的值在被参照表“研究人员”中不存在； 1③对于自定义完整性，试修改某一元组，将其“工作时间”的值改为20。 1234567891011121314151617181920212223242526272829303132333435363738394041424344四、 实验心得1、mysql的check语法：查看官方的文档发现（mysql 5.7版本）：The CHECK clause is parsed but ignored by all storage engines. See Section 1.8.2.3, “Foreign Key Differences”.mysql只是check一下，会被忽略掉，check不强制，所以我插入年龄大于35的记录候还是可以的，纳闷了好久才发现这个问题。解决方法：① 如果要设置CHECK约束的字段范围小，并且比较容易列举全部的值，就可以考虑将该字段的类型设置为枚举类型 enum()或集合类型set()。语法为：`Sex` enum(&#x27;男&#x27;,&#x27;女&#x27;) NOT NULL DEFAULT &#x27;男&#x27;②如果需要设置CHECK约束的字段范围大，且列举全部值比较困难，比如整数或者某一区间，那就只能使用触发器来代替约束实现数据的有效性了。2、在添加项目表的负责人编号的外键的时候报错1215错误：后来发现项目表的负责人属性列和研究人员中人员编号属性列的编码不同！！！！ 而且看过一篇文章说，两个表联合查询的时候，一个表有几百行，另一个表有几万行，当他们通过某列联接起来的时候，如果编码不同，在连接的时候要进行编码转换，会浪费很大的时间，所以在sql调优的时候要注意。3、mysql报1452错误：这是因为表设置了外键约束，而你试图插入一条外键字段所在表纪录不存在的一个值，就会报1452错。比如a、b两表，a表外键id值来自b表的ID。当你在a表中插入一条纪录时，id字段用了不在b表ID值范围内的值，就会报此错。因为我在项目表中先插入了负责人编号为1的记录，而此时没有在研究人员表中加入人员编号为1的记录，导致此时加入noaction的外键失败！！！4、在mysql中删除约束： -- 语法：ALTER TABLE tab_name DROP PRIMARY KEY； 主键是唯一的就这样就行了 -- 语法：ALTER TABLE tab_name DROP [INDEX | KEY] index_name 删除唯一性约束 -- 语法：ALTER TABLE tab_name DROP FOREIGN KEY fk_name 删除外键约束在mysql5.7中好像不支持对check约束的添加和删除的，所以alter table 项目 drop constraint `q12`;语句会报错Sqlserver中支持drop constraint操作。5、enum声明范围时的问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748496、总结外键和主键约束的语法：A、主键约束：①在声明表的时候声明主键：如CREATE TABLE `研究人员`( `人员编号` CHAR(10), `姓名` CHAR(10) not null, `年龄` INT , `职称` CHAR(8) , PRIMARY KEY(`人员编号`) -- 或者联合主键： PRIMARY KEY(`人员编号`，`姓名`) )或者：CREATE TABLE `研究人员`( `人员编号` CHAR(10) PRIMARY KEY, `姓名` CHAR(10) not null, `年龄` INT , `职称` CHAR(8) )②在声明完表之后声明主键：ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;字段名&gt;);如：ALTER TABLE `研究人员` ADD PRIMARY KEY(`人员编号`);③删除主键约数：ALTER TABLE &lt;数据表名&gt; DROP PRIMARY KEY;③：通过给字段添加 AUTO_INCREMENT 属性来实现主键自增长。语法格式如下：字段名 数据类型 AUTO_INCREMENT或者指定自增字段初始值：mysql&gt; CREATE TABLE tb_student2 ( -&gt; id INT NOT NULL AUTO_INCREMENT, -&gt; name VARCHAR(20) NOT NULL, -&gt; PRIMARY KEY(ID)-&gt; )AUTO_INCREMENT=100;B、外键约束：① 在 CREATE TABLE 语句中，通过 FOREIGN KEY 关键字来指定外键，具体的语法格式如下：[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…] []的意思是可选，此时为刚声明的表的字段名为主表的主键列1的外键实例：mysql&gt; CREATE TABLE tb_emp6 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT, -&gt; CONSTRAINT fk_emp_dept1 -&gt; FOREIGN KEY(deptId) REFERENCES tb_dept1(id)-&gt; );②在修改表时添加外键约束，语法格式如下：ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;外键名&gt; FOREIGN KEY(&lt;外键列名&gt;) REFERENCES &lt;主表名&gt; (&lt;主键列名&gt;);③删除外键约束的语法格式如下所示：ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[],"author":"aoyuehan"},{"title":"0508 vjudge","slug":"508-vjudge","date":"2020-05-24T07:31:00.000Z","updated":"2022-02-26T04:29:57.286Z","comments":true,"path":"2020/05/24/508-vjudge/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/24/508-vjudge/","excerpt":"","text":"A - Unimodal Array CodeForces - 831A如果数组满足以下三个条件，则这个数组是有趣的： 它刚开始是严格递增的 之后是不变的 再之后它是严格递减的 但除了第二个条件，其他两个条件（递增和递减）不存在的数组也可以是有趣的。 例如，以下三个数组是有趣的： [5, 7, 11, 11, 2, 1], [4, 4, 2], [7], 但以下三个却不是有趣的: [5, 5, 6, 6, 1], [1, 2, 1, 2], [4, 5, 5, 6]. 请您编写一个程序判断一个数组是否有趣 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;const int m=1005;int a[m],c[m];void pop(int b) &#123; //参数b代表数组的大小，然后依次判断升序，不变，降序 int i,j,k; for(i=0;i&lt;b;i++) &#123;// 升序 if(a[i]&lt;a[i+1]) continue; else break; &#125; for(j=i;j&lt;b;j++) &#123;//不变 if(a[j]==a[j+1]) continue; else break; &#125; for(k=j;k&lt;b;k++) &#123;//降序 if(a[k]&gt;a[k+1]) continue; else break; &#125; if(k&lt;b) printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n&quot;);&#125;int main()&#123; int n; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); pop(n); &#125; return 0;&#125; B此题是一道模拟题，按照另一种模式重新设定26个字母，只需要找出对应关系，然后输出对应模式的 字符串即可。 mnbvcxzlkjhgfdsapoiuytrewq 第一行全为小写字母asdfghjklqwertyuiopzxcvbnm找到两者的对应关系，然后对第三个串进行操作： 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;iostream&gt;using namespace std; char key[300];int main ()&#123; char b,f[30],l[30],sent[10000]; int i,j,x; scanf(&quot;%s&quot;,f); scanf(&quot;%s&quot;,l); scanf(&quot;%s&quot;,sent); for(i=0;i&lt;26;i++) &#123; key[f[i]]=l[i]; //转换小写对应关系 key[f[i]-32]=l[i]-32; //转换大写的对应关系 &#125; for(i=0;i&lt;strlen(sent);i++) &#123; if(key[sent[i]]) &#123; printf(&quot;%c&quot;,key[sent[i]]); &#125; else &#123; printf(&quot;%c&quot;,sent[i]); &#125; &#125; return 0;&#125;","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"aoyuehan"},{"title":"0519 vjudge","slug":"0519-vjudge","date":"2020-05-24T07:28:00.000Z","updated":"2022-02-26T04:29:58.515Z","comments":true,"path":"2020/05/24/0519-vjudge/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/24/0519-vjudge/","excerpt":"","text":"Paper Work CodeForces - 250A解题说明：题目的意思翻译过来是把一组数进行分组，确保每个分组中的负数不超过2个。做法是在输入的时候统计负数的个数，每当负数达到了3个，立刻增加一个新的分组，负数个数变为1.依次下去，直到分组完成。 如1 2 3 -4 -5 | -6 5 -5 | -6 -7 6 ，结果为3段 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;using namespace std; int main()&#123; int n,i,j=1,m,a[101]=&#123;0&#125;,t=0,q=0; //这样声明a数组就会是全0的数组 scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;m); if(m&lt;0) &#123; t++; &#125; if(t&gt;=3) &#123; //负数的个数超过三个 t=1; a[j++]=q; q=1; &#125; else &#123; q++; &#125; &#125; a[j]=q; printf(&quot;%d\\n&quot;,j); for(i=1;i&lt;=j;i++) &#123; printf(&quot;%d &quot;,a[i]); &#125; return 0;&#125;","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"aoyuehan"},{"title":"0523 vjudge","slug":"0523-vjudge","date":"2020-05-24T06:53:20.000Z","updated":"2022-02-26T04:29:58.307Z","comments":true,"path":"2020/05/24/0523-vjudge/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/24/0523-vjudge/","excerpt":"","text":"CodeForces - 330A Cakeminator就是给你一个表格n行m列，然后有一个格子特殊不能算进结果，然后求没有特殊格子的那一行或者那一列的格子的个数，当算这一行或者这一列的时候，这一列或者这一行应该包含以前没有算过的格子才可以。 就是有一个n×m的蛋糕，有几个坏草莓，你吃的时候要避开这些坏草莓，你要一行，一列的吃，要你输出可以吃多少块 （上面的解释不如实际问题好理解呀） 解法：如果一行（列）都没有坏的，就把该行或列标记vis数组对应的位置++，到最后遍历一遍标记数组vis ，可以吃的就算上，输出结果 就好了。 这一题比较难想的地方就是要用一个行和列数组记录这一行这一列有没有坏草莓，这样的话在暴力求解的时候就可以简单一些；所以不要简单的想到一个二维数组来记录每个格子有没有吃 ，而且要想到每一行或列的性质！！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt; using namespace std;const int maxn = 15;int ans=0;string cake[maxn] ;int row[maxn],clo[maxn],vis[maxn][maxn];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;cake[i]; &#125; for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;m;j++) &#123; if(cake[i][j]==&#x27;S&#x27;) &#123; row[i]=1; //标记这一行是否有坏草莓 clo[j]=1; &#125; &#125; &#125; for(int i=0;i&lt;n;i++) &#123;//先判断每一行 if(row[i]) continue; //如果这一行有坏草莓 ，就跳过去 for(int j=0;j&lt;m;j++) if(!vis[i][j]) //没有被吃过就记录答案 &#123; ans++; vis[i][j]=1; &#125; &#125; for(int j=0;j&lt;m;j++) &#123;//判断每一列 if(clo[j]) continue; for(int i=0;i&lt;n;i++) &#123; if(!vis[i][j]) &#123; ans++; vis[i][j]=1; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;","categories":[],"tags":[]},{"title":"0524 ICPC NWRR","slug":"0524-ICPC-NWRR","date":"2020-05-24T06:30:00.000Z","updated":"2022-04-03T13:18:46.621Z","comments":true,"path":"2020/05/24/0524-ICPC-NWRR/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/24/0524-ICPC-NWRR/","excerpt":"","text":"ICPC 2019-2020 North-Western Russia Regional ContestA.Accurate Movement题意：有两个轨道，上面的长，下面的短，然后从第二个图变到第三个图所需的最少的步数，其中长的或短的板子运动的时候不能带动另一个板子。我们把小板子运动一下，大板子运动一下看为一个过程，一共有（n-b）&#x2F;（b-a）向上取整个过程，然后最后小板子靠到最右边次数再加一，得到结果。 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int n,a,b; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; int ans=0; ans=(n-b)/(b-a); if((n-b)%(b-a))ans++; //就是（n-b）/（b-a）向上取余 ans++; //最终小的那块板子靠到最右边 cout&lt;&lt;ans&lt;&lt;endl; &#125; Managing Difficulties这个题卡时间复杂度，题意就是：求n个数的中使得等式a_j-a_i&#x3D;a_k-a_j 成立的排列的个数，一种ijk为n个数的下标。 有一种很巧妙的方法：枚举每一个数字，前面如果有两个数字能够和它得到等差数列，就加上种数，然后把它当作中间数字，枚举前面区间的数字，让能够构成的等差数列的第三个数字数量++，然后每个数字的数量，就用unordered_map&lt;int,int&gt;s来记录 等差数列为：a_j-a_i&#x3D;a_k-a_j，那么有2×a_j&#x3D;a_i+a_k成立。 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3ftypedef long long ll;using namespace std;const int mx=2e5+10;unordered_map&lt;int,int&gt;s;int a[mx]; int main()&#123; int t,n; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; ll ans=0; scanf(&quot;%d&quot;,&amp;n); s.clear(); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); if(s[a[i]]) ans+=s[a[i]]; if(i==n) break; for(int j=1;j&lt;i;j++) s[2*a[i]-a[j]]++; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125;————————————————版权声明：本文为CSDN博主「楚仙子」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/weixin_43901733/java/article/details/103004168 tips：如果在遇到这种求排列或者啥次数的时候就可以这样做，和素数晒那种思想一样。","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"aoyuehan"},{"title":"数据库实验五","slug":"数据库实验五","date":"2020-05-23T04:09:00.000Z","updated":"2022-04-03T13:18:45.556Z","comments":true,"path":"2020/05/23/数据库实验五/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/23/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%BA%94/","excerpt":"","text":"12345678910一、实验目的理解数据库安全性，掌握SQL Server有关用户、角色及操作权限的管理方法。 二、实验内容 查看和编辑现有登录,创建登录,，修改已经创建的登录，删除登录。建立数据库用户。修改数据库用户，删除数据库用户。练习权限管理（授予、收回），建立数据库角色。 三、实验步骤1、创建角色和用户CREATE语句创建一个test用户，主机为localhost（也可以不写，为%，意思为所有主机），IDENTIFIED BY指定密码：CREATE USER &#x27;test&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123&#x27;;查看mysql数据库中的user表： 123456782、给test用户赋予权限：方法一：GRANT SELECT,INSERT ON *.* TO `test` -- 给test用户赋予查询和插入的权限，*.*代表所有数据库的所有表方法二：可以指定某个数据库的某个表：GRANT SELECT,INSERT ON ts.course TO `test` -- 给test用户赋予查询和插入ts数据库的course表的权限对第二种方法进行测试： 123 但是当我对course表进行删除记录的时候是不被允许的：下图为我对course表删除Cno为12的记录时的结果： 1234567891011123、权限回收：删除用户某些特定的权限，语法格式如下：REVOKE priv_type [(column_list)]...ON database.tableFROM user [, user]...如：回收test用户对course表的插入权限：REVOKE INSERT ON ts.courseFROM test 12345678910111213141516171819202122 发现insert的权限被收回了，验证成功。四、 实验心得1、CREATE USER 和 INSERT INTO 语句都可以创建普通用户，但是这两种方式不便授予用户权限。MySQL 提供了 GRANT 语句。2、 删除用户：方法一：使用 DROP USER 语句删除用户的语法格式如下：DROP USER &lt;用户1&gt; [ , &lt;用户2&gt; ]…注意：用户的删除不会影响他们之前所创建的表、索引或其他数据库对象，因为 MySQL 并不会记录是谁创建了这些对象。方法二：使用DELETE语句删除普通用户可以使用 DELETE 语句直接删除 mysql.user 表中相应的用户信息，但必须拥有 mysql.user 表的 DELETE 权限。其基本语法格式如下：DELETE FROM mysql.user WHERE Host=&#x27;hostname&#x27; AND User=&#x27;username&#x27;;3、在创建用户的时候指定用户的权限的写法为：使用 GRANT 语句创建一个新的用户 testUser，密码为 testPwd。用户 testUser 对所有的数据有查询、插入权限，并授予 GRANT 权限。SQL 语句为：GRANT SELECT,INSERT ON *.* TO &#x27;testUser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;testPwd&#x27; WITH GRANT OPTION;","categories":[],"tags":[],"author":"aoyuehan"},{"title":"0514-vjudge","slug":"0514-vjudge","date":"2020-05-23T02:02:50.000Z","updated":"2022-04-03T13:18:47.077Z","comments":true,"path":"2020/05/23/0514-vjudge/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/23/0514-vjudge/","excerpt":"","text":"E题 物理题https://blog.csdn.net/qq_44555205/article/details/100107784 看了好久才明白过来，原来是个初中物理题： 方法二：二分https://blog.csdn.net/powermod0927/article/details/96965232 M题题意： 要求你生成一个排列，要求任意两个相邻的数的差值的绝对值在[2,4]范围内。 思路： 中间为2 4 1 3，然后从5开始就左边一个，右边一个，输出数列即可。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;int main()&#123; int n,t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; int tmp=n; if(n&lt;=3)cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else if(n==4)cout&lt;&lt;&quot;2 4 1 3&quot;&lt;&lt;endl; else if(n&amp;1)&#123; while(n&gt;=5)&#123; cout&lt;&lt;n&lt;&lt;&#x27; &#x27;; n-=2; &#125; cout&lt;&lt;&quot;2 4 1 3 &quot;; int tmpp=6; while(tmpp&lt;=tmp-1)&#123; cout&lt;&lt;tmpp&lt;&lt;&#x27; &#x27;; tmpp+=2; &#125; cout&lt;&lt;endl; &#125;else&#123; n--; while(n&gt;=5)&#123; cout&lt;&lt;n&lt;&lt;&#x27; &#x27;; n-=2; &#125; cout&lt;&lt;&quot;2 4 1 3 &quot;; int tmpp=6; while(tmpp&lt;=tmp)&#123; cout&lt;&lt;tmpp&lt;&lt;&#x27; &#x27;; tmpp+=2; &#125; cout&lt;&lt;endl; &#125; &#125; &#125;","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[]},{"title":"数据库实验四 视图","slug":"数据库实验四-视图","date":"2020-05-18T09:41:00.000Z","updated":"2022-04-03T13:18:46.814Z","comments":true,"path":"2020/05/18/数据库实验四-视图/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E8%A7%86%E5%9B%BE/","excerpt":"","text":"mysql教程视图1、新建视图：建立课程号为3的学生的学生信息和学生成绩 123456789101112131415161718192021222324SELECT `course`.`Cname` AS `课程名`, `sc`.`Grade` AS `课程成绩`, `student`.`Sno` AS `Sno`, `student`.`Ssex` AS `Ssex`, `student`.`Sage` AS `Sage`, `student`.`Sdept` AS `Sdept`, `student`.`Sname` AS `学生姓名`FROM ( ( `course` JOIN `sc` ON ( (`sc`.`Cno` = `course`.`Cno`) ) ) JOIN `student` ON ( (`sc`.`Sno` = `student`.`Sno`) ) )WHERE (`course`.`Cno` = 3)ORDER BY `sc`.`Grade` 同样：mysql也可以使用对象管理器进行建立视图： 2、视图的查询： 1select * from `查询课程号为3的学生的信息` 3、视图的更新和修改： 12修改学生学号为09110103的英语成绩为100：UPDATE `查询课程号为3的学生的信息` set `课程成绩`=100 WHERE Sno=09110103 4、视图的删除： 1drop VIEW view 四、 实验心得1、本来编写view的时候，在整个视图定义的后边写了group by student.Ssex，按照性别进行分组，然后在修改视图的时候报错了，说语句错误。后来查找到，因为视图中有GROUP BY 子句的时候，视图就是不可更新的了，后来想了想，是哈，万一更新了之后数据库中表的依赖变了或者会有冲突。 2、视图是一个虚拟表，实际的数据来自于基本表，所以通过插入、修改和删除操作更新视图中的数据，实质上是在更新视图所引用的基本表的数据。对视图的修改就是对基本表的修改，因此在修改时，要满足基本表的数据定义。 3、在mysql中：DESCRIBE 视图名;或简写成： DESC 视图名;可以来查看视图中的数据；SHOW CREATE VIEW 语句可以查看视图的详细定义语法为SHOW CREATE VIEW 视图名;同样：SELECT × FROM information_schema.views;这个也可以查看视图的sql语句 4、总结一下视图不能更新的情况： 聚合函数 SUM()、MIN()、MAX()、COUNT() 等。 DISTINCT 关键字。 GROUP BY 子句。 HAVING 子句。 UNION 或 UNION ALL 运算符。 位于选择列表中的子查询。 FROM 子句中的不可更新视图或包含多个表。 WHERE 子句中的子查询，引用 FROM 子句中的表。 ALGORITHM 选项为 TEMPTABLE（使用临时表总会使视图成为不可更新的）的时候。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[],"author":"aoyuehan"},{"title":"","slug":"CERC jisaunke 0516","date":"2020-05-17T07:31:00.000Z","updated":"2022-02-26T03:26:59.406Z","comments":true,"path":"2020/05/17/CERC jisaunke 0516/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/17/CERC%20jisaunke%200516/","excerpt":"","text":"C、Bob in Wonderland贪心，统计有多少个度大于$2$的节点数$x$，将他们的度求和$sum$，答案为$sum-2x$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;typedef long long int ll;typedef pair&lt;int, int&gt; pii;#define PB push_back#define MP make_pair#define FOR(prom, a, b) for(int prom = (a); prom &lt; (b); prom++)#define FORD(prom, a, b) for(int prom = (a); prom &gt; (b); prom--)#define FORDE(prom, a, b) for(int prom = (a); prom &gt;= (b); prom--)#define R1(a) do&#123;scanf(&quot;%d&quot;, &amp;(a));&#125;while(0)#define R2(a, b) do&#123;scanf(&quot;%d%d&quot;, &amp;(a), &amp;(b));&#125;while(0)#define R3(a, b, c) do&#123;scanf(&quot;%d%d%d&quot;, &amp;(a), &amp;(b), &amp;(c));&#125;while(0)#define SV(vec) do&#123;int s_v_;scanf(&quot;%d&quot;, &amp;(s_v_));vec.PB(s_v_);&#125;while(0)#define MM(co, cim) memset((co), (cim), sizeof((co)))#define DEB(x) cerr &lt;&lt; &quot;&gt;&gt;&gt; &quot; &lt;&lt; #x &lt;&lt; &quot; : &quot; &lt;&lt; x &lt;&lt; endl;#define INF 1000000007int n, from, to, res;vector&lt;int&gt; g[300014];int main ()&#123; R1(n); FOR(i, 0, n - 1) &#123; R2(from, to); --from; --to; g[from].PB(to); g[to].PB(from); &#125; res = 0; FOR(i, 0, n) res += max((int)g[i].size() - 2, 0); printf(&quot;%d\\n&quot;, res); return 0;&#125;","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"aoyuehan"},{"title":"","slug":"SDUN 0521","date":"2020-05-17T07:31:00.000Z","updated":"2022-04-03T13:18:44.749Z","comments":true,"path":"2020/05/17/SDUN 0521/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/17/SDUN%200521/","excerpt":"","text":"F - Fansblog HDU 6608 题目：Fansblog 题意大致描述：给定一个质数P(1e9≤P≤1e14)，找到比P小的最大的质数Q，并求出Q!%P 需要了解的知识 威尔逊定理 在初等数论中，威尔逊定理给出了判定一个自然数是否为素数的充分必要条件。即：当且仅当p为素数时：( p -1 )! ≡ -1 ( mod p )，但是由于阶乘是呈爆炸增长的，其结论对于实际操作意义不大。 题解上给的是质数密度分布，我百度之后认为这个意思是两个质数之间相隔的不多，可以直接枚举找 逆元，逆元我们根据费马小定理可以很容易的求出来，经常用在分数和除法取模当中，逆元其实特别简单，用公式来说就是a的逆元等于a的(mod-2)次方，用一个快速幂就可以搞定。 公式的推理过程： 所以我们只需要从P-1开始找到Q为止，最后把P-1乘以(Q,P-1]的逆元就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;stdio.h&gt;#include &lt;cmath&gt;#include &lt;string.h&gt;#define ll long longusing namespace std;bool Is_prime(ll n)&#123; if(n==1)return false; if(n==2)return true; for(register ll i=2;i*i&lt;=n;i++) if(n%i==0)return false; return true; &#125;long long Mode(long long a,long long b,ll m) &#123; long long sum=1; a=a%m; while(b&gt;0) &#123; if(b%2==1) sum=(sum*a)%m; b/=2; a=(a*a)%m; &#125; return sum; &#125;int main()&#123; //freopen(&quot;C:\\\\Users\\\\16599\\\\Desktop\\\\in.txt&quot;,&quot;r&quot;,stdin); int T; cin&gt;&gt;T; ll P; while(T--) &#123; cin&gt;&gt;P; ll fz=P-1; ll fm=P-1; while(!Is_prime(fm)) &#123; fz=fz*Mode(fm,P-2,P)%P; fm--; &#125; cout&lt;&lt;fz&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"aoyuehan"},{"title":"数据库实验三查询","slug":"数据库实验三查询","date":"2020-05-16T02:49:00.000Z","updated":"2022-04-03T13:18:46.547Z","comments":true,"path":"2020/05/16/数据库实验三查询/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%B8%89%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"查询操作注意，一定要以分号结束一行语句！！！这与sqlserver不同 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162建表语句：CREATE DATABASE IF NOT EXISTS TS DEFAULT CHARSET utf8 ;USE TS; -- 这地方一定要加; 不然语法不对CREATE TABLE Student( `Sno` CHAR(10), `Sname` CHAR(10) NOT NULL, `Ssex` CHAR(4) NOT NULL , `Sage` INT NOT NULL, `Spol` CHAR(8) , `Snat` CHAR(12), `Sdept` CHAR(20),PRIMARY KEY(Sno) ); USE TS;CREATE TABLE Course( Cno CHAR(10) PRIMARY KEY, Cname CHAR(20) NOT NULL, Credit INT); USE TS;CREATE TABLE SC( Sno CHAR(10),Cno CHAR(10) ,Grade smallint, PRIMARY KEY (Sno,Cno),FOREIGN KEY(Sno) references student(sno),FOREIGN KEY(Cno) references course(cno) ); USE TS;INSERT INTO Student VALUES(&#x27;09110101&#x27;,&#x27;赵平&#x27;, &#x27;男&#x27;,18, &#x27;党员&#x27;,&#x27;汉族&#x27;, &#x27;计算机系&#x27;);INSERT INTO Student VALUES(&#x27;09110102&#x27;, &#x27;蒋路&#x27;, &#x27;男&#x27;,19,&#x27;团员&#x27; , &#x27;回族&#x27;, &#x27;通信系&#x27;);INSERT INTO Student VALUES(&#x27;09110103&#x27;, &#x27;汪琪&#x27;, &#x27;女&#x27;,18, &#x27;党员&#x27;, &#x27;汉族&#x27;, &#x27;自动化系&#x27;);INSERT INTO Student VALUES(&#x27;09110104&#x27;, &#x27;张思思&#x27;, &#x27;女&#x27;,18,&#x27;团员&#x27;,&#x27;汉族&#x27;,&#x27;通信系&#x27;);INSERT INTO Student VALUES(&#x27;09110105&#x27;, &#x27;孙瑶&#x27;, &#x27;男&#x27;,19, &#x27;党员&#x27;, &#x27;维吾尔族&#x27;, &#x27;电子系&#x27;);INSERT INTO Student VALUES(&#x27;09110106&#x27;, &#x27;张军&#x27;, &#x27;男&#x27;,20,&#x27;团员&#x27;,&#x27;朝鲜族&#x27;, &#x27;计算机系&#x27;);INSERT INTO Student VALUES(&#x27;09110107&#x27;, &#x27;王依&#x27;, &#x27;女&#x27;,18, &#x27;群众&#x27;, &#x27;回族&#x27;, &#x27;通信系&#x27;);USE TS;INSERT INTO Course VALUES(&#x27;001&#x27;, &#x27;C语言程序设计&#x27;,2);INSERT INTO Course VALUES(&#x27;002&#x27;, &#x27;高数&#x27;,3);INSERT INTO Course VALUES(&#x27;003&#x27;, &#x27;大学英语&#x27;,2);INSERT INTO Course VALUES(&#x27;004&#x27;, &#x27;软件工程&#x27;,2);INSERT INTO Course VALUES(&#x27;005&#x27;, &#x27;计算机网络&#x27;,3);INSERT INTO Course VALUES(&#x27;006&#x27;, &#x27;操作系统&#x27;,3);INSERT INTO Course VALUES(&#x27;007&#x27;, &#x27;数据库原理&#x27;,2);USE TS; INSERT INTO SC VALUES(&#x27;09110101&#x27;, &#x27;001&#x27;,80); -- 插入后面也要加；INSERT INTO SC VALUES(&#x27;09110101&#x27;, &#x27;003&#x27;,75);INSERT INTO SC VALUES(&#x27;09110102&#x27;, &#x27;002&#x27;,54);INSERT INTO SC VALUES(&#x27;09110102&#x27;, &#x27;003&#x27;,90);INSERT INTO SC VALUES(&#x27;09110102&#x27;, &#x27;005&#x27;,60);INSERT INTO SC VALUES(&#x27;09110103&#x27;, &#x27;002&#x27;,70);INSERT INTO SC VALUES(&#x27;09110103&#x27;, &#x27;003&#x27;,30);INSERT INTO SC VALUES(&#x27;09110104&#x27;, &#x27;003&#x27;,83);INSERT INTO SC VALUES(&#x27;09110105&#x27;, &#x27;001&#x27;,67);INSERT INTO SC VALUES(&#x27;09110105&#x27;, &#x27;003&#x27;,45);INSERT INTO SC VALUES(&#x27;09110107&#x27;, &#x27;003&#x27;,64); 然后是查询练习 123456789101112131415161718192021222324252627282930use ts;SELECT *FROM studentWHERE Sdept=&#x27;计算机系&#x27;;SELECT Cno,GradeFROM Student,SCWHERE student.Sno=SC.Sno AND Sname=&#x27;赵平&#x27;SELECT DISTINCT Sno &#x27;选修课程的学号&#x27;FROM SCSELECT Student.Sno,Sname,GradeFROM student,Course,SCWHERE Student.Sno=SC.Sno AND Course.Cno=SC.Cno AND Course.Cname=&#x27;计算机网络&#x27; AND Grade&gt;=60SELECT SnoFROM SCGROUP BY Sno HAVING COUNT(Cno)&gt;=2SELECT Sno,SnameFROM studentWHERE Sname LIKE &#x27;_平&#x27;SELECT Sno,SnameFROM studentWHERE Sname LIKE &#x27;张%&#x27;ORDER BY Sno DESCSELECT * FROM student WHERE locate(&#x27;族&#x27;, snat) &lt;&gt; 0 遇到的问题 下面这幅图是因为没有设置数据库的默认编码为utf-8导致的，只要在建表的时候CREATE DATABASE IF NOT EXISTS TS DEFAULT CHARSET utf8 ;显式指定编码集就好了。 3、记得limit在分页功能的时候会用到其作用为返回前几条或者中间某几行数据，LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)。 1234567SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-最后. //如果只给定一个参数，它表示返回最大的记录行数目： SELECT * FROM table LIMIT 5; //检索前 5 个记录行 换句话说，LIMIT n 等价于 LIMIT 0,n。 4、出了limit还有contain通过此条语句可以检索到snat字段中包含族这个字的学生信息 5、总结一下常用的查询： 1234567891011查询：select * from table1 where 范围插入：insert into table1(field1,field2) values(value1,value2)删除：delete from table1 where 范围更新：update table1 set field1=value1 where 范围查找：select * from table1 where field1 like ’%value1%’ ---like的语法很精妙，查资料!排序：select * from table1 order by field1,field2 [desc]总数：select count(id) as totalcount from table1求和：select sum(id) as sumvalue from table1 -- as 后面跟着的 是一个别名 平均：select avg(id) as avgvalue from table1最大：select max(id) as maxvalue from table1最小：select min(id) as minvalue from table1 as语法 6、除了第6、7小问中的模糊查询之外，常用的还有范围查询between and 查询 select × from student where idd between 3 and 4 查询3和4之间的数据，包括3和4。7、模糊查询%：表示零个或多个字符。_：表示任意单个字符[]：表示括号内所列字符中的一个（类似正则表达式）。[^]：表示不在括号所列之内的单个字符。 由于通配符的缘故，导致查询特殊字符“%”、“_”、“[” 的语句无法正常实现，把特殊字符用“[]”括起来便可以正常查询。 123select * from flow_user where username LIKE&#x27;[王李张]飞&#x27;;将找出“王飞”“李飞”“张飞”（而不是“张王李飞”）。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[],"author":"aoyuehan"},{"title":"0429 计蒜客","slug":"0429-计蒜客-1","date":"2020-05-14T13:14:10.000Z","updated":"2022-04-03T13:18:45.602Z","comments":true,"path":"2020/05/14/0429-计蒜客-1/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/14/0429-%E8%AE%A1%E8%92%9C%E5%AE%A2-1/","excerpt":"","text":"E题 物理题https://blog.csdn.net/qq_44555205/article/details/100107784 方法二：二分https://blog.csdn.net/powermod0927/article/details/96965232 M题题意： 要求你生成一个排列，要求任意两个相邻的数的差值的绝对值在[2,4]范围内。 思路： 中间为2 4 1 3，然后从5开始就左边一个，右边一个，输出数列即可。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;using namespace std;int main()&#123; int n,t; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; int tmp=n; if(n&lt;=3)cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else if(n==4)cout&lt;&lt;&quot;2 4 1 3&quot;&lt;&lt;endl; else if(n&amp;1)&#123; while(n&gt;=5)&#123; cout&lt;&lt;n&lt;&lt;&#x27; &#x27;; n-=2; &#125; cout&lt;&lt;&quot;2 4 1 3 &quot;; int tmpp=6; while(tmpp&lt;=tmp-1)&#123; cout&lt;&lt;tmpp&lt;&lt;&#x27; &#x27;; tmpp+=2; &#125; cout&lt;&lt;endl; &#125;else&#123; n--; while(n&gt;=5)&#123; cout&lt;&lt;n&lt;&lt;&#x27; &#x27;; n-=2; &#125; cout&lt;&lt;&quot;2 4 1 3 &quot;; int tmpp=6; while(tmpp&lt;=tmp)&#123; cout&lt;&lt;tmpp&lt;&lt;&#x27; &#x27;; tmpp+=2; &#125; cout&lt;&lt;endl; &#125; &#125; &#125;","categories":[],"tags":[],"author":"aoyuehan"},{"title":"科大讯飞杯 第十七届","slug":"科大讯飞杯-第十七届","date":"2020-05-13T01:23:00.000Z","updated":"2022-02-26T04:29:58.210Z","comments":true,"path":"2020/05/13/科大讯飞杯-第十七届/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/13/%E7%A7%91%E5%A4%A7%E8%AE%AF%E9%A3%9E%E6%9D%AF-%E7%AC%AC%E5%8D%81%E4%B8%83%E5%B1%8A/","excerpt":"","text":"F排列计算1234567891011121314151617181920212223242526272829链接：https://ac.nowcoder.com/acm/contest/5477/F?&amp;headNav=acm来源：牛客网题目描述天才程序员菜哭武和石头组队参加一个叫做国际排列计算竞赛 (International Competition of Permutation Calculation, ICPC) 的比赛，这个比赛的规则是这样的： 一个选手给出一个长度为 n 的排列，另一个选手给出 m 个询问，每次询问是一个形如 (l, r) 的数对，查询队友给出的排列中第 l 个数到第 r 个数的和，并将查询到的这个区间和加入总分，最后总分最高的队伍就能获胜。石头手速很快，在比赛一开始就给出了 m 个询问；菜哭武也很强，他总是能找到最合适的排列，使得他们队的总分尽可能高。在看比赛直播的你看到了石头给出的 m 个询问，聪明的你能不能预测出他们队伍最终的得分呢？一个排列是一个长度为 n 的数列，其中 1 ~ n 中的每个数都在数列中恰好出现一次。比如 [1, 3, 2] 是一个排列，而 [2, 1, 4] 和 [1, 2, 3, 3] 不是排列。 输入描述:第一行输入两个数 n (1≤n≤2×105) 和 m (1≤m≤2×105) 。 接下来 m 行，每行输入两个数 l 和 r ，代表这次查询排列中第 l 个到第 r 个的和。输出描述:输出一个整数，代表他们队伍总分的最大值。示例1输入7 31 33 75 6输出46说明一个符合条件的排列是 [1,3, 6, 4, 7, 5, 2]，于是最终的得分为 (1 + 3 + 6) + (6 + 4 + 7 + 5 + 2) + (7 + 5) = 46 方法一：差分+前缀和（用来求某一段区间的出现的次数） 有1到n个数字，然后m个查询，构造一个序列，使得查询后的值最大化。因为只输出一次，不需要关心到底是怎么构造的，考虑，被查询到的数字次数越多，那么就让他的值越大，则，差分前缀和求出每个数字被查询的次数，然后排序，出现次数最小的对应1，最大的对应n即可 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;const int N = 2e5 + 5; int d[N]; //写在main外面，这样会让数组全为0，正好为差分数组的初始化形式int main()&#123; int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++)&#123; int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); d[l] ++ ,d[r + 1]--; //这样的话还原回去就能知道每个位置出现的次数 &#125; for(int i = 1; i &lt;= n; i++)&#123; d[i] += d[i - 1]; &#125; sort(d + 1, d + n + 1); ll ans = 0; for(int i = 1; i &lt;= n; i++) ans += 1ll * d[i] * i; //因为d[i]为int类型数据，要*1ll来转换为ll类型 printf(&quot;%lld\\n&quot;, ans); return 0;&#125; 方法二：用next_permutation()全排列一个个比较结果，算出最大的结果，会超时的方法三：线段树来找出现的次数，用到线段树的区间修改和单点查询问题转化为两个部分：1、区间修改+单点查询2、排序看数据范围：n 对应 2E5 m 对应 2E5，开线段树，维护和值，进行区间更新，复杂度 nlogn然后，单点查询所有点的值，复杂度 nlogn之后，排序，复杂度 nlogn最后，循环求和输出，复杂度 n可以得知，复杂度 O(nlogn)，问题可以解决。下面这种方法为不排序，直接使用降序优先队列进行计算总和的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;#define MAXN 200010 //今天RE了一次，就是因为平时习惯1E5 + 5，没注意到本题的 2E5#define inf 0x3f3f3f3f using namespace std; priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q; struct node&#123; int l,r;//区间[l,r] int add;//区间的延时标记 int sum;//区间和 &#125;tree[MAXN&lt;&lt;2];//一定要开到4倍多的空间 void pushup(int index)&#123; tree[index].sum = tree[index&lt;&lt;1].sum+tree[index&lt;&lt;1|1].sum; &#125; void pushdown(int index)&#123; if(tree[index].add)&#123; tree[index&lt;&lt;1].sum += (tree[index&lt;&lt;1].r-tree[index&lt;&lt;1].l+1)*tree[index].add; tree[index&lt;&lt;1|1].sum +=(tree[index&lt;&lt;1|1].r-tree[index&lt;&lt;1|1].l+1)*tree[index].add; tree[index&lt;&lt;1].add += tree[index].add; tree[index&lt;&lt;1|1].add += tree[index].add; tree[index].add = 0; &#125; &#125; void build(int l,int r,int index)&#123; tree[index].l = l; tree[index].r = r; tree[index].add = 0;//刚开始一定要清0 if(l == r)&#123; tree[index].sum = 0; return ; &#125; int mid = (l+r)&gt;&gt;1; build(l,mid,index&lt;&lt;1); build(mid+1,r,index&lt;&lt;1|1); pushup(index); &#125; void updata(int l,int r,int index,int val)&#123; if(l &lt;= tree[index].l &amp;&amp; r &gt;= tree[index].r)&#123; tree[index].sum += (tree[index].r-tree[index].l+1)*val; tree[index].add += val;//延时标记 return ; &#125; pushdown(index); int mid = (tree[index].l+tree[index].r)&gt;&gt;1; if(l &lt;= mid)&#123; updata(l,r,index&lt;&lt;1,val); &#125; if(r &gt; mid)&#123; updata(l,r,index&lt;&lt;1|1,val); &#125; pushup(index); &#125; int query(int l,int r,int index)&#123; if(l &lt;= tree[index].l &amp;&amp; r &gt;= tree[index].r)&#123; return tree[index].sum; &#125; pushdown(index); int mid = (tree[index].l+tree[index].r)&gt;&gt;1; int ans = 0; int Max = 0; int Min = inf; if(l &lt;= mid)&#123; ans += query(l,r,index&lt;&lt;1); &#125; if(r &gt; mid)&#123; ans += query(l,r,index&lt;&lt;1|1); &#125; return ans; &#125; int main() &#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); build(1,n,1); //建树时全部给0 for(int i = 0;i &lt; m;i++)&#123; int l,r; cin&gt;&gt;l&gt;&gt;r; updata(l,r,1,1); &#125; for(int i = 1;i &lt;= n;i++)&#123; int r = query(i,i,1); q.push(r); &#125; long long ans = 0; long long r1 = n; while(!q.empty())&#123; long long t = q.top(); ans += t * r1--; q.pop(); if(t == 0) break; //一个很小的优化 &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125; A 张老师和菜哭武的游戏1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253链接：https://ac.nowcoder.com/acm/contest/5477/A来源：牛客网题目描述天才程序员菜哭武和张老师有一天到一个城市旅游，旅途中菜哭武觉得无聊就想和张老师玩一个游戏。菜哭武有n个石子，每个石子都标有1到n之间的数，且各不相同，一开始他们会随机从这堆石子选一个石子放置到一个集合中，张老师选的数是a，菜哭武选的是b（a和b不相同）。接下来菜哭武和张老师轮流按照如下规则拿走一个石子：当石子x能被拿走时，当且仅当集合存在y和z，满足x等于y+z或者y-z，当x被拿走时，把它放到集合中。谁完成最后一轮操作时，谁获胜。张老师总是先手，于是张老师就好奇当决定好a和b时，他是否总是能获胜，你能帮助一下张老师吗？输入描述:第一行一个整数T（1≤T≤500），表示共有T组测试数据。对于每组测试数据，第一行三个整数n（2≤n≤20000）、a和b（1≤a,b≤n, a≠b）。输出描述:若张老师能获胜输出Yes，反之No。示例1输入162 1 23 1 367 1 2100 1 28 6 89 6 810 6 811 6 812 6 813 6 814 6 815 6 816 6 81314 6 81994 1 131994 7 12输出NoYesYesNoNoNoYesYesNoNoYesYesNoYesNoNo 解法一：显然在1到n的这n个点中的某个点p要被走到，要满足p&#x3D;xa+yb，那么显然p必须要是gcd（a，b）的倍数，所以判断n&#x2F;gcd（a，b）奇偶即可。 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; int main()&#123; int t; cin&gt;&gt;t; for(int i=0;i&lt;t;i++)&#123; int n,a,b; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; if((n/__gcd(a,b))%2)cout&lt;&lt;&quot;Yes\\n&quot;; else cout&lt;&lt;&quot;No\\n&quot;; &#125; return 0;&#125; 解法二：因为是两个人，而且最后一定会把能拿的数全部拿完。所以我们只需要讨论能拿的数sum有多少个即可。 如果a,b两个数不互质，即他们的最大公因数g大于1，那么在[1,n][1,n][1,n]范围内，所有满足的k∗nk*nk∗n的数都会被拿走。 如果a,b两个数互质，即他们的最大公因数g等于1，那么在[1,n][1,n][1,n]范围内，所有的数都会被拿走。 所以我们知道sum&#x3D;n&#x2F;gcd(a,b)，因为只有两人，且谁完成最后一次操作时，谁获胜。所以sum偶数时张老师必输，奇数时张老师必胜。 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e5 + 7;const ll mod = 1e9 + 7;inline ll read() &#123; ll s = 0, f = 1; char ch; do &#123; ch = getchar(); if (ch == &#x27;-&#x27;) f = -1; &#125; while (ch &lt; 48 || ch &gt; 57); while (ch &gt;= 48 &amp;&amp; ch &lt;= 57) s = (s &lt;&lt; 1) + (s &lt;&lt; 3) + (ch ^ 48), ch = getchar(); return s * f;&#125;int main() &#123; ll t = read(); while (t--) &#123; ll n = read(), a = read(), b = read(); n /= __gcd(a, b); if (n &amp; 1) puts(&quot;Yes&quot;); else puts(&quot;No&quot;); &#125; return 0;&#125;","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[]},{"title":"数据库实验二","slug":"数据库实验二","date":"2020-05-11T07:33:00.000Z","updated":"2022-02-26T04:29:58.538Z","comments":true,"path":"2020/05/11/数据库实验二/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%BA%8C/","excerpt":"","text":"要求索引的建立、删除，利用INSERT语句，UPDATE语句，DELETE语句对实验一中创建的学生基本信息表，课程表，选课表中的数据进行增删改操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647481、use shujuku_shiyan;CREATE INDEX Student_index ON Student(Sno); ##添加普通索引DROP INDEX Student_index ON Student; ##删除索引CREATE UNIQUE INDEX Student_index ON Student (Sno) ##创建唯一索引 2、INSERT语句向Student表中插入一条记录INSERT INTO `Student` ( `Sno`, `Sname`, `Ssex`, `Sage`, `Sdept`)VALUES ( 201215126, &#x27;小志&#x27;, &#x27;男&#x27;, 21, &#x27;IS&#x27; ); 向SC表中添加一条学生学号为 201215126，课程为数据库，成绩为100的记录：INSERT INTO SC ( Sno, Cno,Grade)VALUES ( 201215126, 1, 100 );效果如下： 3、UPDATE语句修改学生表中Sno为201215126 的记录的Ssex为女，Sage的值为23：UPDATE Student set Sage=&#x27;23&#x27; ,Ssex=&#x27;女&#x27; WHERE Sno=&#x27;201215126&#x27; 4、DELETE语句删除Student表中Sno字段为201215126的记录：DELETE FROM Student where Sno=&#x27;201215126&#x27; 四、 实验心得1、在mysql数据库中，用use指令指示要用的数据库是多少，一定要在这句话的行末加上分号，不然会报错的，（就是语法规定吧，以；为一行的结束）。2、DELETE FROM table_name [WHERE Clause] 如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。可以在 WHERE 子句中指定任何条件3、UPDATE table_name SET field1=new-value1, field2=new-value2[WHERE Clause] 可以同时更新一个或多个字段。 可以在 WHERE 子句中指定任何条件。可以在一个单独表中同时更新数据。4、插入语句的格式：INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN ); 技巧 用Navicat自动生成SQL语句https://blog.csdn.net/yinni11/article/details/88668532","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[],"author":"aoyuehan"},{"title":"数据库实验一","slug":"数据库实验一","date":"2020-05-11T06:17:59.000Z","updated":"2022-02-26T04:31:40.715Z","comments":true,"path":"2020/05/11/数据库实验一/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%B8%80/","excerpt":"","text":"问题创建一个教学管理数据库，在数据库中创建学生基本信息表，课程表，选课表，并输入数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657-- course表建立DROP TABLE IF EXISTS `course`;CREATE TABLE `course` ( `Cno` int(11) NOT NULL, `Cname` varchar(255) DEFAULT NULL, `Cpon` int(255) DEFAULT NULL, `Ccredit` int(255) DEFAULT NULL, PRIMARY KEY (`Cno`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- course插入数据INSERT INTO `course` VALUES (&#x27;1&#x27;, &#x27;数据库&#x27;, &#x27;5&#x27;, &#x27;4&#x27;);INSERT INTO `course` VALUES (&#x27;2&#x27;, &#x27;数学&#x27;, null, &#x27;2&#x27;);INSERT INTO `course` VALUES (&#x27;3&#x27;, &#x27;信息系统 &#x27;, &#x27;1&#x27;, &#x27;4&#x27;);INSERT INTO `course` VALUES (&#x27;4&#x27;, &#x27;操作系统 &#x27;, &#x27;6&#x27;, &#x27;3&#x27;);INSERT INTO `course` VALUES (&#x27;5&#x27;, &#x27;数据结构 &#x27;, &#x27;7&#x27;, &#x27;4&#x27;);INSERT INTO `course` VALUES (&#x27;6&#x27;, &#x27;数据处理&#x27;, null, &#x27;2&#x27;);INSERT INTO `course` VALUES (&#x27;7&#x27;, &#x27;PASCAL语言 &#x27;, &#x27;6&#x27;, &#x27;4&#x27;);-- Sc表建立DROP TABLE IF EXISTS `sc`;CREATE TABLE `sc` ( `Sno` bigint(20) NOT NULL, `Cno` int(11) NOT NULL, `Grade` int(11) DEFAULT NULL, PRIMARY KEY (`Sno`,`Cno`), KEY `Cno` (`Cno`), CONSTRAINT `Cno` FOREIGN KEY (`Cno`) REFERENCES `course` (`Cno`), CONSTRAINT `Sno` FOREIGN KEY (`Sno`) REFERENCES `student` (`Sno`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- sc表插入数据INSERT INTO `sc` VALUES (&#x27;201215121&#x27;, &#x27;1&#x27;, &#x27;92&#x27;);INSERT INTO `sc` VALUES (&#x27;201215121&#x27;, &#x27;2&#x27;, &#x27;85&#x27;);INSERT INTO `sc` VALUES (&#x27;201215121&#x27;, &#x27;3&#x27;, &#x27;88&#x27;);INSERT INTO `sc` VALUES (&#x27;201215122&#x27;, &#x27;1&#x27;, &#x27;92&#x27;);INSERT INTO `sc` VALUES (&#x27;201215122&#x27;, &#x27;2&#x27;, &#x27;90&#x27;);INSERT INTO `sc` VALUES (&#x27;201215122&#x27;, &#x27;3&#x27;, &#x27;80&#x27;);-- 建立studentDROP TABLE IF EXISTS `student`;CREATE TABLE `student` ( `Sno` bigint(20) NOT NULL, `Sname` varchar(20) DEFAULT NULL, `Ssex` varchar(20) DEFAULT NULL, `Sage` int(11) DEFAULT NULL, `Sdept` varchar(20) DEFAULT NULL, PRIMARY KEY (`Sno`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;-- 向 student中添加数据INSERT INTO `student` VALUES (&#x27;201215121&#x27;, &#x27;李勇 &#x27;, &#x27;男 &#x27;, &#x27;20&#x27;, &#x27;CS &#x27;);INSERT INTO `student` VALUES (&#x27;201215122&#x27;, &#x27;刘晨 &#x27;, &#x27;女 &#x27;, &#x27;19&#x27;, &#x27;CS &#x27;);INSERT INTO `student` VALUES (&#x27;201215123&#x27;, &#x27;王敏 &#x27;, &#x27;女 &#x27;, &#x27;18&#x27;, &#x27;MA &#x27;);INSERT INTO `student` VALUES (&#x27;201215124&#x27;, &#x27;张立 &#x27;, &#x27;男 &#x27;, &#x27;19&#x27;, &#x27;IS &#x27;); 数据类型总结类型特点Char、固定长度，存储ANSI字符，不足的补英文半角空格Varchar、可变长度，存储ANSI字符，根据数据长度自动变化Nchar、固定长度，存储Unicode字符，不足的补英文半角空格nvcarchar、可变长度，存储Unicode字符，根据数据长度自动变化。 前面加“n”与不加“n”char、varchar、这两个只能用于单字节来存储 数据，适合英文，中文会不兼容。我们常用的汉字需要用两个字节来存储，所以就要使用nchar、nvarchar。 char、varchar因为是单字节的所以在存储的时候最大数值可以达到8000，而nchar、nvarchar是最大数值4000。 那么我们可以通过自己的要求来选择类型：1.如果你肯定存储的数据长度，而且不包中文的，可以选择char类型。2.如果肯定存储的数据长度，但可能包括中文，可以选择nchar类型。3.如果不确定存储的数据长度，存储只有英文、数字的最好用varchar类型4.如果不确定存储的数据长度，也有可能有中文，可以选择nvarchar类型 1452错误Navicat这是因为表设置了外键约束，而你试图插入一条外键字段所在表纪录不存在的一个值，就会报1452错。比如a、b两表，a表外键id值来自b表的ID。当你在a表中插入一条纪录时，id字段用了不在b表ID值范围内的值，就会报此错。因为我先建了三个表，在填数据的时候先太难了Course，然后再填Sc，此时填入的数据在Student中没有，所以会报错。 5.7版本报错[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column ‘information_schema.PROFILING.SEQ’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode&#x3D;only_full_group_by 改不出来了，网上说改my.cnf文件，没找到这文件，直接换了个mysql 8.0版本的。 Navicat常用的指令1.有时按快捷键Ctrl+F搜某条数据的时候搜不到，但是能用sql查出来，这是怎么回事？ Ctrl+F只能搜本页数据，不在本页的数据搜不到，navicat每页默认最多显示1000条数据（这个可自己设置：右下角“限制记录设置”）。在数据多的时候navicat是分页显示的，你可以按右下角的左&#x2F;右箭头翻到上&#x2F;下一页。这时候如果数据太多的话，这么翻页找这条数据太麻烦，还是用sql查找出来。 2.在navicat上对某个字段按照升序或降序排列，navicat上此表的所有页面都是按照这样排列的而不只是本页 3.新建查询。注释sql的快捷键：Ctrl+&#x2F; 取消注释：Shift+Ctrl+&#x2F; 4.Navicat没有查找字段名的功能按钮，只能用sql查（不用百度这个问题了，亲身探索，验证通过，想用自己开发此功能） 查询方法参见：http://blog.csdn.net/superit401/article/details/69389714 5.navicat中按字段的降序或升序排列不会影响数据库里的数据排序，只是navicat显示在眼前的数据顺序变化而已。 6.数据库里的数据顺序是按照创建时间存储并排序的，从数据库查出来（默认排序（SQL中不写排序order by），即ORDER BY CREATE_TIME ASC）的数据放进List里面的顺序与数据库里的数据顺序是一致。Navicat里显示的一条条的数据都是从上往下对应数据创建时间从早到晚。程序查出来（默认排序（SQL中不写排序order by），即ORDER BY CREATE_TIME ASC）的实体类List的顺序也是这样的，对应List的元素索引从小到大，即索引值越大，这条数据的创建时间越晚，与数据库里的顺序是对应的。 7.表的数据内容显示页面切换到表的结构设计页面：在表的数据内容显示页面按快捷键建Ctrl+D 相反切换回数据内容显示页：Ctrl+O 8.快速切换到表的查询：在数据内容显示页面按快捷键Ctrl+Q 8.编辑sql时选中一行快捷键：鼠标三击当前行 9.Navicat快捷键： Ctrl+Q 打开查询窗口Ctrl+&#x2F; 注释sql语句Ctrl+Shift +&#x2F; 解除注释Ctrl+R 运行查询窗口的sql语句Ctrl+Shift+R 只运行选中的sql语句F6 打开一个mysql命令行窗口Ctrl+L 删除一行Ctrl+N 打开一个新的查询窗口Ctrl+W 关闭一个查询窗口 Ctrl+D 表的数据显示显示页面切换到表的结构设计页面，但是在查询页面写sql时是复制当前行 10.“井号”# 是注释作用","categories":[],"tags":[],"author":"aoyuehan"},{"title":"算法 第四章作业","slug":"算法-第四章作业","date":"2020-05-06T03:40:00.000Z","updated":"2022-04-03T13:18:45.565Z","comments":true,"path":"2020/05/06/算法-第四章作业/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/05/06/%E7%AE%97%E6%B3%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"P115算法实现4-6最优服务次序问题设有 n个顾客同时等待一项服务 。顾需要的服务时间为 。应该如何安排 n个顾客的服务次序才能使总的等待时间达到最小？总的等待时间是各顾客等待服务的时间的总和。试给出你的做法的理由 分析问题 因为让总的等待时间和最小，那么我们很直接的联系到每个人的等待时间，而总的等待时间&#x3D;每个人的等待时间乘他们前面的系数之和（该系数就是他们在计算总等待时间时出现的次数），如果我们让每个人的等待时间都尽可能的小，那么最终总的等待时间也是最小的。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; ifstream in(&quot;input.txt&quot;); //打开文件 ，读取测试用例 ofstream out(&quot;output.txt&quot;); int N; double sum = 0; in &gt;&gt; N;//总个数 double p[N]; //用来存每个人的服务时间 for(int i = 0; i &lt; N; i++) &#123; in &gt;&gt; p[i]; //从文件中读取数据 &#125; sort(p,p + N); //排序 double cnt[N]; //系数，即每个ti在总的服务顺序中出现的次数 for(int i = 0; i &lt; N; ++i) &#123; cnt[i] =i+1; &#125; for(int i = 0; i &lt; N; i++) &#123; sum += cnt[N-i-1]*p[i];//计算总和 &#125; out&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2);///保留两位小数 out &lt;&lt; sum; return 0;&#125; 思考题 1、将最优装载问题的贪心算法推广到2艘船的情形，贪心算法仍能产生最优解吗？2、字符a~h出现的频率恰好是前8个Fibonacci数，它们的哈夫曼编码是什么？将结果推广到n个字符的频率分布恰好是前n个个Fibonacci数的情形。 1、是否有一个合理的装载方案，将这n个集装箱装上这2艘船。因为两艘船的装载问题，是先装完第一艘，再装第二艘，所以就必须把第一艘尽可能的装满，才能使总的装载量更多。如果使用贪心算法求解，第一艘船装载的方式只可能有一种最优解，就是装载的物品都是以从轻到重的顺序装载，所能装的最大重量，那么问题就来了，从轻到重这样装，不一定是最满的。反例： 2、","categories":[{"name":"算法分析与设计","slug":"算法分析与设计","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}],"tags":[],"author":"aoyuehan"},{"title":"0429 计蒜客","slug":"0429-计蒜客","date":"2020-04-29T12:13:44.000Z","updated":"2022-04-03T13:18:45.785Z","comments":true,"path":"2020/04/29/0429-计蒜客/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/29/0429-%E8%AE%A1%E8%92%9C%E5%AE%A2/","excerpt":"","text":"题意就是给你w头狼和s头羊和c个胡萝卜，每次可以运k个东东过河，狼会吃羊，羊会吃胡萝卜，不过当他们在船上时是互不干预的，问你，怎么样才可以不受缺的运这些东东过河；1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;using namespace std;int main()&#123; int w,s,c,k; scanf(&quot;%d%d%d%d&quot;,&amp;w,&amp;s,&amp;c,&amp;k); if(w+c&gt;k&amp;&amp;s&gt;k) &#123; printf(&quot;NO\\n&quot;); return 0; &#125; if(s&lt;k) &#123; printf(&quot;YES\\n&quot;); return 0; &#125; if(w+c&lt;k) &#123; printf(&quot;YES\\n&quot;); return 0; &#125; if(w+c==k&amp;&amp;s&lt;=2*k) &#123; printf(&quot;YES\\n&quot;); return 0; &#125; if(s==k&amp;&amp;(w+c)&lt;=2*k) &#123; printf(&quot;YES\\n&quot;); return 0; &#125; printf(&quot;NO\\n&quot;); return 0;&#125; Kaleidoscopic Palindromeshttps://blog.csdn.net/chen_zan_yu_/article/details/84061399 求欧拉数 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int main()&#123; int n; double ans=0,l=1; scanf(&quot;%d&quot;,&amp;n); if(n==0) &#123; printf(&quot;%.15lf\\n&quot;,l); return 0; &#125; for(int i=1; i&lt;=n; i++) &#123; l/=i; ans+=l; &#125; ans++; printf(&quot;%.15lf\\n&quot;,ans); return 0;&#125;","categories":[],"tags":[],"author":"aoyuehan"},{"title":"简史","slug":"简史","date":"2020-04-26T13:42:00.000Z","updated":"2022-02-26T04:29:56.413Z","comments":true,"path":"2020/04/26/简史/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/26/%E7%AE%80%E5%8F%B2/","excerpt":"","text":"本篇文章主要记述本人大学的轨迹高考我当时考了多少分来着，好像是519，去了济南齐鲁工业大学，算是上了一所不是很好，也不算坏的学校吧，其实我真的体会到什么叫做知识改变命运了， 其典型表现： 1．自动自发 2．目标远大 3．情绪控制 4．认识自我 5．人际技巧 6．对自己有清醒的认识，能承受压力。 7．自信而不自满。 8．人际关系良好，和朋友或同事能友好相处。 9．善于处理生活中遇到的各方面的问题。 10．认真对待每一件事情。即：尊重所有人的人权和人格尊严。不将自己的价值观强加于他人。肯于帮助别人。能够放下手头的事情，时不时停下来关注别人，向有困难的人伸出援助之手，而不是完全沉浸在自己的小世界里，这样的人情商高。知道什么时候该拒绝。情商高的人懂得何时以及如何拒绝别人，并有强大的心理承受能力来有礼有节地拒绝。善于读懂别人的面部表情。面部表情是一种通用的情绪语言。能领悟别人感受的人情商高。失败后能重新崛起。情商高的人无论遇到何等逆境，都会坚持下去，迅速调整情绪，恢复活力，具有很强的心理韧性。","categories":[],"tags":[]},{"title":"UCF 2015","slug":"UCF-2015","date":"2020-04-22T11:57:00.000Z","updated":"2022-02-26T03:52:51.708Z","comments":true,"path":"2020/04/22/UCF-2015/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/22/UCF-2015/","excerpt":"","text":"题目链接 A 打印第几条对角线123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;bits/stdc++.h&gt;using namespace std;int n;int k;int m;char s[20][20];int cnt=1;int dx=1,dy=1;void print() &#123; if(m==1) &#123; int x=1; int y=m; while(x&lt;=n&amp;&amp;y&lt;=n) &#123; // cout&lt;&lt;&quot;x=&quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;&quot;y=&quot;&lt;&lt;y&lt;&lt;endl; if(x==n||y==n) cout&lt;&lt;s[x][y]&lt;&lt;endl; else cout&lt;&lt;s[x][y]&lt;&lt;&quot; &quot;; x+=dx; y+=dy; &#125; &#125; else &#123; int x=1; int y=m; while(x&lt;=n&amp;&amp;y&lt;=n) &#123; // cout&lt;&lt;&quot;x=&quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;&quot;y=&quot;&lt;&lt;y&lt;&lt;endl; if(x==n||y==n) cout&lt;&lt;s[x][y]&lt;&lt;endl; else cout&lt;&lt;s[x][y]&lt;&lt;&quot; &quot;; x+=dx; y+=dy; &#125; x=m; y=1; while(x&lt;=n&amp;&amp;y&lt;=n) &#123; // cout&lt;&lt;&quot;x=&quot;&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;&quot;y=&quot;&lt;&lt;y&lt;&lt;endl; if(x==n||y==n) cout&lt;&lt;s[x][y]&lt;&lt;endl; else cout&lt;&lt;s[x][y]&lt;&lt;&quot; &quot;; x+=dx; y+=dy; &#125; &#125;&#125;int main() &#123; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) cin&gt;&gt;s[i][j]; cout&lt;&lt;&quot;Input matrix #&quot;&lt;&lt;cnt++&lt;&lt;&quot;:&quot;&lt;&lt;endl; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) j==n?cout&lt;&lt;s[i][j]:cout&lt;&lt;s[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; cin&gt;&gt;k; while(k--) &#123; cin&gt;&gt;m; cout&lt;&lt;&quot;Symmetric diagonals &quot;&lt;&lt;m&lt;&lt;&quot;:&quot;&lt;&lt;endl; print(); &#125; cout&lt;&lt;endl; &#125; return 0;&#125; C 字符串模拟明显第一个串满足大于200后如果有’-‘直接补0，再分情况讨论第二个串，再由第二个确定的串分情况讨论第三个串。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INF 0x3f3f3f3f#define PI acos(-1)using namespace std;typedef long long ll;typedef pair&lt;ll, ll&gt; P;const int mod=1e9+7;const int maxn=5e4+10;const double pi=3.14159;string change(string s, string t) &#123; string ans; if (t[0]!=&#x27;-&#x27; &amp;&amp; t[1]!=&#x27;-&#x27; &amp;&amp; t[2]!=&#x27;-&#x27;) &#123; return t; &#125; if (t[0]==&#x27;-&#x27; &amp;&amp; t[1]!=&#x27;-&#x27; &amp;&amp; t[2]!=&#x27;-&#x27;) &#123; ans=t[1]; ans+=t[2]; if (t[1]&gt;s[1] || (t[1]==s[1] &amp;&amp; t[2]&gt;s[2])) ans=s[0]+ans; else ans=(char)(s[0]+1)+ans; &#125; if (t[0]!=&#x27;-&#x27; &amp;&amp; t[1]==&#x27;-&#x27; &amp;&amp; t[2]!=&#x27;-&#x27;) &#123; ans=t[0]; if (t[0]&gt;s[0]) &#123; ans+=&#x27;0&#x27;; ans+=t[2]; &#125; else &#123; if (t[2]&gt;s[2]) &#123; ans+=s[1]; ans+=t[2]; &#125; else &#123; ans+=(char)(s[1]+1); ans+=t[2]; &#125; &#125; &#125; if (t[0]!=&#x27;-&#x27; &amp;&amp; t[1]!=&#x27;-&#x27; &amp;&amp; t[2]==&#x27;-&#x27;) &#123; ans=t[0]; ans+=t[1]; if (t[1]&gt;s[1] || t[0]&gt;s[0]) ans=ans+&#x27;0&#x27;; else ans=ans+(char)(s[2]+1); &#125; return ans;&#125;int main() &#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); int T; cin&gt;&gt;T; int ca=1; while (T--) &#123; string a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; string na=&quot;&quot;,nb=&quot;&quot;,nc=&quot;&quot;; if (a[0]==&#x27;-&#x27;) na+=&#x27;2&#x27;; else na+=a[0]; if (a[1]==&#x27;-&#x27;) na+=&#x27;0&#x27;; else na+=a[1]; if (a[2]==&#x27;-&#x27;) na+=&#x27;0&#x27;; else na+=a[2]; nb=change(na,b); nc=change(nb,c); cout&lt;&lt;&quot;Gas Station #&quot;&lt;&lt;ca++&lt;&lt;&quot;:&quot;&lt;&lt;endl; cout&lt;&lt;&quot; Input: &quot;&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl; cout&lt;&lt;&quot; Output: &quot;&lt;&lt;na&lt;&lt;&quot; &quot;&lt;&lt;nb&lt;&lt;&quot; &quot;&lt;&lt;nc&lt;&lt;endl; cout&lt;&lt;endl; &#125; return 0;&#125;错误解法1：#include&lt;iostream&gt;using namespace std;int main()&#123; long long n; cin&gt;&gt;n; getchar(); string s; long long a,b,c; long long count=0; while(n--)&#123; count++; a=0; b=0; c=0; getline(cin,s); printf(&quot;Gas Station #%lld:\\n Input: &quot;,count); cout&lt;&lt;s&lt;&lt;endl; if(s[0]==&#x27;-&#x27;)&#123; a=2; s[0]=&#x27;2&#x27;; a=a*10+(s[1]-&#x27;0&#x27;); a=a*10+(s[2]-&#x27;0&#x27;); &#125; else &#123; for(int i=0;i&lt;3;i++)&#123; if(s[i]==&#x27;-&#x27;)a=a*10+0,s[i]=&#x27;0&#x27;; else a=a*10+(s[i]-&#x27;0&#x27;); &#125; &#125; if(s[4]==&#x27;-&#x27;)&#123; b=2; s[4]=&#x27;2&#x27;; b=b*10+s[5]-&#x27;0&#x27;; b=b*10+s[6]-&#x27;0&#x27;; while(b&lt;=a&amp;&amp;b&lt;=500)b+=100,s[4]+=1; &#125; else if(s[5]==&#x27;-&#x27;)&#123; b=s[4]-&#x27;0&#x27;; b=b*10+s[1]-&#x27;0&#x27;; //这地方不能直接补前面的s[1],应该补0才是最小的 s[5]=s[1]; b=b*10+s[6]-&#x27;0&#x27;; while(b&lt;=a&amp;&amp;b&lt;=500)b+=10,s[5]+=1; &#125; else if(s[6]==&#x27;-&#x27;)&#123; b=s[4]-&#x27;0&#x27;; b=b*10+s[5]-&#x27;0&#x27;; s[6]=s[2]; b=b*10+s[6]-&#x27;0&#x27;; while(b&lt;=a&amp;&amp;b&lt;=500)b+=1,s[6]+=1; &#125; else if(s[4]!=&#x27;-&#x27;&amp;&amp;s[5]!=&#x27;-&#x27;&amp;&amp;s[6]!=&#x27;-&#x27;)&#123; for(int i=4;i&lt;7;i++)b=b*10+(s[i]-&#x27;0&#x27;); &#125; if(s[8]==&#x27;-&#x27;)&#123; c=s[4]-&#x27;0&#x27;; c=c*10+s[9]-&#x27;0&#x27;; c=c*10+s[10]-&#x27;0&#x27;; while(c&lt;=b)c+=100; &#125; else if(s[9]==&#x27;-&#x27;)&#123; c=s[8]-&#x27;0&#x27;; c=c*10+s[5]-&#x27;0&#x27;; c=c*10+s[10]-&#x27;0&#x27;; while(c&lt;=b)c+=10; &#125; else if(s[10]=&#x27;-&#x27;)&#123; c=s[8]-&#x27;0&#x27;; c=c*10+s[9]-&#x27;0&#x27;; c=c*10+s[6]-&#x27;0&#x27;; while(c&lt;=b)c++; &#125; else if(s[8]!=&#x27;-&#x27;&amp;&amp;s[9]!=&#x27;-&#x27;&amp;&amp;s[10]!=&#x27;-&#x27;)&#123; for(int i=8;i&lt;11;i++)c=c*10+(s[i]-&#x27;0&#x27;); &#125; printf(&quot; Output: %lld %lld %lld\\n&quot;,a,b,c); &#125; return 0;&#125;上述解法的正确解法：#include&lt;iostream&gt;using namespace std;int main()&#123; long long n; cin&gt;&gt;n; getchar(); string s; long long a,b,c; long long count=0; while(n--)&#123; count++; a=0; b=0; c=0; getline(cin,s); printf(&quot;Gas Station #%lld:\\n Input: &quot;,count); cout&lt;&lt;s&lt;&lt;endl; if(s[0]==&#x27;-&#x27;)&#123; a=2; s[0]=&#x27;2&#x27;; a=a*10+(s[1]-&#x27;0&#x27;); a=a*10+(s[2]-&#x27;0&#x27;); &#125; else &#123; for(int i=0;i&lt;3;i++)&#123; if(s[i]==&#x27;-&#x27;)a=a*10+0,s[i]=&#x27;0&#x27;; else a=a*10+(s[i]-&#x27;0&#x27;); &#125; &#125; if(s[4]==&#x27;-&#x27;)&#123; b=2; s[4]=&#x27;2&#x27;; b=b*10+s[5]-&#x27;0&#x27;; b=b*10+s[6]-&#x27;0&#x27;; while(b&lt;=a&amp;&amp;b&lt;=500)b+=100,s[4]+=1; &#125; else if(s[5]==&#x27;-&#x27;)&#123; b=s[4]-&#x27;0&#x27;; b=b*10; s[5]=&#x27;0&#x27;; b=b*10+s[6]-&#x27;0&#x27;; while(b&lt;=a&amp;&amp;b&lt;=500)b+=10,s[5]+=1; &#125; else if(s[6]==&#x27;-&#x27;)&#123; b=s[4]-&#x27;0&#x27;; b=b*10+s[5]-&#x27;0&#x27;; s[6]=&#x27;0&#x27;; b=b*10+s[6]-&#x27;0&#x27;; while(b&lt;=a&amp;&amp;b&lt;=500)b+=1,s[6]+=1; &#125; else if(s[4]!=&#x27;-&#x27;&amp;&amp;s[5]!=&#x27;-&#x27;&amp;&amp;s[6]!=&#x27;-&#x27;)&#123; for(int i=4;i&lt;7;i++)b=b*10+s[i]-&#x27;0&#x27;; &#125; if(s[8]==&#x27;-&#x27;)&#123; c=s[4]-&#x27;0&#x27;; c=c*10+s[9]-&#x27;0&#x27;; c=c*10+s[10]-&#x27;0&#x27;; while(c&lt;=b&amp;&amp;c&lt;=500)c+=100; &#125; else if(s[9]==&#x27;-&#x27;)&#123; c=s[8]-&#x27;0&#x27;; c=c*10; c=c*10+s[10]-&#x27;0&#x27;; while(c&lt;=b&amp;&amp;c&lt;=500)c+=10; &#125; else if(s[10]==&#x27;-&#x27;)&#123; c=s[8]-&#x27;0&#x27;; c=c*10+s[9]-&#x27;0&#x27;; c=c*10; while(c&lt;=b&amp;&amp;c&lt;=500)c++; &#125; else if(s[8]!=&#x27;-&#x27;&amp;&amp;s[9]!=&#x27;-&#x27;&amp;&amp;s[10]!=&#x27;-&#x27;)&#123; for(int i=8;i&lt;11;i++)c=c*10+s[i]-&#x27;0&#x27;; &#125; printf(&quot; Output: %lld %lld %lld\\n\\n&quot;,a,b,c); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"剑指offer-第六章-面试中的各项能力","slug":"剑指offer-第六章-面试中的各项能力","date":"2020-04-20T13:26:37.000Z","updated":"2022-02-26T03:52:51.604Z","comments":true,"path":"2020/04/20/剑指offer-第六章-面试中的各项能力/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/20/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E5%90%84%E9%A1%B9%E8%83%BD%E5%8A%9B/","excerpt":"","text":"6.1 面试官谈能力6.2 沟通能力和学习能力6.3 知识迁移能力 剑指Offer（53）：数字在排序数组中出现的次数题目 统计一个数字在排序数组中出现的次数。 思路 既然是已经排序好的数组，那么第一个想到的就是二分查找法。 做法就是使用二分法找到数字在数组中出现的第一个位置，再利用二分法找到数字在数组中出现的最后一个位置。时间复杂度为O(logn + logn)，最终的时间复杂度为O(logn)。 举个例子，找到数字k在数组data中出现的次数。 数组data中，数字k出现的第一个位置： 我们对数组data进行二分，如果数组中间的数字小于k，说明k应该出现在中间位置的右边；如果数组中间的数字大于k，说明k应该出现在中间位置的左边；如果数组中间的数字等于k，并且中间位置的前一个数字不等于k，说明这个中间数字就是数字k出现的第一个位置。 同理，数字k出现的最后一个位置，也是这样找的。但是判断少有不同。我们使用两个函数分别获得他们。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; int length = data.size(); if(length == 0)&#123; return 0; &#125; int first = GetFirstK(data, k, 0, length - 1); int last = GetLastK(data, k, 0, length - 1); if(first != -1 &amp;&amp; last != -1)&#123; return last - first + 1; &#125; return 0; &#125;private: // 迭代实现找到第一个K int GetFirstK(vector&lt;int&gt; data, int k, int begin, int end)&#123; if(begin &gt; end)&#123; return -1; &#125; int middleIndex = (begin + end) &gt;&gt; 1; int middleData = data[middleIndex]; if(middleData == k)&#123; if((middleIndex &gt; 0 &amp;&amp; data[middleIndex - 1] != k) || middleIndex == 0)&#123; return middleIndex; &#125; else&#123; end = middleIndex - 1; &#125; &#125; else if (middleData &gt; k)&#123; end = middleIndex - 1; &#125; else&#123; begin = middleIndex + 1; &#125; return GetFirstK(data, k, begin, end); &#125; // 循环实现找到最后一个K int GetLastK(vector&lt;int&gt; data, int k, int begin, int end)&#123; int length = data.size(); int middleIndex = (begin + end) &gt;&gt; 1; int middleData = data[middleIndex]; while(begin &lt;= end)&#123; if(middleData == k)&#123; if((middleIndex &lt; length - 1 &amp;&amp; data[middleIndex + 1] != k) || middleIndex == length - 1)&#123; return middleIndex; &#125; else&#123; begin = middleIndex + 1; &#125; &#125; else if(middleData &gt; k)&#123; end = middleIndex - 1; &#125; else&#123; begin = middleIndex + 1; &#125; middleIndex = (begin + end) &gt;&gt; 1; middleData = data[middleIndex]; &#125; return -1; &#125;&#125;; 题目二 题目三 剑指Offer（54）：二叉搜索树的第k个结点题目 给定一颗二叉搜索树，请找出其中的第k大的结点。例如，在下图中，按结点数值大小顺序第三个结点的值为4。 这棵树是二叉搜索树，首先想到的是二叉搜索树的一个特点：左子结点的值 &lt; 根结点的值 &lt; 右子结点的值。 思路如上图所示，如果使用终须遍历，则得到的序列式为{2,3,4,5,6,7,8}。因此，只需要用中序遍历一棵二叉搜索树，就很容易找出它的第k大结点。 12345678910111213141516171819202122232425262728293031323334353637383940/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* KthNode(TreeNode* pRoot, int k) &#123; if(pRoot == NULL || k == 0)&#123; return NULL; &#125; return KthNodeCore(pRoot, k); &#125;private: TreeNode* KthNodeCore(TreeNode* pRoot, int &amp;k)&#123; TreeNode* target = NULL; // 先遍历左结点 if(pRoot-&gt;left != NULL)&#123; target = KthNodeCore(pRoot-&gt;left, k); &#125; // 如果没有找到target，则继续减小k，如果k等于1，说明到了第k大的数 if(target == NULL)&#123; if(k == 1)&#123; target = pRoot; &#125; k--; &#125; // 如果没有找到target，继续找右结点 if(pRoot-&gt;right != NULL &amp;&amp; target == NULL)&#123; target = KthNodeCore(pRoot-&gt;right, k); &#125; return target; &#125;&#125;; 剑指Offer（55）：二叉树的深度题目 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 思路 这道题蛮简单的，求二叉树的深度。可以是递归的方法，属于DFS（深度优先搜索）；另一种方法是按照层次遍历，属于BFS（广度优先搜索）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061DFS:/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int TreeDepth(TreeNode* pRoot) &#123; if(pRoot == NULL)&#123; return 0; &#125; int left = TreeDepth(pRoot-&gt;left); int right = TreeDepth(pRoot-&gt;right); return (left &gt; right) ? (left + 1) : (right + 1); &#125;&#125;;BFS:/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int TreeDepth(TreeNode* pRoot) &#123; if(pRoot == NULL)&#123; return 0; &#125; queue&lt;TreeNode*&gt; que; int depth = 0; que.push(pRoot); while(!que.empty())&#123; int size = que.size(); depth++; for(int i = 0; i &lt; size; i++)&#123; //这地方只是为了求树的深度才写这个for的，遍历图的时候不用 TreeNode* node = que.front(); que.pop(); if(node-&gt;left)&#123; que.push(node-&gt;left); &#125; if(node-&gt;right)&#123; que.push(node-&gt;right); &#125; &#125; &#125; return depth; &#125;&#125;; 平衡二叉树遍历一遍就能求树的深度 剑指Offer（56）：数组中只出现一次的数字题目 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 思路 大家首先想到的是顺序扫描法，但是这种方法的时间复杂度是O（n^2）。接着大家又会考虑用哈希表的方法，但是空间复杂度不是O（1）。 应该怎么做才能即满足时间复杂度是O（n）又满足空间复杂度是O（1）的要求呢？ 我们可以想一想“异或”运算的一个性质，我们直接举例说明。 举例：{2,4,3,6,3,2,5,5} 这个数组中只出现一次的两个数分别是4和6。怎么找到这个两个数字呢？ 我们先不看找到俩个的情况，先看这样一个问题，如何在一个数组中找到一个只出现一次的数字呢？比如数组：{4,5,5}，唯一一个只出现一次的数字是4。 我们知道异或的一个性质是：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字。比如数组{4,5,5}，我们先用数组中的第一个元素4（二进制形式：0100）和数组中的第二个元素5（二进制形式：0101）进行异或操作，0100和0101异或得到0001，用这个得到的元素与数组中的三个元素5（二进制形式：0101）进行异或操作，0001和0101异或得到0100，正好是结果数字4。这是因为数组中相同的元素异或是为0的，因此就只剩下那个不成对的孤苦伶仃元素。 现在好了，我们已经知道了如何找到一个数组中找到一个只出现一次的数字，那么我们如何在一个数组中找到两个只出现一次的数字呢？如果，我们可以将原始数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现。这样，我们就可以用上述方法找到那个孤苦伶仃的元素。 我们还是从头到尾一次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数组的异或结果。因为其他数字都出现了两次，在异或中全部抵消了。由于两个数字肯定不一样，那么异或的结果肯定不为0，也就是说这个结果数组的二进制表示至少有一个位为1。我们在结果数组中找到第一个为1的位的位置，记为第n位。现在我们以第n位是不是1为标准把元数组中的数字分成两个子数组，第一个子数组中每个数字的第n位都是1，而第二个子数组中每个数字的第n位都是0。 举例：{2,4,3,6,3,2,5,5} 我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; int length = data.size(); if(length &lt; 2)&#123; return; &#125; // 对原始数组每个元素求异或 int resultExclusiveOR = 0; for(int i = 0; i &lt; length; ++i)&#123; resultExclusiveOR ^= data[i]; &#125; unsigned int indexOf1 = FindFirstBitIs1(resultExclusiveOR); *num1 = *num2 = 0; for(int j = 0; j &lt; length; j++)&#123; if(IsBit1(data[j], indexOf1))&#123; *num1 ^= data[j]; &#125; else&#123; *num2 ^= data[j]; &#125; &#125; &#125;private: // 找到二进制数num第一个为1的位数，比如0010，第一个为1的位数是2。 unsigned int FindFirstBitIs1(int num)&#123; unsigned int indexBit = 0; // 只判断一个字节的 while((num &amp; 1) == 0 &amp;&amp; (indexBit &lt; 8 * sizeof(unsigned int)))&#123; num = num &gt;&gt; 1; indexBit++; &#125; return indexBit; &#125; // 判断第indexBit位是否为1 bool IsBit1(int num, unsigned int indexBit)&#123; num = num &gt;&gt; indexBit; return (num &amp; 1); &#125;&#125;; 上题的变形 剑指Offer（57）：和为S的两个数字题目 输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述： 对应每个测试案例，输出两个数，小的先输出。 思路 对于一个数组，我们可以定义两个指针，一个从左往右遍历（pleft），另一个从右往左遍历（pright）。首先，我们比较第一个数字和最后一个数字的和curSum与给定数字sum，如果curSum &lt; sum，那么我们就要加大输入值，所以，pleft向右移动一位，重复之前的计算；如果curSum &gt; sum，那么我们就要减小输入值，所以，pright向左移动一位，重复之前的计算；如果相等，那么这两个数字就是我们要找的数字，直接输出即可。 这么做的好处是，也保证了乘积最小。 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; vector&lt;int&gt; result; int length = array.size(); if(length &lt; 1)&#123; return result; &#125; int pright = length - 1; int pleft = 0; while(pright &gt; pleft)&#123; int curSum = array[pleft] + array[pright]; if(curSum == sum)&#123; result.push_back(array[pleft]); result.push_back(array[pright]); break; &#125; else if(curSum &lt; sum)&#123; pleft++; &#125; else&#123; pright--; &#125; &#125; return result; &#125;&#125;; 上题的变题 题目 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述： 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序。1、思路 这道题还是蛮简单的。 设定两个指针，一个指向第一个数，一个指向最后一个数，在此之前需要设定第一个数和最后一个数的值，由于是正数序列，所以可以把第一个数设为1，最后一个数为2（因为是要求是连续正数序列，最后不可能和第一个数重合）。下一步就是不断改变第一个数和最后一个数的值，如果从第一个数到最后一个数的和刚好是要求的和，那么把所有的数都添加到一个序列中；如果大于要求的和，则说明从第一个数到最后一个数之间的范围太大，因此减小范围，需要把第一个数的值加1，同时把当前和减去原来的第一个数的值；如果小于要求的和，说明范围太小，因此把最后一个数加1，同时把当前的和加上改变之后的最后一个数的值。这样，不断修改第一个数和最后一个数的值，就能确定所有连续正数序列的和等于S的序列了。 注意：初中的求和公式应该记得吧，首项加尾项的和乘以个数除以2，即sum &#x3D; (a + b) * n &#x2F; 2。 1234567891011121314151617181920212223242526272829class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt; &gt; result; // 高位指针和低位指针 int phigh = 2, plow = 1; // 终止条件是phigh等于sum while(phigh &gt; plow)&#123; // 当前和，使用求和公式s = (a+b) * n / 2 int curSum = (plow + phigh) * (phigh - plow + 1) &gt;&gt; 1; if(curSum &lt; sum)&#123; phigh++; &#125; if(curSum == sum)&#123; vector&lt;int&gt; temp; for(int i = plow; i &lt;= phigh; i++)&#123; temp.push_back(i); &#125; result.push_back(temp); plow++; &#125; if(curSum &gt; sum)&#123; plow++; &#125; &#125; return result; &#125;&#125;; 剑指Offer（58）：翻转单词顺序序列题目 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 思路 观察字符串变化规律，你会发现这道题很简单。只需要对每个单词做翻转，然后再整体做翻转就得到了正确的结果。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string ReverseSentence(string str) &#123; string result = str; int length = result.size(); if(length == 0)&#123; return &quot;&quot;; &#125; // 追加一个空格，作为反转标志位 result += &#x27; &#x27;; int mark = 0; // 根据空格，反转所有单词 for(int i = 0; i &lt; length + 1; i++)&#123; if(result[i] == &#x27; &#x27;)&#123; Reverse(result, mark, i - 1); mark = i + 1; &#125; &#125; // 去掉添加的空格 result = result.substr(0, length); // 整体反转 Reverse(result, 0, length - 1); return result; &#125;private: void Reverse(string &amp;str, int begin, int end)&#123; while(begin &lt; end)&#123; swap(str[begin++], str[end--]); &#125; &#125;&#125;; 上题的变题 左旋转字符串题目 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S&#x3D;”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！😁 思路 例如：输入字符串”abcdefg”和数字2，该函数将返回左旋转2位得到的结果”cdefgab”; 第一步：翻转字符串“ab”，得到”ba”； 第二步：翻转字符串”cdefg”，得到”gfedc”； 第三步：翻转字符串”bagfedc”，得到”cdefgab”； 或者： 第一步：翻转整个字符串”abcdefg”,得到”gfedcba” 第二步：翻转字符串“gfedc”，得到”cdefg” 第三步：翻转字符串”ba”,得到”ab” tips:好像可以直接把前面的串直接移到另一个串的后面输出 123456789101112131415161718192021222324class Solution &#123;public: string LeftRotateString(string str, int n) &#123; string result = str; int length = result.size(); if(length &lt; 0)&#123; return NULL; &#125; if(0 &lt;= n &lt;= length)&#123; int pFirstBegin = 0, pFirstEnd = n - 1; int pSecondBegin = n, pSecondEnd = length - 1; ReverseString(result, pFirstBegin, pFirstEnd); ReverseString(result, pSecondBegin, pSecondEnd); ReverseString(result, pFirstBegin, pSecondEnd); &#125; return result; &#125;private: void ReverseString(string &amp;str, int begin, int end)&#123; while(begin &lt; end)&#123; swap(str[begin++], str[end--]); &#125; &#125;&#125;; 6.3 知识迁移能力6.4 抽象建模能力6.5 发散思维能力","categories":[],"tags":[]},{"title":"数据库知识点","slug":"数据库知识点","date":"2020-04-20T03:21:00.000Z","updated":"2022-02-26T03:52:52.267Z","comments":true,"path":"2020/04/20/数据库知识点/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1.数据模型组成三要素：数据结构，数据操作和完整性约束条件 2.数据库系统的三级模式结构：模式,外模式和内模式 3.数据库是长期存储在计算机内，有组织的，可共享的大量数据的集合 4.数据库的基本特征：数据按一定的数据模型组织、描述和储存，可为各种用户共享，冗余度较小，数据独立性较高，易扩展 5.数据库系统的构成：数据库，数据库管理系统（及其开发工具），应用系统，数据库管理员 6.SQL语句的基本特点：综合统一，高度非过程化，面向集合的操作方式，以同一种语法结构提供多种使用方式，语言简洁。 7.SQL的功能：数据定义、数据操纵、数据控制 8.自主授权控制实现机制：SQL语言，GRANT和REVOKE语句实现 9.数据库安全性控制的方法：用户标识与鉴别，存取控制，授权与回收 10.数据库保护涉及的问题：安全性，完整性，数据库恢复和并发控制(死锁问题) 11.加密的方法：替换、置换、两种结合 12.数据库完整性的方法：实体完整性、参照完整性和自定义完整性 13.数据的完整性和安全性是两个不同概念：1.数据的完整性：防止数据库中存在不符合语义的数据，也就是防止数据库中存在不正确的数据，防范对象：不合语义的、不正确的数据2.数据的安全性：保护数据库防止恶意的破坏和非法的存取，防范对象：非法用户和非法操作 14.数据库设计的步骤：需求分析（用户需求），概念结构设计（E-R图），逻辑结构设计（视图），物理结构设计（索引）数据库实施，数据库运行和维护 15.数据字典的内容：数据项，数据结构，数据流，数据存储，处理过程 16.E-R图合并的冲突：属性冲突，命名冲突，结构冲突 17.优化数据模型的方法：确定数据依赖，消除冗余的联系，确定所属范式 18.引入嵌入式编程的原因：SQL是非过程的语言，事务处理应用需要高级语言 19.高级语言和SQL语言的作用：前者是负责控制数据流程，后者负责操纵数据库 20.SQL通信区的作用：向主语言传递SQL语句的执行状态信息，使主语言能够据此控制程序流程 21.主变量的作用：向SQL语句提供参数，将SQL语句查询数据库的结果交主语言进一步处理 22.游标：解决集合性操作语言与过程性操作语言的不匹配。(数据缓冲区，存放SQL语句的执行结果) 23.为什么使用游标：SQL语言与主语言具有不同数据处理方式。SQL语言是面向集合的，一条SQL语句原则上可以产生或处理多条记录。主语言是面向记录的，一组主变量一次只能存放一条记录。仅使用主变量并不能完全满足SQL语句向应用程序输出数据的要求。嵌入式SQL引入了游标的概念，用来协调这两种不同的处理方式 24.常见的存储介质及其特征：高速缓存存储器：容量小，速度快，最昂贵。主存储器：断电时，贮存内容丢失。快闪存储器：非易失。磁盘存储器：长期联机数据存储。光学存储器：光学存储到光盘上。磁带存储器：顺序访问数据 25.磁盘的请求模式：顺序访问模式：连续的请求会请求处于相同磁道或相邻磁道上连续的块。只需要一次寻道时间。随机访问模式：连续的请求会请求随机位于磁盘上的块，效率较低。 26.优化方法：缓冲：从磁盘读取的数据暂时存在内存缓冲区里。预读：当一个磁盘块被访问时，相邻磁道的连续快也被读入内存缓冲区中。调度：按块经过读写头的顺序发出访问请求。电梯算法。 27.定长记录：多个文件，在任意一个文件只存储一个固定长度的记录。变长记录：构造自己的文件，使之容纳多种长度的记录。 28.文件组织记录的几种方法：堆文件：任意存放。顺序文件组织方式：记录根据其 搜索码 的值顺序存储。散列文件组织方式：在每条记录的某些属性计算一个散列函数，根据其值计算。搜索码是一个属性或多个属性的集合，不一定是主码。在物理上，尽可能接近搜索码的顺序存储记录。插入新纪录时，若位置空闲，则直接插入，否则插入溢出块。记录过多，则需要文件重组，保证搜索码和物理存储顺序的一致性。 29.缓冲区机制：当数据库系统中的程序需要磁盘上的块时，它向缓冲区管理器发出请求（即调用）。如果这个块在缓冲区中，缓冲区管理器将这个块在主存中的地址传给请求者。如果这个块不在缓冲区中，缓冲区首先为这个块分配空间（必要时，移出一些块，这个块必须已经被写回磁盘），然后把请求的块从磁盘读入缓冲区中，并将这个块在主存中的地址传给请求者。 30.应用的技术：缓冲区替换策略:移除最近最少使用的写回磁盘并从缓冲区移走。被钉住的块：使数据库系统从崩溃中回复，限制一个块写回磁盘的时间。块的强制写出：把块强制写回磁盘。防止数据丢失 31.查询处理优化：查询-通过语法分析器与翻译器转化为关系代数表达式-通过优化器优化执行计划-执行引擎得到查询结果。30.事物的特性：原子性、一致性、持续性、隔离性 30.事务是一个数据库操作序列；一个不可分割的工作单位；恢复和并发控制的基本单位31.数据库常见故障种类及其恢复策略：故障种类：事物内部的故障：撤销事务(UNDO)。系统故障(软故障):若事务未提交，强行撤销所有未完成事务。事务提交：但缓冲区中的信息尚未完全写回到磁盘上：重做(REDO)所有已提交的事务。介质故障(硬故障)：装入数据库发生介质故障前某个时刻的数据副本；重做自此开始时的所有成功事务，将这些事务已提交的结果重新计入数据库。计算机病毒：杀毒！","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[],"author":"aoyuehan"},{"title":"蓝桥省赛模拟赛","slug":"蓝桥省赛模拟赛","date":"2020-04-19T07:46:00.000Z","updated":"2022-02-26T03:52:52.062Z","comments":true,"path":"2020/04/19/蓝桥省赛模拟赛/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/19/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B%E6%A8%A1%E6%8B%9F%E8%B5%9B/","excerpt":"","text":"第一题问题描述 由1对括号，可以组成一种合法括号序列：()。 由2对括号，可以组成两种合法括号序列：()()、(())。 由4对括号组成的合法括号序列一共有多少种？ 如果手算的话，三个的情况有（）（）（）、（（））（）、（）（（））、（（（）））、（（）（））五种，那么四个的合法括号的形式就是在三个的基础上再加一个括号，可以把（）三个括号、三个括号（）、（三个括号在里面）、在三个括号的里面插入一个括号的方式的到四个括号的合法方式。 括号生成 - 力扣 123456789101112131415161718192021package 省模拟赛;public class 合法括号有多少种 &#123; //14种 public static int count=0,n=4; public static void main(String[] args) &#123; f(0,0); System.out.println(count); &#125; public static void f(int left,int right)&#123; if(left==n )&#123; count++; return; &#125; f(left+1,right); if(left&gt;right)&#123; f(left,right+1); &#125; &#125;&#125; 2 ３ 4一个包含有2019个结点的无向连通图，最少包含多少条边？一个有n个顶点的无向连通图最多有n（n-1）&#x2F;2条边，最少有n-1条边 凯撒加密 123456789101112131415#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int maxn=110;int main()&#123; char a[maxn]; cin&gt;&gt;a; for(int i=0;i&lt;strlen(a);i++)&#123; a[i]=char(a[i]+3) ; &#125; for(int i=0;i&lt;strlen(a);i++)cout&lt;&lt;a[i]; cout&lt;&lt;endl; return 0;&#125; 求反倍数 12345678910111213141516#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int ans=0; int main()&#123; int n,a,b,c; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c; for(int i=1;i&lt;=n;i++)&#123; if(i%a&amp;&amp;i%b&amp;&amp;i%c)&#123; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 7 螺旋矩阵 1234567891011121314151617181920212223242526import java.util.Scanner;public class _007&#123; static int [][] array = new int [1000][1000]; //定义数组及大小 public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); //行数 int m = sc.nextInt(); //列数 int r1 = sc.nextInt(); int c1 = sc.nextInt(); int num = 0; int r = 1,c = 0; while(num != n * m) &#123; while(c &lt; m &amp;&amp; array[r][c+1] == 0) array[r][++c] = ++ num; while(r &lt; n &amp;&amp; array[r+1][c] == 0) array[++r][c] = ++ num; while(c &gt; 1 &amp;&amp; array[r][c-1] == 0) array[r][--c] = ++ num; while(r &gt; 1 &amp;&amp; array[r-1][c] == 0) array[--r][c] = ++ num; &#125; System.out.println(array[r1][c1]); &#125;&#125; 问题描述 如果一个序列的奇数项都比前一项大，偶数项都比前一项小，则称为一个摆动序列。即 a[2i]&lt;a[2i-1], a[2i+1]&gt;a[2i]。 小明想知道，长度为 m，每个数都是 1 到 n 之间的正整数的摆动序列一共有多少个。输入格式 输入一行包含两个整数 m，n。输出格式 输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。样例输入3 4样例输出14样例说明 以下是符合要求的摆动序列： 2 1 2 2 1 3 2 1 4 3 1 2 3 1 3 3 1 4 3 2 3 3 2 4 4 1 2 4 1 3 4 1 4 4 2 3 4 2 4 4 3 4评测用例规模与约定 对于 20% 的评测用例，1 &lt;&#x3D; n, m &lt;&#x3D; 5； 对于 50% 的评测用例，1 &lt;&#x3D; n, m &lt;&#x3D; 10； 对于 80% 的评测用例，1 &lt;&#x3D; n, m &lt;&#x3D; 100； 对于所有评测用例，1 &lt;&#x3D; n, m &lt;&#x3D; 1000。 1 https://blog.csdn.net/qq_43422111/article/details/105489177 最小生成树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;struct node &#123; double x,y,h;&#125; a[10000],b[100000];struct data &#123; double sum; long long item; friend bool operator &lt;(data a,data b) &#123; return a.sum&gt;b.sum; &#125;&#125; d;long long a1[1000000];priority_queue&lt;data &gt; q;int main() &#123; long long n; cin&gt;&gt;n; for(long long i=0; i&lt;n; i++) &#123; scanf(&quot;%lf%lf%lf&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].h); &#125; a1[0]=1; long long t=0; b[t]=a[0]; t++; double sum=0; while(t&lt;n) &#123; for(int j=0; j&lt;n; j++) &#123; if(a1[j]==0) &#123; double item=sqrt((b[t-1].x-a[j].x)*(b[t-1].x-a[j].x)+(b[t-1].y-a[j].y)*(b[t-1].y-a[j].y))+(b[t-1].h-a[j].h)*(b[t-1].h-a[j].h); d.item=j; d.sum=item; q.push(d); &#125; &#125; while(!q.empty()&amp;&amp;a1[q.top().item])q.pop(); if(!q.empty()) &#123; a1[q.top().item]=1; sum+=q.top().sum; b[t++]=a[q.top().item]; q.pop(); &#125; //while(!q.empty()&amp;&amp;a1[q.top().item])q.pop(); 不能放到地方 &#125; printf(&quot;%.2f&quot;,sum); return 0;&#125; 小小明植树","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[],"author":"aoyuehan"},{"title":"蓝桥省赛2013","slug":"蓝桥省赛2013","date":"2020-04-18T13:46:00.000Z","updated":"2022-02-26T03:52:51.017Z","comments":true,"path":"2020/04/18/蓝桥省赛2013/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/18/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B2013/","excerpt":"","text":"1 高斯日记2 马虎的算式3 第39级台阶4 黄金连分数5 前缀判断6 三部排序7 错误票据8 翻硬币9 带分数10 连号区间数11 总结题目标题: 高斯日记 数学家高斯有个好习惯：无论如何都要记日记。他的日记有个与众不同的地方，他从不注明年月日，而是用一个整数代替，比如：4210后来人们知道，那个整数就是日期，它表示那一天是高斯出生后的第几天。这或许也是个好习惯，它时时刻刻提醒着主人：日子又过去一天，还有多少时光可以用于浪费呢？高斯出生于：1777年4月30日。在高斯发现的一个重要定理的日记上标注着：5343，因此可算出那天是：1791年12月15日。高斯获得博士学位的那天日记上标着：8113请你算出高斯获得博士学位的年月日。提交答案的格式是：yyyy-mm-dd, 例如：1980-03-21请严格按照格式，通过浏览器提交答案。注意：只提交这个日期，不要写其它附加内容，比如：说明性的文字。 每连续四年里一定有一个闰年。这句话是错误的。遇到后两位是0的年份，必须被400整除才是闰年，否则不是。如1900年就不是闰年。从1896年到1904年，相隔8年才是闰年。 method1: 这一题也可以用excel来算相隔的天数，比算法更好实现 method2: 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;bool isLeapYear(int y) &#123; return (y % 4 == 0 &amp;&amp; y % 100 != 0) || (y % 400 == 0);&#125;int main(int argc, const char *argv[]) &#123; int y = 1777; int m = 4; int d = 30; for (int i = 0; i &lt; 8113; ++i) &#123; d++; if (m == 12 &amp;&amp; d == 32) &#123; //实现日历的翻转（就是到了一年的12月31号，就把日历翻到1月1号） y++; m = 1; d = 1; continue; &#125; if ((m == 1 || m == 3 || m == 5 || m == 7 || m == 8 || m == 10) &amp;&amp; d == 32) &#123; m++; d = 1; continue; &#125; if ((m == 4 || m == 6 || m == 9 || m == 11) &amp;&amp; d == 31) &#123; m++; d = 1; continue; &#125; if (m == 2 &amp;&amp; isLeapYear(y) &amp;&amp; d == 30) &#123; m++; d = 1; continue; &#125; if (m == 2 &amp;&amp; !isLeapYear(y) &amp;&amp; d == 29) &#123; m++; d = 1; continue; &#125; &#125; cout &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl; return 0;&#125; 标题: 马虎的算式小明是个急性子，上小学的时候经常把老师写在黑板上的题目抄错了。有一次，老师出的题目是：36 x 495 &#x3D; ?他却给抄成了：396 x 45 &#x3D; ?但结果却很戏剧性，他的答案竟然是对的！！因为 36 × 495 &#x3D; 396 × 45 &#x3D; 17820类似这样的巧合情况可能还有很多，比如：27 × 594 &#x3D; 297 × 54假设 a b c d e 代表1~9不同的5个数字（注意是各不相同的数字，且不含0）能满足形如： ab × cde &#x3D; adb * ce 这样的算式一共有多少种呢？请你利用计算机的优势寻找所有的可能，并回答不同算式的种类数。满足乘法交换律的算式计为不同的种类，所以答案肯定是个偶数。答案直接通过浏览器提交。注意：只提交一个表示最终统计种类数的数字，不要提交解答过程或其它多余的内容。 1234567891011121314151617181920212223242526272829303132//简单枚举#include &lt;iostream&gt;using namespace std;//枚举每个a,b,c,d,e各不相同的值，从而来计算最终结果int main(int argc, const char *argv[]) &#123; int ans=0; for (int a = 1; a &lt; 10; ++a) &#123; for (int b = 1; b &lt; 10; ++b) &#123; if (b != a) for (int c = 1; c &lt; 10; ++c) &#123; if (c != a &amp;&amp; c != b) for (int d = 1; d &lt; 10; ++d) &#123; if (d != a &amp;&amp; d != b &amp;&amp; d != c) for (int e = 1; e &lt; 10; ++e) &#123; if (e != a &amp;&amp; e != b &amp;&amp; e != c &amp;&amp; e != d) &#123;// ab * cde = adb * ce if ((a*10+b)*(c*100+d*10+e)==(a*100+d*10+b)*(c*10+e)) &#123; printf (&quot;(%d*10+%d)*(%d*100+%d*10+%d)==(%d*100+%d*10+%d)*(%d*10+%d)==%d\\n&quot;,a,b,c,d,e,a,d,b,c,e,(a*10+b)*(c*100+d*10+e)); ans++; &#125; &#125; &#125; &#125; &#125; &#125; &#125; printf(&quot;%d&quot;,ans); return 0;&#125; 题目标题: 第39级台阶 小明刚刚看完电影《第39级台阶》，离开电影院的时候，他数了数礼堂前的台阶数，恰好是39级!站在台阶前，他突然又想着一个问题：如果我每一步只能迈上1个或2个台阶。先迈左脚，然后左右交替，最后一步是迈右脚，也就是说一共要走偶数步。那么，上完39级台阶，有多少种不同的上法呢？请你利用计算机的优势，帮助小明寻找答案。要求提交的是一个整数。注意：不要提交解答过程，或其它的辅助说明文字。&#x2F;&#x2F;去掉一个条件：偶数步，只问只能迈上1个或2个台阶的条件下一共有多少种走法呢？&#x2F;&#x2F;f(n&#x3D;39){return f(n-1)+f(n-2)} 母题就是斐波那锲数列 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int ans;/** * * @param n 剩下的阶梯数 * @param step 已走的步数 */void f(int n, int step) &#123; if (n &lt; 0) return; if (n == 0 &amp;&amp; step % 2 == 0)&#123; ans++; ／／结果累加时是有条件的 return; &#125; f(n - 1, step + 1); f(n - 2, step + 1);&#125;int main(int argc, const char *argv[]) &#123; f(39, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 标题: 黄金连分数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162 黄金分割数0.61803... 是个无理数，这个常数十分重要，在许多工程问题中会出现。有时需要把这个数字求得很精确。 对于某些精密工程，常数的精度很重要。也许你听说过哈勃太空望远镜，它首次升空后就发现了一处人工加工错误， 对那样一个庞然大物，其实只是镜面加工时有比头发丝还细许多倍的一处错误而已，却使它成了“近视眼”!! 言归正传，我们如何求得黄金分割数的尽可能精确的值呢？有许多方法。 比较简单的一种是用连分数： 1 黄金数 = --------------------- 1 1 + ----------------- 1 1 + ------------- 1 1 + --------- 1 + ... 这个连分数计算的“层数”越多，它的值越接近黄金分割数。 请你利用这一特性，求出黄金分割数的足够精确值，要求四舍五入到小数点后100位（此时double是不能表示出来的）。 小数点后3位的值为：0.618 小数点后4位的值为：0.6180 小数点后5位的值为：0.61803 小数点后7位的值为：0.6180340 （注意尾部的0，不能忽略） 你的任务是：写出精确到小数点后100位精度的黄金分割值。 注意：尾数的四舍五入！ 尾数是0也要保留！ 显然答案是一个小数，其小数点后有100位数字，请通过浏览器直接提交该数字。 注意：不要提交解答过程，或其它辅助说明类的内容。 *//*1、转为求斐波那契数列的n和n+1项，否则栈会溢出 * 2、n取多少？再增加n，小数点后的101位没有变化 * 3、不能用c语言定义的整数型直接运算，而要手工地写大数加法和除法（减法） * 4、如果是填空，可以用java的大数运算来算出来提交 * 5、这一题的性价比比较低，所以做题顺序上可以调整，而且要这小数后100位是稳定之后的数字 */ #include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;using namespace std;int n = 400;void i2s(int num, string &amp;str) &#123; stringstream ss; ss &lt;&lt; num; ss &gt;&gt; str;&#125;string add(string a, string b) &#123; a = a.substr(a.find_first_not_of(&#x27;0&#x27;)); b = b.substr(b.find_first_not_of(&#x27;0&#x27;)); long long lenA = a.length(); long long lenB = b.length(); long long len = max(lenA, lenB) + 10; //+10的原因是因为最后a，b的长度相等，那么就要进位//翻转，便于从低位逐步求和 reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); string ans(len, &#x27;0&#x27;);//初始化答案为len长，全部为字符0// 把a拷贝到ans中 for (int i = 0; i &lt; lenA; ++i) &#123; ans[i] = a[i]; &#125; int tmp = 0;//tmp是上一位相加后的进位 for (int i = 0; i &lt; len; ++i) &#123; if (i &lt; b.length()) tmp += (ans[i] - &#x27;0&#x27;) + (b[i] - &#x27;0&#x27;);//假设为18 else tmp += (ans[i] - &#x27;0&#x27;); ans[i] = tmp % 10 + &#x27;0&#x27;;//8 8+&#x27;0&#x27; tmp /= 10;//1 &#125; reverse(ans.begin(), ans.end()); return ans.substr(ans.find_first_not_of(&#x27;0&#x27;));&#125;int cmp(string a, string b) &#123; unsigned long i1 = a.find_first_not_of(&#x27;0&#x27;); if (i1 == string::npos)a = &#x27;0&#x27;; else a.substr(i1); unsigned long i2 = b.find_first_not_of(&#x27;0&#x27;); if (i2 == string::npos)b = &#x27;0&#x27;; else b.substr(i2); if (a.length() &gt; b.length())return 1; else if (a.length() &lt; b.length())return -1; else &#123;//长度相等 if (a &lt; b)return -1; if (a &gt; b)return 1; else return 0; &#125;&#125;//此处，a一定大于等于bstring subtract(string a, string b) &#123;// 完整的减法里面，a可以小于b，这时结果为负数，交换ab进行下面的代码// 1.翻转 reverse(a.begin(), a.end()); reverse(b.begin(), b.end());// 2.按位做减法 for (int i = 0; i &lt; b.length(); ++i) &#123; if (a[i] &gt;= b[i]) &#123; a[i] = a[i] - b[i] + &#x27;0&#x27;; //一定要加上&#x27;0&#x27;这样才是字符，否则是不能加上的 &#125; else &#123;//就要借 int k = 1; while (a[i + k] == &#x27;0&#x27;) &#123; a[i + k] = &#x27;9&#x27;; k++; &#125;// 这里可以保证i+k这一位上不是0 a[i + k] = a[i + k] - &#x27;1&#x27; + &#x27;0&#x27;; a[i] = (a[i] - &#x27;0&#x27; + 10) - (b[i] - &#x27;0&#x27;) + &#x27;0&#x27;; &#125; &#125; reverse(a.begin(), a.end()); if (a.find_first_not_of(&#x27;0&#x27;) == string::npos)return &quot;0&quot;; return a.substr(a.find_first_not_of(&#x27;0&#x27;));&#125;/*转换成减法*/string divide(string a, string b) &#123;// 只考虑a&lt;b的情况 string ans = &quot;0.&quot;;// 转化成减法 for (int i = 0; i &lt; 101; ++i) &#123;//101次 a.append(&quot;0&quot;); int t = 0; while (cmp(a, b) &gt;= 0) &#123;//a&gt;=b a = subtract(a, b);//不停地做减法 t++;//记录减法做了多少次 &#125; string t_str; i2s(t, t_str); ans.append(t_str); &#125; return ans;&#125;int main(int argc, const char *argv[]) &#123; string a = &quot;1&quot;; string b = &quot;1&quot;; cout &lt;&lt; subtract(a, b) &lt;&lt; endl; for (int i = 3; i &lt;= n; ++i) &#123; string tmp = b; b = add(a, b); a = tmp;// cout &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; endl; &#125;// a b是斐波那契的n-1和n项 string ans = divide(a, b); cout &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; ans.length()-2 &lt;&lt; endl; return 0;&#125; 题目标题：前缀判断 如下的代码判断 needle_start指向的串是否为haystack_start指向的串的前缀，如不是，则返回NULL。 比如：”abcd1234” 就包含了 “abc” 为前缀 char* prefix(char* haystack_start, char* needle_start) { char* haystack &#x3D; haystack_start; char* needle &#x3D; needle_start; while(*haystack &amp;&amp; *needle){ if(______________________________) return NULL; &#x2F;&#x2F;填空位置 } if(*needle) return NULL; return haystack_start; } 请分析代码逻辑，并推测划线处的代码，通过网页提交。 注意：仅把缺少的代码作为答案，千万不要填写多余的代码、符号或说明文字！！ 123456789101112131415161718192021222324252627282930程序填空题就把给出的代码复制到dev中，然后添加头文件，命名空间，运行，补充逻辑。 */#include &lt;iostream&gt;using namespace std;/** * * @param haystack_start 母串 * @param needle_start 前缀 * @return */char *prefix(char *haystack_start, char *needle_start) &#123; char *haystack = haystack_start; char *needle = needle_start;//前缀 while (*haystack &amp;&amp; *needle) &#123;//两个指针都没有越界// if(______________________________) return NULL; //填空位置//移动指针//并判断 if (*(haystack++) != *(needle++))return NULL; &#125; if (*needle) return NULL; return haystack_start;&#125;int main(int argc, const char *argv[]) &#123; cout &lt;&lt; prefix(&quot;abcd123&quot;, &quot;abd&quot;) &lt;&lt; endl; return 0;&#125; 标题：三部排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 一般的排序有许多经典算法，如快速排序、希尔排序等。 但实际应用时，经常会或多或少有一些特殊的要求。我们没必要套用那些经典算法，可以根据实际情况建立更好的解法。 比如，对一个整型数组中的数字进行分类排序： 使得负数都靠左端，正数都靠右端，0在中部。注意问题的特点是：负数区域和正数区域内并不要求有序。 可以利用这个特点通过1次线性扫描就结束战斗!! 以下的程序实现了该目标。 其中x指向待排序的整型数组，len是数组的长度。void sort3p(int* x, int len)&#123; int mod = 0; int left = 0; int right = len-1; while(mod&lt;=right)&#123; if(x[mod]&lt;0)&#123; int t = x[left]; x[left] = x[mod]; x[mod] = t; left++; mod++; &#125; else if(x[mod]&gt;0)&#123; int t = x[right]; x[right] = x[mod]; x[mod] = t; right--; &#125; else&#123; __________________________; //填空位置 &#125; &#125;&#125; 如果给定数组： 25,18,-2,0,16,-5,33,21,0,19,-16,25,-3,0 则排序后为： -3,-2,-16,-5,0,0,0,21,19,33,25,16,18,25请分析代码逻辑，并推测划线处的代码，通过网页提交注意：仅把缺少的代码作为答案，千万不要填写多余的代码、符号或说明文字！！ */#include &lt;iostream&gt;using namespace std;void sort3p(int* x, int len)&#123; int mod = 0; int left = 0; int right = len-1; while(mod&lt;=right)&#123; if(x[mod]&lt;0)&#123; int t = x[left]; x[left] = x[mod]; x[mod] = t; left++; mod++; &#125; else if(x[mod]&gt;0)&#123; int t = x[right]; x[right] = x[mod]; x[mod] = t; right--; &#125; else&#123;//==0的情况 mod++; &#125; &#125;&#125;int main(int argc, const char * argv[]) &#123; int arr[]=&#123;25,18,-2,0,16,-5,33,21,0,19,-16,25,-3,0&#125;; sort3p(arr,14); for (int i = 0; i &lt; 14; ++i) &#123; cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;; &#125; return 0;&#125; 标题：错误票据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 某涉密单位下发了某种票据，并要在年终全部收回。 每张票据有唯一的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。 因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。 你的任务是通过编程，找出断号的ID和重号的ID。 假设断号不可能发生在最大和最小号。 要求程序首先输入一个整数N(N&lt;100)表示后面数据行数。 接着读入N行数据。 每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000） 每个整数代表一个ID号。 要求程序输出1行，含两个整数m n，用空格分隔。 其中，m表示断号ID，n表示重号ID ***这题中那个m，n的顺序是不能调换的*** 例如： 用户输入（*****这种输入就是每一行的输入个数不确定，让你读取数据所用的方法******）：25 6 8 11 910 12 9 则程序输出： 7 9 再例如： 用户输入：6164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196172 189 127 107 112 192 103 131 133 169 158128 102 110 148 139 157 140 195 197185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119 则程序输出： 105 120 资源约定： 峰值内存消耗 &lt; 64M CPU消耗 &lt; 1000ms 请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。 所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。 注意: main函数需要返回0 注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。 注意: 所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;， 不能通过工程设置而省略常用头文件。 注意:现在的计算机的计算速度是一秒钟10^8次，所以本题要求在1s中计算出结果，而这一题是跑10000个数据，时间复杂度为O(1)。 提交时，注意选择所期望的编译器类型。 *//*原始数据连续，输入的时候是乱序的，求出断开的号码和重复的号码*/#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;using namespace std;const int MaxN = 10000;int line;int data[MaxN];void s2i(string &amp;str, int &amp;num) &#123;//s2i是str to int的意思 stringstream ss; //stringstream可以从string对象中读入和输出 ss &lt;&lt; str; ss &gt;&gt; num; //这样可以实现string转为int类型&#125;int main(int argc, const char *argv[]) &#123; scanf(&quot;%d&quot;, &amp;line); getchar(); int index = 0; for (int i = 0; i &lt; line; ++i) &#123; string s; getline(cin, s); istringstream iss(s); //从string对象中读取到iss中 string tmp; while (getline(iss, tmp, &#x27; &#x27;)) &#123; s2i(tmp, data[index++]); &#125; /* 其中while循环也可以这么写 while(iss&gt;&gt;tmp)&#123; s2i(tmp, data[index++]); &#125; */ &#125;// 最终index就是数据的个数// cout &lt;&lt; index &lt;&lt; endl;//排序 sort(data, data + index); int a, b; for (int i = 1; i &lt; index; ++i) &#123; if (data[i] == data[i - 1] + 2)a = data[i] - 1;//printf(&quot;%d &quot;, data[i] - 1); if (data[i] == data[i - 1]) b = data[i];//printf(&quot;%d&quot;, data[i]); &#125; printf(&quot;%d %d&quot;, a, b); return 0;&#125; 其中补充一下sstring类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt; #include &lt;sstream&gt; //用到stringstream时必须引入的头文件using namespace std; int main() &#123; istringstream istr(&quot;1 56.7&quot;); //str()：使istringstream对象返回一个string字符串 cout&lt;&lt;istr.str()&lt;&lt;endl;//直接输出字符串的数据 &quot;1 56.7&quot; string str = istr.str();//函数str()返回一个字符串 cout&lt;&lt;str&lt;&lt;endl; int n; double d; //以空格为界，把istringstream中数据取出，应进行类型转换 istr&gt;&gt;n;//第一个数为整型数据，输出1 istr&gt;&gt;d;//第二个数位浮点数，输出56.7 //假设换下存储类型 istr&gt;&gt;d;//istringstream第一个数要自动变成浮点型，输出仍为1 istr&gt;&gt;n;//istringstream第二个数要自动变成整型，有数字的阶段，输出为56 //测试输出 cout&lt;&lt;d&lt;&lt;endl; cout&lt;&lt;n&lt;&lt;endl; system(&quot;pause&quot;); return 1; &#125; /*字符串变基本数据类型*/ #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;sstream&gt; using namespace std; int main() &#123; /*字符串 变 double*/ double n; string str = &quot;12.5&quot;; stringstream stream; stream &lt;&lt; str; stream &gt;&gt; n; cout&lt;&lt;n&lt;&lt;endl; stream.clear();//多次使用stringstream，要先清空下,不能使用stream.str(&quot;&quot;);,claer()它并不清空任何内容，它只是重置了流的状态标志而已 /*string 变 char* */ string str1 = &quot;china&quot;; char cStr[10]; stream &lt;&lt; str1; stream &gt;&gt; cStr; cout&lt;&lt;cStr&lt;&lt;endl;//输出china system(&quot;pause&quot;); return 1; &#125; 题目标题：翻硬币 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167有最字那么就要找最大最小， 搜索 ：深搜（递归，能显示路径），宽搜（队列，寻找状态变化的次数），枚举 动态规划 贪心 闭式（直接通过某种公式直接得出结果，如这一题答案为那个下标的差） 小明正在玩一个“翻硬币”的游戏。 桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。 比如，可能情形是：**oo***oooo 如果同时翻转左边的两个硬币，则变为：oooo***oooo 现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面， 最少要翻动多少次呢？ 我们约定：把翻动相邻的两个硬币叫做一步操作，那么要求：程序输入：两行等长的字符串，分别表示初始状态和要达到的目标状态。每行的长度&lt;1000程序输出：一个整数，表示最小操作步数例如：用户输入：**********o****o****程序应该输出：5再例如：用户输入：*o**o***o****o***o**o***程序应该输出：1资源约定：峰值内存消耗 &lt; 64MCPU消耗 &lt; 1000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。 */ //***这一题中没有说不能翻出来的那种情况输出什么，所以这样情况就不用考虑****//method1（闭式，即发现了这样一个规律，就可以很简单的解除答案了）：#include &lt;iostream&gt;using namespace std;int main(int argc, const char *argv[]) &#123; string src; string target; getline(cin, src); getline(cin, target); int n = src.length(); int ans=0; int start=-1; for (int i = 0; i &lt; n; ++i) &#123; if(src[i]!=target[i])&#123; if(start==-1) //还没标记第一个位置（**这种情况一定要考虑到**） &#123; start=i; &#125;else //第一个位置已经标记,现在已经找到了第二个位置 &#123; ans+=(i-start); //ans这地方要不要+1或者-1，那就要画一个实例来试一下就知道了 start=-1; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; method2(bfs):#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;using namespace std;typedef struct stateAndLevel &#123; string str; int level;&#125; stateAndLevel;queue&lt;stateAndLevel&gt; queue1;set&lt;string&gt; set1;int n;int main(int argc, const char *argv[]) &#123; string src; string target; getline(cin, src); getline(cin, target); n = src.length(); stateAndLevel first = &#123;src, 0&#125;; queue1.push(first);//队列的第一个元素就是原串 while (!queue1.empty()) &#123; //获取并弹出队列首部 stateAndLevel &amp;front = queue1.front(); queue1.pop(); string basicString = front.str;// 如果队首元素和目标一致，可以终止程序 if (basicString.compare(target) == 0) &#123; cout &lt;&lt; front.level &lt;&lt; endl;//输出层次，也就是变化多少次到达了这个状态 return 0; &#125;// 把已经处理过的字符串加入set中备查，避免往回翻的状态重复加入 set1.insert(basicString);// 模拟，依次翻转后加入队列中 for (int i = 0; i &lt; n - 1; ++i) &#123; string buff; buff.insert(0, basicString);// 拷贝之后，翻转i和i+1两个位置的字符 if (buff[i] == &#x27;*&#x27;) buff[i] = &#x27;o&#x27;; else buff[i] = &#x27;*&#x27;; if (buff[i + 1] == &#x27;o&#x27;) buff[i + 1] = &#x27;*&#x27;; else buff[i + 1] = &#x27;o&#x27;;// string s(buff);//字符数组转字符串 if (set1.find(buff) == set1.end()) &#123; stateAndLevel obj = &#123;buff, front.level + 1&#125;; queue1.push(obj); &#125; &#125;// cout &lt;&lt; queue1.size() &lt;&lt; endl; &#125;// cout &lt;&lt; src &lt;&lt; &quot;\\n&quot; &lt;&lt; target &lt;&lt; endl; return 0;&#125;method3：其实只要遇到一个不相同的时候一定是要翻转的#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;string s1,s2;int p1[1005],p2[1005];int ans=0;int main()&#123; cin&gt;&gt;s1&gt;&gt;s2; //输入数据处理 for(int i=0 ;i&lt;s1.length(); i++)&#123; if(s1[i]==&#x27;*&#x27;)p1[i]=1; if(s1[i]==&#x27;o&#x27;)p1[i]=-1; if(s2[i]==&#x27;*&#x27;)p2[i]=1; if(s2[i]==&#x27;o&#x27;)p2[i]=-1; &#125; //进行翻转操作 for(int i=0 ;i&lt;s1.length()-1 ;i++)&#123; if(p1[i]!=p2[i])&#123; ans++; p1[i] = -p1[i]; p1[i+1] = -p1[i+1]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 标题：带分数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 100 可以表示为带分数的形式：100 = 3 + 69258 / 714 (3,这地方的数是1~n-1) 还可以表示为：100 = 82 + 3546 / 197 注意特征：带分数中，数字1~9分别出现且只出现一次（不包含0）。 类似这样的带分数，100 有 11 种表示法。题目要求：从标准输入读入一个正整数N (N&lt;1000*1000)程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。注意：不要求输出每个表示，只统计有多少表示法！例如：用户输入：100程序输出：11再例如：用户输入：105程序输出：6资源约定：峰值内存消耗 &lt; 64MCPU消耗 &lt; 3000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。 *///生成1~9这9个数字的全排列，先在可能的位置插入+，再在可能的位置插入/，验算等式，计数#include &lt;iostream&gt;#include &lt;cstdlib&gt; //包含函数atoi()#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;//这个函数是用来截取字符串，转换为int类型的数字的int parse(const char *arr, int pos, int len) &#123; int ans = 0; int t = 1; for (int i = pos + len - 1; i &gt;= pos; --i) &#123; //注意i = pos + len - 1，此时i指向数字的最低位，如12345，此时i指向5；就是注意数组的下标和存数数据的对应关系 ans += (arr[i] - &#x27;0&#x27;) * t; t *= 10; &#125; return ans;&#125;int main(int argc, const char *argv[]) &#123; int n, ans = 0; scanf(&quot;%d&quot;, &amp;n); std::string s = &quot;123456789&quot;; //这里用一个全排列就可以解决互不相同的问题，如果用for和if来判断互不相同就麻烦很多 do &#123; const char *str = s.c_str(); for (int i = 1; i &lt;= 7; ++i) &#123;//+号前的串的长度 int inta = parse(str, 0, i); if (inta &gt;= n)break; for (int j = 1; j &lt;= 9 - i - 1; ++j) &#123;//+/两个符号之间的串的长度 /*不能反复substr函数，会很耗费时间，耗费的不是常数时间 string b = s.substr(i, j); //这是+和/之间的串 string c = s.substr(i + j); //这是/后面的串 int intb = atoi(b.c_str()); int intc = atoi(c.c_str()); */ int intb = parse(str, i, j); int intc = parse(str, i + j, 9 - i - j); if (intb % intc == 0 &amp;&amp; inta + intb / intc == n)ans++; &#125; &#125; &#125; while (std::next_permutation(s.begin(), s.end())); printf(&quot;%d\\n&quot;, ans); return 0;&#125; 小知识：c++中的atoi()和stoi()函数的用法和区别 相同点： ①都是C++的字符处理函数，把数字字符串转换成int输出 ②头文件都是#include 不同点： ①**atoi()的参数是 const char× ,因此对于一个字符串str我们必须调用 c_str()的方法把这个string转换成 const char×类型的,而stoi()的参数是const string×,不需要转化为const char×； ** ②stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error！而atoi()不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界； 标题：连号区间数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 小明这些天一直在思考这样一个奇怪而有趣的问题： 在1~N的某个全排列中有多少个连号区间呢？这里所说的连号区间的定义是： 如果区间[L, R] 里的所有元素（即此排列的第L个到第R个元素）递增排序后能得到一个长度为R-L+1的“连续”数列， 则称这个区间连号区间。 当N很小的时候，小明可以很快地算出答案，但是当N变大的时候，问题就不是那么简单了，现在小明需要你的帮助。输入格式：第一行是一个正整数N (1 &lt;= N &lt;= 50000), 表示全排列的规模。第二行是N个不同的数字Pi(1 &lt;= Pi &lt;= N)， 表示这N个数字的某一全排列。输出格式：输出一个整数，表示不同连号区间的数目。示例：用户输入：43 2 4 1程序应输出：7用户输入：53 4 2 5 1程序应输出：9解释：第一个用例中，有7个连号区间分别是：[1,1], [1,2], [1,3], [1,4], [2,2], [3,3], [4,4]第二个用例中，有9个连号区间分别是：[1,1], [1,2], [1,3], [1,4], [1,5], [2,2], [3,3], [4,4], [5,5]资源约定：峰值内存消耗 &lt; 64MCPU消耗 &lt; 5000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。 */#include &lt;iostream&gt;using namespace std;int n;int arr[50000];int ans;int main(int argc, const char *argv[]) &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;, &amp;arr[i]); &#125; for (int j = 0; j &lt;= n - 1; ++j) &#123; int min=arr[j]; int max = arr[j]; for (int i = j; i &lt;= n - 1; ++i) &#123; //这种搜索要用这样两个for循环来实现，其中max和min要更新，然后要在判断连号的时候用 if(arr[i]&gt;max) max=arr[i]; if(arr[i]&lt;min) min=arr[i]; if (i == j) ans++; else &#123; if(max-min+1==i-j+1) ans++; //j-i形成连号区间 &#125; &#125; &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125; 总结 01 高斯日记 手算&#x2F;excel&#x2F;编程（枚举，模拟翻日历） 第一天 02 马虎的算式 枚举+check（这个不是全排列） 03 第39级台阶 普通走台阶的变体–递归思维（斐波那契变题） ***04 黄金连分数 黄金分割与斐波那契，大数加法，大数除法（减法） n取多少，100位的小数才稳定呢 05 前缀判断 c语言字符串处理，比对+偏移 06 三部排序 快速排序的变体 单指针 双指针 三指针 07 错误票据 排序+遍历 *08 翻硬币 找规律 ***09 带分数 全排列+字符串的切割（这一题要是用递归就完蛋了） 全排列+字符转整数——坑很大 10 连号区间数 简单枚举","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[],"author":"aoyuehan"},{"title":"Preliminaries for Benelux Algorithm  Contest 2018","slug":"Preliminaries-for-Benelux-Algorithm-Contest-2018","date":"2020-04-18T08:32:00.000Z","updated":"2022-02-26T03:52:51.238Z","comments":true,"path":"2020/04/18/Preliminaries-for-Benelux-Algorithm-Contest-2018/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/18/Preliminaries-for-Benelux-Algorithm-Contest-2018/","excerpt":"","text":"Appalling Architecture 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int h, w; cin &gt;&gt; h &gt;&gt; w; vector&lt;string&gt; picture(h); double avg_x = 0; int mass = 0; for(int y = 0; y &lt; h; y++) &#123; cin &gt;&gt; picture[y]; for(int x = 0; x &lt; w; x++) &#123; if(picture[y][x] != &#x27;.&#x27;) &#123; avg_x += x; mass++; &#125; &#125; &#125; avg_x /= mass; double base_min_x; for(int x = 0; x &lt; w; x++) &#123; if(picture[h - 1][x] != &#x27;.&#x27;) &#123; base_min_x = x - 0.5; break;//找最后一层最靠左的第一个不是.的那个x值 &#125; &#125; double base_max_x; for(int x = w - 1; x &gt;= 0; x--) &#123; if(picture[h - 1][x] != &#x27;.&#x27;) &#123; base_max_x = x + 0.5; break; //找最后一层最靠右的那个x的值 &#125; &#125; // cerr &lt;&lt; avg_x &lt;&lt; &#x27; &#x27; &lt;&lt; base_min_x &lt;&lt; &#x27; &#x27; &lt;&lt; base_max_x &lt;&lt; endl; if(avg_x &lt; base_min_x) cout &lt;&lt; &quot;left&quot;; else if(avg_x &gt; base_max_x) cout &lt;&lt; &quot;right&quot;; else cout &lt;&lt; &quot;balanced&quot;; cout &lt;&lt; endl;&#125; Bee Problem题目大意：给出一个h表示现在身上的蜂蜜数量，再给出一个蜂巢的结构图，黑色表示已经满了，白色表示是空着的，每个小格子互相都是连通的，我们可以将身上的蜂蜜往小格子中填充，问若要将身上的蜂蜜都填充到蜂巢中，最少需要对几个小格子操作 这一题原来有六个方向，我看到这个图，之后还是按了上下左右四个方向来做了，明明题意都给了六个方向的，而且我自己做完了之后提交不对我也没意识过来是六个方向。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061四个方向的时候的解法（试用四个方向，但是六个方向就不对了）：#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n, m;int ans;const int maxn=1e6+10;int ll[maxn];char grass[1010][1010];int vis[1010][1010];int nx[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;bool in(int x, int y) &#123; return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m;&#125; void dfs(int x, int y) &#123; for (int i = 0; i &lt;= 3; i++) &#123; int nowx = x + nx[i][0]; int nowy = y + nx[i][1]; if (in(nowx, nowy) &amp;&amp; grass[nowx][nowy] == &#x27;.&#x27; &amp;&amp; !vis[nowx][nowy]) &#123; vis[nowx][nowy] = 1; ll[ans-1]++; dfs(nowx, nowy); &#125; &#125;&#125; int nn;int main() &#123; cin&gt;&gt;nn; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; cin &gt;&gt; grass[i][j]; //输入 &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (grass[i][j] == &#x27;.&#x27; &amp;&amp; !vis[i][j]) &#123; ans++; //记录连通块的个数 ll[ans-1]++; //存下这个连通块的个数，这里要注意一下 vis[i][j] = 1; //将这个点变为已访问 dfs(i, j); //从这个点向周围搜索 &#125; &#125; &#125; sort(ll,ll+ans); //连通块数量排序// for(int i=ans-1;i&gt;=0;i--)&#123;// cout&lt;&lt;ll[i]&lt;&lt;&#x27; &#x27;;// &#125; int aans=0; for(int i=ans-1;i&gt;=0;i--)&#123; if(nn&lt;=0)break; nn-=ll[i]; aans++; &#125; cout &lt;&lt; aans&lt;&lt;endl; return 0;&#125; 题目分析： 转换一下，这就是一个让求最大连通块的问题，只不过这个问题有两个方面需要注意一下，第一就是我们需要将所有的连通块都求出来，然后对每个连通块进行降序排序，因为这个题目中的dfs是边搜边更新的，所以每个点至多遍历一次，时间复杂度也就控制在了n*m之内，这样就不用担心递归会超时的问题了，第二个方面就是这个题目中，不像中规中矩的那种矩形一样是上下左右走的，而是每个点有6个方向可以走，而奇数行和偶数行的方向又有那么一点点不同，所以我们一共设置12个方向，分别供奇数行和偶数行的点来使用，这个画个图就能推出来6个节点的编号，这里不赘述了 然后还有一个小坑，就是在输入的时候，题目每个节点之间都有一个空格，十分的恶心人，而且偶数行的开头还会有一个前置空格，我们在输入的时候要记着用getchar读掉，或者可以直接用cin，可以略过空格直接读到符号，cin大法好嗷，还有一点，这个题目多组输入会TLE。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778六个方向时候的解法：#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=1e3+100;char maze[N][N];int ans[N*N];int cnt;int h,n,m;const int b1[6][2]=&#123;0,1,0,-1,1,0,-1,0,-1,-1,1,-1&#125;;//ji const int b2[6][2]=&#123;0,1,0,-1,1,0,-1,0,1,1,-1,1&#125;;//ouint num; void dfs(int x,int y)&#123; num++; maze[x][y]=&#x27;#&#x27;; for(int k=0;k&lt;6;k++) &#123; int xx,yy; if(x&amp;1) &#123; xx=x+b2[k][0]; yy=y+b2[k][1]; &#125; else &#123; xx=x+b1[k][0]; yy=y+b1[k][1]; &#125; if(xx&lt;0||yy&lt;0||xx&gt;=n||yy&gt;=m) continue; if(maze[xx][yy]==&#x27;#&#x27;) continue; dfs(xx,yy); &#125;&#125; bool cmp(int a,int b)&#123; return a&gt;b;&#125; int main()&#123; scanf(&quot;%d%d%d&quot;,&amp;h,&amp;n,&amp;m); cnt=0; getchar(); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) cin&gt;&gt;maze[i][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) &#123; if(maze[i][j]==&#x27;.&#x27;) &#123; num=0; dfs(i,j); ans[cnt++]=num; &#125; &#125; sort(ans,ans+cnt,cmp);// for(int i=0;i&lt;cnt;i++)// cout&lt;&lt;ans[i]&lt;&lt;&#x27; &#x27;;// cout&lt;&lt;endl; int temp=0; int tem=0; int t=0; while(tem&lt;h&amp;&amp;t&lt;cnt) &#123; temp++; tem+=ans[t++]; &#125; cout&lt;&lt;temp&lt;&lt;endl; return 0;&#125; H to O 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;map&lt;char,int&gt;mp; //求给定的串 mp代表这个元素出现的次数 map&lt;char,int&gt;mp1; //求目标串 int main()&#123; int n; string s; cin&gt;&gt;s&gt;&gt;n; for(int i=0;i&lt;s.length();i++)&#123; char a=s[i]; if((a-0)&gt;=65&amp;&amp;(a-0)&lt;=90)&#123; //如果本位是字母 if((s[i+1]-0)&gt;=48&amp;&amp;(s[i+1]-0)&lt;=57)&#123; //本位的下一位是数字 int ii=i+1,cnt=0; //cnt代表从本位开始向后走了多少位 while((s[ii]-0)&gt;=48&amp;&amp;(s[ii]-0)&lt;=57)&#123; ii++;cnt++; //一直走到不是数字的那一位 &#125; int ans=0,quan=1,iii=cnt;ii--; while(cnt--)&#123; ans+=quan*(s[ii]-48); //把h14这种形式中的14计算出来，存到ans中 //cout&lt;&lt;&quot;ans ans:&quot;&lt;&lt;ans&lt;&lt;&quot; quan*(s[ii]-48):&quot;&lt;&lt;(s[ii]-48)&lt;&lt;endl; quan*=10; ii--; &#125; mp[a]+=ans; //添加这一字母出现的次数 i+=iii; //cout&lt;&lt;&quot;cishi cnt:&quot;&lt;&lt;iii&lt;&lt;&quot; mp+ansde ans:&quot;&lt;&lt;ans&lt;&lt;endl; &#125;else&#123; mp[a]++; //如果这一位的下一位不是数字，那么++就好了 &#125; &#125; &#125; for(char i=&#x27;A&#x27;;i&lt;=&#x27;Z&#x27;;i++)&#123; //cout&lt;&lt;mp[i]&lt;&lt; &#x27; &#x27;; mp[i]*=n; &#125; string ss; cin&gt;&gt;ss; //求目标串中字母出现的次数 for(int i=0;i&lt;ss.length();i++)&#123; char a=ss[i]; if((a-0)&gt;=65&amp;&amp;(a-0)&lt;=90)&#123; if((ss[i+1]-0)&gt;=48&amp;&amp;(ss[i+1]-0)&lt;=57)&#123; int ii=i+1,cnt=0; while((ss[ii]-0)&gt;=48&amp;&amp;(ss[ii]-0)&lt;=57)&#123; ii++;cnt++; &#125; int ans=0,quan=1,iii=cnt;ii--; while(cnt--)&#123; ans+=quan*(ss[ii]-48); //cout&lt;&lt;&quot;ans ans:&quot;&lt;&lt;ans&lt;&lt;&quot; quan*(s[ii]-48):&quot;&lt;&lt;(s[ii]-48)&lt;&lt;endl; quan*=10; ii--; &#125; mp1[a]+=ans; i+=iii; //cout&lt;&lt;&quot;cishi cnt:&quot;&lt;&lt;iii&lt;&lt;&quot; mp+ansde ans:&quot;&lt;&lt;ans&lt;&lt;endl; &#125;else&#123; mp1[a]++; &#125; &#125; &#125; int aans=0x3f3f3f3f,tmp=0; for(char i=&#x27;A&#x27;;i&lt;=&#x27;Z&#x27;;i++)&#123; //cout&lt;&lt;mp[i]&lt;&lt; &#x27; &#x27;; if(mp1[i]&gt;0)&#123; //求每个元素能构造目标串的最小的个数 tmp=mp[i]; aans=min(aans,tmp/mp1[i]); &#125; &#125; if(aans==0x3f3f3f3f)cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;aans&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"十大经济学原理","slug":"十大经济学原理","date":"2020-04-16T10:34:00.000Z","updated":"2022-02-26T03:51:21.546Z","comments":true,"path":"2020/04/16/十大经济学原理/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/16/%E5%8D%81%E5%A4%A7%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/","excerpt":"","text":"这是我大学里选的一门经济学通选课，这里总结一下经济学 微观经济学：研究的是经济社会中经济个体的经济行为，阐述经济社会中的经济单位为什么和怎样作出经济决策 。 宏观经济学：以整个国民经济作为研究对象，研究经济总量的决定及其变化规律，包括通货膨胀、失业和经济增长。 国外经济学家把微观经济学的研究对象概括为 三个基本问题：生产什么、怎么生产和为谁生产。 十大经济学原理疫情期间的十大经济学原理 人们如何做出决策 People face tradeoffs. 人们面临权衡取舍 首先要指出的是天下没有免费的午餐 To get one thing, we usually have to give up another thing.为了得到一物,不得不放弃另一物Making decisions requires trading off one goal against another.作决策，要求在两个目标间进行权衡取舍 The cost of something is what you give up to get it.某种东西的成本是为了得到它而放弃的东西 决策就要比较可供选择的行动方案的成本与利益机会成本：使用一种资源的机会成本是指把该资源投入某一特定用途以后，所放弃的在其他用途中所能得到的最大利益（好处）。 Rational people think at the margin.理性人考虑边际量 Rational people(理性人) systematically and purposefully do the best they can to achieve their objectives. 系统而有目的地尽最大努力实现其目标的人 Marginal changes（边际变动） are small, incremental adjustments to a plan of action. 对行动计划的微小增量调整 你准备出售一款1996年的福田野马，并且已经在这辆车的维修上花了$1000。然而,车的变速器坏了，你能够选择再花$600将车修好再出售，或者直接出售。在下面的情形中，你将把变速器修好吗？并解释。A.如果变速器正常，汽车价值是$6500.如果不正常，则是$5700.B.如果变速器正常，汽车价值是$6000.如果不正常，则是$5500这就是一个理性人考虑边际变动的例子。人通过比较边际收益和边际成本来做出决策– 当 边际利益&gt;边际成本,理性决策者采取行为 People respond to incentives.人们会对激励作出反应 An incentive is something that induces a person to act.( a punishment or a reward) 激励是引起一个人做出某种行为的某种东西。 Incentives change costs and benefitsIncentives cause people to alter their behavior 激励使人们改变他们的行动。 人们如何相互影响 贸易能使每个人状况更好 Trade allows people to specialize in what they do best.贸易使每个人可以专门从事自己擅长的活动 By trading with others, people can buy a greater variety of goods and services at lower cost.通过贸易，可以以较低的价格买到更加丰富的商品和劳务 市场通常是组织经济活动的一种好方法 A market economy is an economy that allocates resources through the decentralized decisions of many firms and households as they interact in markets for goods and services.当许多企业和家庭在物品和劳务市场上相互交易时，通过他们的分散决策配置资源的经济。家庭决策：买什么？为谁工作？企业决策：雇佣谁？生产什么？ 家庭和企业在市场上相互交易，它们仿佛被一只“看不见的手”所指引。 买者和卖者的相互交易决定了价格。价格引导着利己的家庭和企业做出决策。并且使社会经 济福利达到最大。 政府有时可以改善市场结果 政府有时可以改善市场结果 如果市场这只“看不见的手”如此伟大，为什么我们还需要政府呢？ Market failure(市场失灵) occurs when the market fails to allocate resources efficiently.当市场不能有效配置资源时会发生市场失灵。 When the market fails (breaks down) government can intervene to promote efficiency and equity.市场失灵时,政府可以干预以提高效率和公平 How the economy as a whole works. (整体经济如何运行) A country’s standard of living depends on its ability to produce goods and services.一国的生活水平取决于它生产物品与劳务的能力 Almost all variations in living standards are explained by differences in countries’ productivities.几乎所有生活水平的差别都可以归因于各国的生产率。Productivity（生产率） is the amount of goods and services produced from each hour of a worker’s time. 生产率是每一单位劳动投入所生产的物品和劳务数量。 生产率取决于设备、劳动者的技能以及技术。 Prices rise when the government prints too much money.当政府发行了过多货币时,物价上升 Inflation is an increase in the overall level of prices in the economy. 通货膨胀是经济中物价总水平的上升 One cause of inflation is the growth in the quantity of money.引发通货膨胀的一个原因就是货币量的增长 When the government creates large quantities of money, the value of the money falls.一国政府发行了大量本国货币时,货币的价值就下降了 Society faces a short-run tradeoff between inflation and unemployment.社会面临通货膨胀与失业之间的短期交替关系 社会面临通货膨胀与失业之间的短期权衡取舍The Phillips Curve（菲利普斯曲线） illustrates the tradeoff between inflation and unemployment:òInflation ð Unemployment It’s a short-run tradeoff! 货币量ð需求ð抬高物价ð多生产ð增加劳动力","categories":[{"name":"上知天文下知地理","slug":"上知天文下知地理","permalink":"https://zouyunkai.github.io/myblog/categories/%E4%B8%8A%E7%9F%A5%E5%A4%A9%E6%96%87%E4%B8%8B%E7%9F%A5%E5%9C%B0%E7%90%86/"}],"tags":[],"author":"aoyuehan"},{"title":"经济学原理报告","slug":"经济学原理报告","date":"2020-04-16T10:31:00.000Z","updated":"2022-02-26T04:43:14.152Z","comments":true,"path":"2020/04/16/经济学原理报告/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/16/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E6%8A%A5%E5%91%8A/","excerpt":"","text":"疫情期间的经济学原理 什么是经济学呢?对这一概念的界定有各种各样的回答.如经济学探讨生产什么物品，如何生产这些物品和为谁生产这些物品.在名著《经济学》中萨缪尔森写道：“经济学研究社会如何使用稀缺资源来生产有价值的商品,并把它们在不同的人之间进行分配。”我在《管理经济学》一书中从公平与效率、生产与分配的角度出发，指出“经济学是研究如何有效配置经济资源和如何公平分配国民财富，以满足个人或社会目的的一门社会科学。”种种说法归结起来，总离不开这样一种思考，即经济学是使有限的资源被用于最合理的方面以便增加社会总的财富，使社会变得越来越富裕。 经济学作为一种实用性的学科，也是一种分析某种现实现象的工具和方法的存在，随着我国社会的快速发展，经济学与人们的生活联系的越来越紧密。经过这个学期的学习，我对经济学有了深层次的理解，生活中处处是经济学，我们应该把经济学原理应用到生活中，才能发挥它的作用。 我在课后还读了《生活中的经济学》这本书，茅于轼先生用“家常式”的随笔形式，运用简单易懂的经济学知识，巧妙地解释了社会生活中的各种经济现象。书中讲到一个洗衣粉的例子，过去的洗衣粉多半是含磷的化合物，这种洗衣粉透过下水道最终排向河道或海域，使水变得混浊。磷是植物生长的肥料，水草和藻类因获得此种营养而超多繁殖。这些水生植物死亡后吸收水中的氧分而腐烂变质，其后果是水果氧分减少使鱼类死亡，变质的水发出恶臭。改善后的洗衣粉不含磷，避免了对体的污染。 对于洗衣粉或肥皂是否含磷真没什么体会，也所谓有无，更没什么研究了，只觉得那是商家为了抢眼球的又一穴头罢了。老在抱怨那些一味追求利益的工厂排放不达标的污水，看完这段才明白，里面有这么大的学问，原先我们也在往下水道里放“慢性毒药”。茅先生说：“发展中国家环境政策所走的路线往往是先污染后治理。发达国家批评说，先污染后治理在财务成本上不如预先就采取预防措施，不让污染发生。这样的说法简单从财务上看无疑是对的，但是从经济学来看并不必须正确，因为人穷时的一块钱比富有时的一块钱有更大的价值。人在穷的时候先要顾吃饱饭，顾不上环境的好坏。只有吃饱了饭才有可能去治理环境。”他一针见血的道出了原因的所在，所以在感慨发达国家的环境多么好的同时，也明白了经济基础对上层建筑的制约。我们的国家暂时还不够富裕，短时间内我们不可能从根本上改变我们的环境，也许要到我们的下一代，或者需要更长时间和更多人的努力才能赶上发达国家。而对于选取无磷洗衣粉或肥皂是举手之劳。从小事做起，从我做起，然后告诉我们身边的人，为保护我们的环境大家都行动起来吧！ 疫情期间，我们也见到了许多的经济学 现象，比如：美股熔断，供需关系导致石油下跌，政府发放优惠券等等。 一方面，政府发放优惠券是政府补贴的一种表现形式，政府通过发行“消费券”，带动生产增加，生产增加带动收入增加，收入增加又带动消费增加，重新形成消费回补的良性循环。“消费券”并非是独创，而是相对成熟的做法，作为社会救济的工具，经验也非常成熟。而且在疫情期间，政府通过一系列政策，对口罩的价格进行管控，市场经济也有其局限性，其功能缺陷是固有的，光靠市场自身是难以克服的，完全摒弃政府干预的市场调节会使其缺陷大于优势，导致“市场失灵 ”，因而必须借助凌驾于市场之上的力量——政府这只“看得见的手”来纠补市场失灵。这就是政府为了避免出现市场失灵而采取的手段。2月21日中央政治局召开会议，强调要积极扩大有效需求，促进消费回补和潜力释放，发挥好有效投资关键作用，加大新投资项目开工力度，加快在建项目建设进度。这是政府国家干预的表现，有利于实现定观平衡，保持经济持续、稳定、协调增长，是政府对国民经济的总体管理，这也体现了一个国家政府的经济职能。这也能体现政府有时可以改善市场结果这一经济学原理。 另一方面，疫情期间，政府还调整税收政策来发挥自己的经济职能。2020年第13号公告中 “除湖北省外，其他省、自治区、直辖市的增值税小规模纳税人，适用3%征收率的应税销售收入，减按1%征收率征收增值税”的规定，适用于个体工商户。随着支持疫情防控和经济社会发展税费优惠政策的落地实施，不少纳税人享受到了国家的减税降费福利。在第一节课中，老师讲十大经济学原理的时候讲过理性人这个概念，之后的课程学习中我了解到：理性人是会考虑边际量，经济学中存在一种基本的假设——理性人假设。理性人假设认为，每一个从事经济活动的人都是理性的、利己的。而理性人在参与经济活动过程中遵循最大化原则：以最小的经济代价（付出）去获取最大的经济利益（收获）。 虽然，很多情况下人的经济行为并不会严格遵循该假设，消费的非理性行为随处可见，但并不影响我们思考这一现象。理性人在做决策时，会根据边际成本和边际收益的动态关系进行抉择，当边际收益大于或等于边际成本，则会出现决策的可行性及决策的临界点；若是边际收益小于边际成本，决策者就会用脚投票。如路人甲投资兴建了一座大型超市，好友的孩子表示想进去购物但没有戴口罩，非理想的思考是可以让他进去购物，因为孩子的进入只会带给自己更高的销售业绩，更好的利润，却不会付出更多的成本。然而，当考虑到其他消费者的生命健康权益，及政府和全民为疫情防控所付出的努力时，一个未佩戴口罩的小朋友所创造的边际收益（销售收入）小于其带来的边际成本（疫情风险），这种潜在的边际成本（疫情风险）是个体所无法承受的。基于理性人的思考边际量，因而会拒绝朋友的孩子进入超市。 在疫情期间我明白的另外一个经济学原理：人们会对激励做出反应人们会对激励做出反应，而在这里的激励又可以分为正向激励和负向激励两类。经济学中的激励，通常表现为一系列的奖励或者处罚行为，通过激励措施，诱使一部分经济人（政府、企业、个体）从事特定的行为，从而产生其想达到的结果或产品或者服务。如因当下疫情的防控需要，政府加大对医疗行业的扶持力度，通过价格机制、低息贷款、税收减免、优先保障物资需求等，在政府的特定激励行为加持下，当下的众多企业投入到医疗器械行业，极大地提升了防疫物资的保障能力和供给水平。 任何事情的发生发展都必然符合客观规律，只要满足客观规律基本条件条件，规律必然发挥作用，规律作用的结果必然出现。","categories":[{"name":"上知天文下知地理","slug":"上知天文下知地理","permalink":"https://zouyunkai.github.io/myblog/categories/%E4%B8%8A%E7%9F%A5%E5%A4%A9%E6%96%87%E4%B8%8B%E7%9F%A5%E5%9C%B0%E7%90%86/"}],"tags":[],"author":"aoyuehan"},{"title":"算法设计与分析 第四章 贪心","slug":"算法设计与分析-第四章-贪心","date":"2020-04-16T03:02:00.000Z","updated":"2022-02-26T03:52:52.318Z","comments":true,"path":"2020/04/16/算法设计与分析-第四章-贪心/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/16/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B4%AA%E5%BF%83/","excerpt":"","text":"贪心 概述 活动安排 贪心算法的特点以及和动态规划的比较 部分背包问题就是贪心的一种，0-1背包不能用贪心 最优装载 哈夫曼编码 贪心的正确性证明？？？","categories":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"tags":[],"author":"aoyuehan"},{"title":"训练34 cf 0413","slug":"训练34-cf-0414","date":"2020-04-15T13:23:00.000Z","updated":"2022-02-26T03:52:52.271Z","comments":true,"path":"2020/04/15/训练34-cf-0414/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/15/%E8%AE%AD%E7%BB%8334-cf-0414/","excerpt":"","text":"错排A - Almost Identity Permutations CodeForces - 888D 折半搜索B - Maximum Subsequence CodeForces - 888E n&#x3D;35，（2^17的搜索量可以在1s内得出结果）所以用折半搜索降低搜索的复杂度用两个set存两次搜索的模m下的每个和然后合并，更新最大值。合并的方法是枚举第一个set的值(设为i)，用upper_bound从第二个set中找第一个大于m-1-i的位置，此时的模m最大值应该是 i+[ 这个位置-1的位置上的那个数 ]。 12345678910111213141516171819202122232425262728借鉴csdn 晚樱晚樱 #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef set&lt;ll&gt;::iterator IT;ll n,m,x[40];set&lt;ll&gt;a,b;void dfs(int d,int M,set&lt;ll&gt;&amp;t,ll sum)&#123; if(d==M+1)&#123; if(!t.count(sum%m))t.insert(sum%m); return; &#125; dfs(d+1,M,t,sum); dfs(d+1,M,t,sum+x[d]);&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(ll i=1;i&lt;=n;i++)cin&gt;&gt;x[i],x[i]%=m; dfs(1,n/2,a,0); dfs(n/2+1,n,b,0); IT it; ll ans=0; for(auto i:a)&#123; it=b.upper_bound(m-1-i);it--; ans=max(ans,(i+*it)%m); &#125; cout&lt;&lt;ans;&#125; 介绍关于lower_bound( )和upper_bound( )的常见用法 复数幂 蓝桥设i为虚数单位。对于任意正整数n，(2+3i)^n 的实部和虚部都是整数。求 (2+3i)^123456 等于多少？ 即(2+3i)的123456次幂，这个数字很大，要求精确表示。 答案写成 “实部±虚部i” 的形式，实部和虚部都是整数（不能用科学计数法表示），中间任何地方都不加空格，实部为正时前面不加正号。(2+3i)^2 写成: -5+12i，(2+3i)^5 的写成: 122-597i注意：需要提交的是一个很庞大的复数，不要填写任何多余内容 解析：题目中说提交的是一个很庞大的负数，可以用BigInteger来处理，先将(2+3i)的一次幂拿出来作为保留，幂次每增加1，就再乘一次(2+3i)。 大数BigInteger如果计算的数值量太大，控制台都放不开时，控制台上就不显示了，但是数据确是真实存在的；其实也不是不显示，而是数据量太大，但是如果在控制台Ctrl+A，Ctrl+C复制一下，然后在一个文档中Ctrl+V粘贴，所有的数据就复制出来了。这时候也可以将数据通过打印流或输出流输出到一个txt文档中。 1234567891011121314151617181920212223242526272829303132import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.math.BigInteger; public class 复数幂&#123; public static void main(String[] args) throws FileNotFoundException &#123; PrintWriter out = new PrintWriter( //打印流输出到复幂数.txt中 new OutputStreamWriter(new FileOutputStream(&quot;复幂数.txt&quot;))); BigInteger a = BigInteger.valueOf(2); //相当于(a+bi)*(x+yi) BigInteger b = BigInteger.valueOf(3); //a、b两个值一值不变 BigInteger x = BigInteger.valueOf(2); BigInteger y = BigInteger.valueOf(3); for(int i=2;i&lt;=123456;++i) //每次都是两组数据相乘 &#123; BigInteger t1 = a.multiply(x); // a*x BigInteger t2 = a.multiply(y); //a*y BigInteger t3 = b.multiply(x); //b*x BigInteger t4 = b.multiply(y); //b*y x = t1.subtract(t4); // i^2==-1 ax-by y = t2.add(t3); //bx+ay &#125; //由于数字太长，打印台根本输出不了，即便是输出了，也看不到，所以直接砸在控制台Ctrl+C复制即可，然后粘贴到一个txt文档中 //可以通过输出流或打印流输出到一个文档中即可 out.println(x.toString()+y.toString()+&quot;i&quot;); //这个题不用想y也一定是负数，要不然那么大的一个数还要判断正负？ out.close(); //释放资源 &#125; &#125; 当然也可以重载负数幂的方法来做","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"java实验","slug":"java实验","date":"2020-04-15T13:08:14.000Z","updated":"2022-02-26T03:52:52.332Z","comments":true,"path":"2020/04/15/java实验/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/15/java%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"实验三（1） 编写Java应用程序求方程的根。使用package语句将方程的属性即计算根的方法封装在一个有包名的类中，包名是tom.jiafei，类的名字是SquareEquation。编写一个SunRise主类，该主类使用import语句引入tom.jiafei包中的SquareEquation类，并使用其计算方程的根。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// SquareEquation类public class SquareEquation &#123; double a, b, c; double root1, root2; boolean boo; public SquareEquation(double a, double b, double c) &#123; this.a = a; this.b = b; this.c = c; if (a != 0) boo = true; else &#123; boo = false; &#125; &#125;&#125;public void getRoots() &#123; if (boo) &#123; System.out.println(&quot;该方程是一元二次方程&quot;); double panduan = b * b - 4 * a * c; if (panduan &gt;= 0) &#123; root1 = 2 * a * (-b + Math.sqrt(panduan)); root1 = 2 * a * (-b - Math.sqrt(panduan)); System.out.print(&quot;方程的两个根为:&quot;); System.out.print(root2 + &quot;,&quot;); System.out.print(root1); &#125; else System.out.println(&quot;该方程没有实根！&quot;); &#125; else System.out.println(&quot;方程不是一元二次方程&quot;); &#125;&#125;// SunRise主类package tom.jiafei;import tom.jiafei.SquareEquation;public class SunRise &#123;public static void main(String[] args) &#123;SquareEquation se = new SquareEquation(4.0,5.0,1.0);se.getRoots();&#125; 实验七 常用实用类 检索图书图书信息如下：书名：Java程序设计；出版时间：2017.10.01；出版社：清华大学出版社；价格：38.6元；页数：409页。判断图书信息中是否含有“Java”，单独输出图书信息中的出版日期，判断图书价格是否大于38、页数是否小于400。 1234567891011121314151617181920212223242526272829303132333435package shiyanqi;public class FindBook &#123; public static void main(String args[]) &#123; String mess = &quot;书名:Java程序设计,出版时间:2017.10.01,&quot; + &quot;出版社:清华大学出版社,价格:38.6元,页数:409页&quot;; if (mess.contains(&quot;java&quot;)) &#123; // 判断mess中是否含有&quot;Java&quot; System.out.println(&quot;图书信息包含有\\&quot;Java\\&quot;&quot;); &#125; int index = mess.indexOf(&quot;：&quot;, 3);// mess调用indexOf(String s,int start)返回mess中第2个冒号的位置 String date = mess.substring(index + 1, index + 11);// 调用substring方法获取出版日期 System.out.println(date); int pricePosition = mess.indexOf(&quot;价格&quot;);// mess调用indexOf(String s)返回首次出现&quot;价格&quot;的位置 int endPosition = mess.indexOf(&quot;元&quot;); String priceMess = mess.substring(pricePosition + 3, endPosition);// 调用substring方法获取价格 System.out.println(&quot;图书价格:&quot; + priceMess); double price = Double.parseDouble(priceMess); if (price &gt;= 38) &#123; System.out.println(&quot;图书价格&quot; + price + &quot;大于或等于38元&quot;); &#125; else &#123; System.out.println(&quot;图书价格&quot; + price + &quot;小于38元&quot;); &#125; index = mess.lastIndexOf(&quot;:&quot;); // 调用laseIndexOf(String s)返回最后一个冒号位置 endPosition = mess.lastIndexOf(&quot;页&quot;); String pageMess = mess.substring(index + 1, endPosition); // 调用substring方法获取页数 int p = Integer.parseInt(pageMess); if (p &gt;= 400) &#123; System.out.println(&quot;图书的页数&quot; + p + &quot;大于或等于400&quot;); &#125; else &#123; System.out.println(&quot;图书的页数&quot; + p + &quot;小于400&quot;); &#125; &#125;&#125; 运行结果： 购物小票分析购物小票内容如下：牛奶：68.5元 香肠：15.6元 啤酒：58元 巧克力：106元输出购物小票中的价格数据，并计算出购物的总金额。 12345678910111213141516171819package shiyanqi;import java.util.*;public class TotalMoney &#123; public static void main(String args[]) &#123; String s = &quot;牛奶:68.5元，香肠:15.6元 啤酒:58元 巧克力:106元&quot;; String regex = &quot;[^0123456789.]&quot;; // 匹配非数字的正则表达式 String digitMess = s.replaceAll(regex, &quot;*&quot;); StringTokenizer fenxi = new StringTokenizer(digitMess, &quot;*&quot;);// 创建fenxi,用*做分隔标记解析digitMess中的单词 int number = fenxi.countTokens(); // fenxi调用countTokens()方法返回单词数量 double sum = 0; while (fenxi.hasMoreTokens()) &#123; // fenxi调用hasMoreTokens()方法判断是否有更多的单词 String str = fenxi.nextToken(); // fenxi调用nextToken()方法返回单词 System.out.println(str); sum = sum + Double.parseDouble(str); &#125; System.out.println(&quot;购物小票中的商品种类：&quot; + number + &quot;种&quot;); System.out.println(&quot;购物小票中的价格总额：&quot; + sum + &quot;元&quot;); &#125;&#125; 心得体会1、第一题中主要用常用实用类中的string方法，调用indexOf（）来看字符串里有没有另一个子串，用substring() 方法返回字符串的子字符串。调用laseIndexOf(String s)返回最后一个冒号位置。2、第二题中，StringTokenizer fenxi&#x3D;new StringTokenizer(digitMess,”“);创建fenxi,用做分隔标记解析digitMess中的单词，fenxi调用countTokens()方法可返回单词数量，fenxi调用hasMoreTokens()方法判断是否有更多的单词，fenxi调用nextToken()方法返回单词 实验八","categories":[],"tags":[],"author":"aoyuehan"},{"title":"ES6，箭头函数 (=>)注意点","slug":"ES6，箭头函数-注意点","date":"2020-04-13T13:07:00.000Z","updated":"2022-02-26T03:52:51.550Z","comments":true,"path":"2020/04/13/ES6，箭头函数-注意点/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/13/ES6%EF%BC%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0-%E6%B3%A8%E6%84%8F%E7%82%B9/","excerpt":"","text":"ES6，箭头函数 (&#x3D;&gt;)注意点1、函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。2、不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。3、不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。4、不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910111213141516var id = 21;function foo() &#123; setTimeout(function() &#123; console.log(&#x27;id:&#x27;, this.id); &#125;, 100);&#125;function foo1() &#123; setTimeout(() =&gt; &#123; console.log(&#x27;id:&#x27;, this.id); &#125;, 100);&#125;foo.call(&#123; id: 42 &#125;);// 21 普通函数 foo函数中this指向windowfoo1.call(&#123;id:42&#125;);// 42 箭头函数 foo1函数中this指向&#123;id:42&#125;对象 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。 1234567891011121314151617function Timer() &#123; // 构造函数不能使用 箭头函数 this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log(&#x27;s1: &#x27;, timer.s1), 3100); setTimeout(() =&gt; console.log(&#x27;s2: &#x27;, timer.s2), 3100);// s1: 3// s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（此例是window,普通函数中this.s2即为window.s2&#x3D;&#x3D;undefined）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。 箭头函数的不适用点:由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。 1.第一个场合是定义对象的方法，且该方法内部包括this。 123456const cat = &#123; lives: 9, jumps: () =&gt; &#123; this.lives--; &#125;&#125; 上面代码中，cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。 2.第二个场合是需要动态this的时候，也不应使用箭头函数。 1234var button = document.getElementById(&#x27;press&#x27;);button.addEventListener(&#x27;click&#x27;, () =&gt; &#123; this.classList.toggle(&#x27;on&#x27;);&#125;); 上面代码运行时，点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。 另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。 今天再看这个文章的时候，他给submit添加监听的那个方式就写错了，我半天没看出来https://blog.csdn.net/weixin_33701617/article/details/91398282?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576!function () &#123; var view = document.querySelector(&#x27;div.message&#x27;); var model = &#123; init:function () &#123; var APP_ID = &#x27;xxxxxxxxxxx-xxxxxx&#x27;; var APP_KEY = &#x27;xxxxxxxxxxxxxx&#x27;; AV.init(&#123; appId: APP_ID, appKey: APP_KEY &#125;); &#125;, // 获取数据 fetch:function () &#123; var query = new AV.Query(&#x27;Comment&#x27;); return query.find()// 返回 Promise对象 &#125;, // 保存数据 save:function (name,comment) &#123; var Comment = AV.Object.extend(&#x27;Comment&#x27;); var c = new Comment(); return c.save(&#123; &#x27;name&#x27;: name, &#x27;comment&#x27;: comment &#125;) // 返回 Promise对象 &#125; &#125;; var controller = &#123; view:null, model:null, init: function(view,model) &#123; this.view = view; this.model = model; this.model.init(); this.loadMessage(); this.bindEvents(); &#125;, bindEvents:function()&#123; var form = this.view.querySelector(&#x27;form&#x27;); form.addEventListener(&#x27;submit&#x27;,(e)=&gt;&#123; e.preventDefault(); this.saveMessage(); &#125;) &#125;, saveMessage:function()&#123; let name = this.view.querySelector(&#x27;input[name=name]&#x27;).value; let comment = this.view.querySelector(&#x27;input[name=comment]&#x27;).value; this.model.save(name,comment) .then(function(object) &#123; // 将数据新增到页面上 let ul = this.view.querySelector(&#x27;.messageList&#x27;); let li = this.view.createElement(&#x27;li&#x27;); li.innerText = name+&#x27; : &#x27;+comment; ul.appendChild(li); // 将两个input输入框的内容清空 this.view.querySelector(&#x27;input[name=name]&#x27;).value = &#x27;&#x27;; this.view.querySelector(&#x27;input[name=comment]&#x27;).value = &#x27;&#x27;; &#125;) &#125;, loadMessage:function()&#123; this.model.fetch() .then((e)=&gt;&#123; let array = e.map((item)=&gt;&#123;return item.attributes&#125;); let ul = document.querySelector(&#x27;.messageList&#x27;); array.forEach((e)=&gt;&#123; let li = document.createElement(&#x27;li&#x27;); li.innerText = e.name+&#x27; : &#x27;+e.comment; ul.appendChild(li); &#125;) &#125;) &#125; &#125; controller.init.call(controller,view,model);&#125;.call() 复制代码","categories":[{"name":"javaScript","slug":"javaScript","permalink":"https://zouyunkai.github.io/myblog/categories/javaScript/"}],"tags":[],"author":"aoyuehan"},{"title":"剑指offer-第五章-优化时间和空间效率","slug":"剑指offer-第五章-优化时间和空间效率","date":"2020-04-13T03:50:00.000Z","updated":"2022-02-26T03:52:51.859Z","comments":true,"path":"2020/04/13/剑指offer-第五章-优化时间和空间效率/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/13/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E5%92%8C%E7%A9%BA%E9%97%B4%E6%95%88%E7%8E%87/","excerpt":"","text":"5.1 面试官谈效率5.2 时间效率 剑指Offer（39）：数组中出现次数超过一半的数字题目 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 思路 数组中有一个数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现次数的和还要多。因此我们可以考虑在遍历数组的时候保存两个值：一个是数组的一个数字，一个是次数。当我们遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为零，我们需要保存下一个数字，并把次数设为1。由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时对应的数字。 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if(numbers.empty())&#123; return 0; &#125; // 遍历每个元素，并记录次数；若与前一个元素相同，则次数加1，否则次数减1 int result = numbers[0]; int times = 1; for(int i = 1; i &lt; numbers.size(); ++i)&#123; if(times == 0)&#123; // 更新result的值为当前元素，并置次数为1 result = numbers[i]; times = 1; &#125; else if(numbers[i] == result)&#123; times++; &#125; else&#123; times--; &#125; &#125; // 判断result是否符合条件，即出现次数大于数组长度的一半 times = 0; for(int i = 0; i &lt; numbers.size(); ++i) &#123; if(numbers[i] == result)&#123; times++; &#125; &#125; return (times &gt; (numbers.size() &gt;&gt; 1)) ? result : 0; &#125;&#125;; 方法二：基于partation函数的设计 剑指Offer（40） 求最小的k个数最大堆O(nlogk) 首先选取前K个数建立最大堆（根结点值大于左右结点值）。 此后，每次从原数组中取一个元素与根进行比较，如果大于根结点的元素，忽视之，取下一个数组元素继续该过程；如果小于根结点的元素，则将其加入最大堆，并进行堆调整，将根元素移动到最后再删除，即保证最大堆中的元素仍然是排名前K的数，且根元素仍然最大。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; int sz = input.size(); vector&lt;int&gt; vec; if (sz == 0 || k &lt;= 0 || sz &lt; k) return vec; for (int i = 0; i &lt; k; ++i) vec.push_back(input[i]); // 以数组前k个元素建立初始的最大堆 make_heap(vec.begin(), vec.end(), less&lt;int&gt;()); for (int i = k; i &lt; sz; ++i) &#123; if (input[i] &gt; vec.front()) // 如果接下来的元素比堆顶元素大，直接跳过 continue; else // 如果接下来的元素比堆顶元素小，则调整堆 &#123; vec.push_back(input[i]); // 添加新元素调整堆 push_heap(vec.begin(), vec.end()); // 将堆顶元素调整到最后 pop_heap(vec.begin(), vec.end()); // 删除最后那个元素 vec.pop_back(); &#125; &#125; // 以上方法得到的只是求了TopK，但是并未排序，所以使用sort_heap排序一下 sort_heap(vec.begin(), vec.end()); return vec; &#125;&#125;; 【该算法有两个明显的优点】： 没有修改输入的数据（代码中的变量data）。我们每次只是从data中读入数字，所有的写操作都是在容器leastNumbers中进行的。 该算法适合海量数据的输入，不需要将数据一次性全部载入内存。 方法二：基于快排的算法O(n) 利用快速排序划分的思想，每一次划分就会有一个数字位于以数组从小到达排列的的最终位置location（假设下标从1开始）； 位于index左边的数字都小于location对应的值，右边都大于location指向的值；所以，当location&gt; k时，表示k个最小数字一定在location的左边，此时，只需要对location的左边进行划分即可； 当location&lt; k 时，说明location及location左边数字还没能满足k个数字，需要继续对location右边进行划分。 当index &#x3D; k 时，说明已划分完。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: int partition(vector&lt;int&gt;&amp; arr, int low, int high) &#123; int pivot = arr[high]; // 选最后一个元素作为枢纽元 int location = low; // location放置的是最新的比枢纽元小的元素 for (int i = low; i &lt; high; i++) // 比枢纽元小的元素依次放在前半部分 if (arr[i] &lt; pivot) swap(arr[i], arr[location++]); // 移动location swap(arr[high], arr[location]); // 最后交换的是arr[high]，不是pivot return location; &#125; void quick_sort(vector&lt;int&gt;&amp; arr, int low, int high, int k) &#123; if (low &lt; high) &#123; int middle = partition(arr, low, high); // 如果middle大于k-1，则说明arr[middle]右边的元素都大于k，于是只递归arr[low, middle-1]即可 if (middle &gt; k - 1) quick_sort(arr, low, middle-1, k); // 如果middle小于k-1，则说明arr[middle]左边的元素都小于k，于是只递归arr[middle+1, high]即可 if (middle &lt; k - 1) quick_sort(arr, middle+1, high, k); // 如果middle等于k-1说明前k个元素已经找到 if (middle == k - 1) return; &#125; &#125; vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; int sz = input.size(); vector&lt;int&gt; vec; if (sz == 0 || k &lt;= 0 || sz &lt; k) return vec; quick_sort(input, 0, input.size() - 1, k); for (int i = 0; i &lt; k; ++i) &#123; vec.push_back(input[i]); &#125; return vec; &#125;&#125;; 快排的另外一种写法： 剑指Offer（41）：数据流中的中位数 题目 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。1、思路 这道题的解法有很多，文本使用最大堆和最小堆实现。 主要思想： 最大堆 | 最小堆 我们将数据分为两部分，位于左边最大堆的数据比右边最小堆的数据要小，左、右两边内部的数据没有排序，也可以根据左边最大的数及右边最小的数得到中位数。 接下来考虑用最大堆和最小堆实现的一些细节。 首先要保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过1.为了实现平均分配，可以在数据的总数目是偶数时把新数据插入到最小堆中，否则插入到最大堆中。 此外，还要保证最大堆中所有数据小于最小堆中数据。所以，新传入的数据需要先和最大堆的最大值或者最小堆中的最小值进行比较。以总数目为偶数为例，按照我们制定的规则，新的数据会被插入到最小堆中，但是在这之前，我们需要判断这个数据和最大堆中的最大值谁更大，如果最大堆中的数据比较大，那么我们就需要把当前数据插入最大堆，然后弹出新的最大值，再插入到最小堆中。由于最终插入到最小堆的数字是原最大堆中最大的数字，这样就保证了最小堆中所有数字都大于最大堆的数字。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123;public: void Insert(int num) &#123; // 如果已有数据为偶数，则放入最小堆 if(((max.size() + min.size()) &amp; 1) == 0)&#123; // 如果插入的数字小于最大堆里的最大的数，则将数字插入最大堆 // 并将最大堆中的最大的数字插入到最小堆 if(max.size() &gt; 0 &amp;&amp; num &lt; max[0])&#123; // 插入数据插入到最大堆数组 max.push_back(num); // 调整最大堆 push_heap(max.begin(), max.end(), less&lt;int&gt;()); // 拿出最大堆中的最大数 num = max[0]; // 删除最大堆的栈顶元素 pop_heap(max.begin(), max.end(), less&lt;int&gt;()); max.pop_back(); &#125; // 将数据插入最小堆数组 min.push_back(num); // 调整最小堆 push_heap(min.begin(), min.end(), greater&lt;int&gt;()); &#125; // 已有数据为奇数，则放入最大堆 else&#123; if(min.size() &gt; 0 &amp;&amp; num &gt; min[0])&#123; // 将数据插入最小堆 min.push_back(num); // 调整最小堆 push_heap(min.begin(), min.end(), greater&lt;int&gt;()); // 拿出最小堆的最小数 num = min[0]; // 删除最小堆的栈顶元素 pop_heap(min.begin(), min.end(), greater&lt;int&gt;()); min.pop_back(); &#125; // 将数据插入最大堆 //pop_heap()把堆顶元素放到了最后一位，然后对它前面的数字重建了堆。 //这样一来只要再使用pop_back()把最后一位元素删除，就得到了新的堆 max.push_back(num); push_heap(max.begin(), max.end(), less&lt;int&gt;()); &#125; &#125; double GetMedian() &#123; // 统计数据大小 int size = min.size() + max.size(); if(size == 0)&#123; return 0; &#125; // 如果数据为偶数 if((size &amp; 1) == 0)&#123; return (min[0] + max[0]) / 2.0; &#125; // 奇数 else&#123; return min[0]; &#125; &#125;private: // 使用vector建立最大堆和最小堆,min是最小堆数组,max是最大堆数组 vector&lt;int&gt; min; vector&lt;int&gt; max;&#125;; vector建立堆 剑指Offer（42）：连续子数组的最大和思路 数组分析：下图是我们计算数组（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析我们发现，累加的子数组和，如果大于零，那么我们继续累加就行；否则，则需要剔除原来的累加和重新开始。 过程如下： 123456789101112131415161718192021222324252627class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; if(array.empty())&#123; return 0; &#125; // 初始化变量，maxSum为最大和，curSum为当前和 int maxSum = array[0]; int curSum = array[0]; // 遍历所有元素 for(int i = 1; i &lt; array.size(); i++)&#123; // 如果当前和小于等于0，说明之前的是负数，则抛弃前面的和，重新计算 if(curSum &lt;= 0)&#123; curSum = array[i]; &#125; // 如果没有问题，直接累加 else&#123; curSum += array[i]; &#125; // 更新最大和 if(curSum &gt; maxSum)&#123; maxSum = curSum; &#125; &#125; return maxSum; &#125;&#125;; 方法二：动态规划方法 剑指Offer（43 ）：整数中1出现的次数（从1到n整数中1出现的次数）题目 输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字有1，10，11和12，1一共出现了5次。方法一： 方法二： 1234567891011121314class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; // 统计次数 int count = 0; for(int i = 1; i &lt;= n; i *= 10)&#123; // 计算高位和低位 int a = n / i, b = n % i; count += (a + 8) / 10 * i + (a % 10 == 1) * (b + 1); &#125; return count; &#125;&#125;; 剑指Offer（44）：数字序列中某一位的数字 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;unordered_map&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;sstream&gt;using namespace std;#define max_len 9int TheNthDigit(long long f[],int n)&#123; if(n &lt; 0) return -1; if(n &lt;= 9) return n; int pos = 0; for(int i = 1; i &lt;= max_len ;i++) if(f[i] &gt;= n) &#123; pos = i; break; &#125; n = n - f[pos - 1]; int temp1 = n / pos; int temp2 = n % pos; int temp3 = temp1 + pow(10, pos - 1); return (int)(temp3 / pow(10,pos - temp2 -1)) % 10; &#125;int main()&#123; long long f[] = &#123;0,10,190,2890,38890,488890,5888890,68888890,788888890,8888888890&#125;;//初始化长度数组 int n; cin &gt;&gt; n; cout&lt;&lt;TheNthDigit(f,n)&lt;&lt;endl;&#125; 方法二（书上的写法）： 剑指Offer（45）：把数组排成最小的数题目 思路 遇到这个题，全排列当然可以做，但是时间复杂度为O(n!)。在这里我们自己定义一个规则，对拼接后的字符串进行比较。 排序规则如下： 若ab &gt; ba 则 a 大于 b， 若ab &lt; ba 则 a 小于 b， 若ab &#x3D; ba 则 a 等于 b； 根据上述规则，我们需要先将数字转换成字符串再进行比较，因为需要串起来进行比较。比较完之后，按顺序输出即可。 12345678910111213141516171819202122class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; int length = numbers.size(); if(length == 0)&#123; return &quot;&quot;; &#125; sort(numbers.begin(), numbers.end(), cmp); string res; for(int i = 0; i &lt; length; i++)&#123; res += to_string(numbers[i]); &#125; return res; &#125;private: // 升序排序 static bool cmp(int a, int b)&#123; string A = to_string(a) + to_string(b); string B = to_string(b) + to_string(a); return A &lt; B; &#125;&#125;; 剑指Offer（46）：把数字翻译成字符串题目 给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别”bccfi”, “bwfi”, “bczi”, “mcfi” 和”mzi” 。请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。回到顶部思路 看到题目，很容易想到使用递归：用f(i)来表示从第i位开始的不同翻译数目，可以得到有：f(i)&#x3D;f(i+1)+g(i,i+1)*f(i+2)。i和i+1位数字拼起来在10~25范围内时g(i,i+1)的值为1，否则为0。 但是存在重复的子问题，所以递归并非最佳方法，我们从数字的末尾开始计算f(i)，自下而上解决问题，就可以消除重复的子问题了。先算f(len-1)，f(len-2)，再根据公式f(i)&#x3D;f(i+1)+g(i,i+1)*f(i+2)往前逐步推导到f(0)，这就是最终要求的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061自上而下，从最大的问题开始，递归 ： 12258 / \\ b+2258 m+258 / \\ / \\ bc+258 bw+58 mc+58 mz+8 / \\ \\ \\ \\ bcc+58 bcz+8 bwf+8 mcf+8 mzi / \\ \\ \\ bccf+8 bczi bwfi mcfi / bccfi有很多子问题被多次计算，比如258被翻译成几种这个子问题就被计算了两次。自下而上，动态规划，从最小的问题开始 ：f(r)表示以r为开始（r最小取0）到最右端所组成的数字能够翻译成字符串的种数。对于长度为n的数字，f(n)=0,f(n-1)=1,求f(0)。递推公式为 f(r-2) = f(r-1)+g(r-2,r-1)*f(r)；其中，如果r-2，r-1能够翻译成字符，则g(r-2,r-1)=1，否则为0。因此，对于12258：f(5) = 0f(4) = 1f(3) = f(4)+0 = 1f(2) = f(3)+f(4) = 2f(1) = f(2)+f(3) = 3 f(0) = f(1)+f(2) = 5 public class P231_TranslateNumbersToStrings &#123; public static int getTranslationCount(int number)&#123; if(number&lt;0) return 0; if(number==1) return 1; return getTranslationCount(Integer.toString(number)); &#125; //动态规划，从右到左计算。 //f(r-2) = f(r-1)+g(r-2,r-1)*f(r); //如果r-2，r-1能够翻译成字符，则g(r-2,r-1)=1，否则为0 public static int getTranslationCount(String number) &#123; int f1 = 0,f2 = 1,g = 0; int temp; for(int i=number.length()-2;i&gt;=0;i--)&#123; if(Integer.parseInt(number.charAt(i)+&quot;&quot;+number.charAt(i+1))&lt;26) g = 1; else g = 0; temp = f2; f2 = f2+g*f1; f1 = temp; &#125; return f2; &#125; public static void main(String[] args)&#123; System.out.println(getTranslationCount(-10)); //0 System.out.println(getTranslationCount(1234)); //3 System.out.println(getTranslationCount(12258)); //5 &#125;&#125; （47）礼物的最大值思路一：递归，定义一个函数f(i,j)用来表示到达坐标为(i,j)的格子时能拿到的礼物总和的最大值，根据题意只能从右走和下走，所以对当前点(i,j)来说，最大值只需比较左边和上面的。另外考虑当处在上边界和左边界的情况时只有一个方向可以走。 123456789101112131415161718192021222324252627 public static int getMaxValue(int[][]a)&#123; int max = 0; int i = a.length; int j = a[0].length; max = sum(a,i,j); return max; &#125;private static int sum(int[][] a,int row,int col) &#123; //当来到左上角时，终止条件 if(row==1&amp;&amp;col==1) return a[0][0]; //当来到上边界，只能往左走 if(row==1) return sum(a, row, col-1)+a[row-1][col-1]; //当来到左边界，只能往上走 else if(col==1) return sum(a, row-1, col) + a[row-1][col-1]; //否则判断是哪边大 else return Math.max(sum(a, row, col-1), sum(a, row-1, col))+a[row-1][col-1]; &#125; （48）最长不含重复字符的子字符串 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。假设字符串中只包含从’a’到’z’的字符。例如，在字符串中”arabcacfr”，最长非重复子字符串为”acfr”，长度为4。 主要思路：使用动态规划，记录当前字符之前的最长非重复子字符串长度f(i-1)，其中i为当前字符的位置。每次遍历当前字符时，分两种情况： 1）若当前字符第一次出现，则最长非重复子字符串长度f(i) &#x3D; f(i-1)+1。2）若当前字符不是第一次出现，则首先计算当前字符与它上次出现位置之间的距离d。若d大于f(i-1)，即说明前一个非重复子字符串中没有包含当前字符，则可以添加当前字符到前一个非重复子字符串中，所以，f(i) &#x3D; f(i-1)+1。若d小于或等于f(i-1)，即说明前一个非重复子字符串中已经包含当前字符，则不可以添加当前字符，所以，f(i) &#x3D; d。 123456789101112131415161718192021222324252627282930313233public static int longestSubstringWithoutDuplication(String str) &#123; if(str==null || str.equals(&quot;&quot;)) return 0; int maxLength=0; int curLength=0; int[] position = new int[26]; for(int i=0;i&lt;position.length;i++) &#123; position[i]=-1; //初始化为-1，负数表示没出现过 &#125; for(int i=0;i&lt;str.length();i++) &#123; int prevIndex = position[str.charAt(i)-&#x27;a&#x27;]; int distance=i-prevIndex; //如果当前字符没有出现过，或者出现后的d大于当前最长字串长度 if(prevIndex&lt;0 || distance&gt;curLength) curLength++; else &#123; //如果d&lt;=当前最长字串长度，说明两个相同字符在最长字串中 if(curLength &gt; maxLength) maxLength = curLength; curLength = distance; &#125; position[str.charAt(i)-&#x27;a&#x27;] = i; //更新当前字符出现的位置 &#125; if(curLength&gt;maxLength) maxLength=curLength; return maxLength;&#125; 剑指Offer（49 ）：丑数 题目 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 思路 所谓的一个数m是另一个数n的因子，是指n能被m整除，也就是n%m&#x3D;&#x3D;0。根据丑数的定义，丑数只能被2、3和5整除。根据丑数的定义，丑数应该是另一个丑数乘以2、3或者5的结果（1除外）。因此我们可以创建一个数组，里面的数字是排好序的丑数，每一个丑数都是前面的丑数乘以2、3或者5得到的。 这个思路的关键问题在于怎样保证数组里面的丑数是排好序的。对乘以2而言，肯定存在某一个丑数T2，排在它之前的每一个丑数乘以2得到的结果都会小于已有最大的丑数，在它之后的每一个丑数乘以乘以2得到的结果都会太大。我们只需要记下这个丑数的位置，同时每次生成新的丑数的时候，去更新这个T2。对乘以3和5而言，也存在着同样的T3和T5。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if(index &lt; 7)&#123; return index; &#125; vector&lt;int&gt; res(index); for(int i = 0; i &lt; 6; i++)&#123; res[i] = i + 1; &#125; int t2 = 3, t3 = 2, t5 = 1; for(int i = 6; i &lt; index; i++)&#123; res[i] = min(res[t2] * 2, min(res[t3] * 3, res[t5] * 5)); while(res[i] &gt;= res[t2] * 2)&#123; t2++; &#125; while(res[i] &gt;= res[t3] * 3)&#123; t3++; &#125; while(res[i] &gt;= res[t5] * 5)&#123; t5++; &#125; &#125; return res[index - 1]; &#125;&#125;;注意：1，2，3，4，5，6都是丑数。所以当index小于7的时候，直接返回index即可。方法二：class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if (index &lt;= 0) return 0; vector&lt;int&gt; k(index); k[0] = 1; int p1 = 0, p2 = 0, p3 = 0; for (int i = 1; i &lt; index; ++i) &#123; k[i] = min(min(2 * k[p1], 3 * k[p2]), 5 * k[p3]); if (k[i] == 2 * k[p1]) p1 ++; if (k[i] == 3 * k[p2]) p2 ++; if (k[i] == 5 * k[p3]) p3 ++; &#125; return k[index - 1]; &#125;&#125;; 剑指Offer（50）：第一个只出现一次的字符题目 在一个字符串(1&lt;&#x3D;字符串长度&lt;&#x3D;10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置。 思路 建立一个哈希表，第一次扫描的时候，统计每个字符的出现次数。第二次扫描的时候，如果该字符出现的次数为1，则返回这个字符的位置。 12345678910111213141516171819class Solution &#123;public: int FirstNotRepeatingChar(string str) &#123; int length = str.size(); if(length == 0)&#123; return -1; &#125; map&lt;char, int&gt; item; for(int i = 0; i &lt; length; i++)&#123; item[str[i]]++; &#125; for(int i = 0; i &lt; length; i++)&#123; if(item[str[i]] == 1)&#123; return i; &#125; &#125; return -1; &#125;&#125;; 变式题：字符流中出现一次的字符可以用数组模拟哈希表，先初始化为-1，然后用数字记录字符流中字符出现的位置，然后出现一次记为1，出现两次记为-2 剑指Offer（51）：数组中的逆序对题目 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007。 思路 如数组{7,5,6,4}，逆序对总共有5对，{7,5}，{7,6}，{7,4}，{5,4}，{6,4}； 思路1：暴力解法，顺序扫描整个数组，每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成一个逆序对。假设数组中含有n个数字，由于每个数字都要和O(n)个数字作比较，因此这个算法的时间复杂度是O(n^2)。 思路2：分治思想，采用归并排序的思路来处理，如下图，先分后治： 先把数组分解成两个长度为2的子数组，再把这两个子数组分解成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7&gt;5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}，{4}中也有逆序对（6,4），由于已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组进行排序，避免在之后的统计过程中重复统计。逆序对的总数 &#x3D; 左边数组中的逆序对的数量 + 右边数组中逆序对的数量 + 左右结合成新的顺序数组时中出现的逆序对的数量 总结一下：这是一个归并排序的合并过程，主要是考虑合并两个有序序列时，计算逆序对数。 对于两个升序序列，设置两个下标：两个有序序列的末尾。每次比较两个末尾值，如果前末尾大于后末尾值，则有”后序列当前长度“个逆序对；否则不构成逆序对。然后把较大值拷贝到辅助数组的末尾，即最终要将两个有序序列合并到辅助数组并有序。 这样，每次在合并前，先递归地处理左半段、右半段，则左、右半段有序，且左右半段的逆序对数可得到，再计算左右半段合并时逆序对的个数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152注意：InversePairsCore形参的顺序是(data,copy)，而递归调用时实参是(copy,data)。要明白递归函数InversePairsCore的作用就行了，它是对data的左右半段进行合并，复制到辅助数组copy中有序。class Solution &#123;public: int InversePairs(vector&lt;int&gt; data) &#123; if(data.size() == 0)&#123; return 0; &#125; // 排序的辅助数组 vector&lt;int&gt; copy; for(int i = 0; i &lt; data.size(); ++i)&#123; copy.push_back(data[i]); &#125; return InversePairsCore(data, copy, 0, data.size() - 1) % 1000000007; &#125; long InversePairsCore(vector&lt;int&gt; &amp;data, vector&lt;int&gt; &amp;copy, int begin, int end)&#123; // 如果指向相同位置，则没有逆序对。 if(begin == end)&#123; copy[begin] = data[end]; return 0; &#125; // 求中点 int mid = (end + begin) &gt;&gt; 1; // 使data左半段有序，并返回左半段逆序对的数目 long leftCount = InversePairsCore(copy, data, begin, mid); // 使data右半段有序，并返回右半段逆序对的数目 long rightCount = InversePairsCore(copy, data, mid + 1, end); int i = mid; // i初始化为前半段最后一个数字的下标 int j = end; // j初始化为后半段最后一个数字的下标 int indexcopy = end; // 辅助数组复制的数组的最后一个数字的下标 long count = 0; // 计数，逆序对的个数，注意类型 while(i &gt;= begin &amp;&amp; j &gt;= mid + 1)&#123; if(data[i] &gt; data[j])&#123; copy[indexcopy--] = data[i--]; count += j - mid; &#125; else&#123; copy[indexcopy--] = data[j--]; &#125; &#125; for(;i &gt;= begin; --i)&#123; copy[indexcopy--] = data[i]; &#125; for(;j &gt;= mid + 1; --j)&#123; copy[indexcopy--] = data[j]; &#125; return leftCount + rightCount + count; &#125;&#125;; 5.3 时间效率和空间效率的平衡 剑指Offer（52）：两个链表的第一个公共结点题目 输入两个链表，找出它们的第一个公共结点。 思路 这道题和160.Intersection of Two Linked Lists是一样的。都是求两个链表的第一个公共结点。 公共结点的样子：上图就是一个有公共结点的例子，在公共结点之后，两个链表指针指向的地址是相同的。 这道题有两个解法。 方法一： 我们可以把两个链表拼接起来，一个pHead1在前pHead2在后，一个pHead2在前pHead1在后。这样，生成了两个相同长度的链表，那么我们只要同时遍历这两个表，就一定能找到公共结点。时间复杂度O(m+n)，空间复杂度O(m+n)。 方法二： 我们也可以先让把长的链表的头砍掉，让两个链表长度相同，这样，同时遍历也能找到公共结点。此时，时间复杂度O(m+n)，空间复杂度为O(MAX(m,n))。 剑指Offer（53）：数字在排序数组中出现的次数题目 统计一个数字在排序数组中出现的次数。 思路 既然是已经排序好的数组，那么第一个想到的就是二分查找法。 做法就是使用二分法找到数字在数组中出现的第一个位置，再利用二分法找到数字在数组中出现的第二个位置。时间复杂度为O(logn + logn)，最终的时间复杂度为O(logn)。 举个例子，找到数字k在数组data中出现的次数。 数组data中，数字k出现的第一个位置： 我们对数组data进行二分，如果数组中间的数字小于k，说明k应该出现在中间位置的右边；如果数组中间的数字大于k，说明k应该出现在中间位置的左边；如果数组中间的数字等于k，并且中间位置的前一个数字不等于k，说明这个中间数字就是数字k出现的第一个位置。 同理，数字k出现的最后一个位置，也是这样找的。但是判断少有不同。我们使用两个函数分别获得他们。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; int length = data.size(); if(length == 0)&#123; return 0; &#125; int first = GetFirstK(data, k, 0, length - 1); int last = GetLastK(data, k, 0, length - 1); if(first != -1 &amp;&amp; last != -1)&#123; return last - first + 1; &#125; return 0; &#125;private: // 迭代实现找到第一个K int GetFirstK(vector&lt;int&gt; data, int k, int begin, int end)&#123; if(begin &gt; end)&#123; return -1; &#125; int middleIndex = (begin + end) &gt;&gt; 1; int middleData = data[middleIndex]; if(middleData == k)&#123; if((middleIndex &gt; 0 &amp;&amp; data[middleIndex - 1] != k) || middleIndex == 0)&#123; return middleIndex; &#125; else&#123; end = middleIndex - 1; &#125; &#125; else if (middleData &gt; k)&#123; end = middleIndex - 1; &#125; else&#123; begin = middleIndex + 1; &#125; return GetFirstK(data, k, begin, end); &#125; // 循环实现找到最后一个K int GetLastK(vector&lt;int&gt; data, int k, int begin, int end)&#123; int length = data.size(); int middleIndex = (begin + end) &gt;&gt; 1; int middleData = data[middleIndex]; while(begin &lt;= end)&#123; if(middleData == k)&#123; if((middleIndex &lt; length - 1 &amp;&amp; data[middleIndex + 1] != k) || middleIndex == length - 1)&#123; return middleIndex; &#125; else&#123; begin = middleIndex + 1; &#125; &#125; else if(middleData &gt; k)&#123; end = middleIndex - 1; &#125; else&#123; begin = middleIndex + 1; &#125; middleIndex = (begin + end) &gt;&gt; 1; middleData = data[middleIndex]; &#125; return -1; &#125;&#125;; 求最大最小值给定n个数，要求比较次数1.5n同时找出最大值和最小值 写出一个算法,对给定的n个数的序列,返回序列中的最大和最小的数.设计出一个算法,只需要执行1.5n次比较就能找到序列中最大和最小的数吗？能否再少？ 分析：要求比较次数为1.5n，使用一般的逐个遍历每个元素然后判断其是否为最大最小值是需要2n次的比较的，所以这样的方法是行不通的。现在考虑采用，每次从数组中取出两个元素，判断其大小，然后再分别判断其是否是最大或最小值，这样一次处理两个元素，每一次比较3次，最终的比较次数就是n&#x2F;2*3&#x3D;1.5n。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt; #define MIN -1#define MAX 65535 void find_max_min(int num[], int len)&#123; int i, j; int max = MIN; int min = MAX; int tmax, tmin; int count = 0; /*用来统计比较次数*/ i = 0; j = len - 1; while(i &lt;= j) &#123; if(num[i] &lt; num[j]) &#123; tmax = num[j]; tmin = num[i]; count ++; &#125; else &#123; tmax = num[i]; tmin = num[j]; count ++; &#125; if(min &gt; tmin) min = tmin; if(max &lt; tmax) max = tmax; count += 2; /*上面的两次比较*/ i ++; j --; &#125; printf(&quot;The max number is: %d.\\n&quot;, max); printf(&quot;The min number is: %d.\\n&quot;, min); printf(&quot;Compare number is: %d.\\n&quot;, count);&#125; int main()&#123; int num[10] = &#123;2, 4, 5, 6, 8, 3, 7, 1, 9, 10&#125;; find_max_min(num, 10); return 0;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[],"author":"aoyuehan"},{"title":"数据库笔记（三）","slug":"数据库笔记（三）","date":"2020-04-12T14:17:14.000Z","updated":"2022-02-26T03:52:52.248Z","comments":true,"path":"2020/04/12/数据库笔记（三）/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"课堂问题 所以下面这个做法就是错误的 将这一题转换为E-R图 E-R图转换 数据库的逻辑设计 E-R图向关系模型的转换一个一对一，一对多，多对多的关系都可以转换为一个独立的关系","categories":[],"tags":[],"author":"aoyuehan"},{"title":"ICPC Southeastern Europe Contest 2019","slug":"Untitled-1","date":"2020-04-12T06:07:36.000Z","updated":"2022-02-26T03:52:52.385Z","comments":true,"path":"2020/04/12/Untitled-1/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/12/Untitled-1/","excerpt":"","text":"Absolute Game 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;const int maxn=1e5+10;int a[maxn],b[maxn];int main()&#123; int n,ans=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;b[i]; &#125; for(int i=0;i&lt;n;i++)&#123; int tmp=0x3f3f3f3f; //四个3f，0x3f3f3f3f的十进制是1061109567；两个相加也不会超int32,0x7ffffffff就是int32的最大值 for(int j=0;j&lt;n;j++)&#123; tmp=min(tmp,abs(a[i]-b[j])); &#125; ans=max(ans,tmp); &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; Cycle String? 字符串构造123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778题意：给定长度为2∗n的循环字符串，对其重新排列使得新字符串中不存在两个及以上长度为n的相同子串，问能否构造成功并输出任意新字符串。思路：首先容易发现新串是否合法与出现最多字符的数量有关，稍微打个表发现：出现次数最多的字符（一下称ch）出现了x次.①如果x&lt;=n，那么我们直接输出原串就好了。②如果字符种类数&gt;=3，那么一定有解（就是间隔构造）③如果x&gt;=2∗n−2,并且字符种类数==2,那么一定无解④如果x&lt;2∗n−2,并且字符种类数==2,那么可以先构造出n个ch,然后插一个其他字符，再扔进剩下的ch,再扔进剩下的其他字符，这样就保证了不会出现连续的大于n个相同的字符。#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e6+5;char s[maxn];set&lt;char&gt;st;int num[30];char t1[maxn],t2[maxn];int main()&#123; scanf(&quot;%s&quot;,s+1); int len = strlen(s+1); int n = len/2; for(int i = 1; i &lt;= len; i++)&#123; st.insert(s[i]); num[s[i]-&#x27;a&#x27;]++; &#125; if(st.size() &lt;= 1) puts(&quot;NO&quot;); else if(st.size() &gt;= 2)&#123; int mx = 0,val = 0; for(int i = 0; i &lt; 26; i++)&#123; if(num[i]) val++; mx = max(mx, num[i]); &#125; int cnt1 = 0, cnt2 = 0; for(int i = 0; i &lt; 26; i++)&#123; if(num[i] == 0) continue; if(num[i] == mx) for(int j = 0; j &lt; num[i]; j++) t1[cnt1++] = i+&#x27;a&#x27;; else for(int j = 0; j &lt; num[i]; j++) t2[cnt2++] = i+&#x27;a&#x27;; &#125; if(st.size() == 2)&#123; if(mx &lt;= n)&#123; puts(&quot;YES&quot;); sort(s+1,s+len+1); puts(s+1); &#125; else if(mx &gt;= 2*n-2) puts(&quot;NO&quot;); else&#123; puts(&quot;YES&quot;); int c1 = 0, c2 = 0; for(int i = 0; i &lt; min(n, mx); i++) printf(&quot;%c&quot;,t1[i]); c1 = min(n,mx); if(cnt2)&#123; printf(&quot;%c&quot;,t2[0]); c2 = 1; &#125; for(int i = c1; i &lt; cnt1; i++) printf(&quot;%c&quot;,t1[i]); for(int i = c2; i &lt; cnt2; i++) printf(&quot;%c&quot;,t2[i]); &#125; &#125;else&#123; puts(&quot;YES&quot;); int c1 = 0, c2 = 0; for(int i = 0; i &lt; min(n, mx); i++) printf(&quot;%c&quot;,t1[i]); c1 = min(n,mx); if(cnt2)&#123; printf(&quot;%c&quot;,t2[0]); c2 = 1; &#125; for(int i = c1; i &lt; cnt1; i++) printf(&quot;%c&quot;,t1[i]); for(int i = c2; i &lt; cnt2; i++) printf(&quot;%c&quot;,t2[i]); &#125; &#125;&#125;","categories":[],"tags":[],"author":"aoyuehan"},{"title":"训练33 cf 0409","slug":"训练33-cf-0409","date":"2020-04-09T12:16:46.000Z","updated":"2022-02-26T03:51:21.621Z","comments":true,"path":"2020/04/09/训练33-cf-0409/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/09/%E8%AE%AD%E7%BB%8333-cf-0409/","excerpt":"","text":"A题目大意： 沙滩上有n种不同重量的石头，一个人只有两个最大容纳量为m的口袋，而且同一个口袋不能同时装不同种类的石头，给出每种石头的数量，问总共要运多少次才能把所有的石头都运走。 题目分析： 我们知道口袋的容纳量，而且同一个口袋不能同时装两种石头，所以当容纳量为m时，每一种石块的质量为mk,mk+1,mk+2,…,mk+m-1都是等价的，他都要占据m+1次口袋。所以我们只要每次拿一个石子就计算一下他需要用一个口袋运几次，把最终的结果+1再mod 2就可以得到运输的次数 12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; int n,i,k,t,key; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;k)!=EOF) &#123; t=0; for(i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;key); t+=(key+k-1)/k;//计算出重量为key的石子用一个口袋运输需要的次数 &#125; printf(&quot;%d\\n&quot;,(t+1)/2);//如果是偶数，t+1/2==t/2,如果是奇数，t+1/2=t/2+1 &#125; return 0;&#125; Splitting in Teams （Codeforces Round #452 (Div. 2) A）题意：最多能分多少组，小组有三个人，1+2型，1+1+1型,问最多能组成的队有多少？ 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int n=5;int a[n];int main()&#123; ios::sync_with_stdio(0); memset(a,0,sizeof(a)); int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; int x; cin&gt;&gt;x; a[x]++; &#125; if(a[1]==a[2])&#123; cout&lt;&lt;a[1]&lt;&lt;endl; return 0; &#125;else&#123; int ans=min(a[1],a[2]); a[1]-=ans; ans+=a[1]/3; cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125;&#125;","categories":[],"tags":[],"author":"aoyuehan"},{"title":"ICPC NAQC 2015","slug":"ICPC-NAQC-2015","date":"2020-04-09T11:04:33.000Z","updated":"2022-02-26T03:52:51.356Z","comments":true,"path":"2020/04/09/ICPC-NAQC-2015/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/09/ICPC-NAQC-2015/","excerpt":"","text":"本次只做了E题和M题https://www.jisuanke.com/contest/8289?view=challenges A将所有集合极其子集按包含的偏序关系建成一张图，即把题目转换成求这张图的最大反链，根据 Dilworth’s Theorem，最大反链等于最小路径点覆盖，即用最少的不相交链覆盖所有的点，因此在图中，若有x-&gt;y,y-&gt;z,x-&gt;z的情况，x-&gt;z是肯定不在这些链中的，所有的这些边都可以去掉 设原图点数为n，建立一张点数为2n的二分图，对于图中每一条边x-&gt;y，在二分图中连x-&gt;y+n，求其二分图最大匹配为m，则答案为n-m，证明请自行百度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long longusing namespace std;const int N=3e5+5,M=1e9+7;const ull base=13331;const double Pi=acos(-1.0);const int inf=0x3f3f3f3f;inline int read() &#123; int x=0,f=1;char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int head[N],Next[2*N],ver[2*N],cnt=0;void add(int x,int y)&#123; ver[++cnt]=y; Next[cnt]=head[x],head[x]=cnt;&#125;bool vis[N];int match[N],n;bool dfs(int x)&#123; for(int i=head[x];i;i=Next[i])&#123; int y=ver[i]; if(vis[y])continue; vis[y]=1; if(!match[y]||dfs(match[y]))&#123; match[y]=x;return true; &#125; &#125; return false;&#125;int maxmatch()&#123; int ans=0; for(int i=1;i&lt;=n;i++)&#123; memset(vis,0,sizeof(vis)); if(dfs(i))ans++; &#125; return ans;&#125;map&lt;string,int&gt; Ma;map&lt;vector&lt;int&gt; ,int&gt; st;vector&lt;int&gt; G[N];int tot=0,id=0;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; int m;cin&gt;&gt;m; vector&lt;int&gt; vec; for(int j=1;j&lt;=m;j++)&#123; string s;cin&gt;&gt;s; if(!Ma[s])Ma[s]=++id; vec.push_back(Ma[s]); &#125; sort(vec.begin(),vec.end()); if(st[vec])continue; int len=vec.size(),p=(1&lt;&lt;len)-1; for(int j=1;j&lt;=p;j++)&#123; vector&lt;int&gt; tmp; for(int k=0;k&lt;len;k++)&#123; if((j&gt;&gt;k)&amp;1)tmp.push_back(vec[k]); &#125; if(!st[tmp])st[tmp]=++tot; &#125; &#125; map&lt;vector&lt;int&gt;, int&gt;::iterator it; for(it=st.begin();it!=st.end();it++)&#123; vector&lt;int&gt; vec=(it-&gt;first); int len=vec.size(); if(len==1)continue; for(int i=0;i&lt;len;i++)&#123; vector&lt;int&gt; tmp; for(int j=0;j&lt;len;j++)&#123; if(i==j)continue; tmp.push_back(vec[j]); &#125; G[it-&gt;second].push_back(st[tmp]); &#125; &#125; for(int i=1;i&lt;=tot;i++)&#123; for(int j=0;j&lt;G[i].size();j++)&#123; add(i,G[i][j]+tot); &#125; &#125; n=2*tot; cout&lt;&lt;tot-maxmatch()&lt;&lt;endl;&#125; B二分求答案，对每一个点求出当前可以旋转的角度的区间，再扫描线判断是否存在一个旋转角度被n个区间覆盖即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;#define mkp make_pair#define fi first#define se second#define pb push_backtypedef double db;const db eps=1e-9,pi=acos(-1),inf=1e9;inline int sign(db k)&#123;if(k&gt;eps)return 1;else if(k&lt;-eps)return -1;return 0;&#125;inline int cmp(db a,db b)&#123;return sign(a-b);&#125;struct point&#123; db x,y,dis; void scan()&#123;double k1,k2;scanf(&quot;%lf%lf&quot;,&amp;k1,&amp;k2);x=k1;y=k2;dis=sqrt(x*x+y*y);&#125; void adjust()&#123;while(sign(x)==-1||sign(y)==-1)&#123;db tmp=x;x=-y;y=tmp;&#125;&#125;&#125;a;db dot(point k1,point k2)&#123;return k1.x*k2.x+k1.y*k2.y;&#125;db cross(point k1,point k2)&#123;return k1.x*k2.y-k1.y*k2.x;&#125;db rad(point k1,point k2)&#123;return atan2(cross(k1,k2),dot(k1,k2));&#125;int n;vector&lt;point&gt; v;vector&lt; pair&lt;db,int&gt; &gt; seg;int check(db r)&#123; seg.clear();a.x=a.y=r; for(int i=0;i&lt;v.size();i++) &#123; if(cmp(v[i].dis,sqrt(2)*r)&lt;0)return 0; if(cmp(v[i].dis,2*r)&gt;=0)&#123;seg.pb(mkp(0,1));seg.pb(mkp(pi/2,-1));&#125; db d1=rad(a,v[i]),d2=acos(sqrt(2)*r/v[i].dis); if(cmp(v[i].y,-v[i].x+2*r)&gt;=0) &#123; seg.pb(mkp(0,1));seg.pb(mkp(d1+d2,-1)); seg.pb(mkp(pi/2-d2+d1,1));seg.pb(mkp(pi/2,-1)); &#125; else &#123; if(sign(d1)&gt;=0)&#123;seg.pb(mkp(d1-d2,1));seg.pb(mkp(d1+d2,-1));&#125; else &#123;seg.pb(mkp(pi/2+d1-d2,1));seg.pb(mkp(pi/2+d1+d2,-1));&#125; &#125; &#125; sort(seg.begin(),seg.end()); int cnt=0; for(int i=0;i&lt;seg.size();i++) &#123; cnt+=seg[i].se; if(cnt==n)return 1; &#125; return 0;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) &#123; a.scan(); a.adjust(); v.pb(a); &#125; db l=0,r=inf; int k=100; while(k--) &#123; db mid=(l+r)/2; if(check(mid))l=mid; else r=mid; &#125; printf(&quot;%.4lf\\n&quot;,r*8*sqrt(2)); return 0;&#125; C数据结构维护前缀和的区间最大值和区间最小值，可以二分求出在位置pos处有分值val时第一次变为临界值时的位置 考虑倍增，nxt[i][0&#x2F;1][k]表示在位置i处分值为下&#x2F;上临界值时，从i+1开始第2的k次方次变为临界值的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define ls i&lt;&lt;1#define rs i&lt;&lt;1|1#define pii pair&lt;int,int&gt;#define pll pair&lt;ll,ll&gt;#define mkp(a,b) make_pair(a,b)#define fr first#define sc secondconst int M=1e6+5;int n;ll L,U,sum[M];pii nxt[M][2][20];struct d&#123; int l,r; ll mn,mx;&#125;tree[M*4];void build(int i,int l,int r)&#123; tree[i].l=l;tree[i].r=r; if(l==r) &#123; tree[i].mx=tree[i].mn=sum[l]; return ; &#125; int mid=(l+r)/2; build(ls,l,mid); build(rs,mid+1,r); tree[i].mx=max(tree[ls].mx,tree[rs].mx); tree[i].mn=min(tree[ls].mn,tree[rs].mn); return ;&#125;pll que(int i,int l,int r)&#123; if(tree[i].l==l&amp;&amp;tree[i].r==r)return mkp(tree[i].mx,tree[i].mn); int mid=(tree[i].l+tree[i].r)/2; if(r&lt;=mid)return que(ls,l,r); else if(l&gt;mid)return que(rs,l,r); else &#123; pll t1=que(ls,l,mid); pll t2=que(rs,mid+1,r); return mkp(max(t1.fr,t2.fr),min(t1.sc,t2.sc)); &#125;&#125;pii getnxt(int pos,ll val)&#123; int l=pos,r=n+1; while(l&lt;r) &#123; int mid=(l+r)/2; pll t=que(1,pos,mid); if(val+t.fr-sum[pos-1]&gt;U||val+t.sc-sum[pos-1]&lt;L)r=mid; else l=mid+1; &#125; if(l==n+1)return mkp(n+1,0); if(val+sum[l]-sum[pos-1]&gt;U)return mkp(l,1); else return mkp(l,0);&#125;int main()&#123; scanf(&quot;%d%lld%lld&quot;,&amp;n,&amp;L,&amp;U); for(int i=1;i&lt;=n;i++) &#123; ll x;scanf(&quot;%lld&quot;,&amp;x); sum[i]=sum[i-1]+x; &#125; build(1,1,n); for(int i=0;i&lt;=n;i++) &#123; nxt[i][0][0]=getnxt(i+1,L); nxt[i][1][0]=getnxt(i+1,U); &#125; for(int k=1;k&lt;=16;k++) &#123; for(int i=0;i&lt;=n;i++) &#123; for(int j=0;j&lt;2;j++) &#123; if(nxt[i][j][k-1].fr&gt;n)nxt[i][j][k]=nxt[i][j][k-1]; else nxt[i][j][k]=nxt[nxt[i][j][k-1].fr][nxt[i][j][k-1].sc][k-1]; &#125; &#125; &#125; int q;scanf(&quot;%d&quot;,&amp;q); while(q--) &#123; int b,e;ll x;scanf(&quot;%d%d%lld&quot;,&amp;b,&amp;e,&amp;x); pii t=getnxt(b,x); if(t.fr&gt;e)printf(&quot;%lld\\n&quot;,x+sum[e]-sum[b-1]); else &#123; for(int i=16;i&gt;=0;i--) &#123; if(nxt[t.fr][t.sc][i].fr&lt;=e) &#123; t=nxt[t.fr][t.sc][i]; &#125; &#125; ll ans=sum[e]-sum[t.fr]+(t.sc?U:L); printf(&quot;%lld\\n&quot;,ans); &#125; &#125; return 0;&#125; D对于任意两点i、j，如果i的亮度小于j的亮度，则从i向j连一条向量，可以发现如果存在相邻的两向量间的弧度超过了2PI，那么一定存在方案符合题意 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;const db eps=1e-9;const db pi=acos(-1);const int M=1e3+5;inline int sign(db k)&#123;if (k&gt;eps) return 1; else if (k&lt;-eps) return -1; return 0;&#125;inline int cmp(db k1,db k2)&#123;return sign(k1-k2);&#125;int x[M],y[M],b[M];vector&lt;db&gt; vt;db rad(int x,int y)&#123; if(x==0)return y&gt;0?pi/2:(-pi)/2; else if(y==0)return x&gt;0?0:pi; db res=atan((double)(y)/x); return x&gt;0?res:res+pi;&#125;int main()&#123; int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d%d%d&quot;,&amp;x[i],&amp;y[i],&amp;b[i]); for(int j=1;j&lt;i;j++) if(b[i]&gt;b[j])vt.push_back(rad(x[i]-x[j],y[i]-y[j])); else if(b[i]&lt;b[j])vt.push_back(rad(x[j]-x[i],y[j]-y[i])); &#125; if(vt.size()&lt;2)return 0*printf(&quot;Y\\n&quot;); sort(vt.begin(),vt.end()); int flag=0; db last=vt.back()-2*pi; for(int i=0;i&lt;vt.size();i++) &#123; if(cmp(vt[i]-last,pi)&gt;=0)&#123;flag=1;break;&#125; last=vt[i]; &#125; if(flag)puts(&quot;Y&quot;);else puts(&quot;N&quot;); return 0;&#125; E尺取，先将串复制一遍，把一个E和它左边所有的P看成一段，分别处理 对于一个E和它左边的一个P，设P到E的长度为len，那我们可以从E的右边用字母补全，有s-len+1种方案，然后不断循环处理 12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long longusing namespace std;const int N=2e5+5,M=1e9+7;const ull base=13331;const double Pi=acos(-1.0);const int inf=0x3f3f3f3f;inline int read() &#123; int x=0,f=1;char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;char a[N];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;(a+1); int s,n=strlen(a+1);cin&gt;&gt;s; for(int i=1;i&lt;=n;i++)a[i+n]=a[i]; ll ans=0,cnt=0; for(int l=1,r=1;l&lt;=n;l++)&#123; while(r&lt;=2*n&amp;&amp;cnt==0)cnt+=(a[r]==&#x27;E&#x27;),r++; ans+=max(0,s-(r-l)+1); if(a[l]==&#x27;E&#x27;)cnt--; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; Fdp[i][j]表示用了i个格子，最上面一层有j个的方案数，于是：$$dp[i][j]&#x3D;\\sum_{k&#x3D;j}^{s}{dp[i-j][k]*(k-j+1)}$$ 预处理1~i-1列的dp[x][j]和dp[x][j]*j的后缀和。 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long longusing namespace std;const int N=5e3+5,M=1e9+7;const ull base=13331;const double Pi=acos(-1.0);const int inf=0x3f3f3f3f;inline int read() &#123; int x=0,f=1;char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int dp[N][N],h1[N][N],h2[N][N];int main()&#123; ios::sync_with_stdio(false); int s,b;cin&gt;&gt;s&gt;&gt;b;dp[s][s]=1; for(int i=s+1;i&lt;=b;i++)&#123; for(int j=s;j&gt;=1;j--) h1[i-1][j]=(h1[i-1][j+1]+dp[i-1][j])%M, h2[i-1][j]=(h2[i-1][j+1]+(ll)dp[i-1][j]%M*j%M)%M; for(int j=1;j&lt;=min(s,i);j++) dp[i][j]=((dp[i][j]+h2[i-j][j])%M-(ll)h1[i-j][j]*(j-1)%M+M)%M; &#125; int ans=0; for(int i=1;i&lt;=s;i++)ans=(ans+dp[b][i])%M; cout&lt;&lt;ans&lt;&lt;endl;&#125; G每次选取最长的子串，直接后缀自动机匹配 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long longusing namespace std;const int N=2e5+5,M=1e9+7;const ull base=13331;const double Pi=acos(-1.0);const int inf=0x3f3f3f3f;inline int read() &#123; int x=0,f=1;char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int len[N*2],link[N*2],sz,last;int Next[N*2][26];void sam_init()&#123; len[0]=0,link[0]=-1; sz=1,last=0;&#125;void sam_extend(int c)&#123; int cur=sz++; len[cur]=len[last]+1; int p=last;last=cur; while(p!=-1&amp;&amp;!Next[p][c])Next[p][c]=cur,p=link[p]; if(p==-1)link[cur]=0; else&#123; int q=Next[p][c]; if(len[q]==len[p]+1)link[cur]=q; else&#123; int clone=sz++; link[clone]=link[q]; len[clone]=len[p]+1; memcpy(Next[clone],Next[q],sizeof(Next[q])); while(p!=-1&amp;&amp;Next[p][c]==q)Next[p][c]=clone,p=link[p]; link[q]=link[cur]=clone; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); string s;cin&gt;&gt;s;sam_init(); for(int i=0;i&lt;s.size();i++)&#123; sam_extend(s[i]-&#x27;A&#x27;+1); &#125; int m;cin&gt;&gt;m; while(m--)&#123; cin&gt;&gt;s; int ans=0; for(int i=0;i&lt;s.size();)&#123; if(!Next[0][s[i]-&#x27;A&#x27;+1])&#123; ans=-1;break; &#125; int p=0; while(i&lt;s.size()&amp;&amp;Next[p][s[i]-&#x27;A&#x27;+1]) p=Next[p][s[i++]-&#x27;A&#x27;+1]; ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; Hdp[i][j]k表示自己有i分，对手有j分，目前积累的分数有k分时，自己最终获胜的概率 显然dp[75][j][0]&#x3D;1(0&lt;&#x3D;j&lt;75)，dp[i][75][0]&#x3D;0(0&lt;&#x3D;i&lt;75) dp[i][j][k]的状态转移有两种可能： 选择”hold”: 从dp[j][i+k][0]转移 选择”continue”: 从dp[i][j]k+p和dp[j][i][0]转移 但是发现dp[i][j][0]与dp[j][i][0]之间是相互转移的所以对dp[i][j][0]进行二分，由二分答案求出dp[j][i][k]，继续求出dp[i][j][0]与二分的值比较,调整二分的范围 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;const int M=1e2,N=75;db dp[M][M][M];void upd(int i,int j,int k)&#123; db tmp=0; for(int p=1;p&lt;=6;p++)tmp+=(p==1||i+k+p&gt;N)?(1-dp[j][i][0]):dp[i][j][p+k]; dp[i][j][k]=max(1-dp[j][i+k][0],tmp/6);&#125;void init()&#123; for(int i=0;i&lt;N;i++)dp[N][i][0]=1; for(int i=N-1;i&gt;=0;i--)for(int j=N-1;j&gt;=i;j--) &#123; db l=0,r=1; int k=100; while(k--) &#123; db mid=(l+r)/2; dp[i][j][0]=mid; for(int t=N-j;t&gt;=0;t--)upd(j,i,t); if(i!=j)for(int t=N-i;t&gt;=0;t--)upd(i,j,t); if(dp[i][j][0]&gt;mid)l=mid;else r=mid; &#125; &#125;&#125;int main()&#123; init(); int q;scanf(&quot;%d&quot;,&amp;q); while(q--) &#123; int c,h,x;scanf(&quot;%d%d%d&quot;,&amp;c,&amp;h,&amp;x); db t1=1-dp[h][c+x][0]; db t2=0; for(int p=1;p&lt;=6;p++)t2+=(p==1||c+x+p&gt;N)?(1-dp[h][c][0]):dp[c][h][p+x]; if(t2/6&gt;t1)puts(&quot;C&quot;);else puts(&quot;H&quot;); &#125;&#125; I对DAG进行两种dfs 优化前：如果y没被访问到，就标记并搜索y 优化：如果被访问到了，就不进行计数了 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long longusing namespace std;const int N=2e3+5,M=1e9+7;const ull base=13331;const double Pi=acos(-1.0);const int inf=0x3f3f3f3f;inline int read() &#123; int x=0,f=1;char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int head[N],ver[N*N],Next[N*N],tot=0;void add(int x,int y)&#123; ver[++tot]=y; Next[tot]=head[x],head[x]=tot;&#125;int v[N],f[N],n,l;void dfs(int x,int m)&#123; if(x&gt;l)&#123;f[x]=1;return;&#125; for(int i=head[x];i;i=Next[i])&#123; int y=ver[i]; if(!v[y])v[y]=1,dfs(y,m); else if(m)continue; f[x]=(f[x]+f[y])%M; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;l; for(int i=1;i&lt;=l;i++)&#123; int k;cin&gt;&gt;k; for(int j=1;j&lt;=k;j++)&#123; int x;cin&gt;&gt;x;add(i,x); &#125; &#125; memset(v,0,sizeof(v));memset(f,0,sizeof(f)); dfs(1,0);cout&lt;&lt;f[1]&lt;&lt;&#x27; &#x27;; memset(v,0,sizeof(v));memset(f,0,sizeof(f)); dfs(1,1);cout&lt;&lt;f[1]&lt;&lt;endl;&#125; J123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long long#define pii pair&lt;int,int&gt;#define bug cout&lt;&lt;&quot;--------&quot;&lt;&lt;endl;using namespace std;const int N=4e5+5,M=1e9+7;const ull base=13331;const double Pi=acos(-1.0);const int inf=0x3f3f3f3f;inline int read() &#123; int x=0,f=1;char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int a[N],n;struct SegmentTree&#123; int l,r; int val,id; #define l(x) tree[x].l #define r(x) tree[x].r #define val(x) tree[x].val #define id(x) tree[x].id&#125;tree[N*4];void up(int p)&#123; if(val(p&lt;&lt;1)&gt;val(p&lt;&lt;1|1))&#123; val(p)=val(p&lt;&lt;1); id(p)=id(p&lt;&lt;1); &#125; else&#123; val(p)=val(p&lt;&lt;1|1); id(p)=id(p&lt;&lt;1|1); &#125;&#125;void build(int p,int l,int r)&#123; l(p)=l,r(p)=r; if(l==r)&#123;val(p)=a[l],id(p)=l;return;&#125; int mid=((l+r)&gt;&gt;1); build(p&lt;&lt;1,l,mid); build(p&lt;&lt;1|1,mid+1,r); up(p);&#125;pii ask(int p,int l,int r)&#123; if(l&lt;=l(p)&amp;&amp;r(p)&lt;=r)return make_pair(val(p),id(p)); int mid=((l(p)+r(p))&gt;&gt;1); pii ans=make_pair(-1,-1); if(mid&gt;=l)ans=max(ans,ask(p&lt;&lt;1,l,r)); if(mid&lt;r)ans=max(ans,ask(p&lt;&lt;1|1,l,r)); return ans;&#125;void change(int p,int x,int d)&#123; if(l(p)==r(p)&amp;&amp;l(p)==x)&#123;val(p)=d;return;&#125; int mid=((l(p)+r(p))&gt;&gt;1); if(x&lt;=mid)change(p&lt;&lt;1,x,d); else change(p&lt;&lt;1|1,x,d); up(p);&#125;int quaryl(int p,int l,int r,int val)&#123; if(r(p)&lt;l||l(p)&gt;r)return 0; int mid=((l(p)+r(p))&gt;&gt;1),ans=0; if(l(p)&gt;=l&amp;&amp;r(p)&lt;=r)&#123; if(l(p)==r(p)&amp;&amp;val(p)&gt;=val)return id(p); if(val(p&lt;&lt;1|1)&gt;=val)return quaryl(p&lt;&lt;1|1,l,r,val); if(val(p&lt;&lt;1)&gt;=val)return quaryl(p&lt;&lt;1,l,r,val); return 0; &#125; ans=max(ans,quaryl(p&lt;&lt;1|1,l,r,val)); if(ans!=0)return ans; ans=max(ans,quaryl(p&lt;&lt;1,l,r,val)); return ans;&#125;int quaryr(int p,int l,int r,int val)&#123; if(r(p)&lt;l||l(p)&gt;r)return n+1; int mid=((l(p)+r(p))&gt;&gt;1),ans=n+1; if(l(p)&gt;=l&amp;&amp;r(p)&lt;=r)&#123; if(l(p)==r(p)&amp;&amp;val(p)&gt;=val)return id(p); if(val(p&lt;&lt;1)&gt;=val)return quaryr(p&lt;&lt;1,l,r,val); if(val(p&lt;&lt;1|1)&gt;=val)return quaryr(p&lt;&lt;1|1,l,r,val); return n+1; &#125; ans=min(ans,quaryr(p&lt;&lt;1,l,r,val)); if(ans!=n+1)return ans; ans=min(ans,quaryr(p&lt;&lt;1|1,l,r,val)); return ans;&#125;pii ans[N*4];void spread(int p)&#123; if(ans[p].first!=-1)&#123; ans[p&lt;&lt;1]=ans[p&lt;&lt;1|1]=ans[p]; ans[p]=make_pair(-1,-1); &#125;&#125;void update(int p,int L,int R,int l,int r,int ansl,int ansr)&#123; if(R&lt;l||L&gt;r)return; if(L&gt;=l&amp;&amp;R&lt;=r)&#123; ans[p].first=ansl,ans[p].second=ansr; return; &#125; spread(p);int mid=(L+R)&gt;&gt;1; update(p&lt;&lt;1,L,mid,l,r,ansl,ansr); update(p&lt;&lt;1|1,mid+1,R,l,r,ansl,ansr);&#125;int L[N],R[N];void Build(int p,int l,int r,int ansl,int ansr)&#123; if(l&gt;r)return; int t=ask(1,l,r).second; if(ansl==-1)L[t]=t;else L[t]=R[ansl]; if(ansr==-1)R[t]=t;else R[t]=L[ansr]; update(1,1,n,t,t,L[t],R[t]); Build(1,l,t-1,ansl,t); Build(1,t+1,r,t,ansr);&#125;pii quary(int p,int l,int r,int x)&#123; if(l==r)return ans[p]; int mid=((l+r)&gt;&gt;1);spread(p); if(x&lt;=mid)return quary(p&lt;&lt;1,l,mid,x); else return quary(p&lt;&lt;1|1,mid+1,r,x);&#125;int main()&#123; ios::sync_with_stdio(false); int m;cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i]; build(1,1,n);Build(1,1,n,-1,-1); while(m--)&#123; char c;cin&gt;&gt;c; if(c==&#x27;U&#x27;)&#123; int x,val;cin&gt;&gt;x&gt;&gt;val; change(1,x,val); int l=quaryl(1,1,x-1,val); int r=quaryr(1,x+1,n,val); int ansl=x,ansr=x; if(l!=0)ansl=quary(1,1,n,l).second; if(r!=n+1)ansr=quary(1,1,n,r).first; update(1,1,n,x,x,ansl,ansr); if(l&lt;x-1)&#123; int t=ask(1,l+1,x-1).second; update(1,1,n,t+1,x-1,ansl,ansl); if(l==0)update(1,1,n,t,t,t,ansl); else update(1,1,n,t,t,quary(1,1,n,l).second,ansl); &#125; if(r&gt;x+1)&#123; int t=ask(1,x+1,r-1).second; update(1,1,n,x+1,t-1,ansr,ansr); if(r==n+1)update(1,1,n,t,t,ansr,t); else update(1,1,n,t,t,ansr,quary(1,1,n,r).first); &#125; &#125; else&#123; int x;cin&gt;&gt;x; if(c==&#x27;L&#x27;)cout&lt;&lt;quary(1,1,n,x).first&lt;&lt;endl; else cout&lt;&lt;quary(1,1,n,x).second&lt;&lt;endl; &#125; &#125;&#125; K先构造零点式，两个零点之间的P(x)值全部同号，再将零点式转换成一般式，注意判断正负 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long longusing namespace std;const int N=1e4+5,M=1e9+7;const ull base=13331;const double Pi=acos(-1.0);const int inf=0x3f3f3f3f;inline int read() &#123; int x=0,f=1;char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;char s[N];ll a[N],b[N];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;(s+1); int n=strlen(s+1),tot=0; for(int i=1;i&lt;n;i++)&#123; if(s[i]==s[i+1])continue; a[++tot]=2*i+1; &#125; b[1]=1; for(int i=1;i&lt;=tot;i++)&#123; for(int j=i+1;j&gt;=1;j--)b[j]=b[j-1]; for(int j=1;j&lt;=i+1;j++)b[j-1]-=a[i]*b[j]; &#125; int sign=1; if(s[1]==&#x27;H&#x27;&amp;&amp;tot%2)sign=-1; if(s[1]==&#x27;A&#x27;&amp;&amp;tot%2==0)sign=-1; cout&lt;&lt;tot&lt;&lt;endl; for(int i=tot+1;i&gt;=1;i--)&#123; cout&lt;&lt;b[i]*sign; if(i==1)cout&lt;&lt;endl; else cout&lt;&lt;&#x27; &#x27;; &#125;&#125; L先记录每个字符左边包括自己一共有多少个相同字符，再对每一列的每一个字符用单调栈计算左右两边第一个数量严格小于它的字符的位置 最终答案于所有min(h[i][j],r[i]-l[i]-1)中取最大值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long longusing namespace std;const int N=1e3+5,M=1e9+7;const ull base=13331;const double Pi=acos(-1.0);const int inf=0x3f3f3f3f;inline int read() &#123; int x=0,f=1;char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;char a[N][N];int h[N][N],S[N],l[N],r[N];int main()&#123; ios::sync_with_stdio(false); int n,m;cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;(a[i]+1); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; if(a[i][j]==a[i][j-1])h[i][j]=h[i][j-1]+1; else h[i][j]=1; &#125; &#125; int ans=0; for(int j=1;j&lt;=m;j++)&#123; int top=0;S[0]=0; for(int i=1;i&lt;=n;i++)&#123; while(top&gt;0&amp;&amp;h[i][j]&lt;=h[S[top]][j])top--; l[i]=S[top]; S[++top]=i; &#125; top=0,S[0]=n+1; for(int i=n;i&gt;=1;i--)&#123; while(top&gt;0&amp;&amp;h[i][j]&lt;=h[S[top]][j])top--; r[i]=S[top]; S[++top]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; ans=max(ans,min(h[i][j],r[i]-l[i]-1)); &#125; &#125; cout&lt;&lt;ans*ans&lt;&lt;endl;&#125; M简单题，扫一遍即可 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define ll long long#define ull unsigned long longusing namespace std;const int N=2e5+5,M=1e9+7;const ull base=13331;const double Pi=acos(-1.0);const int inf=0x3f3f3f3f;inline int read() &#123; int x=0,f=1;char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;int a[N];int main()&#123; ios::sync_with_stdio(false); int n,x,ans=0,cnt=1;cin&gt;&gt;n&gt;&gt;x; for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i];a[n+1]=inf; for(int i=2;i&lt;=n+1;i++)&#123; if(a[i]-a[i-1]&lt;=x)cnt++; else ans=max(ans,cnt),cnt=1; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;","categories":[],"tags":[],"author":"aoyuehan"},{"title":"UCF Contest 2017","slug":"UCF-Contest-2017","date":"2020-04-08T08:09:50.000Z","updated":"2022-02-26T03:52:52.620Z","comments":true,"path":"2020/04/08/UCF-Contest-2017/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/08/UCF-Contest-2017/","excerpt":"","text":"A题解：签到题，输入一个n，如果没有超过1000，费用就是na，超过1000的话就把超过的乘上b（1000a+（n-1000）*b）就好了 1234567891011121314#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; int n; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; while(n--)&#123; long long tmp; cin&gt;&gt;tmp; cout&lt;&lt;tmp&lt;&lt;&#x27; &#x27;; tmp&gt;1000?cout&lt;&lt;(tmp-1000)*b+1000*a&lt;&lt;endl:cout&lt;&lt;tmp*a&lt;&lt;endl; &#125; &#125; B题解：每个英文的八个方向都跟这个单词相似 比如a跟bkl相似，给你2个字符串，如果这两个字符串完全相等输出1，如果是相似的输出2，如果长度不同或不相似也不相等输出3。用map做，利用map&lt;char,string&gt; mp[‘a’]&#x3D;”bkl”把26的英文写出来，先一个循环判断是否相等或者不相等，如果不相等再来一个循环进行判断有没有相似的英文。 或者直接判断一个字母周围和要比较的字母是否相等就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119方法一：#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;int main()&#123; map&lt;char,string&gt;mp; mp[&#x27;a&#x27;]=&quot;bkj&quot;; mp[&#x27;b&#x27;]=&quot;clkja&quot;; mp[&#x27;c&#x27;]=&quot;dmlkb&quot;; mp[&#x27;d&#x27;]=&quot;enmlc&quot;; mp[&#x27;e&#x27;]=&quot;fonmd&quot;; mp[&#x27;f&#x27;]=&quot;gpone&quot;; mp[&#x27;g&#x27;]=&quot;hqpof&quot;; mp[&#x27;h&#x27;]=&quot;irqpg&quot;; mp[&#x27;i&#x27;]=&quot;rqh&quot;; mp[&#x27;j&#x27;]=&quot;abkts&quot;; mp[&#x27;k&#x27;]=&quot;abclutsj&quot;; mp[&#x27;l&#x27;]=&quot;bcdmvutk&quot;; mp[&#x27;m&#x27;]=&quot;cdenwvul&quot;; mp[&#x27;n&#x27;]=&quot;defoxwvm&quot;; mp[&#x27;o&#x27;]=&quot;efgpyxwn&quot;; mp[&#x27;p&#x27;]=&quot;fghqzyxo&quot;; mp[&#x27;q&#x27;]=&quot;ghirzyp&quot;; mp[&#x27;r&#x27;]=&quot;hizq&quot;; mp[&#x27;s&#x27;]=&quot;jkt&quot;; mp[&#x27;t&#x27;]=&quot;jklus&quot;; mp[&#x27;u&#x27;]=&quot;klmvt&quot;; mp[&#x27;v&#x27;]=&quot;lmnwu&quot;; mp[&#x27;w&#x27;]=&quot;mnoxv&quot;; mp[&#x27;x&#x27;]=&quot;nopyw&quot;; mp[&#x27;y&#x27;]=&quot;opqzx&quot;; mp[&#x27;z&#x27;]=&quot;pqry&quot;; int t,flag,flag1; string a,b; cin&gt;&gt;t; while(t--)&#123; flag=0,flag1=0; cin&gt;&gt;a&gt;&gt;b; if(a.size()!=b.size())&#123; cout&lt;&lt;&quot;3&quot;&lt;&lt;endl; continue; &#125; for(int i=0;i&lt;a.size();i++)&#123; if(a[i]!=b[i])&#123; flag=1; break; &#125; &#125; if(flag==0)&#123; cout&lt;&lt;&quot;1&quot;&lt;&lt;endl; continue; &#125; else&#123; for(int i=0;i&lt;a.size();i++)&#123; flag1=0; if(a[i]==b[i])&#123; flag1=1; continue; &#125; if(a[i]!=b[i])&#123; for(int j=0;j&lt;mp[a[i]].size();j++)&#123; if(mp[a[i]][j]==b[i])&#123; flag1=1; break; &#125; &#125; &#125; if(flag1==0)&#123; break; &#125; &#125; if(flag1==1)&#123; cout&lt;&lt;&quot;2&quot;&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;&quot;3&quot;&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125;方法二：#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; while(n--)&#123; string s1,s2;int flag1=0,flag2=0; cin&gt;&gt;s1&gt;&gt;s2; if(s1.length()!=s2.length())&#123; cout&lt;&lt;3&lt;&lt;endl; &#125;else&#123; for(int i=0;i&lt;s1.length();i++)&#123; if(s1[i]==s2[i])&#123; &#125;else if((s1[i]+10)==s2[i]||(s1[i]+1)==s2[i]||(s1[i]+9)==s2[i]||(s1[i]+8)==s2[i]||(s1[i]-1)==s2[i]||(s1[i]-9)==s2[i]||(s1[i]-10)==s2[i]||(s1[i]-8)==s2[i])&#123; //这就是用的方法二 //((s1[i]-&#x27;a&#x27;+10)==s2[i])这样不对，因为前者是一个相对于字符a的便移数字 flag1=1; &#125;else&#123; flag2=1;break; &#125; &#125; if(flag2)&#123; cout&lt;&lt;3&lt;&lt;endl; &#125;else&#123; if(flag1)cout&lt;&lt;2&lt;&lt;endl; else cout&lt;&lt;1&lt;&lt;endl; &#125; &#125; &#125;//cout&lt;&lt;(char)(&#x27;a&#x27;+10) 这样会输出字母 //cout&lt;&lt;endl&lt;&lt;(&#x27;a&#x27;-0)&lt;&lt;endl; 会输出数组97 //int a=48;char c=a+&#x27;0&#x27;;//cout&lt;&lt;endl&lt;&lt;(97+&#x27;0&#x27;); 这样并不能输出英文字母 &#125; C 题解：要求的是把每首歌放完最少需要按几下按钮，你的初始位置在第一首歌，放完后你可以选择向前放（就是重新播放当前的歌），或者向后放(就是从第一首到第三首），另外他放完一首歌之后自动跳到下一首歌，最后一首放完了跳到第一首歌 所以只需用两个函数分别计算从当前歌跳至下一首目标歌曲时，往前跳和往后跳所需次数，取min记录，最后求和即是答案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273方法一：简洁#include&lt;iostream&gt;using namespace std;int main()&#123; int t; int n,k; long long a,b; long long sum; cin&gt;&gt;t; while(t--)&#123; sum=0; cin&gt;&gt;n&gt;&gt;k; cin&gt;&gt;a; for(int i=1;i&lt;k;i++)&#123; cin&gt;&gt;b; if(a==b)&#123; sum=sum+1; &#125; else if(a&lt;b)&#123; sum=sum+min(b-a-1,n+a-b+1); //这地方要分a和b的关系分别讨论一次答案， //此时-1 +1的问题不能忽视，就是因为他放完一首歌后会自动跳到下一首歌 &#125; else&#123; sum=sum+min(a-b+1,n+b-a-1); &#125; a=b; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;方法二：#include&lt;iostream&gt;using namespace std;const int maxn=1010;int main()&#123; int n; cin &gt;&gt;n; while(n--)&#123; long long a,b;long long ans=0; long long c[maxn]; cin&gt;&gt;a&gt;&gt;b; for(int i=0;i&lt;b;i++)&#123; cin&gt;&gt;c[i]; &#125; for(int i=1;i&lt;b;i++)&#123; if((c[i]-c[i-1])==1||(c[i-1]==a&amp;&amp;c[i]==1))&#123; &#125;else&#123; long long tmp=0; if(c[i-1]&gt;c[i])&#123; tmp= c[i-1]-c[i]+1; ans+=min(tmp,a-c[i-1]+c[i]-1); &#125;else if(c[i-1]&lt;c[i])&#123; tmp=c[i]-c[i-1]-1; ans+=min(tmp,a-c[i]+c[i-1]+1); &#125;else&#123; ans+=1; &#125;// 10 8 // 1 9 10 1 2 1 1 2// //3 2 1 //cout&lt;&lt;&quot;cishi:&quot;&lt;&lt;ans&lt;&lt;endl; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"xss","slug":"xss","date":"2020-04-05T07:06:00.000Z","updated":"2022-02-26T03:52:52.556Z","comments":true,"path":"2020/04/05/xss/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/05/xss/","excerpt":"","text":"原理练习https://www.cnblogs.com/r00tuser/p/7407459.html","categories":[{"name":"网络安全","slug":"网络安全","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[],"author":"aoyuehan"},{"title":"二进制状态压缩","slug":"二进制状态压缩","date":"2020-04-04T08:28:00.000Z","updated":"2022-02-26T03:52:51.863Z","comments":true,"path":"2020/04/04/二进制状态压缩/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"如何进行状压？对于一个01数组a[],我们用一个二进制数替代它。例如，a[]&#x3D;{0,1,1,0,0}，则进行状态压缩后的a&#x3D;01100&#x3D;12，这样一来空间就缩小了许多。当然，二进制状压所能压缩的远不止5位二进制数。但是在进行压缩时，我们也要注意压缩后的数字不能超过int(long long)的范围。反过来说，在看到一些题目中n&lt;&#x3D;31或m&lt;&#x3D;31时，我们可以很自然的想到二进制状态压缩。 360笔试题-找所有连续子序列的偶串个数一个字符串S是偶串当且仅当S中的每一个字符都出现了偶数次。如字符串”aabccb”是一个偶串，因为字符a,b,c都出现了两次。而字符串”abbcc”不是偶串，因为字符a出现了一次。 现在给出一个长度为n的字符串T&#x3D;t1,t2,t3,…,tn。字符串的子串为其中任意连续一段。T长度为1的子串有n个，长度为2的子串有n-1个，以此类推，T一共有n(n+1)&#x2F;2个子串。给定T，你能算出它有多少个子串是偶串吗？ 输入：输入一个字符串T，T中只有小写字母。T的长度不超过100000。 输出：输出一个数，T的所有子串中偶串的个数。 解答： 要点：相同元素异或为0；利用移位运算来保存各个字符的奇偶性 过程： 根据偶串各个元素异或操作为零，采用二进制数来保存各个字符的奇偶性，一旦二进制数出现相等，即偶串出现，若多次出现相同的二进制数，则存在偶串相连的情况，故采用类似前缀和的方式来计算偶串。 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;map&gt; #define maxn 100009using namespace std;char s[maxn];map&lt;int, int&gt;mp;//记录cur代表的子串出现的次数int n;int main()&#123; scanf(&quot;%s&quot;, s); n = strlen(s); mp[0] = 1; int cur = 0; long long ans = 0; for (int i = 0; i &lt; n; i++)&#123; int x = s[i] - &#x27;a&#x27;; cur ^= (1 &lt;&lt; x); ans += mp[cur]; mp[cur]++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 互不侵犯可以明确的一点是：这是一道状压dp因为这篇文章主要讲的是状态压缩，所以dp方程就不具体推了我们建立dp[i][j][k]来存储第i行第j个状态，且放了k个国王的方案数 第一步，列出所有可能成立的单行状态因为国王可以攻击到左右两格，所以可以通过上面的(a&amp;(a&lt;&lt;1))||(a&amp;(a&gt;&gt;1))来排除一些不可能成立的状态我们将所有成立的状态存储到一个数组里便于取用注意全0状态也算进去 第二步，初始化先列出第一行每一种状态的方案数，以便于后面的dp使用 第三部：动规枚举i,j,l,k，这里l指第i-1行的状态是第l种，j指第i行的状态是第j种，并且排除掉上下行的国王可以互相攻击到的情况用a代表j状态，b代表l状态排除方法：if((a&amp;b)||(a&amp;(b&lt;&lt;1))||(a&amp;(b&gt;&gt;1)))continue;接下来再通过dp[i][j][k]+&#x3D;dp[i-1][l][k-sum(a)]的dp方程求出最终要求的方案数，这里sum(a)指a在二进制下1的个数 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int n,k,a,b,tot,use[1001];long long dp[11][1001][101];long long ans;int sum(int s)&#123; int num=0; while(s)&#123; if(s%2)num++; s/=2; &#125; return num;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;=(1&lt;&lt;n)-1;i++) if(!(i&amp;(i&gt;&gt;1)))use[++tot]=i; for(int i=1;i&lt;=tot;i++)&#123; dp[1][i][sum(use[i])]=1; &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=1;j&lt;=tot;j++)&#123; for(int t=1;t&lt;=tot;t++)&#123; a=use[j],b=use[t]; if((a&amp;b)||(a&amp;(b&lt;&lt;1))||(a&amp;(b&gt;&gt;1)))continue; for(int p=sum(a);p&lt;=k;p++)&#123; dp[i][j][p]+=dp[i-1][t][p-sum(a)]; &#125; &#125; &#125; &#125; for(int i=1;i&lt;=tot;i++)&#123; ans+=dp[n][i][k]; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"Codejam-Qualification-Round-2020","slug":"Codejam-Qualification-Round-2020","date":"2020-04-04T07:34:23.000Z","updated":"2022-02-26T03:52:51.218Z","comments":true,"path":"2020/04/04/Codejam-Qualification-Round-2020/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/04/Codejam-Qualification-Round-2020/","excerpt":"","text":"Vestigium题意：求主对角线的值，然后求出一行或者一列有重复数的行数列数之和。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;const int maxn=110;int main()&#123; int n,cnt=1; cin&gt;&gt;n; while(n--)&#123; int mx[maxn][maxn]; int N,rows=0,cols=0;long long ans=0; cin&gt;&gt;N; for(int i=0;i&lt;N;i++)&#123; map&lt;int,int&gt;mp;int flag=0; for(int j=0;j&lt;N;j++)&#123; cin&gt;&gt;mx[i][j]; if(mp[mx[i][j]])flag=1;//判断本行是否出现过这个数 mp[mx[i][j]]=1; &#125; if(flag)rows++; &#125; for(int j=0;j&lt;N;j++)&#123; map&lt;int,int&gt;mp;int flag=0; for(int i=0;i&lt;N;i++)&#123; if(i==j)ans+=mx[i][j];//累加得到主对角线的总和 if(mp[mx[i][j]])flag=1;//哦按段该列是否出现该数 mp[mx[i][j]]=1; &#125; if(flag)cols++; &#125; cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cnt++&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;&#x27; &#x27;&lt;&lt;rows&lt;&lt;&#x27; &#x27;&lt;&lt;cols&lt;&lt;endl; &#125;&#125; Nesting Depth题意：加括号，如果这一位为2，那么在2的的两边要加上2个括号，求最小的加括号的情况下的结果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071方法一：求01串#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int maxn=110;int main()&#123; int n,cnt=1; cin&gt;&gt;n; while(n--)&#123; string s; cin&gt;&gt;s; int start=0,end=s.length(),run=0; cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cnt++&lt;&lt;&quot;: &quot;; while(run!=end)&#123; if((s[run]-&#x27;0&#x27;)==0)cout&lt;&lt;&quot;0&quot;; else&#123;//找到一个1110的10断层，输出（1..） while((s[run]-&#x27;0&#x27;)==1&amp;&amp;run!=end)&#123; run++; &#125; cout&lt;&lt;&#x27;(&#x27;; for(int i=start;i&lt;run;i++)cout&lt;&lt;&#x27;1&#x27;; cout&lt;&lt;&#x27;)&#x27;; run--;//--只是为了下面n++ 简单操作而已 &#125; run++; start=run;//此时更新start要放在run之后才可以 &#125; cout&lt;&lt;endl; &#125;&#125; 方法二：求所有的结果，不用分块来做，只需要考虑相邻两个数之间的断层大小即可#include&lt;iostream&gt;using namespace std;int main() &#123; string s; long long n; cin&gt;&gt;n; long long k=1; while(k&lt;=n) &#123; cin&gt;&gt;s; long long sum=0;//sum表示上一次的值的大小 printf(&quot;Case #%lld: &quot;,k); k++; for(long long i=0; i&lt;s.length(); i++) &#123; if(s[i]&gt;=&#x27;0&#x27;&amp;&amp;s[i]&lt;=&#x27;9&#x27;) &#123;//只考虑相邻两位的大小关系就好了，而不是像那种分块找到块的断层来做 if(sum&lt;s[i]-&#x27;0&#x27;) &#123; for(int j=0; j&lt;(s[i]-&#x27;0&#x27;)-sum; j++) &#123; printf(&quot;(&quot;);//打印两个数之间的断层个括号 &#125; sum=s[i]-&#x27;0&#x27;; &#125; else if(sum&gt;s[i]-&#x27;0&#x27;) &#123; for(int j=0; j&lt;sum-(s[i]-&#x27;0&#x27;); j++) &#123; printf(&quot;)&quot;); &#125; sum=s[i]-&#x27;0&#x27;;//更新一下sum &#125; &#125; printf(&quot;%c&quot;,s[i]); &#125; while(sum&gt;0)printf(&quot;)&quot;),sum--; printf(&quot;\\n&quot;); &#125; return 0;&#125; 安排时间给你n个时间段，每个时间段代表一个任务，给两个人安排任务，做到一个人这一个时间段干一个活动，求安排的顺序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364方法一：只能过一部分#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=24*60+10;struct qujian&#123; int s,e; int id;&#125;qu[1010];bool cmp(qujian a,qujian b)&#123; if(a.s==b.s)&#123; return a.e&lt;b.e; &#125; return a.s&lt;b.s;&#125;int main()&#123; int n,cnt=1; cin&gt;&gt;n; while(n--)&#123; int anss[maxn]; int mx[maxn];int xiabiao=0; memset(mx,0,sizeof(mx)); int t,tmpa,tmpb; cin&gt;&gt;t; for(int i=0;i&lt;t;i++)&#123; cin&gt;&gt;tmpa&gt;&gt;tmpb; qu[xiabiao].s=tmpa; qu[xiabiao].id=i; qu[xiabiao++].e=tmpb; for(int i=tmpa;i&lt;tmpb;i++)&#123; mx[i]++; &#125; &#125; cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cnt++&lt;&lt;&quot;: &quot;; int flag=0; for(int i=0;i&lt;=1442;i++)&#123; if(mx[i]&gt;2)&#123;//不能安排任务的条件不对 flag=1;break; &#125; &#125; if(flag)&#123; cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl; &#125;else&#123; sort(qu,qu+xiabiao,cmp); int lastend=0,lastid=0,lastfan=1; for(int i=0;i&lt;xiabiao;i++)&#123; if(qu[i].s&gt;=lastend)anss[qu[i].id]=anss[lastid]; else anss[qu[i].id]=lastfan; lastend=qu[i].e; lastid=qu[i].id; if(anss[qu[i].id]==1)lastfan=0; else lastfan=1; &#125; for(int i=0;i&lt;xiabiao;i++)&#123; if(anss[i]==0)cout&lt;&lt;&quot;J&quot;; else cout&lt;&lt;&quot;C&quot;; &#125; cout&lt;&lt;endl; &#125; &#125;&#125; 方法一错误的原因，不能安排任务的条件判断错误了： 方法二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;struct node &#123; long long s,e; long long item;//item代表原来这个段相对于其他段的顺序 &#125; a[1010];bool cmp(node a,node b) &#123; if(a.s!=b.s) return a.s&lt;b.s; else return a.e&lt;b.e;&#125;char s[10000];int main() &#123; long long t,n; cin&gt;&gt;t; long long k=1; while(k&lt;=t) &#123; scanf(&quot;%lld&quot;,&amp;n); for(long long i=0; i&lt;n; i++)scanf(&quot;%lld%lld&quot;,&amp;a[i].s,&amp;a[i].e),a[i].item=i; sort(a,a+n,cmp); int f=0;//f来记录是否有区间覆盖而不能安排任务的情况 long long c=0,j=0;//c记录C是否是第一次，j同理 for(int i=0; i&lt;n; i++) &#123; f=0; if(c==0)c=a[i].e,s[a[i].item]=&#x27;C&#x27;,f=1; else if(a[i].s&gt;=c)c=a[i].e,s[a[i].item]=&#x27;C&#x27;,f=1; //j的这个起始和上一个j的末尾相比，若果大于说明可以，否则不行 else if(c&amp;&amp;j==0)j=a[i].e,s[a[i].item]=&#x27;J&#x27;,f=1; else if(a[i].s&gt;=j)j=a[i].e,s[a[i].item]=&#x27;J&#x27;,f=1; //如果有一次不能安排上任务，此时就就安排不上任务了 if(f==0)break; &#125; s[n]=&#x27;\\0&#x27;; if(f==0)printf(&quot;Case #%lld: IMPOSSIBLE\\n&quot;,k); else printf(&quot;Case #%lld: %s\\n&quot;,k,s); k++; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"ICPC Asia Taipei-Hsinchu Regional 2019","slug":"ICPC-Asia-Taipei-Hsinchu-Regional-2019","date":"2020-04-03T11:48:52.000Z","updated":"2022-02-26T03:52:52.474Z","comments":true,"path":"2020/04/03/ICPC-Asia-Taipei-Hsinchu-Regional-2019/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/04/03/ICPC-Asia-Taipei-Hsinchu-Regional-2019/","excerpt":"","text":"QLU的一题 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int maxn=200010; int s[maxn];typedef long long ll;ll mod=1000000007;ll geshu(ll n)&#123; return (n*(n+1)/2)%mod; &#125;int main()&#123; int n; ll ans=0; cin&gt;&gt;n; string s; cin&gt;&gt;s;int cnt=0,tmp; for(int i=0;i&lt;s.length();i++)&#123; tmp=s[i]-&#x27;0&#x27;; if(tmp)&#123; cnt=i+1;//cnt记录最右边1的位置 &#125; //cout&lt;&lt;&quot;cishi tmp:&quot;&lt;&lt;tmp&lt;&lt;&quot;cishi cnt:&quot;&lt;&lt;cnt&lt;&lt;endl; ans=(ans+((geshu(i+1)-geshu(i+1-cnt))*cnt%mod))%mod; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; B c E F G 异或 简单方法： 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int T;ll n;int main()&#123; cin&gt;&gt;T; while(T--) &#123; cin&gt;&gt;n; ll ans=0; for(ll i=1;i&lt;=n;++i)if((n*n)%i==0) &#123; ll y=n+n*n/i; ll x=n+i; ll a=x^y; ans=max(ans,a); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; C- Are They All Integers? 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[55];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i]); bool yes=1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j)if(j!=i) for(int k=1;k&lt;=n;++k)if(k!=i&amp;&amp;k!=j) &#123; int x=abs(a[i]-a[j]); if(x%a[k])yes=0; &#125; if(yes)puts(&quot;yes&quot;); else puts(&quot;no&quot;);&#125; D-Tapioka 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;string s;int main()&#123; bool has=0; while(cin&gt;&gt;s) &#123; if(s==&quot;bubble&quot;||s==&quot;tapioka&quot;)continue; has=1; cout&lt;&lt;s&lt;&lt;&quot; &quot;; &#125; if(!has)puts(&quot;nothing&quot;);&#125; 选和不选的问题,二进制子集题意：给定一个m×n的01矩阵，然后选取其中的某些行，确保每一列都至少有一个1在选中的行中，求最少选中的行数。的01矩阵，然后选取其中的某些行，确保每一列都至少有一个1在选中的行中，求最少选中的行数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384纯暴力dfs搜索，每一行都有选和不选两种状态：#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;string s[1000000];//代表这n列m行的矩阵 long long sum=0,count;//count代表dfs时m中有多少个1 long long n,m;long long ma=100000000;//最小的答案 int a[501];void dfs(int i)&#123;//也就是说这m行，有选和不选两种方式 if(count==n)&#123; if(sum&lt;ma)ma=sum; &#125; if(sum&gt;=ma)return ;//如果此时sum比已经求出来的答案要大了，再往下求没有意义了，剪枝 for(int j=i+1;j&lt;m;j++)&#123; for(int k=0;k&lt;s[j].length();k++)if(s[j][k]==&#x27;1&#x27;&amp;&amp;a[k]==0)count++,a[k]++; else if(s[j][k]==&#x27;1&#x27;)a[k]++; sum+=1; dfs(j); for(int k=0;k&lt;s[j].length();k++)if(s[j][k]==&#x27;1&#x27;&amp;&amp;a[k]==1)count--,a[k]--; else if(s[j][k]==&#x27;1&#x27;)a[k]--;//通过这句把状态恢复成原来没有走这一步的状态 sum-=1; &#125;&#125;int main()&#123; long long t; cin&gt;&gt;t; while(t--)&#123; ma=100000000; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++)cin&gt;&gt;s[i]; sum=0; for(int i=0;i&lt;m;i++)&#123;//这里进行m-1次的情况就是为了i之前不选的情况 //比如，i为0，则进行下面语句是为了求出选第0行的情况， //i=1，进行下面语句是为了求出不选第0行但是选第一行的所有情况 sum=1; memset(a,0,sizeof(a)); count=0; for(int j=0;j&lt;s[i].length();j++)if(s[i][j]==&#x27;1&#x27;)count++,a[j]=1;//这个a就是一个 dfs(i); &#125; if(ma!=100000000) cout&lt;&lt;ma&lt;&lt;endl; else cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; &#125; return 0;&#125;方法二：二进制枚举子集，暴力判断#include &lt;bits/stdc++.h&gt;using namespace std;bitset&lt;500&gt; number[30];char str[1001];int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while (T--)&#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=0;i&lt;m;++i)&#123; scanf(&quot;%s&quot;,str); number[i]=bitset&lt;500&gt;(str);//用str来初始化bitset &#125; int len=1&lt;&lt;m;//len就是这个子集的总数 int ans=m+1; for (int i=1;i&lt;len;++i)&#123;//枚举子集 如t=101，则取第一个和第三个集合作为要选择的集合 int t=i; int s=0; bitset&lt;500&gt; now(0); for (int j=0;j&lt;m &amp;&amp; t&gt;0;++j)&#123; if (t&amp;1)&#123; now=now|number[j]; s++;&#125;//如果这个子集t的这一位为1， //那么或上答案中的那个子集，然后数量++，计算或上的子集数 t&gt;&gt;=1;//求下一位 &#125; if (now.count()==n) ans=min(ans,s);//如果now中1的个数为n，记录答案 &#125; if (ans==m+1) printf(&quot;-1\\n&quot;); else printf(&quot;%d\\n&quot;,ans); &#125;&#125; K 合并石子 优先队列12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; ios::sync_with_stdio(false); int T; cin &gt;&gt; T; while (T--) &#123; int n; cin &gt;&gt; n; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; que; //greater 算子在优先队列中小的在队头，大的在队尾（优先队列的默认排序是从大到小） //在sort（sort中默认从小到大）中greater表示内置类型从大到小排序，less表示内置类型从小到大排序。 for (int i = 0; i &lt; n; ++i) &#123; int x; cin &gt;&gt; x; que.push(x); &#125; int sum = 0; while (!que.empty()) &#123; if (que.size() == 1) &#123; cout &lt;&lt; sum &lt;&lt; endl; break; &#125; int x = que.top();//取队列最小的两个数出队 que.pop(); int y = que.top(); que.pop(); sum += x + y; que.push(x + y);//注意要重新加进去 &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"剑指offer 第三章 代码质量","slug":"剑指offer-第三章-高质量的代码","date":"2020-03-31T12:42:00.000Z","updated":"2022-02-26T03:52:50.972Z","comments":true,"path":"2020/03/31/剑指offer-第三章-高质量的代码/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/31/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81/","excerpt":"","text":"3.1面试官谈代码质量 3.2代码规范性3.3代码完整性 剑指Offer（16）：数值的整数次方题目给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 思路 当指数为负数的时候，可以先对指数求绝对值，然后算出次方的结果之后再取倒数。如果底数为0，则直接返回0。此时的次方在数学上是没有意义的。 除此之外，我们要注意：由于计算机表示小数（包括float和double型小数）都有误差，我们不能直接用等号（&#x3D;&#x3D;）判断两个小数是否相等。如果两个小数的差的绝对值很小，比如小于0.0000001，就可以认为它们相等。 在计算次方的时候，除了简单的遍历，我们可以使用如下公式进行计算，来减少计算量： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: double Power(double base, int exponent) &#123; if(equal(base, 0.0))&#123; return 0.0; &#125; unsigned int absExponent = 0; if(exponent &gt; 0)&#123; absExponent = (unsigned int)(exponent); &#125; else&#123; absExponent = (unsigned int)(-exponent); &#125; double result = PowerWithUnsignedExponent(base, absExponent); if(exponent &lt; 0)&#123; result = 1.0 / result; &#125; return result; &#125;private: bool equal(double num1, double num2)&#123; if(num1 - num2 &gt; -0.0000001 &amp;&amp; (num1 - num2) &lt; 0.0000001)&#123; return true; &#125; else&#123; return false; &#125; &#125; double PowerWithUnsignedExponent(double base, unsigned int exponent)&#123; if(exponent == 0)&#123; return 1; &#125; if(exponent == 1)&#123; return base; &#125; double result = PowerWithUnsignedExponent(base, exponent &gt;&gt; 1); result *= result;//如果是7的话就是（base）^3*3然后在乘一次base if(exponent &amp; 0x1 == 1)&#123; result *= base; //为奇数的时候 &#125; return result; &#125;&#125;; 剑指Offer（17） 打印1到最大的n位数 123456789101112131415首先计算出n位数的最大十进制数，然后利用循环输出从1到最大的n位数。public void printToMaxOfNDigits(int n)&#123; long number = 1; int i = 0; while(i &lt; n)&#123; //利用while循环计算出比n位十进制多1的数 number *= 10; ++i; &#125; for (long j = 1; j &lt; number; j++) &#123; //利用for循环输出从1到最大的n位数 System.out.print(j + &quot; &quot;); if(j%5 == 0)&#123; System.out.println(); &#125; &#125;&#125; 用字符串进行模拟大数运算鲁棒性好的思路： 因为上面分析可知我们在遇到比长整型还大的数时，上面的代码是不能成功执行的，即基本类型已经存储不下的数字。这时我们需要考虑用字符串或者数组来表示大数。 用字符串表示数字的时候，最直观的方法就是字符串里每个字符都是‘0’到‘9’之间的某一个字符，用来表示数字中的一位。因为最大的是n位的，因此我们需要一个长度为n+1的字符串（字符串中最后一个是结束符号‘\\0’。当实际数字不够n位的时候，在字符串的前半部分补0）。 首先我们把字符串中的每一个数字都初始化为‘0’，然后每一次为字符串表示的数字加1，再打印出来。故我们只需要做两件事：一是在字符串表达数字上模拟加法，二是把字符串表达的数字打印出来。 在字符串表达数字上模拟加法，我们首先设置是否溢出标识，是否进位标识，以及取得字符数组长度，遍历这个字符数组，在末尾进行+1操作，如果末尾字符在+1后变为不小于10的数字，我们将末尾减去10加上‘0’字符赋值为末位，进位标识设置为1，在循环次位时+1，然后再判断是否为不小于10，是的话重复上面的步骤。直到判断高位是不是不小于10，是的话字符数组溢出；如果末尾字符在+1后是小于10的数字，直接加上‘0’赋值给末尾，跳出当前循环，返回没有溢出。 在字符串表达的数字打印出来方法时，没有什么特别，直接利用for循环遍历输出字符数组，但是要从高位第一个不是0的开始输出。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//打印1到最大的n位数public void printToMaxOfDigits(int n)&#123; if(n &lt;= 0)&#123; System.out.println(&quot;输入的n没有意义&quot;); return; &#125; //声明字符数组,用来存放一个大数 char number[] = new char[n]; for (int i = 0; i &lt; number.length; ++i) &#123; //放字符0进行初始化 number[i] = &#x27;0&#x27;; &#125; while(!incrementNumber(number))&#123; //如果大数自加，直到自溢退出 printNumber(number); //打印大数 &#125;&#125;//自加private boolean incrementNumber(char[] number) &#123; boolean isOverflow = false; //判断是否溢出 int nTakeOver = 0; //判断是否进位 int nLength = number.length; for (int i = nLength - 1; i &gt;= 0 ; --i) &#123; int nSum = number[i] - &#x27;0&#x27; + nTakeOver; //取到第i位的字符转换为数字 +进位符 if(i == nLength - 1)&#123; //末尾自加1 ++nSum; &#125; if(nSum &gt;= 10)&#123; if(i == 0)&#123; isOverflow = true; &#125;else&#123; nSum -= 10; nTakeOver = 1; number[i] = (char) (&#x27;0&#x27; + nSum); &#125; &#125;else&#123; number[i] = (char) (nSum + &#x27;0&#x27;); break; &#125; &#125; return isOverflow;&#125;//打印数字private void printNumber(char[] number) &#123; boolean isBeginning0 = true; int nLength = number.length; for (int i = 0; i &lt; nLength; ++i) &#123; if(isBeginning0 &amp;&amp; number[i]!=&#x27;0&#x27;)&#123; isBeginning0 = false; &#125; if(!isBeginning0)&#123; System.out.print(number[i]); &#125; &#125; System.out.println();&#125; 递归解决打印从1~n 把问题转化为数字排列的解法，使用递归可以使代码简洁明了。即：如果在所有的数字前面补0的话，就会发现n位所有的十进制数其实就是n个从0到9的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到了所有的十进制数。在打印时，数字排在前面的0不打印。 全排列递归实现最容易。数字的每一位都可能是0到9的一个数，然后设置下一位。递归结束的条件就是我们已经设置了数字的最后一位。 1234567891011121314151617181920212223242526272829303132333435363738394041//打印1到最大的n位数的主方法public void printToMaxOfDigits(int n)&#123; if(n &lt;= 0)&#123; System.out.println(&quot;输入的n没有意义&quot;); return; &#125; char number[] = new char[n]; for (int i = 0; i &lt; number.length; i++) &#123; number[i] = &#x27;0&#x27;; &#125; for (int i = 0; i &lt; 10; ++i) &#123; number[0] = (char) (i + &#x27;0&#x27;); printToMaxOfNDigitsRecursively(number, n, 0); &#125; &#125;//利用递归实现1到最大的n位数的全排列public void printToMaxOfNDigitsRecursively(char[] number, int n, int index) &#123; if(index == n - 1)&#123; printNumber(number); return; &#125; for (int i = 0; i &lt; 10; ++i) &#123; number[index + 1] = (char) (i + &#x27;0&#x27;); printToMaxOfNDigitsRecursively(number, n, index + 1); &#125;&#125; //输出private void printNumber(char[] number) &#123; boolean isBeginning0 = true; int nLength = number.length; for (int i = 0; i &lt; nLength; ++i) &#123; if(isBeginning0 &amp;&amp; number[i]!=&#x27;0&#x27;)&#123; isBeginning0 = false; &#125; if(!isBeginning0)&#123; System.out.print(number[i]); &#125; &#125; System.out.println();&#125; 剑指Offer（18） 删除链表中的节点 在O(1)时间内删除链表节点.给定单向链表的头指针和一个节点指针, 定义一个函数在O(1)时间内删除该节点.链表节点定义如下: 12345678 public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 思路 常规思路: 删除一个节点, 让待删节点的前一个节点指向待删节点的下一个节点 寻找待删节点的前一个节点的时间复杂度是O(n),不满足O(1)的要求 另一种思路: 将待删节点的value改成待删节点的下一个节点的value, 然后将待删节点指向下一个节点的下一个节点. 上面这种思路不需要寻找待删节点的上一个节点, 时间复杂度是O(1) 链表问题特别要注意的是: 末尾节点; 只有一个节点的链表 待删节点为末尾节点时, 只能从头开始找到末尾节点的上一个节点, 将该节点指向null 链表只有一个节点时, 直接将头指针指向null 123456789101112131415161718192021222324252627282930313233343536373839public class MST18 &#123; public static void main(String[] args) &#123; &#125; public static class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125; &#125; public static void deleteNode(ListNode pHead, ListNode pToBeDeleted) &#123; // 健壮性判断 if(pHead == null || pToBeDeleted == null) throw new RuntimeException(&quot;链表为空或未指定待删除节点&quot;); // 正常执行 /* 1. sp:链表只有一个节点, 头指针指向null即可 2. sp:删除最后一个节点, 找出倒数第二个节点并让该节点指向null 3. 令待删节点的value等于待删节点下一个节点的value, 并令待删节点指向下一个节点的下一个节点 */ //1. if(pHead.next == null) pHead = null; //2. ListNode temp = pHead; if(pToBeDeleted.next == null)&#123; while(temp.next != pToBeDeleted) temp = temp.next; temp.next = null; &#125; //3. temp = pToBeDeleted.next; pToBeDeleted.val = temp.val; pToBeDeleted.next = temp.next; &#125;&#125; 上题的变式题目 删除链表中重复的节点 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。 思路删除重复结点，只需要记录当前结点前的最晚访问过的不重复结点pPre、当前结点pCur、指向当前结点后面的结点pNext的三个指针即可。如果当前节点和它后面的几个结点数值相同，那么这些结点都要被剔除，然后更新pPre和pCur；如果不相同，则直接更新pPre和pCur。 需要考虑的是，如果第一个结点是重复结点我们该怎么办？这里我们分别处理一下就好，如果第一个结点是重复结点，那么就把头指针pHead也更新一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if(pHead == NULL)&#123; return NULL; &#125; // 指向当前结点前最晚访问过的不重复结点 ListNode* pPre = NULL; // 指向当前处理的结点 ListNode* pCur = pHead; // 指向当前结点后面的结点 ListNode* pNext = NULL; while(pCur != NULL)&#123; // 如果当前结点与下一个结点相同 if(pCur-&gt;next != NULL &amp;&amp; pCur-&gt;val == pCur-&gt;next-&gt;val)&#123; pNext = pCur-&gt;next; // 找到不重复的最后一个结点位置 while(pNext-&gt;next != NULL &amp;&amp; pNext-&gt;next-&gt;val == pCur-&gt;val)&#123; pNext = pNext-&gt;next; &#125; // 如果pCur指向链表中第一个元素，pCur -&gt; ... -&gt; pNext -&gt;... // 要删除pCur到pNext, 将指向链表第一个元素的指针pHead指向pNext-&gt;next。 if(pCur == pHead)&#123; pHead = pNext-&gt;next; &#125; // 如果pCur不指向链表中第一个元素，pPre -&gt; pCur -&gt;...-&gt;pNext -&gt;... // 要删除pCur到pNext，即pPre-&gt;next = pNext-&gt;next else&#123; pPre-&gt;next = pNext-&gt;next; &#125; // 向前移动 pCur = pNext-&gt;next; &#125; // 如果当前结点与下一个结点不相同 else&#123; pPre = pCur; pCur = pCur-&gt;next; &#125; &#125; return pHead; &#125;&#125;; 剑指Offer（19）：正则表达式匹配 题目请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配。 思路这道题有些绕，需要好好思考下。 我们先来分析下如何匹配一个字符，现在只考虑字符’.’，不考虑’*’看一下： 如果字符串和模式串的当前字符相等，那么我们继续匹配它们的下一个字符；如果模式串中的字符是’.’，那么它可以匹配字符串中的任意字符，我们也可以继续匹配它们的下一个字符。 接下来，把字符’*’考虑进去，它可以匹配任意次的字符，当然出现0次也可以。 我们分两种情况来看：（1）模式串的下一个字符不是’‘，也就是上面说的只有字符’.’的情况。如果字符串中的第一个字符和模式串中的第一个字符相匹配，那么字符串的模式串都向后移动一个字符，然后匹配剩余的字符串和模式串。如果字符串中的第一个字符和模式中的第一个字符不相匹配，则直接返回false。（2）模式串的下一个字符是’‘，此时就要复杂一些。 因为可能有多种不同的匹配方式。 选择一：无论字符串和模式串当前字符相不相等，我们都将模式串后移两个字符，相当于把模式串中的当前字符和’‘忽略掉，因为’‘可以匹配任意次的字符，所以出现0次也可以。 选择二：如果字符串和模式串当前字符相等，则字符串向后移动一个字符。而模式串此时有两个选择：1、我们可以在模式串向后移动两个字符，继续匹配；2、也可以保持模式串不变，这样相当于用字符’‘继续匹配字符串，也就是模式串中的字符’‘匹配字符串中的字符多个的情况。 用一张图表示如下： 上图所示，当匹配进入状态2，并且字符串中的字符是’a’时，我们有两个选择：可以进入状态3（在模式串向后移动两个字符），也可以回到状态2（模式串保持不变）。除此之外，还要注意对空指针的处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: bool match(char* str, char* pattern) &#123; // 指针为空，返回false if(str == NULL || pattern == NULL)&#123; return false; &#125; return matchCore(str, pattern); &#125;private: bool matchCore(char* str, char* pattern)&#123; // 字符串和模式串都运行到了结尾，返回true if(*str == &#x27;\\0&#x27; &amp;&amp; *pattern == &#x27;\\0&#x27;)&#123; return true; &#125; // 字符串没有到结尾，模式串到了，则返回false // 模式串没有到结尾，字符串到了，则根据后续判断进行，需要对&#x27;*&#x27;做处理 if((*str != &#x27;\\0&#x27; &amp;&amp; *pattern == &#x27;\\0&#x27;))&#123; return false; &#125; // 如果模式串的下一个字符是&#x27;*&#x27;，则进入状态机的匹配 if(*(pattern + 1) == &#x27;*&#x27;)&#123; // 如果字符串和模式串相等，或者模式串是&#x27;.&#x27;，并且字符串没有到结尾，则继续匹配 if(*str == *pattern || (*pattern == &#x27;.&#x27; &amp;&amp; *str != &#x27;\\0&#x27;))&#123; // 进入下一个状态，就是匹配到了一个 return matchCore(str + 1, pattern + 2) || // 保持当前状态，就是继续那这个&#x27;*&#x27;去匹配 matchCore(str + 1, pattern) || // 跳过这个&#x27;*&#x27; matchCore(str, pattern + 2); &#125; // 如果字符串和模式串不相等，则跳过当前模式串的字符和&#x27;*&#x27;，进入新一轮的匹配 else&#123; // 跳过这个&#x27;*&#x27; return matchCore(str, pattern + 2); &#125; &#125; // 如果字符串和模式串相等，或者模式串是&#x27;.&#x27;，并且字符串没有到结尾，则继续匹配 if(*str == *pattern || (*pattern == &#x27;.&#x27; &amp;&amp; *str != &#x27;\\0&#x27;))&#123; return matchCore(str + 1, pattern + 1); &#125; return false; &#125;&#125;; 剑指Offer（20）：表示数值的字符串 题目请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。思路这道题还是比较简单的。表示数值的字符串遵循如下模式：[ sign ] integral-digits[ . [ fractional-digits ] ][ e|E [ sign ]exponential-digits ]其中，(‘[‘和’]’之间的为可有可无的部分)。 在数值之前可能有一个表示正负的’+’或者’-‘。接下来是若干个0到9的数位表示数值的整数部分（在某些小数里可能没有数值的整数部分）。如果数值是一个小数，那么在小数后面可能会有若干个0到9的数位表示数值的小数部分。如果数值用科学记数法表示，接下来是一个’e’或者’E’，以及紧跟着的一个整数（可以有正负号）表示指数。 判断一个字符串是否符合上述模式时，首先看第一个字符是不是正负号。如果是，在字符串上移动一个字符，继续扫描剩余的字符串中0到9的数位。如果是一个小数，则将遇到小数点。另外，如果是用科学记数法表示的数值，在整数或者小数的后面还有可能遇到’e’或者’E’。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123;public: // 数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示， // 其中A和C都是整数（可以有正负号，也可以没有） // 而B是一个无符号整数 bool isNumeric(char* string) &#123;string为一个char类型的数组，所以此时string为一个char类型的指针，指向这个数组的首地址 // 非法输入处理 if(string == NULL || *string == &#x27;\\0&#x27;)&#123; return false; &#125; // 正负号判断 if(*string == &#x27;+&#x27; || *string == &#x27;-&#x27;)&#123; ++string;//此时只能写为++string,意思为这个指针向后移动一次 &#125; bool numeric = true; scanDigits(&amp;string); if(*string != &#x27;\\0&#x27;)&#123; // 小数判断 if(*string == &#x27;.&#x27;)&#123; ++string; scanDigits(&amp;string);//这里传送这个string指针指向的内容，即从string开始的那个剩下的字符串 if(*string == &#x27;e&#x27; || *string == &#x27;E&#x27;)&#123; numeric = isExponential(&amp;string); &#125; &#125; // 整数判断 else if(*string == &#x27;e&#x27; || *string == &#x27;E&#x27;)&#123; numeric = isExponential(&amp;string); &#125; else&#123; numeric = false; &#125; &#125; return numeric &amp;&amp; *string == &#x27;\\0&#x27;; &#125;private: // 扫描数字，对于合法数字，直接跳过 void scanDigits(char** string)&#123; //这里的参数为char类型指针的指针 while(**string != &#x27;\\0&#x27; &amp;&amp; **string &gt;= &#x27;0&#x27; &amp;&amp; **string &lt;= &#x27;9&#x27;)&#123; ++(*string);//这里要这样写才可以 &#125; &#125; // 用来潘达un科学计数法表示的数值的结尾部分是否合法 bool isExponential(char** string)&#123; ++(*string); if(**string == &#x27;+&#x27; || **string == &#x27;-&#x27;)&#123; ++(*string); &#125; if(**string == &#x27;\\0&#x27;)&#123; return false; &#125; scanDigits(string); // 判断是否结尾，如果没有结尾，说明还有其他非法字符串 return (**string == &#x27;\\0&#x27;) ? true : false; &#125;&#125;; 剑指Offer（21）：调整数组顺序使奇数位于偶数前面 题目 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 思路1： 思路2：创建双向队列，遍历数组，奇数前插入，偶数后插入。最后使用assign方法实现不同容器但相容的类型赋值。 1234567891011121314151617181920class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; deque&lt;int&gt; result; int num = array.size(); for(int i = 0; i &lt; num; i++)&#123; if(array[num - i - 1] % 2 == 1)&#123; result.push_front(array[num - i - 1]); &#125; if(array[i] % 2 == 0)&#123; result.push_back(array[i]); &#125; &#125; array.assign(result.begin(),result.end()); &#125;&#125;;tips：void assign(input_iterater start,input_iterater end)//把start到end的值赋值到队列中void assign(size_num,const_val);//给队列复制num个val tips：双端队列的用法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//双向队列#include&lt;deque&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;const int MAX_N = 20;using namespace std;int main()&#123; deque&lt;int&gt; ideq(MAX_N); deque&lt;int&gt;::iterator pos; int i; // 进行赋值 for (i = 0; i &lt; MAX_N; i++) &#123; ideq[i] = i; &#125; // 输出deque for (i = 0; i &lt; MAX_N; i++) &#123; printf(&quot;%d &quot;, ideq[i]); &#125; // 在头部和尾部加入数据 puts(&quot;&quot;); puts(&quot;在头部和尾部加入数据&quot;); ideq.push_back(100); // 尾部 ideq.push_front(101); //头部 // 输出deque的数据 for (pos = ideq.begin(); pos != ideq.end(); pos++) &#123; printf(&quot;%d &quot;, *pos); &#125; puts(&quot;&quot;); //查找 const int FIND_NUMBER = 12; printf(&quot;查找数据%d\\n&quot;, FIND_NUMBER); pos = find(ideq.begin(), ideq.end(), FIND_NUMBER); if (pos != ideq.end()) &#123; printf(&quot;成功找到！ %d\\n&quot;, *pos); &#125; else &#123; printf(&quot;失败！\\n&quot;); &#125; // 在头部和尾部删除数据 puts(&quot;在头部和尾部删除数据&quot;); ideq.pop_back(); ideq.pop_front(); // 再次输出数据 puts(&quot;再次输出数据!&quot;); for (pos = ideq.begin(); pos != ideq.end(); pos++) &#123; printf(&quot;%d &quot;, *pos); &#125; return 0;&#125; 3.4代码的鲁棒性 鲁棒性介绍 剑指Offer（22）：链表中倒数第k个结点 题目输入一个链表，输出该链表中倒数第k个结点。思路 我们可以定义两个指针。第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个指针（走在后面的）指针正好是倒数第k个结点。 效果示意图，以链表总共6个结点，求倒数第3个结点为例： 除此之外，要注意代码的鲁棒性。需要判断传入参数合法性问题。 12345678910111213141516171819202122232425262728293031/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) &#123; if(pListHead == NULL || k == 0)&#123; return NULL; &#125; ListNode *pAhead = pListHead; ListNode *pBehind = pListHead; for(unsigned int i = 0; i &lt; k - 1; i++)&#123; if(pAhead-&gt;next != NULL)&#123; pAhead = pAhead-&gt;next; &#125; else&#123; return NULL; &#125; &#125; while(pAhead-&gt;next != NULL)&#123; pAhead = pAhead-&gt;next; pBehind = pBehind-&gt;next; &#125; return pBehind; &#125;&#125;; 剑指Offer（23）：链表中环的入口结点题目一个链表中包含环，请找出该链表的环的入口结点。思路 可以用两个指针来解决这个问题。先定义两个指针P1和P2指向链表的头结点。如果链表中的环有n个结点，指针P1先在链表上向前移动n步，然后两个指针以相同的速度向前移动。当第二个指针指向的入口结点时，第一个指针已经围绕着揍了一圈又回到了入口结点。 以下图为例，指针P1和P2在初始化时都指向链表的头结点。由于环中有4个结点，指针P1先在链表上向前移动4步。接下来两个指针以相同的速度在链表上向前移动，直到它们相遇。它们相遇的结点正好是环的入口结点。 现在，关键问题在于怎么知道环中有几个结点呢？ 可以使用快慢指针，一个每次走一步，一个每次走两步。如果两个指针相遇，表明链表中存在环，并且两个指针相遇的结点一定在环中。 随后，我们就从相遇的这个环中结点出发，一边继续向前移动一边计数，当再次回到这个结点时，就可以得到环中结点数目了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if(pHead == NULL)&#123; return NULL; &#125; ListNode* meetingnode = MeetingNode(pHead); if(meetingnode == NULL)&#123; return NULL; &#125; // 回环链表结点个数 int nodesloop = 1; // 找到环中结点个数 ListNode* pNode1 = meetingnode; while(pNode1-&gt;next != meetingnode)&#123; pNode1 = pNode1-&gt;next; nodesloop++; &#125; pNode1 = pHead; // 第一个指针向前移动nodesloop步 for(int i = 0; i &lt; nodesloop; i++)&#123; pNode1 = pNode1-&gt;next; &#125; // 两个指针同时移动，找到环入口 ListNode* pNode2 = pHead; while(pNode1 != pNode2)&#123; pNode1 = pNode1-&gt;next; pNode2 = pNode2-&gt;next; &#125; return pNode1; &#125;private: // 使用快慢指针，找到任意的一个环中结点 ListNode* MeetingNode(ListNode* pHead)&#123; ListNode* pSlow = pHead-&gt;next; if(pSlow == NULL)&#123; return NULL; &#125; ListNode* pFast = pSlow-&gt;next; while(pFast != NULL &amp;&amp; pSlow != NULL)&#123; if(pFast == pSlow)&#123; return pFast; &#125; pSlow = pSlow-&gt;next; pFast = pFast-&gt;next; if(pFast != NULL)&#123; pFast = pFast-&gt;next; &#125; &#125; return NULL; &#125;&#125;; 剑指Offer（24）：反转链表题目输入一个链表，反转链表后，输出链表的所有元素。思路 这个很简单，我们使用三个指针，分别指向当前遍历到的结点、它的前一个结点以及后一个结点。 在遍历的时候，做当前结点的尾结点和前一个结点的替换。 1234567891011121314151617181920212223242526/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* ReverseList(ListNode* pHead) &#123; ListNode* pReversedHead = NULL; ListNode* pNode = pHead; ListNode* pPrev = NULL; while(pNode != NULL)&#123; ListNode* pNext = pNode-&gt;next; if(pNext == NULL)&#123; pReversedHead = pNode; &#125; pNode-&gt;next = pPrev; pPrev = pNode; pNode = pNext; &#125; return pReversedHead; &#125;&#125;; 剑指Offer（25）：合并两个排序的链表题目 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 思路 先判断输入的链表是否为空的指针。如果第一个链表为空，则直接返回第二个链表；如果第二个链表为空，则直接返回第一个链表。如果两个链表都是空链表，合并的结果是得到一个空链表。 两个链表都是排序好的，我们只需要从头遍历链表，判断当前指针，哪个链表中的值小，即赋给合并链表指针即可。使用递归就可以轻松实现。 注意鲁棒性，输入空链表的时候的处理结果 12345678910111213141516171819202122232425262728293031/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; //判断指针是否为空 if(pHead1 == NULL)&#123; return pHead2; &#125; else if(pHead2 == NULL)&#123; return pHead1; &#125; ListNode* pMergedHead = NULL; if(pHead1-&gt;val &lt; pHead2-&gt;val)&#123; pMergedHead = pHead1; pMergedHead-&gt;next = Merge(pHead1-&gt;next, pHead2); &#125; else&#123; pMergedHead = pHead2; pMergedHead-&gt;next = Merge(pHead1, pHead2-&gt;next); &#125; return pMergedHead; &#125;&#125;; 剑指Offer（26）：树的子结构题目 输入两颗二叉树A，B，判断B是不是A的子结构。（PS：我们约定空树不是任意一个树的子结构）。 思路 要查找树A中是否存在和树B结构一样的子树，我们可以分为两步：第一步在树A中找到和B的根结点的值一样的结点R，第二步再判断树A中以R为根节点的子树是不是包含和树B一样的结构。 这里使用递归的方法即可。 1234567891011121314151617181920212223242526272829303132333435363738394041/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123; bool result = false; if(pRoot1 != NULL &amp;&amp; pRoot2 != NULL)&#123; if(pRoot1-&gt;val == pRoot2-&gt;val)&#123; result = DoesTree1HasTree2(pRoot1, pRoot2); &#125; if(!result)&#123; result = HasSubtree(pRoot1-&gt;left, pRoot2); &#125; if(!result)&#123; result = HasSubtree(pRoot1-&gt;right, pRoot2); &#125; &#125; return result; &#125;private: bool DoesTree1HasTree2(TreeNode* pRoot1, TreeNode* pRoot2)&#123; if(pRoot2 == NULL)&#123; return true; &#125; if(pRoot1 == NULL)&#123; return false; &#125; if(pRoot1-&gt;val != pRoot2-&gt;val)&#123; return false; &#125; return DoesTree1HasTree2(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; DoesTree1HasTree2(pRoot1-&gt;right, pRoot2-&gt;right); &#125;&#125;;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[],"author":"aoyuehan"},{"title":"第三章第二次作业 算法","slug":"第三章第二次作业-算法","date":"2020-03-31T09:07:00.000Z","updated":"2022-02-26T03:52:51.347Z","comments":true,"path":"2020/03/31/第三章第二次作业-算法/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/31/%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%BD%9C%E4%B8%9A-%E7%AE%97%E6%B3%95/","excerpt":"","text":"二维dp 求串A变为串B的最小步数 题目： 设A和B是2个字符串。要用最少的字符操作将字符串A转换为字符串B。这里所说的字符操作包括：（1）删除一个字符；（2）插入一个字符；（3）将一个字符改为另一个字符。将字符串A变换为字符串B所用的最少字符操作数称为字符串A到B的编辑距离，记为d(A,B)。设计一个算法，对任给的2个字符串A和B，计算它们的编辑距离d(A,B)。 方法一的思路： 首先定义A[0…N-1]的长度为N，B[0….M-1]长度为M，那么定义dp[i][j]为A[0…i]到B[0…j]的 编辑距离；在从串A到串B之间的变换（两个状态之间的转换）需要考虑对其中一个字符串的删除操作、插入操作和替换操作分别花费的开销，找其中最小的一个开销作为两个状态转换的代价，经过证明，这样求的最后的解是最优的。这里分为两种情况来讨论两种状态转换时的最小开销： （1） 当A[i]&#x3D;&#x3D;B[j]时i. 因为A[i]&#x3D;&#x3D;B[j]，所以A[0:i-1]与B[0:j-1]变为A[0:i]与B[0:j]（即状态dp[i-1][j-1]向dp[i][j]转变）的最小开销就是dp[i-1][j-1]。ii. A[0:i-1]与B[0:j]变为A[0:i]与B[0:j]（即状态dp[i-1][j]向dp[i][j]转变）的最小开销就是dp[i-1][j]+1，因为此时在A中添加了一个字符，无论是把A中新添加的这个字符删掉，还是在B中新添加一个字符来得到编辑距离，都要在原来的编辑距离上加一次操作。iii. A[0:i]与B[0:j-1]变为A[0:i]与B[0:j]（即状态dp[i][j-1]向dp[i][j]转变）的最小开销就是dp[i][j-1]+1，道理同ii。（2） 当A[i]!&#x3D;B[j]时i. 因为A[i]！&#x3D;B[j]，所以A[0:i-1]与B[0:j-1]变为A[0:i]与B[0:j]（即状态dp[i-1][j-1]向dp[i][j]转变）的最小开销就是dp[i-1][j-1]+1，进行这一次操作，让串A变为串B。ii. A[0:i-1]与B[0:j]变为A[0:i]与B[0:j]（即状态dp[i-1][j]向dp[i][j]转变）的最小开销就是dp[i-1][j]+1，因为此时在A中添加了一个字符，无论是把A中新添加的这个字符删掉，还是在B中新添加一个字符来得到编辑距离，都要在原来的编辑距离上加一次操作。iii. A[0:i]与B[0:j-1]变为A[0:i]与B[0:j]（即状态dp[i][j-1]向dp[i][j]转变）的最小开销就是dp[i][j-1]+1，道理同ii。 动规方程：此时我们就可以写出状态转移方程为（二维dp）： 举个例子： 实现： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int maxn=1e3;int dp[maxn][maxn];int GetMinNum(int a, int b, int c)//获取三个数中最小数&#123; int min = a &lt; b ? a : b; return min &lt; c ? min : c;&#125;int MinDistance(char *s1, int N, char *s2, int M)&#123; for (int i = 0; i &lt;=N; i++) &#123;//初始化 dp[i][0] = i; &#125; for (int j = 0; j &lt;= M; j++) &#123; dp[0][j] = j; &#125; for (int i = 1; i &lt;= N; i++) &#123; for (int j = 1; j &lt;=M; j++) &#123; int cost = (s1[i] == s2[j] ? 0 : 1); dp[i][j] = GetMinNum(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost); &#125; &#125; return dp[N][M];&#125;int main()&#123; char s1[maxn] ,s2[maxn] ; s1[0]=&#x27; &#x27;,s2[0]=&#x27; &#x27;; cin&gt;&gt;s1+1&gt;&gt;s2+1; cout&lt;&lt;&quot;最小距离为：&quot;&lt;&lt;MinDistance(s1, strlen(s1), s2, strlen(s2)); return 0;&#125; 方法二的思路： 假设 A的长度为 lena，B的长度为 lenb。字符串 A为 A[1]，A[2]，⋯⋯，A[lena]；字符串 B为 B[1]，B[2]，⋯⋯， B[lenb]。假设 f（i，j）表示将 A[i]，⋯⋯，A[lena]变成 B[j]，⋯⋯，B[lenb]一样的编辑距离。 那我们可以通过A[i]中是否有和B[j：lenb]有相同的字符，来讨论三种情况： （1）A[i]和 B[j]相等，此时 f（i，j）&#x3D;f（i+1，j+1）（2）A[i]和 B[j]不等，但是存在某个 A[k]和 B[j]相等，此时若 A[i+1]和B[j]相等则 f（i，j）&#x3D;f（i+1，j）+1。若 k 不等于 i+1，k 之前 i 到k-1 的字符都要删除并且把 A[k+1]，⋯⋯，A[LA]变为 B[j+1]，⋯⋯，B[LB]即可。假设测试k&#x3D;i+3，那么我们其实只要重复三次A[i+1]和B[j]相等时执行的操作即可，所以这种情况下公式也为 f（i，j）&#x3D;f（i+1，j）+1。（3） A[i]和 B[j]不等，也不存在某个 A[k]和 B[j]相等，即 A 中没有字符和 B[j]相等。只需将 A[i]变为 B[j]，然后将 A[i+1]，⋯⋯， A[LA]变为 B[j+1]，⋯⋯， B[LB]即可。此时 f（i，j）&#x3D;f（i+1，j+1）+1。 举个例子 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;char A[100];char B[100];int lena,lenb;int minn(int a,int b,int c)&#123; return (a&lt;b?a:b)&lt;c?(a&lt;b?a:b):c;&#125; int f(int i,int j)&#123; int d=0; if(i==lena+1&amp;&amp;j==lenb+1)&#123; return d; &#125; if(i==lena+1)&#123; return d=lenb-j+1; &#125; if(j==lenb+1)&#123; return d=lena-i+1; &#125; d=minn(f(i+1,j)+1,f(i+1,j+1)+(A[i]==B[j]?0:1),f(i,j+1)+1); return d; &#125;int main()&#123; cin&gt;&gt;A+1; cin&gt;&gt;B+1; lena=strlen(A+1); lenb=strlen(B+1); cout&lt;&lt;&quot;编辑距离为：&quot;&lt;&lt;f(1,1)&lt;&lt;endl;&#125; 搜狗的一道笔试题 题目： a[0]变为a[1]到a[n-1]的积，a[1]变为a[0]和a[2]到a[n-1]的积，……a[n-1]为a[0]到a[n-2]的积。要求：具有线性复杂度。不能使用除法运算符。思路，如果可以用除法的话，可以先求出a[0] 到a[n-1]之间所有数的乘积，然后除以其中一项就能得到相应的结果，但是本题限制用除法。 我们可以很巧妙的用一下前缀积和后缀积，要求某一项结果的时候只需要这个数的前缀积和后缀积相乘。 举个例子： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main(void) &#123; int a[]= &#123;1,2,3,5,6&#125;; int N=5;//N为a数组中的个数 int b[10]; // b[N]表示在第i位之前的各位的积，c[N]表示在第i位置之后的积 int c[10]; int i; int j; b[0]=1;//初始化 c[N-1]=1; for(i=1; i&lt;N; i++)//此时i不能从1开始计数 b[i]=a[i-1]*b[i-1];//求前缀积 for(j=N-2; j&gt;=0; j-- ) c[j]=a[j+1]*c[j+1];//求后缀积 for(i=0; i&lt;N ; i++) a[i]=b[i]*c[i];//计算结果 for(i=0; i&lt;N; i++) cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;; cout&lt;&lt;endl;// for(i=0; i&lt;N; i++)cout&lt;&lt;b[i]&lt;&lt;&#x27; &#x27;;// cout&lt;&lt;endl;// for(i=0; i&lt;N; i++)cout&lt;&lt;c[i]&lt;&lt;&#x27; &#x27;;&#125; 皇宫看守 （皇树上dp）树上的DP转移一般有两个方向：从根到叶和从叶到根。此题满足从叶到根。这一题刚开始看的时候，以为从根到叶子节点只需要有一个节点有人看守就可以，其实，应该是相邻节点需要有一个节点被看守，才可以做到所有的节点被看守。 对于每一个结点，只要在其本身或者父结点或者子结点有侍卫时，就一定可以被观察到，所以转移的状态可以简单的分为这三种。（son[x]表示x的子结点） f[x][0]表示x没有侍卫，但x的父结点有侍卫； f[x][1]表示x没有侍卫，但x的子结点有侍卫； f[x][2]表示x本身有侍卫。 然后我们按这三种情况求一下转移方程：（1）对于f[x][0]的情况： 此时x结点已经被观察到，因为想要保证花费最小，所以此时x结点不必要安放侍卫即可。 那么对于x的所有子结点只有两种情况（不能在出现f[x][0]的情况了）：自己有侍卫或者可以x的所有后代节点有侍卫 。状态转移方程是f[x][0]+&#x3D;min(f[son[x]][2],f[son[x]][1])（2）对于f[x][1]的情况： 此时x结点已经被观察到，所以x结点处不必安放侍卫。只用找出x的所有子结点中花费最小的即可。 同样的，子结点也只有上述的两种情况。 理想的情况下，x的子结点中如果有至少有一个结点满足min{F[son[x]][1],F [son[x]][2]}的结果为F [son[x]][2]，那么递推方程为F[x][1]&#x3D;min{F[son[x]][1],F [son[x]][2]}。 但是不理想的状态为x中所有的子节点都是F[son[x]][1]小于F [son[x]][2]，那么我们就得去这两者绝对值更小的一组中的F [son[x]][2]作为此时的开销加到递归方程中（这个额外的开销就是因为此时最优解是从F[x][1]转移而来，要额外的加上这部分开销），总和一下得：f[x][1]+&#x3D;min( f[son[x]][2],f[son[x]][1] )+d ;其中d&#x3D;min(d,f[son[x]][2]-min( f[son[x]][2] , f[son[x]][1] ) ) （3）对于f[x][2]的情况：此时x结点已经有侍卫了，x的儿子可以有侍卫，也可以被其子结点看守，还可以被其父结点看守。所以状态转移方程是f[x][2]+&#x3D;min(f[son[x]][0],f[son[x]][1],f[son[x]][2])+w[x] (w[x]表示在x结点处安放侍卫的花费） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;struct edge &#123;//数组记录改边的下一条边 int next, to;//next指向同一个起点的下一条边，to该边的终点 &#125; tree[500050];int n, f[500050][3], w[500050], root, pd[500050], num, head[500050];void addedge(int u, int v) &#123;//链式向前星的方式来 模拟邻接表 ，参数u为起点，v为终点 tree[++num] = (edge)&#123; head[u], v &#125;; head[u] = num;&#125;void dp(int u) &#123; int d = 9999999; for (int i = head[u]; i; i = tree[i].next) &#123; int y = tree[i].to; dp(y); f[u][0] += min(f[y][2], f[y][1]); f[u][1] += min(f[y][2], f[y][1]); d = min(d, f[y][2] - min(f[y][2], f[y][1])); f[u][2] += min(f[y][2], min(f[y][1], f[y][0])); &#125; f[u][1] += d;//f[u][1]加上额外的开销 f[u][2] += w[u];//f[u][2]加上在此处暗访卫兵的花费 &#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) &#123; int u, v, k; scanf(&quot;%d%d%d&quot;, &amp;v, &amp;k, &amp;u); w[v] = k; for (int j = 1; j &lt;= u; j++) &#123; int x; scanf(&quot;%d&quot;, &amp;x); pd[x] = 1; addedge(v, x); &#125; &#125; for (int i = 1; i &lt;= n; i++) if (!pd[i]) &#123;//找到一个没有入度的点当做根节点 root = i; break; &#125; dp(root);//从根开始进行dp cout &lt;&lt; min(f[root][1], f[root][2]);//两者之间的最小值就是结果 return 0;&#125; 整数划分 12345678910111213141516171819#include&lt;iostream&gt;using namespace std; int split(int n,int m)&#123; if(n == 1 || m == 1) return 1; else if(n &lt; m) return split(n,n); else if(n == m) return split(n,n-1) + 1; else return split(n,m-1)+split(n-m,m);&#125;int main()&#123; int n; printf(&quot;输入划分数:&quot;); scanf(&quot;%d&quot;,&amp;n); printf(&quot;整数划分为:%d\\n&quot;,split(n,n)); return 0;&#125; 钢条切割 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657自顶向下法 记忆化递归：#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define INF 0x3f3f3f3f#define MAXN 100000 //这里假设n最大为100000，视情况改变MAXN int mem[MAXN];//递归记忆化数组 int p[MAXN];//记录i长度的钢条价格 int cut_rod(int n)&#123; if(mem[n]) return mem[n];//对于已经处理过的值，直接返回记忆化数组的值 if(n==0) return 0; int res=-INF; for(int i=1;i&lt;=n;i++)&#123;//对左边一段切下来的长度进行枚举，之后左边的便不再进行切割 。 res=max(res,p[i]+cut_rod(n-i));//递归继续处理右边的部分。 &#125; mem[n]=res; //cout&lt;&lt;&quot;res of &quot;&lt;&lt;n&lt;&lt;&quot; : &quot;&lt;&lt;res&lt;&lt;endl;//调试 return res;&#125;int main()&#123; int n; cin&gt;&gt;n; memset(mem,0,sizeof(mem)); for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;p[i];//读入数据 &#125; cout&lt;&lt;cut_rod(n)&lt;&lt;endl;//输出长度为n的钢条切割最优值 &#125;自底向上法：#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define INF 0x3f3f3f3f#define MAXN 100000 //这里假设n最大为100000，视情况改变MAXN int a[MAXN];//记录结果 int p[MAXN];//记录i长度的钢条价格 int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;p[i];//读入数据 &#125; a[0]=0; for(int i=1;i&lt;=n;i++)&#123;//当前钢条长度 a[i]=0; for(int j=1;j&lt;=i;j++)&#123;//枚举分割方式 a[i]=max(a[i],p[j]+a[i-j]);//动态规划递推求解 &#125; //cout&lt;&lt;&quot;res of &quot;&lt;&lt;i&lt;&lt;&quot; : &quot;&lt;&lt;a[i]&lt;&lt;endl;//调试 &#125; cout&lt;&lt;a[n];&#125; 重构解以刚刚的钢条切割为例，如果要返回最优的切割方案，我们该怎么做？这时候我们就应该另外去保存对应的切割方案 即对长度j的钢条不仅计算其最大收益rj，也储存最优解的第一段钢条的长度sj 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define INF 0x3f3f3f3f#define MAXN 100000 //这里假设n最大为100000，视情况改变MAXN int a[MAXN];//记录结果 int p[MAXN];//记录i长度的钢条价格 int s[MAXN]=&#123;0&#125;;void print_method(int x)&#123;//输出切割方案 while(x!=0)&#123; cout&lt;&lt;s[x]&lt;&lt;&#x27; &#x27;; x-=s[x]; &#125; cout&lt;&lt;endl;&#125; int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;p[i];//读入数据 &#125; a[0]=0; for(int i=1;i&lt;=n;i++)&#123;//当前钢条长度 a[i]=0; for(int j=1;j&lt;=i;j++)&#123;//枚举分割方式 if(a[i]&lt;p[j]+a[i-j])&#123; s[i]=j;//记录解的分割方案 a[i]=p[j]+a[i-j]; &#125;//动态规划递推求解 &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; cout&lt;&lt;&quot;res of &quot;&lt;&lt;i&lt;&lt;&quot; : &quot;; cout&lt;&lt;a[i]&lt;&lt;endl; print_method(i); &#125;&#125;另一种写法：import java.util.Scanner;public class ButtomToUp &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); while (in.hasNext()) &#123; int n = in.nextInt(); int[] p = new int[n + 1];// 收益数组 int[] r = new int[n + 1];// 最大收益值数组 int[] s = new int[n + 1];// 第i个规模最优时，第一段的长度 p[0] = 0; for (int a = 1; a &lt;= n; a++) &#123; p[a] = in.nextInt(); &#125; r[0] = 0; // 动态规划进行由底到顶计算 for (int i = 1; i &lt;= n; i++) &#123; int max = Integer.MIN_VALUE; for (int j = 1; j &lt;= i; j++) &#123; if (max &lt; p[j] + r[i - j]) &#123; max = p[j] + r[i - j]; s[i] = j; &#125; &#125; r[i] = max; &#125; System.out.println(&quot;规模为i时最优值：&quot; + r[n]); System.out.println(&quot;最优解的值分别为：&quot;); while (n &gt; 0) &#123; int value = s[n]; n = n - s[n]; System.out.print(value + &quot;\\t&quot;); &#125; &#125; &#125;&#125;","categories":[{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"}],"tags":[],"author":"aoyuehan"},{"title":"剑指offer 第二章 面试所需要的基础知识","slug":"剑指offer-第二章-面试所需的基础知识","date":"2020-03-29T03:06:05.000Z","updated":"2022-02-26T03:52:52.314Z","comments":true,"path":"2020/03/29/剑指offer-第二章-面试所需的基础知识/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/29/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%9D%A2%E8%AF%95%E6%89%80%E9%9C%80%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"2.1 面试官谈基础知识2.2 编程语言 面试题-1 面试题-2 面试题-3 2.3 数据结构数组 剑指Offer(3)：数组中重复的数字题目在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 思路还可以把当前序列当成是一个下标和下标对应值是相同的数组（时间复杂度为O(n),空间复杂度为O(1)）； 遍历数组，判断当前位的值和下标是否相等： 若相等，则遍历下一位； 若不等，则将当前位置i上的元素和a[i]位置上的元素比较：若它们相等，则找到了第一个相同的元素；若不等，则将它们两交换。换完之后a[i]位置上的值和它的下标是对应的，但i位置上的元素和下标并不一定对应；重复2的操作，直到当前位置i的值也为i，将i向后移一位，再重复2。 举例说明：{2,3,1,0,2,5,3} 0(索引值)和2(索引值位置的元素)不相等，并且2(索引值位置的元素)和1(以该索引值位置的元素2为索引值的位置的元素)不相等，则交换位置，数组变为：{1,3,2,0,2,5,3}； 0(索引值)和1(索引值位置的元素)仍然不相等，并且1(索引值位置的元素)和3(以该索引值位置的元素1为索引值的位置的元素)不相等，则交换位置，数组变为：{3,1,2,0,2,5,3}； 0(索引值)和3(索引值位置的元素)仍然不相等，并且3(索引值位置的元素)和0(以该索引值位置的元素3为索引值的位置的元素)不相等，则交换位置，数组变为：{0,1,2,3,2,5,3}； 0(索引值)和0(索引值位置的元素)相等，遍历下一个元素； 1(索引值)和1(索引值位置的元素)相等，遍历下一个元素； 2(索引值)和2(索引值位置的元素)相等，遍历下一个元素； 3(索引值)和3(索引值位置的元素)相等，遍历下一个元素； 4(索引值)和2(索引值位置的元素)不相等，但是2(索引值位置的元素)和2(以该索引值位置的元素2为索引值的位置的元素)相等，则找到了第一个重复的元素。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false bool duplicate(int numbers[], int length, int* duplication) &#123; // 非法输入 if(numbers == NULL || length &lt;= 0)&#123; return false; &#125; // 非法输入 for(int i = 0; i &lt; length; i++)&#123; if(numbers[i] &lt; 0 || numbers[i] &gt; length - 1)&#123; return false; &#125; &#125; // 遍历查找第一个重复的数 for(int i = 0; i &lt; length; i++)&#123; while(numbers[i] != i)&#123; if(numbers[i] == numbers[numbers[i]])&#123; *duplication = numbers[i]; return true; &#125; swap(numbers[i], numbers[numbers[i]]); &#125; &#125; return false; &#125;&#125;; 剑指Offer(4)：二维数组中的查找 题目在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数组，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。 举例如果在一个二维数组中找到数字7，则返回true，如果没有找到，则返回false。 123456789101112131415161718192021222324bool Find(int* matrix, int rows, int columns, int number)&#123; bool found = false; if(matrix != nullptr &amp;&amp; rows &gt; 0 &amp;&amp; columns &gt; 0) &#123; int row = 0; int column = columns - 1;//初始化matrix[row][column]指向右上角的元素 while(row &lt; rows &amp;&amp; column &gt;=0) &#123;//在边界条件内循环 if(matrix[row * columns + column] == number) &#123; found = true; break; &#125; else if(matrix[row * columns + column] &gt; number) -- column; //如果该数字大于要查找的数组，剔除这个数字所在的列 else ++ row; //如果该数字小于要查找的数字，剔除这个数字所在的行,然后继续查找 &#125; &#125; return found;&#125; 字符串 剑指Offer(5)：替换空格 题目请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 思路：我们可以先遍历一次字符串，这样就可以统计出字符串空格的总数，并可以由此计算出替换之后的字符串的总长度。每替换一个空格，长度增加2，因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。以”We are happy”为例，”We are happy”这个字符串的长度为14（包括结尾符号”\\n”），里面有两个空格，因此替换之后字符串的长度是18。 我们从字符串的尾部开始复制和替换。首先准备两个指针，P1和P2，P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾。接下来我们向前移动指针P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格为止。碰到第一个空格之后，把P1向前移动1格，在P2之前插入字符串”%20”。由于”%20”的长度为3，同时也要把P2向前移动3格。 移动示意图： 12345678910111213141516171819202122232425262728293031323334353637383940414243/*length 为字符数组str的总容量，大于或等于字符串str的实际长度*/void ReplaceBlank(char str[], int length)&#123; if(str == nullptr &amp;&amp; length &lt;= 0) return; /*originalLength 为字符串str的实际长度*/ int originalLength = 0; int numberOfBlank = 0; int i = 0; while(str[i] != &#x27;\\0&#x27;) &#123; ++ originalLength; if(str[i] == &#x27; &#x27;) ++ numberOfBlank; ++ i; &#125; /*newLength 为把空格替换成&#x27;%20&#x27;之后的长度*/ int newLength = originalLength + numberOfBlank * 2; if(newLength &gt; length) return;//char数组存不下的情况 int indexOfOriginal = originalLength; //为指针p1 int indexOfNew = newLength; //p2指针指向末尾 while(indexOfOriginal &gt;= 0 &amp;&amp; indexOfNew &gt; indexOfOriginal) &#123; if(str[indexOfOriginal] == &#x27; &#x27;) &#123; str[indexOfNew --] = &#x27;0&#x27;; str[indexOfNew --] = &#x27;2&#x27;; str[indexOfNew --] = &#x27;%&#x27;; &#125; else &#123; str[indexOfNew --] = str[indexOfOriginal]; &#125; -- indexOfOriginal;//p1指针前移 &#125;&#125; 链表 剑指Offer（6）：从尾到头打印链表 题目输入一个链表，返回一个反序的链表。思路通常，这种情况下，我们不希望修改原链表的结构。返回一个反序的链表，这就是经典的“后进先出”，我们可以使用栈实现这种顺序。每经过一个结点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出结点的值，给一个新的链表结构，这样链表就实现了反转。 或者使用递归式方法。 1234567891011121314151617181920212223242526272829303132方法一：栈的操作void PrintListReversingly_Iteratively(ListNode* pHead)&#123; std::stack&lt;ListNode*&gt; nodes; ListNode* pNode = pHead; while(pNode != nullptr) &#123;//压栈 nodes.push(pNode); pNode = pNode-&gt;m_pNext; &#125; while(!nodes.empty()) &#123;//出栈 pNode = nodes.top(); printf(&quot;%d\\t&quot;, pNode-&gt;m_nValue); nodes.pop(); &#125;&#125;方法二：递归栈方法void PrintListReversingly_Recursively(ListNode* pHead)&#123; if(pHead != nullptr) &#123; if (pHead-&gt;m_pNext != nullptr) &#123; PrintListReversingly_Recursively(pHead-&gt;m_pNext); &#125; //把打印操作放在这里，当函数到底之后向上返回的时候打印出节点的值 printf(&quot;%d\\t&quot;, pHead-&gt;m_nValue); &#125;&#125; 树 剑指Offer（7）：重建二叉树 题目输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路：通常树有如下几种遍历方式： 前序遍历：先访问根结点，再访问左子结点，最后访问右子结点。 中序遍历：先访问左子结点，再访问根结点，最后访问右子结点。 后序遍历：先访问左子结点，再访问右子结点，最后访问根结点。本题为前序遍历和中序遍历，最少需要两种遍历方式，才能重建二叉树。 前序遍历序列中，第一个数字总是树的根结点的值。在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。剩下的我们可以递归来实现，具体如图： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123; if(pre.size() == 0)&#123; //如果为空，返回NULL return NULL; &#125; //依次是前序遍历左子树，前序遍历右子树，中序遍历左子树，中序遍历右子树 vector&lt;int&gt; left_pre, right_pre, left_vin, right_vin; //前序遍历第一个节点一定为根节点 TreeNode* head = new TreeNode(pre[0]); //找到中序遍历的根节点 int root = 0; //遍历找到中序遍历根节点索引值 for(int i = 0; i &lt; pre.size(); i++)&#123; if(pre[0] == vin[i])&#123; root = i; break; &#125; &#125; //利用中序遍历的根节点，对二叉树节点进行归并 for(int i = 0; i &lt; root; i++)&#123; left_vin.push_back(vin[i]); left_pre.push_back(pre[i + 1]); //前序遍历第一个为根节点 &#125; for(int i = root + 1; i &lt; pre.size(); i++)&#123; right_vin.push_back(vin[i]); right_pre.push_back(pre[i]); &#125; //递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点 head-&gt;left = reConstructBinaryTree(left_pre, left_vin); head-&gt;right = reConstructBinaryTree(right_pre, right_vin); return head; &#125;&#125;;方法二：标程BinaryTreeNode* Construct(int* preorder, int* inorder, int length)&#123; if(preorder == nullptr || inorder == nullptr || length &lt;= 0) return nullptr; return ConstructCore(preorder, preorder + length - 1, inorder, inorder + length - 1);&#125;BinaryTreeNode* ConstructCore( int* startPreorder, int* endPreorder, int* startInorder, int* endInorder)&#123; // 前序遍历序列的第一个数字是根结点的值 int rootValue = startPreorder[0]; BinaryTreeNode* root = new BinaryTreeNode(); root-&gt;m_nValue = rootValue; root-&gt;m_pLeft = root-&gt;m_pRight = nullptr; if(startPreorder == endPreorder) &#123; if(startInorder == endInorder &amp;&amp; *startPreorder == *startInorder) return root; else throw std::exception(&quot;Invalid input.&quot;); &#125; // 在中序遍历中找到根结点的值 int* rootInorder = startInorder; while(rootInorder &lt;= endInorder &amp;&amp; *rootInorder != rootValue) ++ rootInorder; if(rootInorder == endInorder &amp;&amp; *rootInorder != rootValue) throw std::exception(&quot;Invalid input.&quot;); int leftLength = rootInorder - startInorder; int* leftPreorderEnd = startPreorder + leftLength; if(leftLength &gt; 0) &#123; // 构建左子树 root-&gt;m_pLeft = ConstructCore(startPreorder + 1, leftPreorderEnd, startInorder, rootInorder - 1); &#125; if(leftLength &lt; endPreorder - startPreorder) &#123;//这地方为什么？ // 构建右子树 root-&gt;m_pRight = ConstructCore(leftPreorderEnd + 1, endPreorder, rootInorder + 1, endInorder); &#125; return root;&#125; 剑指Offer(8)：二叉树的下一个节点题目给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 思路（依据二叉树的性质来做）我们以上图为例进行讲解，上图二叉树的中序遍历是d,b,h,e,i,a,f,c,g。我们以这棵树为例来分析如何找出二叉树的下一个结点。 如果一个结点有右子树，那么它的下一个结点就是它的右子树的最左子结点。也就是说从右子结点出发一直沿着指向左子树结点的指针，我们就能找到它的下一个结点。例如，图中结点b的下一个结点是h，结点a的下一个结点是f。 接着我们分析一下结点没有右子树的情形。如果结点是它父结点的左子结点，那么它的下一个结点就是它的父结点。例如，途中结点d的下一个结点是b，f的下一个结点是c。 如果一个结点既没有右子树，并且它还是父结点的右子结点，这种情形就比较复杂。我们可以沿着指向父结点的指针一直向上遍历，直到找到一个是它父结点的左子结点的结点。如果这样的结点存在，那么这个结点的父结点就是我们要找的下一个结点。例如，为了找到结点g的下一个结点，我们沿着指向父结点的指针向上遍历，先到达结点c。由于结点c是父结点a的右结点，我们继续向上遍历到达结点a。由于结点a是树的根结点。它没有父结点。因此结点g没有下一个结点。 123456789101112131415161718192021222324252627282930313233343536373839404142/*struct TreeLinkNode &#123; int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeLinkNode* GetNext(TreeLinkNode* pNode) &#123; if(pNode == NULL)&#123; return NULL; &#125; TreeLinkNode* pNext = NULL; // 当前结点有右子树，那么它的下一个结点就是它的右子树中最左子结点 if(pNode-&gt;right != NULL)&#123; TreeLinkNode* pRight = pNode-&gt;right; while(pRight-&gt;left != NULL)&#123; pRight = pRight-&gt; left; &#125; pNext = pRight; &#125; // 当前结点无右子树，则需要找到一个是它父结点的左子树结点的父结点 else if(pNode-&gt;next != NULL)&#123; // 当前结点 TreeLinkNode* pCur = pNode; // 父节点 TreeLinkNode* pPar = pNode-&gt;next; while(pPar != NULL &amp;&amp; pCur == pPar-&gt;right)&#123; pCur = pPar; pPar = pCur-&gt;next; &#125; pNext = pPar; &#125; return pNext; &#125;&#125;; 栈和队列 剑指Offer（9）：用两个栈实现队列 题目用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。思路创建两个栈stack1和stack2，使用两个“先进后出”的栈实现一个“先进先出”的队列。 我们通过一个具体的例子分析往该队列插入和删除元素的过程。首先插入一个元素a，不妨先把它插入到stack1，此时stack1中的元素有{a}，stack2为空。再压入两个元素b和c，还是插入到stack1中，此时stack1的元素有{a,b,c}，其中c位于栈顶，而stack2仍然是空的。 这个时候我们试着从队列中删除一个元素。按照先入先出的规则，由于a比b、c先插入队列中，最先删除的元素应该是a。元素a存储在stack1中，但并不在栈顶，因此不能直接进行删除操作。注意stack2我们一直没有使用过，现在是让stack2发挥作用的时候了。如果我们把stack1中的元素逐个弹出压入stack2，元素在stack2中的顺序正好和原来在stack1中的顺序相反。因此经过3次弹出stack1和要入stack2操作之后，stack1为空，而stack2中的元素是{c,b,a}，这个时候就可以弹出stack2的栈顶a了。此时的stack1为空，而stack2的元素为{b,a}，其中b在栈顶。 因此我们的思路是：当stack2中不为空时，在stack2中的栈顶元素是最先进入队列的元素，可以弹出。如果stack2为空时，我们把stack1中的元素逐个弹出并压入stack2。由于先进入队列的元素被压倒stack1的栈底，经过弹出和压入之后就处于stack2的栈顶，有可以直接弹出。如果有新元素d插入，我们直接把它压入stack1即可。 流程示意图： 123456789101112131415161718192021222324class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; if(stack2.empty())&#123; while(stack1.size() &gt; 0)&#123; int data = stack1.top(); stack1.pop(); stack2.push(data); &#125; &#125; int pop_element = stack2.top(); stack2.pop(); return pop_element; &#125; private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; 2.4 算法和数据操作递归和排序 剑指Offer（10）：斐波那锲数列题目大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。（n&lt;&#x3D;39）斐波那契数列公式为：思路这道题递归很好写，但是存在很严重的效率问题。我们以求解f(10)为例类分析递归的求解过程。想求f(10)，需要先求得f(9)和f(8)。同样，想求得f(9)，需要先求的f(8)和f(7)….我们可以用树形结构来表示这种依赖关系，如下图所示： 我们不难发现在这棵树中有很多结点是重复的，而且重复的结点数会随着n的增加而急剧增加，这意味计算量会随着n的增加而急剧增大。事实上，递归方法计算的时间复杂度是以n的指数的方式递增的。 所以，使用简单的循环方法来实现。 12345678910111213141516class Solution &#123;public: int Fibonacci(int n) &#123; if(n &lt;= 0) return 0; if(n == 1) return 1; int first = 0, second = 1, third = 0; for (int i = 2; i &lt;= n; i++) &#123; third = first + second; first = second; second = third; &#125; return third; &#125;&#125;; 查找和排序 剑指Offer（11）：旋转数组的最小数字题目 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 我们注意到旋转之后的数组实际上可以划分为两个排序的字数组，而且前面的字数组的元素大于或者等于后面字数组的元素。我们还注意到最小的元素刚好是这两个字数组的分界线。在排序的数组中可以用二分查找实现O(logn)的查找。本题给出的数组在一定程度上是排序的，因此我们可以试着用二分查找法的思路来寻找这个最小的元素。 接着我们可以找到数组中间的元素。如果中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时最小元素应该位于该中间元素之后，然后我们把第一个指针指向该中间元素，移动之后第一个指针仍然位于前面的递增子数组中。 同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时最小元素应该位于该中间元素之前，然后我们把第二个指针指向该中间元素，移动之后第二个指针仍然位于后面的递增子数组中。 第一个指针总是指向前面递增数组的元素，第二个指针总是指向后面递增数组的元素。最终它们会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环结束的条件。示意图如下： ** 特殊情况**： 如果把排序数组的0个元素搬到最后面，这仍然是旋转数组，我们的代码需要支持这种情况。如果发现数组中的一个数字小于最后一个数字，就可以直接返回第一个数字了。 下面这种情况，即第一个指针指向的数字、第二个指针指向的数字和中间的数字三者相等，我们无法判断中间的数字1是数以前面的递增子数组还是后面的递增子数组。正样的话，我们只能进行顺序查找。 当我们解决问题的时候，一定要考虑边界，特殊的问题，看此种算法能不能解决这个问题，所以问题要考虑全面 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int size = rotateArray.size(); //数组长度 if(size == 0)&#123; return 0; &#125; int left = 0; //左指针 int right = size - 1; //右指针 int mid = 0; //中间指针 while(rotateArray[left] &gt;= rotateArray[right])&#123; //确保旋转 if(right - left == 1)&#123; //左右指针相邻 mid = right; break; &#125; mid = left + (right - left) / 2; //计算中间指针位置 //特殊情况：如果无法确定中间元素是属于前面还是后面的递增子数组，只能顺序查找 if(rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[mid] == rotateArray[left])&#123; return MinInOrder(rotateArray, left, right); &#125; //中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面 if(rotateArray[mid] &gt;= rotateArray[left])&#123; left = mid; &#125; //中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面 else&#123; right = mid; &#125; &#125; return rotateArray[mid]; &#125;private: //顺序寻找最小值 int MinInOrder(vector&lt;int&gt; &amp;num, int left, int right)&#123; int result = num[left]; for(int i = left + 1; i &lt; right; i++)&#123; if(num[i] &lt; result)&#123; result = num[i]; &#125; &#125; return result; &#125;&#125;; 回溯法 剑指Offer（12）：矩阵中的路径题目 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如在下面的3x4的矩阵中包含一条字符串”bcced”的路径（路径中的字母用斜体表示）。但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 思路这是一个可以用回溯法解决的典型问题。 首先，遍历这个矩阵，我们很容易就能找到与字符串str中第一个字符相同的矩阵元素ch。然后遍历ch的上下左右四个字符，如果有和字符串str中下一个字符相同的，就把那个字符当作下一个字符（下一次遍历的起点），如果没有，就需要回退到上一个字符，然后重新遍历。为了避免路径重叠，需要一个辅助矩阵来记录路径情况。 下面代码中，当矩阵坐标为（row，col）的格子和路径字符串中下标为pathLength的字符一样时，从4个相邻的格子（row，col-1）、（row-1，col）、（row，col+1）以及（row+1，col）中去定位路径字符串中下标为pathLength+1的字符。 如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确，我们需要回到前一个字符串（pathLength-1），然后重新定位。 一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到格式的位置（此时str[pathLength] &#x3D;&#x3D; ‘\\0’）。 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: bool hasPath(char* matrix, int rows, int cols, char* str) &#123; if(matrix == NULL || rows &lt; 1 || cols &lt; 1 || str == NULL)&#123; return false; &#125; bool* visited = new bool[rows*cols]; memset(visited, 0, rows*cols); int pathLength = 0; for(int row = 0; row &lt; rows; row++)&#123; for(int col = 0; col &lt; cols; col++)&#123; if(hasPathCore(matrix, rows, cols, row, col, str, pathLength, visited))&#123; delete[] visited; return true; &#125; &#125; &#125; delete[] visited; return false; &#125;private: bool hasPathCore(char* matrix, int rows, int cols, int row, int col, char* str, int&amp; pathLength, bool* visited)&#123; if(str[pathLength] == &#x27;\\0&#x27;)&#123; return true; &#125; bool hasPath = false; if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; matrix[row*cols+col] == str[pathLength] &amp;&amp; !visited[row*cols+col])&#123; ++pathLength; visited[row*cols+col] = true; hasPath = hasPathCore(matrix, rows, cols, row-1, col, str, pathLength, visited) || hasPathCore(matrix, rows, cols, row+1, col, str, pathLength, visited) || hasPathCore(matrix, rows, cols, row, col-1, str, pathLength, visited) || hasPathCore(matrix, rows, cols, row, col+1, str, pathLength, visited); if(!hasPath)&#123; --pathLength;//这条路径走下去不符合要求，回溯到上一个节点处，再继续向下寻找 visited[row*cols+col] = false; &#125; &#125; return hasPath; &#125;&#125;; tips：回溯法 回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 剑指Offer（13）：机器人的运动范围题目 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 &#x3D; 18。但是，它不能进入方格（35,38），因为3+5+3+8 &#x3D; 19。请问该机器人能够达到多少个格子？ 思路 和上一道题十分相似，只不过这次的限制条件变成了坐标位数之和。对于求坐标位数之和，我们单独用一个函数实现，然后套入上一道题的代码中即可。 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: int movingCount(int threshold, int rows, int cols) &#123; int count = 0; if(threshold &lt; 1 || rows &lt; 1 || cols &lt; 1)&#123; return count; &#125; bool* visited = new bool[rows*cols]; memset(visited, 0, rows*cols); count = movingCountCore(threshold, rows, cols, 0, 0, visited);//从坐标为（0,0）这地方开始展开搜索 delete[] visited; return count; &#125;private: int movingCountCore(int threshold, int rows, int cols, int row, int col, bool* visited)&#123; //这个函数返回的就不是简单的可以走还是不可以走，而是从这个节点往下走可以走的路径的数量和 int count = 0; if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; getDigitSum(row)+getDigitSum(col) &lt;= threshold &amp;&amp; !visited[row*cols+col])&#123; visited[row*cols+col] = true; count = 1 + movingCountCore(threshold, rows, cols, row+1, col, visited) + movingCountCore(threshold, rows, cols, row-1, col, visited) + movingCountCore(threshold, rows, cols, row, col+1, visited) + movingCountCore(threshold, rows, cols, row, col-1, visited); &#125; return count; &#125; int getDigitSum(int num)&#123; int sum = 0; while(num)&#123; sum += num % 10; num /= 10; &#125; return sum; &#125;&#125;; 动态规划和贪婪算法 剑指Offer（14）：剪绳子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std; int maxProduct_DP(int len)&#123; if(len&lt;2) return 0; if(len==2) return 1; if(len==3) return 2; vector&lt;int&gt; vec(len+1,0); vec[0]=0; vec[1]=1; vec[2]=2; vec[3]=3; int mx=0; for(int i=4;i&lt;=len;i++) &#123; mx=0; for(int j=1;j&lt;=i/2;j++) &#123; int res=vec[j]*vec[i-j]; if(res&gt;mx) mx=res; vec[i]=mx; &#125; &#125; mx=vec[len]; return mx;&#125; int main()&#123; cout&lt;&lt;maxProduct_DP(10)&lt;&lt;endl; return 0;&#125;方法二：贪婪算法 #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std; int maxProduct_GD(int len)&#123; if(len&lt;2) return 0; if(len==2) return 1; if(len==3) return 2; int timesof3=len/3;//剪成长度为3的最多的段数 if(len-timesof3*3==1) &#123;//留出一个长度为4的段 timesof3-=1; &#125; int timesof2=(len-timesof3*3)/2; return (int)pow(3,timesof3)*(int)pow(2,timesof2);&#125; int main()&#123; cout&lt;&lt;maxProduct_GD(10)&lt;&lt;endl; return 0;&#125; 位运算 剑指Offer（15）：二进制中1的个数 题目输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 思路如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011&#x3D;1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 12345678int NumberOf1(int n) &#123; int count = 0; while(n)&#123; ++count; n = (n - 1) &amp; n; &#125; return count;&#125;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[],"author":"aoyuehan"},{"title":"蓝桥杯每周一练总结","slug":"蓝桥杯每周一练总结","date":"2020-03-29T01:31:32.000Z","updated":"2022-02-26T03:52:51.562Z","comments":true,"path":"2020/03/29/蓝桥杯每周一练总结/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/29/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%AF%8F%E5%91%A8%E4%B8%80%E7%BB%83%E6%80%BB%E7%BB%93/","excerpt":"","text":"3n+1问题1、 中间计算过程会超过 int 或 long （如果 int 或 long 型均为 4 字节存储空间） 型数据所能表示的范围，故需要选择 long long （8 字节存储空间）型整数（除非你使用的算法在做乘的时候不使用一般的乘法，而是使用替代方法实现原数的三倍加一）。注意运算时的溢出 2、 输入时可能较大的数在前面，需要调整顺序，这个是导致算法正确却 WA 的重要原因。 3、 采用填表的方法保存既往计算结果，可以显著减少计算时间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.HashMap;import java.util.Scanner;public class W1_UVa100_3nPlus1 &#123; static HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNext()) &#123; int i = sc.nextInt(); int j = sc.nextInt(); int a = i; int b = j; //坑 if (i &gt; j) &#123; a = j; b = i; &#125; int max = -1; for (int k = a; k &lt;= b; k++) &#123; Integer fk = map.get(k); if (fk == null) &#123; fk = f(k); map.put(k, fk); &#125; max = Integer.max(max, fk); &#125; System.out.println(i + &quot; &quot; + j + &quot; &quot; + max); &#125; &#125; static int f(long k) &#123; int count = 1; while (k != 1) &#123; if ((k &amp; 1) == 0) &#123; k /= 2; &#125; else &#123; k = k * 3 + 1; &#125; count++; &#125; return count; &#125;&#125;方法二：#include&lt;stdio.h&gt;int main()&#123; long long a,b,max,min; while(scanf(&quot;%lld%lld&quot;,&amp;a,&amp;b)!=EOF) &#123; long long i,k,t,max0=0,temp;//中间过程可能溢出，开longlong if(a&gt;b) &#123;//循环之前要想到这个大小的问题，逻辑要缜密 max=a;min=b; &#125; else &#123; max=b;min=a; &#125; for(i=min;i&lt;=max;i++) &#123;//直接暴力就好 k=1; t=i; while(t&gt;1)&#123; if(t%2!=0) t=3*t+1; else t=t/2; k++; &#125; if(max0&lt;=k)//记录最大值 max0=k; &#125; printf(&quot;%lld %lld %lld\\n&quot;,a,b,max0); &#125; return 0;&#125; 扫雷问题 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cstring&gt; int a[120][120]; int main(void)&#123; int n, m, count = 1, i, j,ii,jj; while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m),n) &#123; getchar(); if (count &gt; 1) putchar(&#x27;\\n&#x27;); char ch; memset(a,0,sizeof(a)); for (i = 1; i &lt;= n; i++) &#123; for (j = 1; j &lt;= m; j++) &#123; scanf(&quot;%c&quot;, &amp;ch); if (ch == &#x27;*&#x27;) &#123; a[i][j] = 11;///小技巧 for (ii = i - 1; ii &lt;= i + 1; ii++) for (jj = j - 1; jj &lt;= j + 1; jj++) a[ii][jj]++; &#125; &#125; getchar(); &#125; printf(&quot;Field #%d:\\n&quot;, count); for (i = 1; i &lt;= n; i++) &#123; for (j = 1; j &lt;= m; j++) &#123; if (a[i][j] &gt; 10) putchar(&#x27;*&#x27;); else printf(&quot;%d&quot;, a[i][j]); &#125; putchar(&#x27;\\n&#x27;); &#125; count++; &#125; return 0;&#125; 第三周 X星球居民小区的楼房123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263X星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为1,2,3...当排满一行时，从下一行相邻的楼往反方向排号。比如：当小区排号宽度为6时，开始情形如下：1 2 3 4 5 612 11 10 9 8 713 14 15 .....我们的问题是：已知了两个楼号m和n，需要求出它们之间的最短移动距离（不能斜线方向移动）输入为3个整数w m n，空格分开，都在1到10000范围内w为排号宽度，m,n为待计算的楼号。要求输出一个整数，表示m n 两楼间最短移动距离。例如：用户输入：6 8 2则，程序应该输出：4再例如：用户输入：4 7 20则，程序应该输出：5资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 1000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。*/#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;int main(int argc, const char *argv[]) &#123; int w, m, n; scanf(&quot;%d %d %d&quot;, &amp;w, &amp;m, &amp;n); int rm = m % w == 0 ? m / w : m / w + 1;//判断m点所在的行 int rn = n % w == 0 ? n / w : n / w + 1; int cm = 0; int cn = 0; if (rm % 2 == 0)cm = rm * w - m + 1;//判断m点所在的列（分奇偶讨论 else cm = w - (rm * w - m); if (rn % 2 == 0)cn = rn * w - n + 1; else cn = w - (rn * w - n); printf(&quot;%d\\n&quot;,abs(cm-cn)+abs(rm-rn));//结果就是两者横纵坐标的差 return 0;&#125; 第四周高斯日记 第五周123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172题目大意：给你一叠薄煎饼，请你写一个程序来指出要如何翻转（flip）才能使这些薄煎饼按半径由小到大排好。所有的薄煎饼半径均不相同。（这里为了简化问题，就不说从上到下了，就按数组下标来说）。翻转（flip）：比如输入一组数：5 1 2 3 4，数组下标分别为1,2,3,4,5。翻转（flip）只能从a[i]到a[1]进行翻转（翻转后，会依相反的次序排列）。5 1 2 3 4 从4到5翻转（从a[5]到a[1]）4 3 2 1 5 从1到4翻转（从a[4]到a[1]）1 2 3 4 5 从小到大排到完成而翻转（flip），如果从最后一个数开始翻转就是flip(1),从倒数第二个数开始翻转就是flip(2)。所以题目输出1 2 0解题思路：因为翻转不是随便指定两个数进行翻转，而是必须从a[i]到a[1]进行翻转，所以应该先找出当前最大的数放在它应该在的位置。例如，输入一组数：3 1 2 5 4当前最大的数为5，它应该在下标为5的位置上，所以将它翻转到a[1] 5 2 1 3 4编号5 4 3 2 1 （这是翻转时的编号，并不是数组中下标的编号） 栈底-----&gt;栈顶 从小到大从栈底到铲子插入的这一段会进行翻转然后翻转到a[5]的位置上4 3 1 2 5此时已经排好5，只看前4个数，所以长度-1同理，找前4个数中最大的数是4。4已经在a[1]位置，所以将它翻转到a[4]2 1 3 4 5长度-1,3已经排好，长度-1，2已经在a[1]位置，所以将它翻转到a[2]1 2 3 4 5所以输出： 2 1 2 4 0#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;sstream&gt;using namespace std;int n;int a[10005];string s;void solve(int p)&#123; for(int i=0;i&lt;p-i;i++) &#123; swap(a[i],a[p-i]); //翻转就是这种相对应位置上的交换数值 &#125; cout&lt;&lt;n-p&lt;&lt;&quot; &quot;; //当p为n-1的时候，此时输出1&#125;int main()&#123; while(getline(cin,s)) &#123; cout&lt;&lt;s&lt;&lt;endl; stringstream ss(s); n=0; while(ss&gt;&gt;a[n]) n++; for(int i=n-1;i&gt;0;i--) &#123; int p=max_element(a,a+i+1)-a;//查找最大元素的位置 if(p==i)//如果=i则说明它在自己的位置上 continue; if(p&gt;0)//否则将最大元素翻转到顶部 solve(p); solve(i); // solve(p)和solve(i)两步加起来才能让最大值翻转到顶部 &#125; cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; &#125;&#125; 第六周 快速过桥问题：深夜过桥问题，一共有n个人，只有一个手电筒，必须要有手电筒才能够，且桥上只能同时容纳两个人前进（且前进按照团体最长时间算）。给出n个人的过桥耗时，问最小的时间能够让全部能通过。每次过桥之后都要等到手电筒传回来之后才能继续进行下一组。 首先将所有过桥时间排序，以下为获得最小过桥时间的算法：（1）过桥总人数为 1，该人的过桥时间即为最短过桥时间。（2）过桥总人数为 2，过桥时间较大的人的过桥时间即为最短过桥时间。（3）过桥总人数为 3，假设为A，B，C，则（AB），（A），（AC）策略和 （AC），（A），（AB）策略的时间相同，3人过桥时间之和为最短时间。（4）过桥总人数大于3，假设最前面为A，B两人，最后为Y，Z两人，有两种策略：（AB），（A），（YZ），（B），（AB）和（AZ），（A），（AY），（A），（AB）。比较两种策略那种过桥时间少就选那种，然后将总人数减去 2，若总人数仍大于 3，继续该步骤直到剩下需要过桥的人数小于等于 3。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll; const int maxn =1100; int num[maxn]; int main()&#123; int t,n; scanf(&quot;%d&quot;,&amp;t); for(int i=1;i&lt;=t;i++) &#123; if(i!=1) printf(&quot;\\n&quot;); int ans=0,m; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;num[i]); sort(num,num+n); m=n; while(m&gt;=4) &#123; ans+=min(num[0]*2+num[m-1]+num[m-2],num[0]+num[1]*2+num[m-1]); //取两种方式的最小值 m-=2; &#125; if(m==3) &#123; ans+=num[0]+num[1]+num[2]; &#125; else if(m==2) &#123; ans+=num[1]; &#125; else &#123; ans+=num[0]; &#125; printf(&quot;%d\\n&quot;,ans); while(n&gt;=4) &#123; if(num[0]*2+num[n-1]+num[n-2]&lt;num[0]+num[1]*2+num[n-1]) printf(&quot;%d %d\\n%d\\n%d %d\\n%d\\n&quot;,num[0],num[n-1],num[0],num[0],num[n-2],num[0]); else printf(&quot;%d %d\\n%d\\n%d %d\\n%d\\n&quot;,num[0],num[1],num[0],num[n-2],num[n-1],num[1]); n-=2; &#125; if(n==3) &#123; printf(&quot;%d %d\\n%d\\n%d %d\\n&quot;,num[0],num[1],num[0],num[0],num[2]); &#125; else if(n==2) &#123; printf(&quot;%d %d\\n&quot;,num[0],num[1]); &#125; else if(n==1) &#123; printf(&quot;%d\\n&quot;,num[0]); &#125; &#125; return 0;&#125; 这题算是贪心吧，要知道，贪心的策略可能不止一种，比如本题中，就是两者之间取最优，所以要多举一些列子来推测贪心的策略是什么，而且到大胆的有依据的猜测。 算式最大值【问题描述】给定:1)N个正整数A1, A2, … AN;2)P个加号+和Q个减号-; (P+Q&#x3D;N-1)3)K对括号()请你使用全部整数、加减号和括号，组成一个合法的算式(A1~AN在算式中的顺序随意)，使得算式的结果最大。注意加减号只能作为二元运算符出现在算式中，不能作为正负号。括号可以出现在算式最左和最右，例如(((1+2)))是合法的。例如对于样例数据，(2-1)+3或3+(2-1)等都是结果最大的算式。【输入】第一行包含4个整数，N，P, Q和K。第二行包含N个整数A1, A2, … AN。2 ≤ N ≤ 100 P+Q+1&#x3D;N 0 ≤ K ≤ 101 ≤ Ai ≤ 1000【输出】最大算式结果【样例输入】3 1 1 11 2 3【样例输出】4 这是一道思维题，只要有括号总能把若干个减号化成一个减号， 我们只要减去数组里最小的即可，而且只要一个括号就行，多的也没用，如果没有括号，只能把大的加起来，再减去小的。 1234567891011121314151617181920212223242526272829303132public class W7_算式最大值 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt();//数字个数 int p = sc.nextInt();//加号个数 int q = sc.nextInt();//减号个数 int k = sc.nextInt();//括号对数 int[] a = new int[n]; for (int i = 0; i &lt; n; i++) &#123; a[i] = sc.nextInt(); &#125; //===数据准备完毕=== //1.排序 Arrays.sort(a); int ans = 0; //2.没有括号存在，只能将最大的p+1个数相加，再减去较小的q个数 if (k == 0) &#123; for (int i = n - 1; i &gt;= n - 1 - p; i--) ans += a[i]; for (int i = n - p - 2; i &gt;= 0; i--) ans -= a[i]; &#125; else &#123; //3.有括号存在，总能把q-1个减号变成正号：a-(b-c-d-...)，可令b是最小的数字， // 得到最大的算式值:前n-1个数相加，减去最小的数 for (int i = n - 1; i &gt; 0; i--) ans += a[i]; ans -= a[0]; &#125; System.out.println(ans); &#125;&#125;","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[],"author":"aoyuehan"},{"title":"UCF local 2016","slug":"UCF-local-2016","date":"2020-03-28T12:44:00.000Z","updated":"2022-02-26T03:52:51.704Z","comments":true,"path":"2020/03/28/UCF-local-2016/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/28/UCF-local-2016/","excerpt":"","text":"Majestic 10 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n ,a,b,c; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;int cnt=0; if(a&gt;=10)cnt++; if(b&gt;=10)cnt++; if(c&gt;=10)cnt++; cout&lt;&lt;a&lt;&lt;&#x27; &#x27;&lt;&lt;b&lt;&lt;&#x27; &#x27;&lt;&lt;c&lt;&lt;endl; if(cnt==3)&#123; cout&lt;&lt;&quot;triple-double&quot;&lt;&lt;endl&lt;&lt;endl; &#125;else if(cnt==2)&#123; cout&lt;&lt;&quot;double-double&quot;&lt;&lt;endl&lt;&lt;endl; &#125;else if(cnt==1)&#123; cout&lt;&lt;&quot;double&quot;&lt;&lt;endl&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;zilch&quot;&lt;&lt;endl&lt;&lt;endl; &#125; &#125;&#125; Phoneme Palindromes 回文将所有可以相互替换的字母都统一替换成相同字母，然后判断回文即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;char,char&gt;mp;int check(string s,int len)&#123; for(int i=0;i&lt;len;i++)s[i]=mp[s[i]];//将可以互相替换的字母换为一个 int head=0,tail=len-1;int flag=1; while(head&lt;=tail)&#123;//进行回文判断 if(s[head]!=s[tail])&#123; flag=0; &#125; head++;tail--; &#125; return flag;&#125;int main()&#123; int n,cnt=0; cin&gt;&gt;n; while(++cnt&lt;=n)&#123; for(char i=&#x27;a&#x27;;i&lt;&#x27;z&#x27;;i++)mp[i]=i; int p,q;char tmpa,tmpb;string s[110];int is[110]; cin&gt;&gt;p; for(int i=0;i&lt;p;i++)&#123; cin&gt;&gt;tmpa&gt;&gt;tmpb; mp[tmpb]=tmpa; &#125; cin&gt;&gt;q; for(int i=0;i&lt;q;i++)&#123; cin&gt;&gt;s[i]; if(check(s[i],s[i].length()))&#123; is[i]=1; &#125;else&#123; is[i]=0; &#125; &#125; cout&lt;&lt;&quot;Test case #&quot;&lt;&lt;cnt&lt;&lt;&quot;:&quot;&lt;&lt;endl; for(int i=0;i&lt;q;i++)&#123; if(is[i]==1)cout&lt;&lt;s[i]&lt;&lt;&quot; YES&quot;&lt;&lt;endl; else cout&lt;&lt;s[i]&lt;&lt;&quot; NO&quot;&lt;&lt;endl; &#125; cout&lt;&lt;endl; &#125;&#125; tips：scanf不吸收回车要用，getchar（）吸收回车 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n=4; char a,b; char s[100];int cnt=0; for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%c %c&quot;,&amp;a,&amp;b);//输入两个字符，并打印出来 getchar(); //注意吸收回车 s[cnt]=a;cnt++; s[cnt]=b;cnt++; &#125; for(int i=0;i&lt;cnt;i++)cout&lt;&lt;s[i]&lt;&lt;&#x27; &#x27;;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"剑指offer 第四章 解决面试题的思路","slug":"剑指offer-第四章-解决面试题的思路","date":"2020-03-28T10:13:00.000Z","updated":"2022-02-26T03:52:51.646Z","comments":true,"path":"2020/03/28/剑指offer-第四章-解决面试题的思路/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/28/%E5%89%91%E6%8C%87offer-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A7%A3%E5%86%B3%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF/","excerpt":"","text":"4.1面试官谈面试思路4.2画图让抽象问题形象化 剑指Offer（27）：二叉树的镜像操作给定的二叉树，将其变换为源二叉树的镜像。 先交换根节点的两个子结点之后，我们注意到值为10、6的结点的子结点仍然保持不变，因此我们还需要交换这两个结点的左右子结点。做完这两次交换之后，我们已经遍历完所有的非叶结点。此时变换之后的树刚好就是原始树的镜像。交换示意图如下所示： 12345678910111213141516171819202122232425262728293031/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if((pRoot == NULL) || (pRoot-&gt;left == NULL &amp;&amp; pRoot-&gt;right == NULL))&#123; return; &#125; //交换根节点的左右结点 TreeNode *pTemp = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = pTemp; //递归左子树 if(pRoot-&gt;left)&#123; Mirror(pRoot-&gt;left); &#125; //递归右子树 if(pRoot-&gt;right)&#123; Mirror(pRoot-&gt;right); &#125; &#125;&#125;; 剑指Offer（28）：对称的二叉树题目 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 我们通常有三种不同的二叉树遍历算法，即前序遍历、中序遍历和后序遍历。在这三种遍历算法中，都是先遍历左子结点再遍历右子结点。以前序遍历为例，我们可以定义一个遍历算法，先遍历右子结点再遍历左子结点，暂且称其为前序遍历的对称遍历。 遍历第一棵树，前序遍历的遍历序列为{8,6,5,7,6,7,5}，其对称遍历的遍历序列为{8,6,5,7,6,7,5}。 遍历第二颗树，前序遍历的遍历序列为{8,6,5,7,9,7,5}，其对称遍历的遍历序列为{8,9,5,7,6,7,5}。 可以看到，使用此方法可以区分前两棵树，第一棵树为对称树，第二颗树不是对称树。但是当使用此方法，你会发现第三颗树的前序遍历和对称前序遍历的遍历序列是一样的。 怎么区分第三颗树呢？解决办法就是我们也要考虑NULL指针。此时，前序遍历的遍历序列{7,7,7,NULL,NULL,7,NULL,NULL,7,7,NLL,NULL,NULL}，其对称遍历的遍历序列为{7,7,NULL,7,NULL,NULL,7,7,NULL,NULL,7,NULL,NULL}。因为两种遍历的序列不同，因此这棵树不是对称树。 123456789101112131415161718192021222324252627282930313233/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool isSymmetrical(TreeNode* pRoot) &#123; if(pRoot == NULL)&#123; //传入的为空树 return true; &#125; return isSymmetriacalCor(pRoot, pRoot); &#125;private: bool isSymmetriacalCor(TreeNode* pRoot1, TreeNode* pRoot2)&#123; if(pRoot1 == NULL &amp;&amp; pRoot2 == NULL)&#123; return true; &#125; if(pRoot1 == NULL || pRoot2 == NULL)&#123; return false; &#125; if(pRoot1-&gt;val != pRoot2-&gt;val)&#123; return false; &#125; return isSymmetriacalCor(pRoot1-&gt;left, pRoot2-&gt;right) &amp;&amp; isSymmetriacalCor(pRoot1-&gt;right, pRoot2-&gt;left); &#125;&#125;; 剑指Offer（29）：顺时针打印矩阵题目 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵：则依次打印出数组：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11，10。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; int rows = matrix.size(); //行数 int cols = matrix[0].size(); //列数 vector&lt;int&gt; result; if(rows == 0 &amp;&amp; cols == 0)&#123; return result; &#125; int left = 0, right = cols - 1, top = 0, bottom = rows - 1; while(left &lt;= right &amp;&amp; top &lt;= bottom)&#123; //从左到右 for(int i = left; i &lt;= right; ++i)&#123; result.push_back(matrix[top][i]); &#125; //从上到下 for(int i = top + 1; i &lt;= bottom; ++i)&#123; result.push_back(matrix[i][right]); &#125; //从右到左 if(top != bottom)&#123; for(int i = right - 1; i &gt;= left; --i)&#123; result.push_back(matrix[bottom][i]); &#125; &#125; //从下到上 if(left != right)&#123; for(int i = bottom - 1; i &gt; top; --i)&#123; result.push_back(matrix[i][left]); &#125; &#125; left++, top++, right--, bottom--; &#125; return result; &#125;&#125;; 4.3举例让抽象问题具体化 剑指Offer（30）：包含min函数的栈题目 定义栈的数据结构，请在类型中实现一个能够得到栈最小元素的min函数。思路 使用两个stack，一个为数据栈，另一个为辅助栈。数据栈用于存储所有数据，辅助栈用于存储最小值。 举个例子： 入栈的时候：首先往空的数据栈里压入数字3，显然现在3是最小值，我们也把最小值压入辅助栈。接下来往数据栈里压入数字4。由于4大于之前的最小值，因此我们只要入数据栈，不压入辅助栈。 出栈的时候：当数据栈和辅助栈的栈顶元素相同的时候，辅助栈的栈顶元素出栈。否则，数据栈的栈顶元素出栈。 获得栈顶元素的时候：直接返回数据栈的栈顶元素。 栈最小元素：直接返回辅助栈的栈顶元素。 123456789101112131415161718192021222324252627class Solution &#123;public: void push(int value) &#123; Data.push(value); if(Min.empty())&#123;//第一次时最小栈为空，特判 Min.push(value); &#125; if(Min.top() &gt; value)&#123; Min.push(value); &#125; &#125; void pop() &#123; if(Data.top() == Min.top())&#123; Min.pop(); &#125; Data.pop(); &#125; int top() &#123; return Data.top(); &#125; int min() &#123; return Min.top(); &#125;private: stack&lt;int&gt; Data; //数据栈 stack&lt;int&gt; Min; //最小栈&#125;; 剑指Offer（31）：栈的压入、弹出序列题目 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）思路 借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。 123456789101112131415161718class Solution &#123;public: bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; if(pushV.size() == 0)&#123; return false; &#125; for(int i = 0, j = 0; i &lt; pushV.size();i++)&#123; stackData.push(pushV[i]); while(j &lt; popV.size() &amp;&amp; stackData.top() == popV[j])&#123; stackData.pop(); j++; &#125; &#125; return stackData.empty(); //栈为空，则返回true &#125;private: stack&lt;int&gt; stackData;&#125;; 剑指Offer（32）：从上往下打印二叉树 题目 从上往下打印出二叉树的每个节点，同层节点从左至右打印。思路 举例说明：广度优先遍历二叉树 如上图所示，因为按层打印的顺序决定应该先打印根结点，所以我们从树的根结点开始分析。为了接下来能够打印值为8的结点的两个子结点，我们应该在遍历该结点时把值为6和10的两个结点保存到一个容器里，现在容器内就有两个结点了。按照从左到右打印的要求，我们先取出为6的结点。打印出值6之后把它的值分别为5和7的两个结点放入数据容器。此时数据容器中有三个结点，值分别为10、5和7。接下来我们从数据容器中取出值为10的结点。注意到值为10的结点比值为5、7的结点先放入容器，此时又比这两个结点先取出，这就是我们通常说的先入先出，因此不难看出这个数据容器应该是一个队列。由于值为5、7、9、11的结点都没有子结点，因此只要依次打印即可。 整个打印过程如下图所示： 通过上面具体例子的分析，我们可以找到从上到下打印二叉树的规律：每一次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾。接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直至队列中所有的结点都打印出来为止。 12345678910111213141516171819202122232425262728293031323334/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; TreeNode* fr; if(root == NULL)&#123; return result; &#125; que.push(root); while(!que.empty())&#123; fr = que.front(); result.push_back(fr-&gt;val); if(fr-&gt;left != NULL)&#123; que.push(fr-&gt;left); &#125; if(fr-&gt;right != NULL)&#123; que.push(fr-&gt;right); &#125; que.pop(); &#125; return result; &#125;private: vector&lt;int&gt; result; queue&lt;TreeNode*&gt; que;&#125;; 上题的变题 按之字顺序打印二叉树题目 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。按之字顺序打印上图二叉树，打印顺序为：13 24 5 6 715 14 13 12 12 10 9 8 为了达到这样打印的效果，我们需要使用两个栈。我们在打印某一行结点时，把下一层的子结点保存到相应的栈里。如果当前打印的是奇数层（第一层、第三层等），则先保存左子树结点再保存右子树结点到第一个栈里。如果当前打印的是偶数层（第二层、第四层等），则则先保存右子树结点再保存左子树结点到第二个栈里。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt; &gt; result; if(pRoot == NULL)&#123; return result; &#125; stack&lt;TreeNode* &gt; s[2];//s[0]为第二个栈， s[1]为第一个栈 s[0].push(pRoot); //根节点压栈 while(!s[0].empty() || !s[1].empty())&#123; vector&lt;int&gt; v[2]; // 打印奇数行时，先左子树再右子树 while(!s[0].empty())&#123; v[0].push_back(s[0].top()-&gt;val); if(s[0].top()-&gt;left != NULL)&#123; s[1].push(s[0].top()-&gt;left); &#125; if(s[0].top()-&gt;right != NULL)&#123; s[1].push(s[0].top()-&gt;right); &#125; s[0].pop(); &#125; if(!v[0].empty())&#123; //v[0]栈为空的时候就向结果集中添加 result.push_back(v[0]); &#125; // 打印偶数行时，先存右子树在左子树 while(!s[1].empty())&#123; v[1].push_back(s[1].top()-&gt;val); if(s[1].top()-&gt;right != NULL)&#123; s[0].push(s[1].top()-&gt;right); &#125; if(s[1].top()-&gt;left != NULL)&#123; s[0].push(s[1].top()-&gt;left); &#125; s[1].pop(); &#125; if(!v[1].empty())&#123; result.push_back(v[1]); &#125; &#125; return result; &#125;&#125;; 上一题的变题 把二叉树打印成多行题目 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。思路和上一道题一样，区别在于，这把是先入先出，使用队列即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt; &gt; result; if(pRoot == NULL)&#123; return result; &#125; queue&lt;TreeNode* &gt; nodes[2]; nodes[0].push(pRoot); while(!nodes[0].empty() || !nodes[1].empty())&#123; vector&lt;int&gt; v[2]; while(!nodes[0].empty())&#123; v[0].push_back(nodes[0].front()-&gt;val); if(nodes[0].front()-&gt;left != NULL)&#123; nodes[1].push(nodes[0].front()-&gt;left); &#125; if(nodes[0].front()-&gt;right != NULL)&#123; nodes[1].push(nodes[0].front()-&gt;right); &#125; nodes[0].pop(); &#125; if(!v[0].empty())&#123; result.push_back(v[0]); &#125; while(!nodes[1].empty())&#123; v[1].push_back(nodes[1].front()-&gt;val); if(nodes[1].front()-&gt;left != NULL)&#123; nodes[0].push(nodes[1].front()-&gt;left); &#125; if(nodes[1].front()-&gt;right != NULL)&#123; nodes[0].push(nodes[1].front()-&gt;right); &#125; nodes[1].pop(); &#125; if(!v[1].empty())&#123; result.push_back(v[1]); &#125; &#125; return result; &#125;&#125;; 剑指Offer（33）：二叉搜索树的后序遍历序列 题目 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes，否则输出No。假设输入的数组的任意两个数字都互不相同。思路 举例说明：以{5,7,6,9,11,10,8}为例，后序遍历结果的最后一个数字8就是根结点的值。在这个数组中，前3个数字5、7和6都比8小，是值为8的结点的左子树结点；后3个数字9、11和10都比8大，是值为8的结点的右子树结点。 我们接下来用同样的方法确定与数组每一部分对应的子树的结构。这其实就是一个递归的过程。对于序列5、7、6，最后一个数字6是左子树的根结点的值。数字5比6小，是值为6的结点的左子结点，而7则是它的右子结点。同样，在序列9、11、10中，最后一个数字10是右子树的根结点，数字9比10小，是值为10的结点的左子结点，而11则是它的右子结点。 我们使用递归的方法，先判断数组的左子树和右子树的位置，然后再判断左子树、右子树是不是二叉搜索树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; return bst(sequence, 0, sequence.size() - 1); &#125;private: bool bst(vector&lt;int&gt; seq, int begin, int end)&#123; if(seq.empty() || begin &gt; end)&#123; return false; &#125; //根结点 int root = seq[end]; //在二叉搜索树中左子树的结点小于根结点 int i = begin; for(; i &lt; end; ++i)&#123; if(seq[i] &gt; root)&#123; break; &#125; &#125; //在二叉搜索书中右子树的结点大于根结点 for(int j = i; j &lt; end; ++j)&#123; if(seq[j] &lt; root)&#123; return false; &#125; &#125; //判断左子树是不是二叉搜索树 bool left = true; if(i &gt; begin)&#123; left = bst(seq, begin, i - 1); &#125; //判断右子树是不是二叉搜索树 bool right = true; if(i &lt; end - 1)&#123; right = bst(seq, i , end - 1); &#125; return left &amp;&amp; right; &#125;&#125;; 剑指Offer（34）：二叉树中和为某一值的路径题目 输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 思路 深度优先搜索。使用前序遍历，使用两个全局变量result和tmp，result来存放最终结果，tmp用来存放临时结果。 每次遍历，我们先把root的值压入tmp，然后判断当前root是否同时满足： 与给定数值相减为0； 左子树为空； 右子树为空。 如果满足条件，就将tmp压入result中，否则，依次遍历左右子树。需要注意的是，遍历左右子树的时候，全局变量tmp是不清空的，直到到了根结点才会清空tmp。 123456789101112131415161718192021222324252627282930313233/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber)&#123; if(root == NULL)&#123; return result; &#125; tmp.push_back(root-&gt;val); if((expectNumber - root-&gt;val ) == 0 &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)&#123; result.push_back(tmp); &#125; //遍历左子树 FindPath(root-&gt;left, expectNumber - root-&gt;val); //遍历右子树 FindPath(root-&gt;right, expectNumber - root-&gt;val); tmp.pop_back();//一层递归条用完了之后，需要的值expectNumber会发生变化 return result; &#125;private: vector&lt;vector&lt;int&gt; &gt; result; vector&lt;int&gt; tmp;&#125;; 4.4分解让复杂问题简单化 剑指Offer（35）：复杂链表的复制 题目 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 思路 大部分人首先想到的可能是先复制复杂指针的label和next，然后再查找random并更新。查找random又分为两种，一种是每次都从头查找，时间复杂度为O(n^2)；另一种是空间换时间，复制label和next的同时建立一个hash表来存放新旧复杂指针的对应关系，所以后续只需一步就能找到random，算法时间复杂度为O(n)。 我们这里将复杂链表的复制过程分解为三个步骤。在写代码的时候我们每一步定义一个函数，这样每个函数完成一个功能，整个过程的逻辑也就非常清晰明了了。 我们这里采用三步： 第一步：复制复杂指针的label和next。但是这次我们把复制的结点跟在元结点后面，而不是直接创建新的链表； 第二步：设置复制出来的结点的random。因为新旧结点是前后对应关系，所以也是一步就能找到random； 第三步：拆分链表。奇数是原链表，偶数是复制的链表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: //第一步，复制复杂指针的label和next void CloneNodes(RandomListNode* pHead)&#123; RandomListNode* pNode = pHead; while(pNode != NULL)&#123; RandomListNode* pCloned = new RandomListNode(0); pCloned-&gt;label = pNode-&gt;label; pCloned-&gt;next = pNode-&gt;next; pCloned-&gt;random = NULL; pNode-&gt;next = pCloned; pNode = pCloned-&gt;next; &#125; &#125; //第二步，处理复杂指针的random void ConnectSiblingNodes(RandomListNode* pHead)&#123; RandomListNode* pNode = pHead; while(pNode != NULL)&#123; RandomListNode* pCloned = pNode-&gt;next; if(pNode-&gt;random != NULL)&#123; pCloned-&gt;random = pNode-&gt;random-&gt;next; &#125; pNode = pCloned-&gt;next; &#125; &#125; //第三步，拆分复杂指针 RandomListNode* ReconnectNodes(RandomListNode* pHead)&#123; RandomListNode* pNode = pHead; RandomListNode* pClonedHead = NULL; RandomListNode* pClonedNode = NULL; if(pNode != NULL)&#123; pClonedHead = pClonedNode = pNode-&gt;next; pNode-&gt;next = pClonedNode-&gt;next; pNode = pNode-&gt;next; &#125; while(pNode != NULL)&#123; pClonedNode-&gt;next = pNode-&gt;next; pClonedNode = pClonedNode-&gt;next; pNode-&gt;next = pClonedNode-&gt;next; pNode = pNode-&gt;next; &#125; return pClonedHead; &#125; RandomListNode* Clone(RandomListNode* pHead) &#123; CloneNodes(pHead); ConnectSiblingNodes(pHead); return ReconnectNodes(pHead); &#125;&#125;; 剑指Offer（36）：二叉搜索树与双向链表题目 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 思路 举例说明： 二叉搜索树如上图所示，我们将其转换为配需双向链表。 根据二叉搜索树的特点：左结点的值&lt;根结点的值&lt;右结点的值，我们不难发现，使用二叉树的中序遍历出来的数据的数序，就是排序的顺序。因此，首先，确定了二叉搜索树的遍历方法。 接下来，我们看下图，我们可以把树分成三个部分：值为10的结点、根结点为6的左子树、根结点为14的右子树。根据排序双向链表的定义，值为10的结点将和它的左子树的最大一个结点链接起来，同时它还将和右子树最小的结点链接起来。 按照中序遍历的顺序，当我们遍历到根结点时，它的左子树已经转换成一个排序的好的双向链表了，并且处在链表中最后一个的结点是当前值最大的结点。我们把值为8的结点和根结点链接起来，10就成了最后一个结点，接着我们就去遍历右子树，并把根结点和右子树中最小的结点链接起来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* Convert(TreeNode* pRootOfTree) &#123; //用于记录双向链表尾结点 TreeNode* pLastNodeInList = NULL; //开始转换结点 ConvertNode(pRootOfTree, &amp;pLastNodeInList); //pLastNodeInList指向双向链表的尾结点，我们需要重新返回头结点 TreeNode* pHeadOfList = pLastNodeInList; while(pHeadOfList != NULL &amp;&amp; pHeadOfList-&gt;left != NULL)&#123; pHeadOfList = pHeadOfList-&gt;left; &#125; return pHeadOfList; &#125; void ConvertNode(TreeNode* pNode, TreeNode** pLastNodeInList)&#123; //叶结点直接返回 if(pNode == NULL)&#123; return; &#125; TreeNode* pCurrent = pNode; //递归左子树 if(pCurrent-&gt;left != NULL) ConvertNode(pCurrent-&gt;left, pLastNodeInList); //左指针 pCurrent-&gt;left = *pLastNodeInList; //右指针 if(*pLastNodeInList != NULL)&#123; (*pLastNodeInList)-&gt;right = pCurrent; &#125; //更新双向链表尾结点 *pLastNodeInList = pCurrent; //递归右子树 if(pCurrent-&gt;right != NULL)&#123; ConvertNode(pCurrent-&gt;right, pLastNodeInList); &#125; &#125;&#125;; 剑指Offer（37）：序列化二叉树题目 请实现两个函数，分别用来序列化和反序列化二叉树。 思路 这道题思路简单，使用前序遍历来序列化和发序列化即可。只要自己写的程序格式对应上即可。可以使用$符号表示NULL，同时每个结点之间，需要添加逗号，即’,’进行分隔。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: char* Serialize(TreeNode *root) &#123; if(!root)&#123; return NULL; &#125; string str; SerializeCore(root, str); // 把str流中转换为字符串返回 int length = str.length(); char* res = new char[length+1]; // 把str流中转换为字符串返回 for(int i = 0; i &lt; length; i++)&#123; res[i] = str[i]; &#125; res[length] = &#x27;\\0&#x27;; return res; &#125; TreeNode* Deserialize(char *str) &#123; if(!str)&#123; return NULL; &#125; TreeNode* res = DeserializeCore(&amp;str); return res; &#125; void SerializeCore(TreeNode* root, string&amp; str)&#123; // 如果指针为空，表示左子节点或右子节点为空，则在序列中用#表示 if(!root)&#123; str += &#x27;#&#x27;; return; &#125; string tmp = to_string(root-&gt;val); str += tmp; // 加逗号，用于区分每个结点 str += &#x27;,&#x27;; SerializeCore(root-&gt;left, str); SerializeCore(root-&gt;right, str); &#125; // 递归时改变了str值使其指向后面的序列，因此要声明为char** TreeNode* DeserializeCore(char** str)&#123; // 到达叶节点时，调用两次，都返回null，所以构建完毕，返回父节点的构建 if(**str == &#x27;#&#x27;)&#123; (*str)++; return NULL; &#125; // 因为整数是用字符串表示，一个字符表示一位，先进行转换 int num = 0; while(**str != &#x27;,&#x27; &amp;&amp; **str != &#x27;\\0&#x27;)&#123; num = num * 10 + ((**str) - &#x27;0&#x27;); (*str)++; &#125; TreeNode* root = new TreeNode(num); if(**str == &#x27;\\0&#x27;)&#123; return root; &#125; else&#123; (*str)++; &#125; root-&gt;left = DeserializeCore(str); root-&gt;right = DeserializeCore(str); return root; &#125;&#125;; 剑指Offer（38）：字符串的排列题目 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc，则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述： 输入一个字符串,长度不超过9(可能有字符重复)，字符只包括大小写字母。 思路 我们求整个字符串的排列，可以看成两步：首先求所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。如下图所示： 上图就是分别把第一个字符a和后面的b、c等字符交换的情形。首先固定第一个字符，求后面所有字符的排列。这个时候我们仍把后面的所有字符分为两部分：后面的字符的第一个字符，以及这个字符之后的所有字符。然后把第一个字符逐一和它后面的字符交换。 这个思路，是典型的递归思路。 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;string&gt; Permutation(string str) &#123; //判断输入 if(str.length() == 0)&#123; return result; &#125; PermutationCore(str, 0); //对结果进行排序 sort(result.begin(), result.end()); return result; &#125; private: void PermutationCore(string str, int begin)&#123; //递归结束的条件：第一位和最后一位交换完成 if(begin == str.length())&#123; result.push_back(str); return; &#125; for(int i = begin; i &lt; str.length(); i++)&#123; //如果字符串相同，则不交换 if(i != begin &amp;&amp; str[i] == str[begin])&#123; continue; &#125; //位置交换 swap(str[begin], str[i]); //递归调用，前面begin+1的位置不变，后面的字符串全排列 PermutationCore(str, begin + 1); &#125; &#125; vector&lt;string&gt; result;&#125;;","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%89%91%E6%8C%87offer/"}],"tags":[],"author":"aoyuehan"},{"title":"office技巧","slug":"office","date":"2020-03-28T08:13:00.000Z","updated":"2022-02-26T03:52:51.538Z","comments":true,"path":"2020/03/28/office/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/28/office/","excerpt":"","text":"word 2 3 4 excel 2 3 4 ppt 2 3","categories":[{"name":"Windows和office的使用技巧","slug":"Windows和office的使用技巧","permalink":"https://zouyunkai.github.io/myblog/categories/Windows%E5%92%8Coffice%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}],"tags":[],"author":"aoyuehan"},{"title":"c++面向对象程序设计","slug":"c-面向对象程序设计","date":"2020-03-28T05:47:00.000Z","updated":"2022-02-26T03:51:21.489Z","comments":true,"path":"2020/03/28/c-面向对象程序设计/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/28/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"1、 构造函数和析构函数的作用是什么，什么时候需要自己定义构造函数和析构函数（1） 构造函数的作用：用于新建对象的初始化工作。 析构函数的作用：用于在撤销对象前，完成一些清理工作，比如：释放内存等。（2） 每当创建对象时，需要添加初始化代码时，则需要定义自己的构造函数；而对象撤销时，需要自己添加清理工作的代码时，则需要定义自己的析构函数。 2、 构造函数和析构函数调用的顺序是什么？（1） 构造函数的调用顺序 为：基类构造函数、对象成员构造函数、派生类本身的构造函数。（2） 析构函数的调用顺序为：派生类本身的析构函数、对象成员析构函数、基类析构函数（与构造顺序正好相反）。","categories":[{"name":"c++面向对象","slug":"c-面向对象","permalink":"https://zouyunkai.github.io/myblog/categories/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[],"author":"aoyuehan"},{"title":"sqlserver使用debug","slug":"sqlserver使用debug","date":"2020-03-27T08:30:00.000Z","updated":"2022-02-26T03:52:52.212Z","comments":true,"path":"2020/03/27/sqlserver使用debug/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/27/sqlserver%E4%BD%BF%E7%94%A8debug/","excerpt":"","text":"阻止保存要求重新创建表的更改我在修改数据库中已经存在的表中字段类型的时候报出不能修改的命令： 解决办法： 工具-〉选项-〉左侧有个 设计器-〉表设计器和数据库设计器 -&gt; 阻止保存要求重新创建表的更改(右侧) 把钩去掉即可。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[],"author":"aoyuehan"},{"title":"计网（二）","slug":"计网（二）","date":"2020-03-27T02:04:00.000Z","updated":"2022-02-26T03:52:51.544Z","comments":true,"path":"2020/03/27/计网（二）/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/27/%E8%AE%A1%E7%BD%91%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"续第四章 高速以太网 无线局域网 第五章 因特网原理因特网概述 ipv4 一个例子 更正，b向a发送的是单播，此时x，y，z主机不会接受到b发出的地址，此时不会记录b的ip地址和mac地址。 ARP协议中，A主机想要获取本网络中B主机的MAC地址，则A主机的ARP请求分组是以广播方式发送，B主机的ARP响应分组是单播发送。 例题： 广播风暴？一个数据帧或包被传输到本地网段上的每个节点就是广播；由于网络拓扑的设计和连接问题，或其他原因导致广播在网段内大量复制，传播数据帧，导致网络性能下降，甚至网络瘫痪，这就是广播风暴。所以需要有能够 隔离广播域的设备才可以抑制广播风暴，只有路由器可以隔离广播域。 子网划分 无分类地址和CIDR ip分组的转发 因特网的路由协议 内部网关协议 外部网关协议 专用网络互连 IPV6","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"aoyuehan"},{"title":"asp实验五","slug":"asp实验五","date":"2020-03-27T00:15:00.000Z","updated":"2022-02-26T03:51:21.483Z","comments":true,"path":"2020/03/27/asp实验五/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/27/asp%E5%AE%9E%E9%AA%8C%E4%BA%94/","excerpt":"","text":"实验项目名称 验证控件和母版站点地图的学习一、实验内容1、server对象的扩展学习，理解不同页面跳转区别，response.Redirect()和Server.Transfer() 各种验证控件：非空验证控件、比较验证控件、范围验证控件、正则表达式验证控件、验证汇总控件 学习使用母版页统一页面布局、母版页与站点地图 至5.9用户登录退出的实现。2、用上次课学习的验证控件和母版站点地图等知识编写自己的程序，程序功能不限。 二、实验方法与步骤1、用sever.transfer方法，Response.Redirect方法实现页面跳转。123456789101112131415161718代码：窗体中添加两个按钮，然后在后台编写按钮的方法：public partial class WebForm1 : System.Web.UI.Page &#123; protected void Page_Load(object sender, EventArgs e) &#123; &#125; protected void Button1_Click(object sender, EventArgs e) &#123; Server.Transfer(&quot;WebForm2.aspx&quot;); &#125; protected void Button2_Click(object sender, EventArgs e) &#123; Response.Redirect(&quot;WebForm2.aspx&quot;); &#125; &#125; 2、非空验证控件编写一个文本框，添加非空验证的控件，提交测试。代码： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html &quot;&gt;&lt;head runat=&quot;server&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt; &lt;div&gt; 用户名：&lt;asp:TextBox ID=&quot;TextBox1&quot; runat=&quot;server&quot;&gt;&lt;/asp:TextBox&gt; &lt;asp:RequiredFieldValidator ID=&quot;RequiredFieldValidator1&quot; runat=&quot;server&quot; ControlToValidate=&quot;TextBox1&quot; ErrorMessage=&quot;用户名输入有误！&quot; ForeColor=&quot;#FF3300&quot; InitialValue=&quot; &quot;&gt;&lt;/asp:RequiredFieldValidator&gt; &lt;br /&gt; &lt;br /&gt; &lt;asp:Button ID=&quot;Button1&quot; runat=&quot;server&quot; Text=&quot;提交注册&quot; /&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在编写的时候忘记了在属性中写需要验证文本框控件，出现了错误： 3、比较验证代码：注意设置控件的参数，不能漏了。显示两个控件的时候，让显示为Dymatic形式，更好看一些。 4、范围验证1234567891011&lt;div&gt; 输入体重：&lt;asp:TextBox ID=&quot;TextBox1&quot; runat=&quot;server&quot; Visible=&quot;True&quot; TextMode=&quot;SingleLine&quot;&gt;&lt;/asp:TextBox&gt; &lt;asp:RequiredFieldValidator ID=&quot;RequiredFieldValidator1&quot; runat=&quot;server&quot; ControlToValidate=&quot;TextBox1&quot; ErrorMessage=&quot;请输入体重&quot; ForeColor=&quot;#FF3300&quot; InitialValue=&quot; &quot;&gt;&lt;/asp:RequiredFieldValidator&gt; &lt;asp:RangeValidator ID=&quot;RangeValidator2&quot; runat=&quot;server&quot; ErrorMessage=&quot;学员体重必须在60~70kg之间&quot; ControlToValidate=&quot;TextBox1&quot; Display=&quot;Dynamic&quot; ForeColor=&quot;Red&quot; MaximumValue=&quot;70&quot; MinimumValue=&quot;60&quot;&gt;&lt;/asp:RangeValidator&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;br /&gt; 出生日期：&lt;asp:TextBox ID=&quot;TextBox2&quot; runat=&quot;server&quot; TextMode=&quot;SingleLine&quot;&gt;&lt;/asp:TextBox&gt; &lt;asp:RequiredFieldValidator ID=&quot;RequiredFieldValidator2&quot; runat=&quot;server&quot; ErrorMessage=&quot;请输入出生日期&quot; ControlToValidate=&quot;TextBox2&quot; Display=&quot;Dynamic&quot; ForeColor=&quot;Red&quot;&gt;&lt;/asp:RequiredFieldValidator&gt; &lt;asp:RangeValidator ID=&quot;RangeValidator1&quot; runat=&quot;server&quot; ErrorMessage=&quot;学员身高必须在160~170之间&quot; ControlToValidate=&quot;TextBox2&quot; Display=&quot;Dynamic&quot; ForeColor=&quot;Red&quot; MaximumValue=&quot;170&quot; MinimumValue=&quot;160&quot;&gt;&lt;/asp:RangeValidator&gt; &lt;br /&gt; &lt;asp:Button ID=&quot;Button1&quot; runat=&quot;server&quot; Text=&quot;提交注册&quot; /&gt; &lt;/div&gt; Debug：在选择验证数据的类型时出现了一个问题： 5、正则验证 12345678&lt;div&gt; 请输入电子邮件：&lt;asp:TextBox ID=&quot;TextBox1&quot; runat=&quot;server&quot;&gt;&lt;/asp:TextBox&gt; &lt;asp:RequiredFieldValidator ID=&quot;RequiredFieldValidator1&quot; runat=&quot;server&quot; ControlToValidate=&quot;TextBox1&quot; ErrorMessage=&quot;邮件不能为空！&quot; ForeColor=&quot;#FF3300&quot; InitialValue=&quot; &quot;&gt;&lt;/asp:RequiredFieldValidator&gt; &lt;asp:RegularExpressionValidator ID=&quot;RegularExpressionValidator1&quot; runat=&quot;server&quot; ErrorMessage=&quot;电子邮件地址不正确&quot; ControlToValidate=&quot;TextBox1&quot; Display=&quot;Dynamic&quot; ValidationExpression=&quot;\\w+([-+.&#x27;]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*&quot;&gt;&lt;/asp:RegularExpressionValidator&gt; &lt;br /&gt; &lt;br /&gt; &lt;asp:Button ID=&quot;Button1&quot; runat=&quot;server&quot; Text=&quot;提交注册&quot; /&gt;&lt;/div&gt; 6、验证汇总 7、母版页 8、总和实践站点地图的设计，在母版页中添加站点地图控件，然后在新建站点地图，写上url和title，然后在编写好的页面中点击查看部分代码：数据库访问实现 三、实验心得1、在第一个题目的时候把Server.Transfer(“WebForm2.aspx”);写成Server.Transfer(“&#x2F;WebForm2.aspx”)，结果不显示界面，因为WebForm2和WebForm1在同一个目录下；而&#x2F;代表服务器的根目录。2、在添加站点地图的时候拖拽错了控件，结果一直没显示。后来重看了一次视频，发现要拖动工具栏-&gt;导航-&gt;SiteMapPath控件，到此，才算添加成功。3、一个文本框后面有两个验证的时候，我们可以把两个验证的Display属性设置为：”Dynamic”，这样的话就不会空出一块来，让页面更加美观。","categories":[{"name":"asp","slug":"asp","permalink":"https://zouyunkai.github.io/myblog/categories/asp/"}],"tags":[],"author":"aoyuehan"},{"title":"UCF  local 2018","slug":"UCF-local-2018","date":"2020-03-26T13:25:48.000Z","updated":"2022-02-26T03:52:52.469Z","comments":true,"path":"2020/03/26/UCF-local-2018/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/26/UCF-local-2018/","excerpt":"","text":"A Window on the Wall直接判断墙的长和宽是否均长于 2 倍的 d，因为两边均要留有空隙窗户的最大面积为（w-2d）(h-2*d) 12345678910#include&lt;bits/stdc++.h&gt;using namespace std;int w,h,d;int main()&#123; cin&gt;&gt;w&gt;&gt;h&gt;&gt;d; if(w&gt;2*d&amp;&amp;h&gt;2*d) printf(&quot;%d\\n&quot;,(w-2*d)*(h-2*d)); else puts(&quot;0&quot;); return 0;&#125; G Parity of Strings直接模拟判断字符串中每个字符出现的次数如果均是偶数次输出 0如果均是奇数次输出 1如果均有则输出 2 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;char s[75];int cnt[30];int main() &#123; scanf(&quot;%s&quot;,s); int len=strlen(s); for(int i=0;i&lt;len;i++) cnt[s[i]-&#x27;a&#x27;]++; int flageven=0,flagodd=0; for(int i=0;i&lt;26;i++)&#123; if(cnt[i]&gt;0&amp;&amp;cnt[i]%2==0)flageven=1; if(cnt[i]%2==1) flagodd=1; &#125; if (flageven&amp;&amp;flagodd) printf(&quot;2\\n&quot;); else if(flageven) printf(&quot;0\\n&quot;); else printf(&quot;1\\n&quot;); return 0;&#125; H Historical TV Remote Control 简单贪心楼层的范围是 1 到 999，直接判断每个楼层是否可达，假如该楼层中包含损坏的数字则不可达，否则可达，注意特判 0 层的情况若该楼层可达且比当前答案值更小，则更新答 1234567891011121314151617181920212223242526272829精简法：#include&lt;bits/stdc++.h&gt;using namespace std;int n,broken[10],target;bool check(int x) &#123; if(x==0&amp;&amp;broken[0]) return false;//特判 while(x) &#123; int pos=x%10; if(broken[pos]) return false; x/=10; &#125; return true;&#125;int main() &#123; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; int x; cin&gt;&gt;x; broken[x]=1; &#125; cin&gt;&gt;target; int ans=1000; for(int i=0; i&lt;=999; i++) &#123; if(check(i)) ans=min(ans,abs(i-target)); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556暴力法：#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[20];int ans=1010;int t;int s[1010];int main() &#123; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++)&#123; cin&gt;&gt;a[i]; if(a[i]==0)s[0]=-1; &#125; cin&gt;&gt;t; for(int i=1; i&lt;1000; i++) s[i]=i; if(s[0]!=-1)s[0]=0;//0这个位置要特判一下 for(int i=1; i&lt;1000; i++) &#123; int tmp=i; int q[4]; int sum=0; while(tmp!=0) &#123;//把这个的每一位存一下 q[sum]=tmp%10; sum++; tmp/=10; &#125; // cout&lt;&lt;endl; // for(int j=0;j&lt;sum;j++) // cout&lt;&lt;q[j]&lt;&lt;&quot; &quot;; // cout&lt;&lt;endl; int f=0; for(int j=0; j&lt;sum; j++) &#123; for(int k=1; k&lt;=n; k++) if(q[j]==a[k]) &#123;//如果这个数字中出现不能出现的数字就让s[i]变为-1 f=1; break; &#125; if(f) &#123; s[i]=-1; break; &#125; &#125; &#125; for(int i=0; i&lt;1000; i++) if(s[i]!=-1)//遍历没有出现-1的值中，选最小的 ans=min(ans,abs(t-s[i])); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; B SGA President题意：给定一个整数 n，后面紧接着 n 个字符串，代表着名字。要求：字符串首字母相等，而两字符串不相等则为一种成功组合。问最多有多少组合。其中 abc&#x2F;acc 是一种成功组合，acc&#x2F;abc 也是一种成功组合。；题中的样例一，一个JOSH可以和两个同名的JENNIFER算两次组合，然后翻转在算两次，而JENNIFER和JENNIFER不能算为一次组合。思路：先排序是必须的，然后遍历一遍即可。在相同的首字母中遍历，如果下一个与上一个不相同，则 ans+遍历的长度若相同则 ans+上一次遍历的长度 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;typedef long long ll;bool cmp(string x,string y) &#123; return x&lt;y;&#125;string str[100010];int main() &#123; ll n,ans=0; cin&gt;&gt;n; for (int i=1; i&lt;=n; i++) cin&gt;&gt;str[i]; sort(str+1,str+n+1,cmp); int l=1,r=1; char tmp=str[1][0]; for (int i=2; i&lt;=n; i++) &#123; if (str[i][0]!=tmp) &#123; tmp=str[i][0]; l=r=1; continue; &#125; if (str[i]!=str[i-1]) &#123; r=0; &#125; ans+=2*(l-r); l++; r++; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[],"author":"aoyuehan"},{"title":"java Thread","slug":"java-Thread","date":"2020-03-26T01:34:00.000Z","updated":"2022-02-26T03:52:51.023Z","comments":true,"path":"2020/03/26/java-Thread/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/26/java-Thread/","excerpt":"","text":"什么是进程和线程？ 进程 - 进程是具有一定独立功能的程序（例如QQ.exe），关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。 线程 - 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位；线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行。 相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。 多线程的优点其实多线程从某方面可以等价于多任务，当你有多个任务要处理时，多个任务一起做所消耗的时间肯定比任务串行起来做，所消耗的时间短；下图可以很好的说明： 在我们现在的系统中，CPU的运行速度是很快的，其中很大的时间消耗是在等硬盘、IO输入、网络等资源；当多任务时，CPU完全可以在多个任务之间来回切换。使用的花费的时间远远少于所有任务需要消耗的少。 多线程问题 并发与并行 线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码： 1234void transferMoney(User from, User to, float amount)&#123; to.setMoney(to.getBalance() + amount); from.setMoney(from.getBalance() - amount);&#125; 同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。 使用多线程在Java的JDK包中，已经自带了对多线程技术的支持，可以非常方便地进行多线程的编程。实现多线程编程的方式主要有两种： 继承Thread类 实现Runnable接口Thread类实现了Runnable接口，它们之间具有多态关系。 Runnable接口类源代码： 1234@FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; Thread类的主要源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Thread implements Runnable &#123; public static native Thread currentThread(); public static native void yield(); public static native void sleep(long millis) throws InterruptedException; public static void sleep(long millis, int nanos) throws InterruptedException &#123; // ... sleep(millis); &#125; public Thread() &#123; init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; public Thread(Runnable target) &#123; init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; public Thread(ThreadGroup group, Runnable target) &#123; init(group, target, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; public synchronized void start() &#123; // ... start0(); // ... &#125; private native void start0(); @Deprecated public final void stop() &#123; // ... &#125; public void interrupt() &#123; // ... &#125; public static boolean interrupted() &#123; return currentThread().isInterrupted(true); &#125; public boolean isInterrupted() &#123; return isInterrupted(false); &#125; private native boolean isInterrupted(boolean ClearInterrupted); public final native boolean isAlive(); @Deprecated public final void suspend() &#123; checkAccess(); suspend0(); &#125; @Deprecated public final void resume() &#123; checkAccess(); resume0(); &#125;&#125; 这二种创建线程的方式有什么区别？这个主要是因为Java类是单继承的，而接口可以支持多继承，使用Thread类的方式创建新线程时，最大的局限就是不支持多继承。所以具体选择哪种方式来创建线程，就看你是不是需要具体多继承的特性；其他没有本质的区别。 Thread详解通过Thread的源代码，我们现在对其主要的的一些方法进行讲解一下 native关键字 - native是与C++联合开发的时候用的！使用native关键字说明这个方法是原生函数，也就是说这个方法是用C&#x2F;C++语言实现的，并且被编译成dll相关组件，由java来调用。所以从上面的Thread类源代码中可以看到，有好多是调用了原生的函数。 构造方法 - Thread有一组构造方法，具体指定了线程名称(name)、线程组(ThreadGroup)、接口类(Runnable)、栈大小(stackSize)等参数 。 isAlive() - 方法isAlive()是判断当前的线程是否处于活动状态。而这个活动状态指的是：线程已经启动且尚未终止，如正在运行,准备开始运行的状态，都认为线程是“存活”的。 sleep() - 在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指this.currentThread()返回的线程。 getId() - 取得线程的唯一标识。每个线程在初始化的过程中都会调用nextThreadID方法获取到一个唯一标识。 12345private static long threadSeqNumber;private static synchronized long nextThreadID() &#123; return ++threadSeqNumber;&#125; 在一个进程中，线程的ID是唯一的 停止线程 - 停止线程是在多线程开始时很重要的技术点，而停止线程在Java中并不像break语句那样干脆，需要一些技巧性的处理。 使用退出标志，使线程正常退出，即当run方法完成后线程终止。 使用stop方法强行终止线程，但是不推荐使用该方法，因为stop和suspend及resume一样，都是作废过期的方法，使用它们可能产生不可预料的结果。 使用interrupt方法中断线程。 暂停线程 - 暂停线程意味着此线程还可以恢复运行。使用suspend()方法暂停线程，resume()方法恢复线程的执行。 yield - yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。但是放弃的时间不确定，有可能刚放弃，马上又获得CPU时间片了。 线程优先级 - 在操作系统中，线程可以划分优先级，优先级较高的线程得到的CPU资料较多，也就是CPU优先执行优先级较高的线程对象中的任务。在Thread中，我们使用setPriority()方法设置优先级别。 12345678java的线程优先级分为1~10这10个等级public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5; //默认public final static int MAX_PRIORITY = 10; 线程优先级具有继承特性， 比如A线程启动B线程，则B线程的优先级与A是一样的。 优先级具有规则性，虽然我们使用setPriority()方法设置了优先级，但是真正执行的过程中，不会保证优先级高的线程绝对比优先级低的线程优先完成。即CPU尽量将执行资源让给优先级比较高的线程。 *优先级具有随机性，具优先级较高的线程不一定每一次都先执行完。 守护线程 - 在Java线程中有两种线程，一种是用户线程，另一种是守护线程。 守护线程是一种特殊的线程，它的特性有“陪伴”的含义，当进程中不存在非守护线程了，则守护线程自动销毁。典型的守护线程就是垃圾回收线程，当进程中没有非守护线程了，则垃圾回收线程则没有存在的必要了，自动销毁。只要当前JVM实例中存在任何一个非守护线程没有结束，守护线程就在工作，只有当最后一个非守护线程结束时，守护线程才随着JVM一同结束工作。通过调用Thread.setDaemon(true)设置是否为守护线程。 线程的同步：在同步代码块中，只能存在一个线程。线程的安全问题:什么是线程安全问题呢？线程安全问题是指，多个线程对同一个共享数据进行操作时，线程没来得及更新共享数据，从而导致另外线程没得到最新的数据，从而产生线程安全问题。 上述例子中：创建三个窗口卖票，总票数为100张票1.卖票过程中，出现了重票（票被反复的卖出，ticket未被减少时就打印出了）错票。2.问题出现的原因：当某个线程操作车票的过程中，尚未完成操作时，其他线程参与进来，也来操作车票。（将此过程的代码看作一个区域，当有线程进去时，装锁，不让别的线程进去）生动理解的例子：有一个厕所，有人进去了，但是没有上锁，于是别人不知道你进去了，别人也进去了对厕所也使用造成错误。3.如何解决：当一个线程在操作ticket时，其他线程不能参与进来，直到此线程的生命周期结束4.在java中，我们通过同步机制，来解决线程的安全问题。 实例讲解解决线程安全的三个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566在不解决同步问题的时候：public class ThreadUnSecurity &#123; static int tickets = 10; class SellTickets implements Runnable&#123; @Override public void run() &#123; // 未加同步时产生脏数据 while(tickets &gt; 0) &#123; System.out.println(Thread.currentThread().getName()+&quot;---&gt;售出第： &quot;+tickets+&quot; 票&quot;); tickets--; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (tickets &lt;= 0) &#123; System.out.println(Thread.currentThread().getName()+&quot;---&gt;售票结束！&quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; SellTickets sell = new ThreadUnSecurity().new SellTickets(); Thread thread1 = new Thread(sell, &quot;1号窗口&quot;); Thread thread2 = new Thread(sell, &quot;2号窗口&quot;); Thread thread3 = new Thread(sell, &quot;3号窗口&quot;); Thread thread4 = new Thread(sell, &quot;4号窗口&quot;); thread1.start(); thread2.start(); thread3.start(); thread4.start(); &#125;&#125;结果为：1号窗口---&gt;售出第： 10 票3号窗口---&gt;售出第： 10 票2号窗口---&gt;售出第： 10 票4号窗口---&gt;售出第： 10 票2号窗口---&gt;售出第： 6 票1号窗口---&gt;售出第： 5 票3号窗口---&gt;售出第： 4 票4号窗口---&gt;售出第： 3 票2号窗口---&gt;售出第： 2 票4号窗口---&gt;售出第： 1 票1号窗口---&gt;售出第： 1 票3号窗口---&gt;售票结束！2号窗口---&gt;售票结束！1号窗口---&gt;售票结束！4号窗口---&gt;售票结束！我们可以看出同一张票在不对票数进行保护时会出现同一张票会被出售多次！由于线程调度中的不确定性，多次运行出现的运行结果会有不同。 方法一 同步代码块： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.bpan.spring.beans.thread;import com.sun.org.apache.regexp.internal.recompile;public class ThreadSynchronizedSecurity &#123; static int tickets = 10; class SellTickets implements Runnable&#123; @Override public void run() &#123; // 同步代码块 while(tickets &gt; 0) &#123; synchronized (this) &#123; // System.out.println(this.getClass().getName().toString()); if (tickets &lt;= 0) &#123; return; &#125; System.out.println(Thread.currentThread().getName()+&quot;---&gt;售出第： &quot;+tickets+&quot; 票&quot;); tickets--; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (tickets &lt;= 0) &#123; System.out.println(Thread.currentThread().getName()+&quot;---&gt;售票结束！&quot;); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; SellTickets sell = new ThreadSynchronizedSecurity().new SellTickets(); Thread thread1 = new Thread(sell, &quot;1号窗口&quot;); Thread thread2 = new Thread(sell, &quot;2号窗口&quot;); Thread thread3 = new Thread(sell, &quot;3号窗口&quot;); Thread thread4 = new Thread(sell, &quot;4号窗口&quot;); thread1.start(); thread2.start(); thread3.start(); thread4.start(); &#125;&#125; 方法二 同步方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.bpan.spring.beans.thread;public class ThreadSynchroniazedMethodSecurity &#123; static int tickets = 10; class SellTickets implements Runnable&#123; @Override public void run() &#123; //同步方法 while (tickets &gt; 0) &#123; synMethod(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; if (tickets&lt;=0) &#123; System.out.println(Thread.currentThread().getName()+&quot;---&gt;售票结束&quot;); &#125; &#125; &#125; synchronized void synMethod() &#123; //此方法为同步方法 synchronized (this) &#123; if (tickets &lt;=0) &#123; return; &#125; System.out.println(Thread.currentThread().getName()+&quot;----&gt;售出第 &quot;+tickets+&quot; 票 &quot;); tickets-- ; &#125; &#125; &#125; public static void main(String[] args) &#123; SellTickets sell = new ThreadSynchroniazedMethodSecurity().new SellTickets(); Thread thread1 = new Thread(sell, &quot;1号窗口&quot;); Thread thread2 = new Thread(sell, &quot;2号窗口&quot;); Thread thread3 = new Thread(sell, &quot;3号窗口&quot;); Thread thread4 = new Thread(sell, &quot;4号窗口&quot;); thread1.start(); thread2.start(); thread3.start(); thread4.start(); &#125;&#125; 方法三 Lock锁机制， 通过创建Lock对象，采用lock()加锁，unlock()解锁，来保护指定的代码块： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.bpan.spring.beans.thread;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class ThreadLockSecurity &#123; static int tickets = 10; class SellTickets implements Runnable&#123; Lock lock = new ReentrantLock();//此为可重入锁 @Override public void run() &#123; // Lock锁机制 while(tickets &gt; 0) &#123; try &#123; lock.lock(); if (tickets &lt;= 0) &#123; return; &#125; System.out.println(Thread.currentThread().getName()+&quot;---&gt;售出第： &quot;+tickets+&quot; 票&quot;); tickets--; &#125; catch (Exception e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125;finally &#123; lock.unlock(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; if (tickets &lt;= 0) &#123; System.out.println(Thread.currentThread().getName()+&quot;---&gt;售票结束！&quot;); &#125; &#125; &#125; public static void main(String[] args) &#123; SellTickets sell = new ThreadLockSecurity().new SellTickets(); Thread thread1 = new Thread(sell, &quot;1号窗口&quot;); Thread thread2 = new Thread(sell, &quot;2号窗口&quot;); Thread thread3 = new Thread(sell, &quot;3号窗口&quot;); Thread thread4 = new Thread(sell, &quot;4号窗口&quot;); thread1.start(); thread2.start(); thread3.start(); thread4.start(); &#125;&#125; 最后总结： 由于synchronized是在JVM层面实现的，因此系统可以监控锁的释放与否；而ReentrantLock是使用代码实现的，系统无法自动释放锁，需要在代码中的finally子句中显式释放锁lock.unlock()。 另外，在并发量比较小的情况下，使用synchronized是个不错的选择；但是在并发量比较高的情况下，其性能下降会很严重，此时ReentrantLock是个不错的方案。 补充： 在使用synchronized 代码块时,可以与wait()、notify()、nitifyAll()一起使用，从而进一步实现线程的通信。其中，wait()方法会释放占有的对象锁，当前线程进入等待池，释放cpu,而其他正在等待的线程即可抢占此锁，获得锁的线程即可运行程序；线程的sleep()方法则表示，当前线程会休眠一段时间，休眠期间，会暂时释放cpu，但并不释放对象锁，也就是说，在休眠期间，其他线程依然无法进入被同步保护的代码内部，当前线程休眠结束时，会重新获得cpu执行权,从而执行被同步保护的代码。wait()和sleep()最大的不同在于wait()会释放对象锁，而sleep()不会释放对象锁。 notify()方法会唤醒因为调用对象的wait()而处于等待状态的线程，从而使得该线程有机会获取对象锁。调用notify()后，当前线程并不会立即释放锁，而是继续执行当前代码，直到synchronized中的代码全部执行完毕，才会释放对象锁。JVM会在等待的线程中调度一个线程去获得对象锁，执行代码。 需要注意的是，wait()和notify()必须在synchronized代码块中调用。 notifyAll()是唤醒所有等待的线程。 深入了解可重入锁和独占锁 ReentrantLock和synchronized的比较（1）synchronized是独占锁，加锁和解锁的过程自动进行，易于操作，但不够灵活。ReentrantLock也是独占锁，加锁和解锁的过程需要手动进行，不易操作，但非常灵活。 （2）synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。 （3）synchronized不可响应中断，一个线程获取不到锁就一直等着；ReentrantLock可以相应中断。 ReentrantLock好像比synchronized关键字没好太多，我们再去看看synchronized所没有的，一个最主要的就是ReentrantLock还可以实现公平锁机制。什么叫公平锁呢？也就是在锁上等待时间最长的线程将获得锁的使用权。通俗的理解就是谁排队时间最长谁先执行获取锁。 ReentrantLock简单使用 公平锁实现 首先new一个ReentrantLock的时候参数为true，表明实现公平锁机制。在这里我们多定义几个线程ABCDE，然后再test方法中循环执行了两次加锁和解锁的过程。 非公平锁实现 非公平锁那就随机的获取，谁运气好，cpu时间片轮到哪个线程，哪个线程就能获取锁，和上面公平锁的区别很简单，就在于先new一个ReentrantLock的时候参数为false，当然我们也可以不写，默认就是false。直接测试一下 响应中断 响应中断就是一个线程获取不到锁，不会傻傻的一直等下去，ReentrantLock会给予一个中断回应。在这里我们举一个死锁的案例。 首先我们定义一个测试类ReentrantLockTest3。 在这里我们定义了两个锁lock1和lock2。然后使用两个线程thread和thread1构造死锁场景。正常情况下，这两个线程相互等待获取资源而处于死循环状态。但是我们此时thread中断，另外一个线程就可以获取资源，正常地执行了。 我们运行测试一下： 限时等待 这个是什么意思呢？也就是通过我们的tryLock方法来实现，可以选择传入时间参数，表示等待指定的时间，无参则表示立即返回锁申请的结果：true表示获取锁成功，false表示获取锁失败。我们可以将这种方法用来解决死锁问题。 首先还是测试代码，不过在这里我们不需要再去中断其中的线程了，我们直接看线程类是如何实现的。 在这个案例中，一个线程获取lock1时候第一次失败，那就等10毫秒之后第二次获取，就这样一直不停的调试，一直等到获取到相应的资源为止。 当然，我们可以设置tryLock的超时等待时间tryLock(long timeout,TimeUnit unit)，也就是说一个线程在指定的时间内没有获取锁，那就会返回false，就可以再去做其他事了。 Lock，tryLock，lockInterruptibly区别12345678910lockpublic void lock()获取锁。如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1。 指定者：接口 Lock 中的 lock 123456789101112131415161718192021222324252627lockInterruptiblypublic void lockInterruptibly() throws InterruptedException1）如果当前线程未被中断，则获取锁。 2）如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。 3）如果当前线程已经保持此锁，则将保持计数加 1，并且该方法立即返回。 4）如果锁被另一个线程保持，则出于线程调度目的，禁用当前线程，并且在发生以下两种情况之一以前，该线程将一直处于休眠状态： 1）锁由当前线程获得；或者 2）其他某个线程中断当前线程。 5）如果当前线程获得该锁，则将锁保持计数设置为 1。 如果当前线程： 1）在进入此方法时已经设置了该线程的中断状态；或者 2）在等待获取锁的同时被中断。 则抛出 InterruptedException，并且清除当前线程的已中断状态。 6）在此实现中，因为此方法是一个显式中断点，所以要优先考虑响应中断，而不是响应锁的普通获取或重入获取。 指定者： 接口 Lock 中的 lockInterruptibly抛出： InterruptedException 如果当前线程已中断。 123456789101112131415161718tryLock public boolean tryLock() 仅在调用时锁未被另一个线程保持的情况下，才获取该锁。 1）如果该锁没有被另一个线程保持，并且立即返回 true 值，则将锁的保持计数设置为 1。即使已将此锁设置为使用公平排序策略，但是调用 tryLock() 仍将 立即获取锁（如果有可用的），而不管其他线程当前是否正在等待该锁。在某些情况下，此“闯入”行为可能很有用，即使它会打破公平性也如此。如果希望遵守此锁的公平设置，则使用 tryLock(0, TimeUnit.SECONDS) ，它几乎是等效的（也检测中断）。 2）如果当前线程已经保持此锁，则将保持计数加 1，该方法将返回 true。 3）如果锁被另一个线程保持，则此方法将立即返回 false 值。 指定者： 接口 Lock 中的 tryLock返回： 如果锁是自由的并且被当前线程获取，或者当前线程已经保持该锁，则返回 true；否则返回 false","categories":[{"name":"java interview","slug":"java-interview","permalink":"https://zouyunkai.github.io/myblog/categories/java-interview/"}],"tags":[],"author":"aoyuehan"},{"title":"java SE note three","slug":"java-SE-note-three","date":"2020-03-25T06:04:00.000Z","updated":"2022-02-26T03:51:21.493Z","comments":true,"path":"2020/03/25/java-SE-note-three/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/25/java-SE-note-three/","excerpt":"","text":"集合（一） 请说明List、Map、Set三个接口存取元素时，各有什么特点？考察点：List参考回答：List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。 阐述ArrayList、Vector、LinkedList的存储性能和特性考察点：ArrayList参考回答：ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。 请判断List、Set、Map是否继承自Collection接口？考察点：collection接口参考回答：List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 请判断List、Set、Map是否继承自Collection接口？考察点：collection接口参考回答：List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。 请讲讲你所知道的常用集合类以及主要方法？考察点：集合参考回答：最常用的集合类是List 和 Map。List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其中每个键映射到一个值。 请说明Collection 和 Collections的区别。考察点：集合参考回答：Collection是集合类的上级接口，继承与他的接口主要有Set 和List.Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。 请简要说明ArrayList ,Vector,LinkedList的存储性能和特性是什么？考察点：ArrayList参考回答：ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector由于使用了synchronized方法（线程安全），通常性能上较ArrayList差，而LinkedList使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。 请说明ArrayList和LinkedList的区别？考察点：ArrayList参考回答：ArrayList和LinkedList都实现了List接口，他们有以下的不同点：ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。HashMap之快速失败 请说说快速失败(fail-fast)和安全失败(fail-safe)的区别？考察点：集合参考回答：Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。详细见 请你说说Iterator和ListIterator的区别？考察点：迭代器参考回答： Iterator和ListIterator的区别是：Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 请简单说明一下什么是迭代器？考察点：JAVA迭代器参考回答：Iterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口,每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例, 然后对集合的元素进行迭代操作.有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除. 集合（二） 请解释为什么集合类没有实现Cloneable和Serializable接口？考察点：JAVA集合参考回答：克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。实现Serializable序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。实现 Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化。 请说明Java集合类框架的基本接口有哪些？考察点：JAVA集合参考回答：集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：Collection：代表一组对象，每一个对象都是它的子元素。Set：不包含重复元素的Collection。List：有顺序的collection，并且可以包含重复元素。Map：可以把键(key)映射到值(value)的对象，键不能重复。 请你说明一下ConcurrentHashMap的原理？ 考察点：JAVA内存模型参考回答： ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 &#x2F; 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。 12345678910111213static final class HashEntry&lt;K,V&gt; &#123; final K key; // 声明 key 为 final 型 final int hash; // 声明 hash 值为 final 型 volatile V value; // 声明 value 为 volatile 型 final HashEntry&lt;K,V&gt; next; // 声明 next 为 final 型 HashEntry(K key, int hash, HashEntry&lt;K,V&gt; next, V value) &#123; this.key = key; this.hash = hash; this.next = next; this.value = value; &#125;&#125; 在ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry 对象后的结构图： 图1. 插入三个节点后桶的结构示意图： 注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。 Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。 请你说明concurrenthashmap有什么优势以及1.7和1.8区别？考点：集合参考回答：Concurrenthashmap线程安全的，1.7是在jdk1.7中采用Segment + HashEntry的方式进行实现的，lock加在Segment上面。1.7size计算是先采用不加锁的方式，连续计算元素的个数，最多计算3次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果前后两次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数； 1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount，通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数； 请你说明ConcurrentHashMap锁加在了哪些地方？加在每个Segment 上面。 请你说明一下Map和ConcurrentHashMap的区别？考点：集合参考回答： hashmap是线程不安全的，put时在多线程情况下，会形成环从而导致死循环。CoucurrentHashMap是线程安全的，采用分段锁机制，减少锁的粒度。 请解释一下TreeMap?考察点：key-value集合参考回答： TreeMap是一个有序的key-value集合，基于红黑树（Red-Black tree）的 NavigableMap实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator进行排序，具体取决于使用的构造方法。 请你说明一下TreeMap的底层实现？考点：集合参考回答： TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。 红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑树性质：性质1：每个节点要么是红色，要么是黑色。性质2：根节点永远是黑色的。性质3：所有的叶节点都是空节点（即 null），并且是黑色的。性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。 请说明ArrayList是否会越界？考点：集合参考回答：ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；ArrayList并发add()可能出现数组下标越界异常。 请你解释HashMap的容量为什么是2的n次幂？ 考点：集合参考回答： 负载因子默认是0.75， 2^n是为了让散列更加均匀，例如出现极端情况都散列在数组中的一个下标，那么hashmap会由O（1）复杂退化为O（n）的。 如果hashMap的key是一个自定义的类，怎么办？考点：集合参考回答： 使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。 hashMap是如何实现的？Hashmap基于数组实现的，通过对key的hashcode &amp; 数组的长度得到在数组中位置，如当前数组有元素，则数组当前元素next指向要插入的元素，这样来解决hash冲突的，形成了拉链式的结构。put时在多线程情况下，会形成环从而导致死循环。数组长度一般是2n，从0开始编号，所以hashcode &amp; （2n-1），（2n-1）每一位都是1，这样会让散列均匀。需要注意的是，HashMap在JDK1.8的版本中引入了红黑树结构做优化，当链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8&#x2F;2&#x3D;4，这才有转换为树的必要。链表长度如果是小于等于6，6&#x2F;2&#x3D;3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。 还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。 请你简单介绍一下ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的 效率高？考点：集合参考回答： ArrayList采用数组数组实现的，查找效率比LinkedList高。LinkedList采用双向链表实现的，插入和删除的效率比ArrayList要高。一直在list的尾部添加元素，LinkedList效率要高。 实测 源码为： 当输入的数据一直是小于千万级别的时候，大部分是Linked效率高，后来翻开源码，我猜想应该是当出现ArrayList扩容的时候，会效率降低，所以ArrayList的效益比较低。而当数据量大于千万级别的时候，就会出现ArrayList的效率比较高了。为什么呢？原来 LinkedList每次增加的时候，会new 一个Node对象来存新增加的元素，所以当数据量小的时候，这个时间并不明显，而ArrayList需要扩容，所以LinkedList的效率就会比较高，其中如果ArrayList出现不需要扩容的时候，那么ArrayList的效率应该是比LinkedList高的，当数据量很大的时候，new对象的时间大于扩容的时间，那么就会出现ArrayList’的效率比Linkedlist高了。","categories":[{"name":"java interview","slug":"java-interview","permalink":"https://zouyunkai.github.io/myblog/categories/java-interview/"}],"tags":[],"author":"aoyuehan"},{"title":"asp学生管理系统","slug":"asp学生管理系统","date":"2020-03-25T02:46:00.000Z","updated":"2022-02-26T03:52:51.082Z","comments":true,"path":"2020/03/25/asp学生管理系统/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/25/asp%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"debug记录对路径“C:Program Files (x86)IIS Express projectlog.log”的访问被拒绝修改一下这个文件的权限 在与 SQL Server 建立连接时出现与网络相关的或特定于实例的错误。未找到或无法访问服务器。1、点击MSSQLSERVER的协议，在右侧的页面中选择TCP&#x2F;IP协议 2、右键点击TCP&#x2F;IP协议，选择“属性”，需要修改连接数据库的端口地址 3、跳出来的对话框，里面有好多TCP&#x2F;IP的端口，找到“IP3”，更改IP地址 为自己电脑的IP地址（或者是127.0.0.1，其实随便改一个地址就可，然后记得把已启用改成是，然后重启服务） 在TCP端口添加1433，然后选择启动 4、“IPALL”的所有端口改成“1433”；改的只要相对应就好。 5、重新启动服务 6、通过以上1-6步骤设置好端口，重新打开SQL Server Management Studio，在服务器名称输入：(local)或者127.0.0.1，即可登录数据库了。 用户登录数据访问出现异常:阅读器关闭时尝试调用 Read 无效。“阅读器关闭时尝试调用 Read 无效”了。这里需要说明的是，在数据读取完毕之后，不再需要SqlDataReader时，必须将其进行手动关闭。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static SqlDataReader SqlDataReader(string sqlOrProduceName, SqlParameter[] param, bool isProcedure) &#123; SqlConnection conn = new SqlConnection(connString); SqlCommand cmd = new SqlCommand(sqlOrProduceName, conn); if (isProcedure) &#123; cmd.CommandType = CommandType.StoredProcedure; &#125; try &#123; conn.Open(); cmd.Parameters.AddRange(param); return cmd.ExecuteReader(CommandBehavior.CloseConnection); &#125; catch (Exception ex) &#123; //将错误信息写入日志 WriteLog(&quot;执行public static SqlDataReader SqlDataReader(string sqlOrProduceName, SqlParameter[] param, bool isProcedure)方法时产生异常：&quot; + ex.Message); throw ex; &#125; finally &#123; //conn.Close(); 此时的原因就是因为这地方写了这个才错了 //这个sqlReader不能在这里关闭，要在调用次方法的那个实例读取完之后关闭连接 &#125; &#125; public SysAdmin AdminLogin(SysAdmin objAdmin) &#123; string sql = &quot;select AdminName from Admins where LoginId=@LoginId and LoginPwd=@LoginPwd&quot;; SqlParameter[] param = new SqlParameter[] &#123; new SqlParameter(&quot;@LoginId&quot;,objAdmin.LoginId), new SqlParameter(&quot;@LoginPwd&quot;,objAdmin.LoginPwd), &#125;;//这里要加；，为什么呀 try &#123; SqlDataReader objReader = SQLHelper.SqlDataReader(sql, param, false); if (objReader.Read()) &#123; objAdmin.AdminName = objReader[&quot;AdminName&quot;].ToString(); &#125; else &#123; objAdmin = null; &#125; objReader.Close();//出错的原因，是要在这里关闭，而不是在上面关闭，因为这时候还要用reader来读取objAdmin.AdminName，在上面那个方法中关了之后，下面就不能用了 &#125; catch(Exception ex) &#123; throw new Exception(&quot;用户登录数据访问出现异常：&quot; + ex.Message); &#125; return objAdmin; &#125;","categories":[{"name":"asp","slug":"asp","permalink":"https://zouyunkai.github.io/myblog/categories/asp/"}],"tags":[],"author":"aoyuehan"},{"title":"java polymorphism","slug":"java-Polymorphism","date":"2020-03-24T04:20:00.000Z","updated":"2022-02-26T03:52:51.242Z","comments":true,"path":"2020/03/24/java-Polymorphism/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/24/java-Polymorphism/","excerpt":"","text":"多态的概念现实概念现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。 多态存在的三个必要条件 继承 重写 父类引用指向子类对象（引用还是指向父类） 注意：在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。 多态中成员的特点1、多态成员变量：编译运行看左边 Fu f&#x3D;new Zi(); System.out.println(f.num); &#x2F;&#x2F;f是Fu中的值，而且只能取到父中的值2、多态成员方法：编译看左边，运行看右边 Fu f1&#x3D;new Zi(); System.out.println(f1.show());&#x2F;&#x2F;f1的门面类型是Fu,但实际类型是Zi,所以调用的是子类重写后的方法。3、Static方法编译看左边（父类），运行看左边（父类）。 instanceof关键字 作用：用来判断某个对象是否属于某种数据类型。 注意： 返回类型为布尔类型 12345678Fu f1=new Zi();Fu f2=new Son();if(f1 instanceof Zi)&#123; System.out.println(&quot;f1是Zi的类型&quot;);&#125; else&#123; System.out.println(&quot;f1是Son的类型&quot;);&#125; 多态的转型多态的转型分为向上转型和向下转型两种1、向上转型：多态本身就是向上转型过的过程 使用格式：父类类型 变量名&#x3D;new 子类类型(); 适用场景：当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作。 2、向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型 使用格式：子类类型 变量名&#x3D;（子类类型） 父类类型的变量； 适用场景：当要使用子类特有功能时。 例子12345678910111213141516171819202122232425262728293031class A&#123; static int i; int j,k; public void fun() &#123; for(int j=0;j&lt;20;j++) &#123; i++; &#125; &#125; public void f() &#123; fun();//父类的引用指向子类对象时，该引用调用子类中重写的方法，所以此时调用子类中重写之后的fun函数 &#125;&#125;class B extends A&#123; static int k; public void fun() &#123; for(j=0;j&lt;10;j++) &#123;//此时j为父类中的j，所以最后a.j为10 k+=3;//重写之后的方法能操作 子类中与父类同名 的变量，或者操作从父类中继承而来的变量，是不能操作父类中与子类中的同名的变量；但是在a.k的时候，这里的k是父类中的这和在重写方法里不同； //所以此时的k为子类中的k &#125; &#125;&#125;public class Main&#123; public static void main(String []args) &#123; A a=new B(); a.f(); //因为子类中没有重写f函数，所以此时调用父类中的f方法 System.out.println(a.k); //调用的是父类中的k System.out.println(((B)a).k); //对象a向下转型，所以调用的是子类中的k System.out.println(a.j); //调用的是父类中的j &#125;&#125;结果为0 30 10","categories":[{"name":"java interview","slug":"java-interview","permalink":"https://zouyunkai.github.io/myblog/categories/java-interview/"}],"tags":[],"author":"aoyuehan"},{"title":"四大范式定义和判别","slug":"四大范式定义和判别","date":"2020-03-24T03:18:00.000Z","updated":"2022-02-26T03:52:52.848Z","comments":true,"path":"2020/03/24/四大范式定义和判别/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/24/%E5%9B%9B%E5%A4%A7%E8%8C%83%E5%BC%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%A4%E5%88%AB/","excerpt":"","text":"1.第一范式（1NF）定义 (1NF, Normal Form) 如果一个关系模式R中的每个属性A的域值都是原子的，即属性值是不可再分的，则关系模式R属于第一范式，简记为R ∈ 1NF。若数据库模式R中的每个关系模式都是1NF，数据库模式 R∈1NF。 这个非常好理解，基本上，只要题目给了，他就是一个满足第一范式的关系模式 2.第二范式（2NF）定义 2NF指的就是，我们的关系模式中的所有非主属性完全依赖于每个键。什么意思呢，这里呢最重要的是理解什么是非主属性，什么是主属性，什么是键。那非主属性和主属性怎么理解呢，举个例子：关系模式R&#x3D;｛A,B,C,D｝ ,已知R的候选键是AD ， 那么AD中的A和D就是主属性，而B和C就是非主属性。包含在候选键里的属性就是主属性！ 已知，R&#x3D;｛A，B，C｝，函数依赖集为 F &#x3D;{ B →C, AC →B } ，判断关系模式是不是2NF那么我们首先看这个R关系模式里面的键是谁利用属性闭包算法求出R的候选键为：AC，所以第二步 就是看是否有非主属性部分依赖于主属性AC （我们这里的非主属性就是B）很明显并没有B部分依赖于A或者C ，所以R是2NF 已知，R&#x3D;｛A，B，C，D｝，函数依赖集为F &#x3D;{ A →C,AD →B }，判断关系模式是不是2NF 和第一个例子一样，我们首先看这个R中的键是谁用属性闭包算法，求出R的候选键为：AD （AD+ &#x3D; ABCD） ，所以C和B都是非主属性，A和D是主属性所以，很明显，我们发现 AD中的A竟然可以单独决定C（A-&gt;C），所以C部分依赖于AC ，存在非主属性部分依赖于主属性，R不是2NF 3.第三范式（3NF）定义 第三范式的意思就是，R中没有非主属性传递依赖于R的键,R才是3NF这里也隐含了一个条件，那就是，如果是R中的主属性传递依赖于R的键，那么R也是满足3NF的注意区分主属性传递依赖和非主属性传递依赖喔 已知R(A,B,C), 其函数依赖集为 F &#x3D;{ B →C, AC →B };该关系模式是否第3范式 我们来判断判断，首先第一步，找键！我们发现AC是候选键（AC+&#x3D;ABC，通过属性闭包算法求的候选键）同时由于AC-&gt;B , B-&gt;C ，所以C传递依赖于AC ，那么R是不是3NF呢？R 当然是3NF啦，因为R的候选键是AC，所以C是主属性，因此 这里是主属性C传递依赖于键AC，R是3NF注意！只有当非主属性传递依赖于R的时候,R才不是3NF R(A,B,C，D), 其函数依赖集为 F &#x3D;{AB →C, C →D };该关系模式是否第3范式 首先第一步，还是找键！ 发现AB是候选键， 但是由于AB -&gt; C , C -&gt; D ，所以D传递依赖于AB那么R是3NF吗？R当然不是3NF啦，因为D是非主属性，所以这里是非主属性D传递依赖于主属性AB，因此就不满足3NF的定义啦 4.Boyce-Codd范式（BCNF）定义 BCNF最高级了，它指的是R中没有任何属性传递依赖于R中的任何一个键。所以联想到上面我们3NF中的举例1，它虽然满足3NF，但是由于有主属性传递依赖于键，它就不是BCNF。 很明显，两个都是BCNF，因为都没有任何属性存在传递依赖最后说一下，满足BCNF的关系模式，肯定也满足3NF；同理，满足3NF的关系模式，肯定也满足2NF 例题关系模式R 中的属性全部是主属性，则R的最高范式至少是( )。一个全部是主属性的关系必然不会有非主属性部分或者传递依赖的问题，故至少是3NF。但此关系无法保证每一个非平凡的多值依赖或者函数依赖都包含码，所以R的最高范式至少是3NF。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[],"author":"aoyuehan"},{"title":"java-复习","slug":"java-复习","date":"2020-03-23T12:24:36.000Z","updated":"2022-02-26T03:52:51.166Z","comments":true,"path":"2020/03/23/java-复习/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/23/java-%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"java基本数据与数组Java允许创建不规则数组，即Java多维数组中各行的列数可以不同。 字符串有length( )，数组有length属性。 一个数组不可以存放不同类型的数值。集合可以吗？？ Java的各种数据类型占用固定长度，与具体的软硬件平台环境无关。 与c，c++不同，Java语言中使用的字符是 16位Unicode编码字符集。 Java语言中，变量名可以用汉字表示。 与c，c++不同，boolean型数据的值只有true和false。 MAX_LENGTH是int型public成员变量，变量值保持为常量55，用简短语句定义这个变量public final int MAX_LENGTH&#x3D;55 int[ ] a&#x3D;new int[2]; int[ ] a&#x3D;{1,2}; int a[ ]&#x3D;{1,2}; int a[2]&#x3D;{1,2}; 前三个对，最后一个不对 int a[][]&#x3D;new int [3][3]; 对 int a[][]&#x3D;new int [3][]; 对 int a[][]&#x3D;new int [][3]; 错，不能在空维之后指定数组维 有语句String s&#x3D;”hello world”; ，以下操作哪个是不合法的？（ ） int i&#x3D;s.length(); s&gt;&gt;&gt;&#x3D;3; 不对，对于字符没有&gt;&gt;&gt;运算 String ts&#x3D;s.trim(); String t&#x3D;s+”!”; 当访问无效的数组下标时，会发生（ 抛出异常）。 System.out.println(4 + 5 + “” + 3 + 6); 结果为4536 System.out.println(new Integer(2) &#x3D;&#x3D; new Integer(2)); 结果为false 只有为字符串常量时在内存中才为同一个引用 System.out.println(new Integer(5) &#x3D;&#x3D; new Integer(5).intValue()); 结果为true 面向对象static关键字可以修饰成员变量，也可以修饰局部变量。 错 12345678910111213141516171819202122231. static全局变量与普通的全局变量有什么区别 ? 全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。 这两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。 static全局变量只初使化一次，防止在其他文件单元中被引用; 2. static局部变量和普通局部变量有什么区别 ？ 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。 static局部变量只被初始化一次，下一次依据上一次结果值； 3. static函数与普通函数有什么区别？ static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static修饰的函数)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件. static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝 一个类的静态方法不可以访问该类的非静态成员变量。 在Java程序中，可以使用protected来修饰一个类. (F) 类的修饰符分为：可访问控制符和非访问控制符两种。可访问控制符是：公共类修饰符 public非访问控制符有：抽象类修饰符 abstract ；最终类修饰符 final—-也就是protected是不能用来修饰一个类的 12345678910111213class A &#123; int i; static String s; void method1() &#123; &#125; static void method2() &#123; &#125; &#125; class Main&#123; public static void main(String[ ] args)&#123; A a=new A(); System.out.println( a.i); &#125; &#125;输出0，但是A.method1(); 是错误的 关于被私有访问控制符private修饰的成员变量，只能被该类自身所访问和修改java有四种访问类型，分别为public，protected，default和private，其 中public变量可以被所有的外部类访问，而pretected变量可以被同一个包及该类的子类 访问，default变量即没有任何修饰符的变量可以被同一个包中的类访问，而private变量 只能在被该类内部被访问。题目中的外部类应该理解为除该类自身的其他类。 以下哪句是错误的？ C编译器会搜索要import的类的编译结果文件而不是源文件import是告诉编译器要import的包的信息import是把要import的类的源代码插入到import语句所在的地方编译器在编译的时候需要能访问得到要import的类的编译结果文件 Java的外部类为什么不能使用private、protected进行修饰 对于顶级类(外部类)来说，只有两种修饰符：public和默认(default)；对于内部类来说，可以用protected（本包内的父子类之间）和private（仅限这个类的外部类）进行修饰。因为外部类的上一单元是包，所以外部类只有两个作用域：同包，任何位置。因此，只需要两种控制权限：包控制权限和公开访问权限，也就对应两种控制修饰符：public和默认(default)。 如果类使用了private修饰符，说明是个内部类。内部类的上一级是外部类，那么对应的有四种访问控制修饰符：本类(private)，同包(default)，父子类(protected)，任何位置(public)。当一个内部类使用了private修饰后，只能在该类的外部类内部使用。访问修饰符作用范围由大到小是(public-protected-default-private ) 上面这些都是平时使用司空见惯的，但是为什么是这种情况呢？ 可以想一下，一个java项目是不可能在一个class里面完成的。mvc模式中，是把类分为三层，一层层调用类。如果定义为私有的和受保护的就无法调用。换句话说，对于一个java文件，要么就是自己单独运行，要么就是被其他程序作为库调用，如果一个java文件的类被private修饰，那么是不是其他的程序或是类是无法使用它的，那么他作为一个单独的文件就没啥用了。如果它作为单个文件运行，类加载怎么找到它呢，因为它对外不可见。同时，也失去了类的存在意义。因此，类只有public和默认修饰符。 下列关于使用包中的类哪个说法是正确的。 ？？？？ 类不可以使用其所在包中的private类 类可以使用其他包中的所有类 类可以使用其他包中的public类 以上说法都不正确 3、 定义在类中的变量被称为__成员变 量___,定义在方法中的变量被称为局部变量___ https://www.open-open.com/doc/5cf72906066f4045bea60eaf59174650.html https://blog.csdn.net/qq_43382350/article/details/103003922 https://wenku.baidu.com/view/e3197412ccbff121dd3683f3.html https://wenku.baidu.com/view/6cad94273d1ec5da50e2524de518964bce84d248.html 类和对象java.lang包是Java的核心类库，它包含了运行Java程序必不可少的系统类。对 在实例方法或构造器中，this用来引用当前对象，通过使用this可引用当前对象的任何成员 对 下面关于Java的引用的说法正确的是_可能选a_。 引用实际上就是指针 引用本身是原始类型（primitive type） 引用就是对象本身 不对 一个对象只能被一个引用所指示 继承final类中的属性和方法都必须被final修饰符修饰。 不对，只是说该类不能被继承了final类不能派生子类，final方法不能被覆盖。 修饰符protected主要是允许其他包中的子类来访问父类的特定属性。这是对的。 以下（D）添加到ComputerBook中不会出错class Book{protected int getPrice(){return 30;}}public class ComputerBook extends Book{}A) protected float getPrice(){}B) protected int getPrice(int page){}C) int getPrice(){}D) public int getPrice(){return 10;} 下列选项中关于java中super关键字的说法错误的是BA、super关键字是在子类对象内部指代其父类对象的引用B、super关键字不仅可以指代子类的直接父类，还可以指代父类的父类C、子类可以通过super关键字调用父类的方法D、子类可以通过super关键字调用父类的属性 这以下属于面向对象的特征的是(继承和封装） 重写 重载 继承 封装 如果一个成员变量被修饰为final的，就是常量，常量必须赋给初值，而且不能再发生变化。 子类如果想使用父类的构造方法，必须在子类的构造方法中使用，并且必须使用关键字super来表示，而且super必须是子类构造方法中的头一条语句。如果在子类的构造方法中，没有使用关键字super调用父类的某个构造方法，那么默认有super();语句，即调用父类的不带参数的构造方法。 可以覆盖在父类中定义的私有方法 错误；首先要明确：子类是不能够覆盖（重写）父类的私有方法的。比较直观的理由是，子类要能够重写父类的方法的前提条件是继承，子类对父类的私有方法并不继承，也没有访问权限，自然也是不能重写的。 一个类在重写其父类的某个方法时，在重写方法的定义中，哪个部分可以与父类被重写方法的定义不同 访问修饰符？ 在子类中可以根据需要对从父类中继承来的方法进行改造—-方法的覆盖 （ 也叫重写）。覆盖方法必须和被覆盖方法具有相同的方法名称、参数列表和返回值类型。 有意思 1234567891011121314public class Test extends Father&#123; private String name=”test”; public static void main(String[] args)&#123; Test test = new Test(); System.out.println(test.getName()); &#125;&#125;class Father&#123; private String name=”father”; public String getName() &#123; return name; &#125;&#125;输出father，什么原理来着 构造函数的执行顺序 12345678910111213141516171819202122class People &#123; String name; public People() &#123; System.out.print(1); &#125; public People(String name) &#123; System.out.print(2); this.name = name; &#125; &#125; class Child extends People &#123; People father; public Child(String name) &#123; System.out.print(3); this.name = name; father = new People(name + &quot;:F&quot;); &#125; public Child()&#123; System.out.print(4); &#125; &#125;结果为：132 下列选项中关于java中super关键字的说法错误的是 只有第一项是对的 super关键字是在子类对象内部指代其父类对象的引用 super关键字不仅可以指代子类的直接父类，还可以指代父类的父类 错 子类可以通过super关键字调用父类的方法 错 子类可以通过super关键字调用父类的属性 错 以下关于final关键字说法错误的是（A C) final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性 final修饰的类不能被继承 final修饰的方法不能被重载 final修饰的变量不允许被再次赋值 1.final修饰变量，则等同于常量2.final修饰方法中的参数，称为最终参数。3.final修饰类，则类不能被继承4.final修饰方法，则方法不能被重写。final 不能修饰抽象类final修饰的方法可以被重载 但不能被重写 实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.util.Arrays;import java.util.Scanner; public class Main&#123;public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n1 = in.nextInt(); int i; PersonOverride person1[] = new PersonOverride[n1]; for (i = 0; i &lt; n1; i++) &#123; person1[i] = new PersonOverride(); &#125; int n2 = in.nextInt(); PersonOverride person2[] = new PersonOverride[n2]; int count=0; PersonOverride p = null; for (i = 0; i &lt; n2; i++) &#123; p = new PersonOverride(in.next(), in.nextInt(), in.nextBoolean()); int j = 0; while (j &lt; count) &#123; if (p.equals(person2[j])) break; j++; &#125; if (j &gt;= count) &#123; person2[count] = p; count++; &#125; &#125; in.close(); for(i=0;i&lt;n1;i++) &#123; System.out.println(person1[i].toString()); &#125; for (i = 0; i &lt; count; i++) &#123; System.out.println(person2[i].toString()); &#125; System.out.println(count); System.out.println(Arrays.toString(PersonOverride.class.getConstructors()));&#125;&#125;class PersonOverride &#123;private String name;private int age;private boolean gender;public PersonOverride() &#123; this(&quot;default&quot;, 1, true);&#125;public PersonOverride(String name, int age, boolean gender) &#123;this.name=name;this.age=age;this.gender=gender;&#125;@Overridepublic String toString() &#123; return name + &quot;-&quot; + age + &quot;-&quot;+ gender;&#125;@Overridepublic int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + age; result = prime * result + (gender ? 1231 : 1237); result = prime * result + ((name == null) ? 0 : name.hashCode()); return result;&#125;@Overridepublic boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; PersonOverride other = (PersonOverride) obj; if (age != other.age) return false; if (gender != other.gender) return false; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true;&#125;&#125; 一个类继承和内嵌类的例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class Person &#123; private String nameString; private int age; private boolean is;//男女值 public String getNameString() &#123; return nameString; &#125; public void setNameString(String nameString) &#123; this.nameString = nameString; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public boolean isIs() &#123; return is; &#125; public void setIs(boolean is) &#123; this.is = is; &#125;&#125;class Company &#123; private String gongsi; public String getGongsiString() &#123; return gongsi; &#125; public void setGongsiString(String gongsi) &#123; this.gongsi = gongsi; &#125;&#125;class Employee extends Person &#123; private Company company; private double salary; public Employee(String name, String company, int age, double sal, boolean isman) &#123; this.setAge(age); this.setNameString(name); this.setIs(isman); this.company = new Company(); // 这地方很重要，因为你不初始化公司类的话，直接调用company的set方法，会出向空指针错误 this.company.setGongsiString(company); ; this.setSalary(sal); &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double salary) &#123; this.salary = salary; &#125; public Company getCompany() &#123; return company; &#125; public void setAompany(Company aompany) &#123; this.company = aompany; &#125; public String tosString() &#123; return getNameString() + &#x27;-&#x27; + getAge() + &#x27;-&#x27; + isIs() + &#x27;-&#x27; + getCompany().getGongsiString() + &#x27;-&#x27; + getSalary(); //这地方也可以重写person，公司类的tostring函数，可能还简便规范一点 &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Employee employee = new Employee(&quot;zhang&quot;, &quot;IBM&quot;, 23, 9000.123, true); System.out.println(employee.tosString()); &#125;&#125; 一个对象数组的例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); Media[] ms = new Media[n]; for (int i=0; i&lt;n; i++) &#123; String type = sc.next(); if (type.equals(&quot;book&quot;)) &#123; ms[i] = new Book(sc.next(), sc.nextDouble()); //这地方处理的很巧妙 &#125;else &#123; ms[i] = new DVD(sc.next()); &#125; &#125; double rent = MediaShop.calculateRent(ms, sc.nextInt()); System.out.printf(&quot;%.2f&quot;, rent); &#125;&#125;class Media &#123; protected String nameString; //这地方必须得设置为protected，若为私有，则子类不可见 public double getDailyRent() &#123; return 0; &#125; public String getNameString() &#123; return nameString; &#125; public void setNameString(String nameString) &#123; this.nameString = nameString; &#125;&#125;class Book extends Media&#123; private double jiage; public Book(String next, double nextDouble) &#123; this.setNameString(nameString); this.jiage=nextDouble; //这地方一定要对价钱和书名都赋值 &#125; public double getJiage() &#123; return jiage; &#125; public void setJiage(double jiage) &#123; this.jiage = jiage; &#125; public double getDailyRent() &#123; return jiage*0.01; &#125;&#125;class DVD extends Media&#123;public DVD(String next) &#123; this.setNameString(nameString); &#125;public double getDailyRent() &#123; return 1; &#125;&#125;class MediaShop&#123; public static double calculateRent(Media[] ms, int nextInt) &#123; // TODO 自动生成的方法存根 double rentall=0; for(int i=0;i&lt;ms.length;i++) &#123; rentall+=(ms[i].getDailyRent()*nextInt); &#125; return rentall; &#125; &#125; “抽象类其实是可以被实例化的，但是它的实例化方式并不是通过普通的new方式来创建对象，而是通过父类的应用来指向子类的实例间接地实现父类的实例化，因为子类在实例化之前，一定会先实例化它的父类。这样创建了继承抽象类的子类对象，也就把其父类（抽象类）给实例化了。” 抽象类不是必须有抽象方法。“抽象类可以没有抽象方法,但是如果你的一个类已经声明成了抽象类,即使这个类中没有抽象方法,它也不能再实例化,即不能直接构造一个该类的对象。如果一个类中有了一个抽象方法,那么这个类必须声明为抽象类,否则编译通不过。” abstract和final不可以同时作为一个类的修饰符。Abstract表示抽象类，抽象类本身不可实例化，必须有子类去继承，且子类中实现抽象父类中所有的抽象方法，子类才可实例化。final修饰的类，不可继承。 Abstract方法不能用final,static修饰；非abstract方法在abstract类中可以用fina这个修饰符功能相克的。 -下面的概念，哪个不是关于对象的多态性的体现。BA 方法的重载B 方法的继承C 方法的覆盖D 对象的上、下转型 选项中哪一行代码可以替换题目中&#x2F;&#x2F;add code here而不产生编译错误？（ A） 1234567891011121314public abstract class MyClass &#123; public int constInt = 5; //add code here public void method() &#123; &#125; &#125; A、public abstract void method(int a);B、value = value + 5;C、public int method();D、public abstract void anotherMethod() &#123;&#125; B应该大括号包裹，作为代码块C不加abstract不是抽象方法，需要方法体，且与下method方法冲突 D抽象方法没有方法体 抽象类的用法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.*;abstract class Shape&#123; final static double PI=3.14; public abstract double getPerimeter(); public abstract double getArea(); public static double sumAllArea(Shape []shapes) &#123; double x=0; for(Shape e:shapes) &#123; x+=e.getArea(); &#125; return x; &#125; public static double sumAllPerimeter(Shape []shapes) &#123; double y=0; for(Shape e:shapes) &#123; y+=e.getPerimeter(); &#125; return y; &#125;&#125;class Rectangle extends Shape&#123; private int width; private int length; public double getPerimeter() &#123; return 2*(width+length); &#125; public double getArea() &#123; return width*length; &#125; public Rectangle(int width,int length) &#123; this.width=width; this.length=length; &#125; @Override public String toString() &#123; return &quot;Rectangle [width=&quot; + width + &quot;, length=&quot; + length + &quot;]&quot;; &#125;&#125;class Circle extends Shape&#123; private int radius; public double getPerimeter() &#123; // TODO Auto-generated method stub return 2*PI*radius; &#125; public double getArea() &#123; // TODO Auto-generated method stub return PI*radius*radius; &#125; public Circle(int radius) &#123; this.radius=radius; &#125; @Override public String toString() &#123; return &quot;Circle [radius=&quot; + radius + &quot;]&quot;; &#125;&#125;public class Main&#123; public static void main(String[] args) &#123; Scanner in=new Scanner(System.in); int n; n=in.nextInt(); Shape shapes[]=new Shape[n]; for(int i=0;i&lt;n;i++) &#123; String s=in.next(); switch(s) &#123; case &quot;rect&quot;: int width,length; width=in.nextInt(); length=in.nextInt(); shapes[i]=new Rectangle(width, length); break; case &quot;cir&quot;: int radius; radius=in.nextInt(); shapes[i]=new Circle(radius); break; &#125; &#125; System.out.println(Shape.sumAllPerimeter(shapes)); System.out.println(Shape.sumAllArea(shapes)); System.out.println(Arrays.toString(shapes)); for(int i=0;i&lt;n;i++) &#123; System.out.println(shapes[i].getClass()+&quot;,&quot;+shapes[i].getClass().getSuperclass()); &#125; &#125;&#125; 一个抽象类加排序的例子，有人类，学生类和工人类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217import java.text.DecimalFormat;import java.util.ArrayList;import java.util.Comparator;import java.util.Scanner;abstract class Person&#123; //按照题目要求定义抽象类，其实是不是抽象类并不重要 private String name, c; private int age; private boolean gender; public String getName() &#123; return name; &#125; public String getC() &#123; return c; &#125; public int getAge() &#123; return age; &#125; public boolean isGender() &#123; return gender; &#125; public Person(String c, String name, int age, boolean gender) &#123; this.c = c; this.name = name; this.age = age; this.gender = gender; &#125; @Override public String toString() &#123; return name + &quot;-&quot; + age + &quot;-&quot; + gender; //返回&quot;name-age-gender&quot;格式的字符串 &#125; public boolean equals(Object obj) &#123; Person per = (Person) obj; //对于String类型，如果为null则不创建对象，而赋值为null。比较name之前应先判断其是否为空。 if(per.name == null || this.name == null) return false; return (per.name.compareTo(this.name) == 0 &amp;&amp; per.age == this.age &amp;&amp; per.gender == this.gender ); //比较name、age、gender,都相同返回true,否则返回false &#125;&#125;class Student extends Person&#123; private String stuNo; private String clazz; public Student(String c, String name, int age, boolean gender, String stuNo, String clazz) &#123; super(c, name, age, gender); //用super复用Person类的相关有参构造函数,切记放在首句 this.stuNo = stuNo; this.clazz = clazz; &#125; public String toString()&#123; return super.toString() + &quot;-&quot; + stuNo + &quot;-&quot; + clazz; //返回 “Student:person的toString-stuNo-clazz”格式的字符串 &#125; public boolean equals(Object obj) &#123; Student per = (Student)obj; if(super.equals(obj)) &#123; //首先调用父类的equals方法,如果返回true，则继续比较stuNo与clazz。 if(per.stuNo == null || per.clazz == null || this.stuNo == null || this.clazz == null) return false; return (per.stuNo.compareTo(this.stuNo) == 0 &amp;&amp; per.clazz.compareTo(this.clazz) == 0); &#125; return false; &#125;&#125;class Company&#123; private String name; public Company(String name) &#123; this.name = name; &#125; public String toString() &#123; //直接返回name return name; &#125;//右键Source或者Alt+Shift+s;然后选择Generate hashCode() and equals()...（这两个一般要一起用的） @Override public boolean equals(Object obj) &#123; if (this == obj) //如果this和obj指向的内存单元相同，即两个指的就是同一个东西当然要返回true了 return true; if (obj == null) //如果obj指向空 return false; if (getClass() != obj.getClass()) //getClass()获得类名，若类都不同那内容肯定也不同了 return false; Company other = (Company) obj; if (name == null) &#123; if (other.name != null) return false; &#125; else if (!name.equals(other.name)) return false; return true; //name相同返回true &#125;&#125;class Employee extends Person&#123; private Company company; private double salary; public Employee(String c, String name, int age, boolean gender, double salary, Company company) &#123; super(c, name, age, gender); //使用super复用Person类的相关有参构造函数 this.salary = salary; this.company = company; &#125; @Override public String toString() &#123; return super.toString() + &quot;-&quot; + company.toString() + &quot;-&quot; + salary; //返回&quot;Employee:person的toString-company-salary&quot;格式的字符串 &#125; @Override public boolean equals(Object obj) &#123; if(super.equals(obj)) &#123; //首先调用父类的equals方法,如果返回true。再比较company与salary。 Employee per = (Employee)obj; if(this.company.toString() == null || per.company.toString() == null) return false; //比较salary属性时，使用DecimalFormat df = new DecimalFormat(&quot;#.#&quot;);保留1位小数 String newpersalary = new DecimalFormat(&quot;#.#&quot;).format(per.salary); String newthissalary = new DecimalFormat(&quot;#.#&quot;).format(this.salary); return (per.company.toString().compareTo(this.company.toString()) == 0 &amp;&amp; newpersalary.compareTo(newthissalary) == 0); &#125; return false; &#125; &#125;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner input = new Scanner(System.in); String c, name, stuNo, clazz, companyname, str; int age; boolean gender; double salary; ArrayList&lt;Person&gt; personList = new ArrayList&lt;Person&gt;(); ArrayList&lt;Student&gt; studentList = new ArrayList&lt;Student&gt;(); ArrayList&lt;Employee&gt; employeeList = new ArrayList&lt;Employee&gt;(); while(true) &#123; c = input.next(); if(c.compareTo(&quot;s&quot;) == 0) &#123; name = input.next(); age = input.nextInt(); gender = input.nextBoolean(); stuNo = input.next(); clazz = input.next(); Student student = new Student(c, name, age, gender, stuNo, clazz); personList.add(student); &#125; else if(c.compareTo(&quot;e&quot;) == 0) &#123; name = input.next(); age = input.nextInt(); gender = input.nextBoolean(); salary = input.nextDouble(); companyname = input.next(); Company company = new Company(companyname); Employee employee = new Employee(c, name, age, gender, salary, company); personList.add(employee); &#125; else &#123; personList.sort(Comparator.comparing(Person::getName).thenComparingInt(Person::getAge)); //对personList中的元素实现先按照姓名升序排序，姓名相同再按照年龄升序排序。 for(int i = 0; i &lt; personList.size(); ++i) &#123; //将personList中元素输出，并将其非重复元素分到studentList和employeeList数组中 if(personList.get(i).getC().compareTo(&quot;s&quot;) == 0) &#123; System.out.println(&quot;Student:&quot; + personList.get(i).toString()); int flag = 0; for(int j = 0; j &lt; studentList.size(); ++j) &#123; if(studentList.get(j).equals(personList.get(i))) &#123; flag = 1; break; &#125; &#125; if(flag == 0) studentList.add((Student)personList.get(i)); &#125; else if(personList.get(i).getC().compareTo(&quot;e&quot;) == 0)&#123; System.out.println(&quot;Employee:&quot; + personList.get(i).toString()); int flag = 0; for(int j = 0; j &lt; employeeList.size(); ++j) &#123; if(employeeList.get(j).equals(personList.get(i))) &#123; flag = 1; break; &#125; &#125; if(flag == 0) employeeList.add((Employee)personList.get(i)); &#125; &#125; str = input.next(); //如果输入为exit则return退出程序 if(str.compareTo(&quot;exit&quot;) == 0 || str.compareTo(&quot;return&quot;) == 0) return; System.out.println(&quot;stuList&quot;); for(int i = 0; i &lt; studentList.size(); ++i) System.out.println(&quot;Student:&quot; + studentList.get(i).toString()); System.out.println(&quot;empList&quot;); for(int i = 0; i &lt; employeeList.size(); ++i) System.out.println(&quot;Employee:&quot; + employeeList.get(i).toString()); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829本题考的是多态class A&#123; static int i; int j,k; public void fun() &#123; for(int j=0;j&lt;20;j++) &#123; i++; &#125; &#125; public void f() &#123; fun(); &#125;&#125;class B extends A&#123; static int k; public void fun() &#123; for(j=0;j&lt;10;j++) &#123; k+=3; &#125; &#125;&#125;public class Main&#123; public static void main(String []args) &#123; A a=new B(); a.f(); System.out.println(a.k); System.out.println(a.j); &#125;&#125; 多态的例子 Java多态的三个必要条件：1、 继承2、 子类重写父类方法3、 父类引用指向子类对象 给出结论：Father c &#x3D; new Child() 在c的眼里只能看到 child 里面的 father 属性！ 当满Java多态的三个条件时，可以发现c.eat()调用的实际上是子类的eat（是因为子类重写覆盖了父类方法）， 但c.age调用的还是父类的age（属性&#x2F;变量不存在重写和覆盖），而c.play()则不会通过编译。 答案为 0 10 接口与实现接口中的方法默认是public abstract方法，所以类在实现接口方法时必须给出方法体，并且一定要用public来修饰，而且接口中的常量默认是public static常量。 若A1、A2为已定义的接口 ,以下接口定义中没有语法错误的是（ A ） 。A.interface B { void print();}B.interface B { void print() { } } &#x2F;&#x2F;给出了方法体，不是好像可以给出方法体嘛C.abstract interface B { void print() }D.abstract interface B extends A1,A2 { abstract void print(){ };}abstract不能修饰接口，能修饰类或者成员方法 1234567891011121314151617181920以下代码，描述正确的有interface IDemo&#123; public static final String name;1 void print();2 public void getInfo();3&#125;abstract class Person implements IDemo&#123;4 public void print()&#123; &#125;&#125;A、第1行错误，没有给变量赋值B、第2行错误，方法没有修饰符C、第4行错误，没有实现接口的全部方法D、第3行错误，没有方法的实现A正确，接口中的变量一定要赋值，因为默认是static和final型的，不赋值会报错B接口中方法默认为publicC抽象类可以不实现接口中的所有方法D接口中不能有方法的实现（java8可以有默认实现） 以下关于final关键字说法错误的是（AC）A、final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性B、final修饰的类不能被继承C、final修饰的方法不能被重载D、final修饰的变量不允许被再次赋值1.final修饰变量，则等同于常量2.final修饰方法中的参数，称为最终参数。3.final修饰类，则类不能被继承4.final修饰方法，则方法不能被重写。 final 不能修饰抽象类final修饰的方法可以被重载 但不能被重写final如果修饰引用变量的话，引用变量所指向的值是可以改变的，只是这个引用只能指向这个地址了而已，也就是引用本身的值不能改变 。 jdk1.8版本之前的前提下，接口和抽象类描述正确的有（BC ）A、抽象类没有构造函数 &#x2F;&#x2F;抽象类可以有构造函数。只是不能被实例化！B、接口没有构造函数C、抽象类不允许多继承 &#x2F;&#x2F;因为都是类D、接口中的方法可以有方法体 jdk1.8后，可以用static或default修饰方法，也可以有方法体，但应该是空的。 jdk1.8后现在的接口与抽象类的区别：1，接口中不能有main方法，抽象类中可以有main方法。2、接口中的default和static修饰的方法还是使用的public修饰，而抽象类中可以使用protected,private,public来修饰。 一个类继承的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156import java.util.*;public class Main &#123; public static void main(String[] args) &#123; List persons=getPersons(); //得到一个所有人的线性表 List teachers=new ArrayList(); List students=new ArrayList(); MyTool.separateStu_T( persons,teachers,students); //将persons线性表中的 teacher，student分别放到teachers,students两个线性表中 Collections.sort(teachers); //对教师线性表排序 Collections.sort(students); //对学生线性表排序 showResult(teachers); //显示教师线性表排序以后的结果 showResult(students); //显示学生线性表排序以后的结果 &#125; public static List getPersons() &#123; List persons=new ArrayList(); Scanner in=new Scanner(System.in); Person person=null; int num=Integer.parseInt(in.nextLine()); for(int i=0;i&lt;num;i++) &#123; String str=in.nextLine(); String []data=str.split(&quot;,&quot;); if(data[0].equalsIgnoreCase(&quot;student&quot;)) person=new Student(Integer.parseInt(data[1]),data[2],data[3],Integer.parseInt(data[4]),data[5]); else if (data[0].equalsIgnoreCase(&quot;teacher&quot;)) person=new Teacher(Integer.parseInt(data[1]),data[2],data[3],Integer.parseInt(data[4]),data[5]); else person=null; persons.add(person); &#125; return persons; &#125; public static void showResult(List persons) &#123; for(int i=0;i&lt;persons.size();i++) &#123; Person per=(Person)persons.get(i); System.out.println(per.getName()+&quot;,&quot;+per.getGender()+&quot;,&quot;+per.getAge()); &#125; &#125; &#125; abstract class Person implements Comparable&#123; private String name; private String gender; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person(String name, String gender, int age) &#123; super(); this.name = name; this.gender = gender; this.age = age; &#125;&#125;class Student extends Person &#123; private int sno; private String major; public Student(int sno, String name, String gender, int age, String major) &#123; super(name, gender, age); this.sno = sno; this.major = major; &#125; @Override public int compareTo(Object o) &#123; // TODO Auto-generated method stub Student s = (Student)o; return s.getSno() - this.getSno(); &#125; public int getSno() &#123; return this.sno; &#125;&#125;class Teacher extends Person &#123; private int tno; private String subject; public Teacher(int tno, String name, String gender, int age, String subject) &#123; super(name, gender, age); this.tno = tno; this.subject = subject; // TODO Auto-generated constructor stub &#125; @Override public int compareTo(Object o) &#123; // TODO Auto-generated method stub Teacher t = (Teacher)o; return this.getAge() - t.getAge(); &#125;&#125;class MyTool &#123; public static void separateStu_T(List persons, List teachers, List students) &#123; for (int i = 0; i &lt; persons.size(); i++) &#123; if (persons.get(i) instanceof Student) &#123; students.add(persons.get(i)); &#125; else &#123; teachers.add(persons.get(i)); &#125; &#125; &#125;&#125; 自定义接口的编写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.*; interface IntegerStack&#123; public Integer push(Integer item); public Integer pop(); public Integer peek(); public boolean empty(); public int size();&#125; class ArrayIntegerStack implements IntegerStack&#123; Integer A[]; int Max,Size = 0; public ArrayIntegerStack(int n) &#123; A = new Integer[n]; Max = n; &#125; public Integer push(Integer item) &#123; if(item == null) return null; else if(Size == Max) return null; else &#123; A[Size] = item; Size++; return item; &#125; &#125; public Integer pop() &#123; if(Size == 0) return null; Size--; return A[Size]; &#125; public Integer peek() &#123; if(Size == 0) return null; else return A[Size - 1]; &#125; public boolean empty() &#123; if(Size == 0) return true; else return false; &#125; public int size() &#123; return Size; &#125; public String toString() &#123; return Arrays.toString(A); &#125; &#125;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); ArrayIntegerStack A = new ArrayIntegerStack(n); int m = in.nextInt(); for(int i = 0;i &lt; m;i++) &#123; System.out.println(A.push(in.nextInt())); &#125; System.out.println(A.peek() + &quot;,&quot; + A.empty() + &quot;,&quot; + A.size()); System.out.println(A.toString()); int x = in.nextInt(); for(int i = 0;i &lt; x;i++) &#123; System.out.println(A.pop()); &#125; System.out.println(A.peek() + &quot;,&quot; + A.empty() + &quot;,&quot; + A.size()); System.out.println(A.toString()); in.close(); &#125; &#125; 内部类和异常类 运行与非运行异常 Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。 运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。 非运行时异常 （编译异常）：从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，不过一般情况下不自定义检查异常。其实就是：RuntimeException与其子类和错误（Error）不是必须要捕获或抛出。 类可以有两种重要的成员：成员变量和方法，类还可以有一种成员：内部类。 对 异常类 以下对自定义异常描述正确的是（C）A) 自定义异常必须继承ExceptionB) 自定义异常可以继承自ErrorC) 自定义异常可以更加明确定位异常出错的位置和给出详细出错信息D) 程序中已经提供了丰富的异常类，使用自定义异常没有意义 以下描述不正确的有 D try块不可以省略 可以使用多重catch块 finally块可以省略 catch块和finally块可以同时省略 getCustomerInfo()方法如下，try中可以捕获三种类型的异常，如果在该方法运行中产生了一个IOException，将会输出什么结果（） 1234567891011public void getCustomerInfo() &#123; try &#123; // do something that may cause an Exception &#125; catch (java.io.FileNotFoundException ex) &#123; System.out.print(&quot;FileNotFoundException!&quot;); &#125; catch (java.io.IOException ex) &#123; System.out.print(&quot;IOException!&quot;); &#125; catch (java.lang.Exception ex) &#123; System.out.print(&quot;Exception!&quot;); &#125; &#125; A IOException!BIOException!Exception!CFileNotFoundException!IOException!DFileNotFoundException!IOException!Exception!答案：A解析：考察多个catch语句块的执行顺序。当用多个catch语句时，catch语句块在次序上有先后之分。从最前面的catch语句块依次先后进行异常类型匹配，这样如果父异常在子异常类之前，那么首先匹配的将是父异常类，子异常类将不会获得匹配的机会，也即子异常类型所在的catch语句块将是不可到达的语句。所以，一般将父类异常类即Exception老大放在catch语句块的最后一个。 例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342public class Test &#123; public static void main(String[] args) &#123; Test t = new Test(); t.show(new Car() &#123; public void run() &#123; System.out.println(&quot;test run&quot;); &#125; &#125;); &#125; public void show(Car c) &#123; c.run(); c.show(); &#125;&#125;abstract class Car &#123; public void run() &#123; System.out.println(&quot;car run&quot;); &#125; public void show() &#123; System.out.println(getClass().getName()); &#125;&#125;结果为：test run类和对象.Test$1- 字符串变换public class Main &#123; public static void main(String[] args) &#123; String s = &quot;hello&quot;; try &#123; s = s + &quot; world&quot;; s.toUpperCase(); System.out.println(s.toUpperCase()); String[] a = s.split(&quot;o&quot;); //split是区分大小写的，Instr不区分大小写 System.out.println(a.length); &#125; catch (Exception e) &#123; System.out.print(s); &#125; finally &#123; System.out.println(s); &#125; &#125;&#125;结果为：HELLO WORLD3hello worldpublic class Main &#123; public static void main(String [] args) &#123; try &#123; badMethod(); System.out.print(&quot;A&quot;); &#125; catch (RuntimeException ex) &#123; System.out.print(&quot;B&quot;); &#125; catch (Exception ex1) &#123; System.out.print(&quot;C&quot;); &#125; finally &#123; System.out.print(&quot;D&quot;); &#125; System.out.print(&quot;E&quot;); &#125; public static void badMethod() &#123; throw new RuntimeException(); &#125;&#125;结果为：BDEclass Exception1 extends Exception &#123;&#125;class Exception2 extends Exception1 &#123;&#125;public class Test &#123; public static void main(String[] args) throws Exception &#123; try &#123; try &#123; throw new Exception2(); &#125; catch ( Exception1 a ) &#123; System.out.println(&quot;Caught Exception1&quot;); throw a; &#125; &#125; catch ( Exception2 s ) &#123; System.out.println(&quot;Caught Exception2&quot;); return ; &#125; finally &#123; System.out.println(&quot;Hello World!&quot;);&#125;&#125;&#125;结果为：Caught Exception1Caught Exception2Hello World!class NoWater extends Exception &#123;&#125;class NoDrinkableWater extends NoWater &#123;&#125;public class FinallyWorks &#123; static int count = 0; public static void main(String[] args) throws NoWater &#123; while ( true ) &#123; try &#123; count++; if ( count == 1 ) &#123; System.out.println(&quot;OK&quot;); &#125; else if ( count == 2 ) &#123; System.out.println(&quot;Exception raised: NoDrinkableWater&quot;); throw new NoDrinkableWater(); &#125; else if ( count == 3 ) &#123; System.out.println(&quot;Exception raised: NoWater&quot;); throw new NoWater(); &#125; &#125; catch (NoDrinkableWater e) &#123; System.out.println(e); &#125; finally &#123; System.out.println(&quot;finally&quot;); if ( count == 3 ) break; &#125; &#125; &#125;&#125;结果为：OKfinallyException raised: NoDrinkableWater类和对象.NoDrinkableWaterfinallyException raised: NoWater //此时抛出父类的异常，捕获子类的异常时捕获不到该父类的异常finally- 错误处理使用异常处理输入机制，让程序变得更健壮。main方法： 输入n，创建大小为n的int数组。 输入n个整数，放入数组。输入时，有可能输入的是非整型字符串，这时候需要输出异常信息，然后重新输入。 使用Arrays.toString输出数组中的内容。import java.lang.reflect.Array;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); String s=sc.nextLine(); int a[]=new int[Integer.valueOf(s)]; for (int i=0;i&lt;a.length;i++)&#123; String str=sc.nextLine(); if (Character.isDigit(str.charAt(0)))&#123; a[i]=Integer.valueOf(str); &#125;else &#123; System.out.println(&quot;java.lang.NumberFormatException: For input string: \\&quot;&quot;+str+&quot;\\&quot;&quot;); i--; &#125; &#125; System.out.println(Arrays.toString(a)); &#125;&#125;- 7.3 jmu-Java-06异常-03-throw与throws (10分)前言C语言中一般通过返回错误代码来表示一个函数执行是否有误。然而有的时候错误返回值可能与正常值相混淆。Java中使用异常来表示程序运行中发生的错误。本实验的主要目的为了演示使用异常机制替代错误返回值。题目内容编写类ArrayUtils方法：public static double findMax(double[] arr,int begin, int end)方法功能：用来返回arr数组中在下标begin与end-1之间（包括end-1）的最大值。注意：必须使用throws关键字声明findMax。方法说明： 要求begin&lt;end，否则抛出相应的异常(IllegalArgumentException)。 begin不得小于0，end不得大于arr.length，否则也抛出异常。注意：抛出异常时，应让用户知道错误发生的原因。main方法： 输入n，创建大小为n的int数组。 输入n个整数，放入数组。 输入若干对整数，代表begin与end，然后调用ArrayUtils.findMax方法。当输入的不是整数类型字符串，则退出输入循环。 最后使用如下代码打印标识信息 try &#123; System.out.println(ArrayUtils.class.getDeclaredMethod(&quot;findMax&quot;, double[].class,int.class,int.class)); &#125; catch (Exception e1) &#123; &#125; 输入样例：51 3 5 6 8 0 53 33 43 2-1 30 6end输出样例：8.0java.lang.IllegalArgumentException: begin:3 &gt;= end:36.0java.lang.IllegalArgumentException: begin:3 &gt;= end:2java.lang.IllegalArgumentException: begin:-1 &lt; 0java.lang.IllegalArgumentException: end:6 &gt; arr.length//这里是标识信息import java.util.Scanner;class ArrayUtils&#123; public static double findMax(double[] arr,int begin, int end)throws IllegalArgumentException&#123; if(begin&gt;=end) &#123; throw new IllegalArgumentException(&quot;begin:&quot;+begin+&quot; &gt;= end:&quot;+end); &#125; else if(begin&lt;0)&#123; throw new IllegalArgumentException(&quot;begin:&quot;+begin+&quot; &lt; 0&quot;); &#125; else if(end&gt;arr.length)&#123; throw new IllegalArgumentException(&quot;end:&quot;+end+&quot; &gt; arr.length&quot;); &#125; double max=0; for(int i=begin;i&lt;end;i++)&#123; if(max&lt;arr[i]) max=arr[i]; &#125; return max; &#125;&#125;public class Main&#123; public static void main(String argn[])&#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); double[] arr =new double[n]; for(int i=0;i&lt;n;i++)&#123; arr[i]=scan.nextInt(); &#125; while(true)&#123; int begin,end; int m=0; ArrayUtils hsj[] =new ArrayUtils[100]; hsj[m++]=new ArrayUtils(); try&#123; begin = Integer.parseInt(scan.next()); end = Integer.parseInt(scan.next()); &#125; catch(NumberFormatException e)&#123; break; &#125; try &#123; System.out.println(hsj[m].findMax(arr,begin,end)); &#125; catch (IllegalArgumentException e) &#123; System.out.println(e.toString()); &#125; &#125; try &#123; System.out.println(ArrayUtils.class.getDeclaredMethod(&quot;findMax&quot;, double[].class,int.class,int.class)); &#125; catch (Exception e1) &#123; &#125; &#125;&#125;- 天不假年程序填空题。根据题目要求完善下面的代码。请提交完整代码。 “今年50，明年18”是一个美好的愿望。人的年龄只能不断增长。 Person类的setAge方法用于更新年龄。 如果新的年龄比原来的年龄小，则输出B表示发现异常，否则输出A表示正常。import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner in = new Scanner(System.in); int age; age = in.nextInt(); Person p = new Person(age); age = in.nextInt(); try&#123; p.setAge(age); System.out.println(&quot;A&quot;); &#125;catch(AgeException e)&#123; System.out.println(&quot;B&quot;); &#125; &#125;&#125;class Person&#123; int age; public Person(int age)&#123; this.age = age; &#125; public void setAge(int age) throws AgeException &#123; if(this.age &lt;=age)&#123; this.age = age; &#125;else&#123; throw new AgeException(); &#125; &#125;&#125;class AgeException extends Exception&#123;&#125;- 输出数字的和输入样例:在这里给出一组输入。例如：1 2 3 a 4 5输出样例:在这里给出相应的输出。例如：15import java.util.Scanner;public class Book&#123; public static void main(String args[]) &#123; Scanner scanner=new Scanner(System.in); String string=scanner.nextLine(); String s[]=new String [100]; s=string.split(&quot; &quot;); int ans=0; for(int i=0;i&lt;s.length;i++) &#123; try &#123; int tmp=Integer.valueOf(s[i]); ans+=tmp; &#125; catch (Exception e) &#123; &#125; &#125; System.out.println(ans); &#125;&#125; 接口与实现编程题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.util.Scanner;public class Main implements Comparable&lt;Main&gt;&#123; public int x; public int y; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Main other = (Main) obj; if (x != other.x) return false; if (y != other.y) return false; return true; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; public Main(int x, int y) &#123; this.x = x; this.y = y; &#125; public Main( ) &#123; &#125; public String toString() &#123; return &quot;Point [x=&quot;+x+&quot;, y=&quot;+y+&quot;]&quot;; &#125; @Override public int compareTo(Main o) &#123; // TODO 自动生成的方法存根 if(this.x==o.x) &#123; if(this.y&gt;=o.y) &#123; return 1; &#125;else &#123; return -1; &#125; &#125;else &#123; if(this.x&gt;o.x) &#123; return 1; &#125;else &#123; return -1; &#125; &#125; &#125; public int distance(Main p) &#123; return (int) Math.sqrt((x-p.x)*(x-p.x)+(y-p.y)*(y-p.y)); &#125; public static void main(String args[]) &#123; Scanner scanner=new Scanner(System.in); Main p1,p2; int x,y,x1,y1; x=scanner.nextInt(); y=scanner.nextInt(); p1=new Main(x,y); x1=scanner.nextInt(); y1=scanner.nextInt(); p2=new Main(x1,y1); System.out.println(p1.toString()); if(p1.compareTo(p2)&gt;=0) System.out.println(&quot;true&quot;); else System.out.println(&quot;false&quot;); System.out.println(p1.distance(p2)); &#125;&#125; 接口与实现的例题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.util.Arrays;import java.util.Comparator; class PersonCompartor implements Comparator&lt;Main&gt;&#123; @Override public int compare(Main o1, Main o2) &#123; return o1.getTuanxian()-o2.getTuanxian(); &#125;&#125;public class Main implements Comparable&lt;Main&gt;&#123; private String nameString; private String age; private int num; private int tuanxian; private int gexian; public Main(String nameString, String age, int num, int tuanxian, int gexian) &#123; super(); this.nameString = nameString; this.age = age; this.num = num; this.tuanxian = tuanxian; this.gexian = gexian; &#125; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; public int getTuanxian() &#123; return tuanxian; &#125; public void setTuanxian(int tuanxian) &#123; this.tuanxian = tuanxian; &#125; public int getGexian() &#123; return gexian; &#125; public void setGexian(int gexian) &#123; this.gexian = gexian; &#125; public String getNameString() &#123; return nameString; &#125; public void setNameString(String nameString) &#123; this.nameString = nameString; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public static void main(String[] args) &#123; Main []persons=new Main[5]; persons[0]=new Main(&quot;职工1&quot;,&quot;female&quot; ,1, 500, 400); persons[2]=new Main(&quot;职工2&quot;,&quot;female&quot; ,2, 400, 600); persons[1]=new Main(&quot;职工3&quot;,&quot;male&quot; ,3, 600, 300); persons[3]=new Main(&quot;职工4&quot;,&quot;female&quot; ,4, 800, 200); persons[4]=new Main(&quot;职工5&quot;,&quot;male&quot; ,5, 500, 700); System.out.println(&quot;编号,团险,个险,姓名,性别&quot;); for(int i=0;i&lt;5;i++) &#123; System.out.println(persons[i].getNum()+&quot;,&quot;+persons[i].getTuanxian()+&quot;,&quot;+persons[i].getGexian()+&quot;,&quot;+persons[i].getNameString()+&quot;,&quot;+persons[i].getAge()); &#125; Arrays.sort(persons,new PersonCompartor()); //因为重写了compareto方法，可以用Arrays.sort（persions）,直接完成排序 System.out.println(&quot;编号,团险,个险,姓名,性别&quot;); for(int i=0;i&lt;5;i++) &#123; System.out.println(persons[i].getNum()+&quot;,&quot;+persons[i].getTuanxian()+&quot;,&quot;+persons[i].getGexian()+&quot;,&quot;+persons[i].getNameString()+&quot;,&quot;+persons[i].getAge()); &#125; &#125; @Override public int compareTo(Main o) &#123; // TODO 自动生成的方法存根 return this.tuanxian-o.getTuanxian(); &#125;&#125; 以下描述错误的有 C abstract 可以修饰类、接口、方法 abstract修饰的类主要用于被继承 abstract 可以修饰变量 abstract修饰的类，其子类也可以是abstract修饰的 Java中类允许嵌套但是方法都不允许嵌套定义。 Java程序执行时出现异常，也不一定是程序本身的错。 对 匿名对象 匿名对象是没有名字的实体，也就是该实体没有对应的变量名引用 匿名对象的特征: 创建的匿名类的对象只能够调用一次 匿名对象只在堆内存中开辟空间，而不存在栈内存的引用 每次创建匿名对象都是不同的对象 下列有关匿名对象的说法，正确的有 ABDA\\ 匿名对象只能继承一个类或实现一个接口B\\ 匿名对象可以有构造函数C\\ 匿名对象不能被重复构造D\\ 每个匿名对象都具有独一无二的类型 常用实用类设String对象s&#x3D;”Hello “，运行语句 System.out.println(s.concat(“World!”));后String对象s的内容为”Hello world!”，所以语句输出为Hello world!。 (F)&#x2F;&#x2F; String定义之后永远不会发生改变，任何对String的操作都是另外返回一个新的String，而不是在原有的String上进行修改但是System.out.println(s.concat(“World!”))打印的确实是”Hello world!” java中字符串的&#x3D;&#x3D;和equals方法 12345678910111213141516171819202122232425求一个串中字母数字空格的个数public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); String str=sc.nextLine(); char x[]=str.toCharArray(); int a=0; int b=0; int c=0; int d=0; for(int i=0;i&lt;x.length;i++)&#123; char ch=x[i]; if(63&lt;= ch&amp;&amp;ch&lt;=90||97&lt;=ch&amp;&amp;ch&lt;=122) a++; else if(ch&gt;48&amp;&amp;ch&lt;97) b++; else if(ch==&#x27; &#x27;) c++; else d++; &#125; System.out.println(&quot;letters=&quot;+a);//输出英文字母个数 System.out.println(&quot;digits=&quot;+b);//输出数字个数 System.out.println(&quot;spaces=&quot;+c);//输出空格个数 System.out.println(&quot;others=&quot;+d);//输出其他字符个数 &#125; 1234567891011121314151617181920212223242526272829303132333435363738package 常用实用类;import java.util.Scanner;public class aaa &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String str = sc.nextLine(); StringBuffer stringBuffer = new StringBuffer(); int flag = 0; for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) == &#x27;_&#x27;) &#123; flag = 1; continue; &#125; if (flag == 1) &#123; stringBuffer.append((char) (str.charAt(i) - 32)); // 字符转换为大写 flag = 0; &#125; else &#123; stringBuffer.append(str.charAt(i)); &#125; &#125; System.out.println(stringBuffer); /* * * 字符串大小写转换 String test=&quot;SHA34cccddee&quot;; * System.out.println(test.toUpperCase());//小写转大写 * * * * String test=&quot;SHA34cccddee&quot;; System.out.println(test.toLowerCase());//大写转小写 * */ //输入 //sum_of_array //sumOfArray &#125;&#125; 字符串处理的例题 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String str = sc.nextLine(); String iString=sc.nextLine(); String to=sc.nextLine(); String s[]=str.split(&quot; &quot;); StringBuffer stringBuffer = new StringBuffer(); int flag=0; for (int i = 0; i &lt; s.length; i++) &#123; for(int j=0;j&lt;s[i].length();j++) &#123; if(s[i].charAt(j)==&#x27;,&#x27;)flag=1; &#125; if(flag==1) &#123; if (s[i].substring(0, s[i].length()-1).equals(iString)) &#123; stringBuffer.append(to +&#x27;,&#x27;+&#x27; &#x27;); // 字符转换为大写 &#125;else &#123; stringBuffer.append(s[i]+&#x27; &#x27;); &#125; &#125;else &#123; if (s[i].equals(iString)) &#123; stringBuffer.append( to+&#x27; &#x27;); // 字符转换为大写 &#125; else &#123; stringBuffer.append(s[i]+&#x27; &#x27;); &#125; &#125; flag=0; &#125; System.out.println(stringBuffer.substring(0,stringBuffer.length()-1)); &#125;&#125; 字符串处理年月日 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner; public class Main &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); int count=Integer.valueOf(sc.nextLine()); String s[]=new String[count]; for (int i=0;i&lt;count;i++)&#123; s[i]=sc.nextLine(); &#125; String temp; SimpleDateFormat df=new SimpleDateFormat(&quot;yyyyMMdd&quot;); while (true)&#123; String tem=sc.nextLine(); if (tem.equals(&quot;sort1&quot;))&#123; Date date[]=new Date[count]; for (int j=0;j&lt;count;j++)&#123; for (int i=0;i&lt;count-j-1;i++)&#123; String bir1=s[i].substring(6,14); String bir2=s[i+1].substring(6,14); Date d1; Date d2; try &#123; d1 = df.parse(bir1); d2 =df.parse(bir2); if (d1.getTime()&gt;d2.getTime())&#123; temp=s[i]; s[i]=s[i+1]; s[i+1]=temp; &#125; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125; for (int i=0;i&lt;count;i++)&#123; String bir=s[i]; System.out.println(bir.substring(6,10)+&quot;-&quot;+bir.substring(10,12)+&quot;-&quot;+bir.substring(12,14)); &#125; &#125;else if (tem.equals(&quot;sort2&quot;))&#123; Date date[]=new Date[count]; for (int j=0;j&lt;count;j++)&#123; for (int i=0;i&lt;count-j-1;i++)&#123; String bir1=s[i].substring(6,14); String bir2=s[i+1].substring(6,14); Date d1; Date d2; try &#123; d1 = df.parse(bir1); d2 =df.parse(bir2); if (d1.getTime()&gt;d2.getTime())&#123; temp=s[i]; s[i]=s[i+1]; s[i+1]=temp; &#125; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125; for (int i=0;i&lt;count;i++)&#123; System.out.println(s[i]); &#125; &#125;else &#123; System.out.println(&quot;exit&quot;); &#125; &#125; &#125;&#125; 在复选框中移动鼠标，然后单击一选项，要捕获所选项必需实现哪个接口？（ItemListener） ActionListener MouseListener MouseMotionListern ItemListener 伪随机数（通过算法产生的随机数）输入格式:在一行中输入3个不超过10000的正整数n,m,k。输出格式:在一行中输出以k为种子建立的Random对象产生的第n个0到m-1之间的伪随机数。 12345678910111213141516171819202122import java.util.*;public class Main &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int m = sc.nextInt(); int k = sc.nextInt(); List&lt;Integer&gt; ss = new ArrayList&lt;Integer&gt;(); //Set&lt;Integer&gt; ss = new HashSet&lt;Integer&gt;(); Random rand = new Random(k); for(int i = 0;i &lt; n;i++) &#123; ss.add(rand.nextInt(m)); if(i==n-1) //求第n个随机数 System.out.println(ss.get(i)); &#125; &#125; &#125; 公历类 123456789101112import java.util.Calendar;import java.util.GregorianCalendar;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; GregorianCalendar date=new GregorianCalendar(); Scanner in=new Scanner(System.in); long millis=in.nextLong(); date.setTimeInMillis(millis); System.out.println(date.get(Calendar.YEAR)+&quot;-&quot;+(date.get(Calendar.MONTH))+&quot;-&quot;+date.get(Calendar.DAY_OF_MONTH)); &#125; // 本来0表示一月份，所以要加一，但是本题没有要求加1&#125; 字符串操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.ArrayList;import java.util.Scanner;public class Main &#123; public static void main(String[] args)&#123; Scanner in = new Scanner(System.in); ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;(); while(true) &#123; String s = in.next(); if(s.equals(&quot;!!end!!&quot;)) break; strList.add(s); &#125; strList.add(0, &quot;begin&quot;); strList.add(&quot;end&quot;); System.out.println(strList); String str = in.next(); System.out.println(strList.contains(str)); System.out.println(strList.indexOf(str)); System.out.println(strList.lastIndexOf(str)); System.out.println(strList.get(0)); strList.remove(0); System.out.println(strList); str = in.next(); strList.set(1, str); System.out.println(strList); str = in.next(); ArrayList&lt;String&gt; strList1 = new ArrayList&lt;&gt;(); for(int i=0;i&lt;strList.size();i++) &#123; if(strList.get(i).contains(str)) strList1.add(strList.get(i)); &#125; System.out.println(strList1); strList.remove(str); System.out.println(strList); strList.clear(); System.out.println(strList+&quot;,&quot;+strList.size()+&quot;,&quot;+strList.isEmpty()); &#125;&#125;","categories":[{"name":"java interview","slug":"java-interview","permalink":"https://zouyunkai.github.io/myblog/categories/java-interview/"}],"tags":[],"author":"aoyuehan"},{"title":"训练26 BAPC 2019","slug":"训练26-BAPC-2019","date":"2020-03-22T02:46:00.000Z","updated":"2022-02-26T03:52:52.130Z","comments":true,"path":"2020/03/22/训练26-BAPC-2019/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/22/%E8%AE%AD%E7%BB%8326-BAPC-2019/","excerpt":"","text":"题目链接 B Breaking Branches设 N 表示当前状态先手必败，P 表示先手必胜。结论：n 为奇数时为 N 态，n 为偶数时为 P 态。证明：当 n &#x3D; 1，n &#x3D; 2 时已知结论成立。如果对于 n &lt;&#x3D; 2k 结论都成立，那么对于 n &#x3D; 2k+1，必然要分为奇数+偶数，所以 n &#x3D; 2k+1 必然要分为 N 态 + P 态，即 n &#x3D; 2k+1 为 N 态。（博弈论有向图游戏）同理，对于 n &#x3D; 2k+2，可以将其分为任意两个奇数的和，使其分为 N 态 + N 态，从而 n &#x3D; 2k+2 为 P态。故 n &#x3D; 2k+1 , n &#x3D; 2k+2 时结 论成立。综上所述，若 n 为奇数，则先手必败，若 n 为偶数，则先手必胜。 123456789#include&lt;bits/stdc++.h&gt;using namespace std;int n;int main()&#123;cin &gt;&gt; n;if(n&amp;1) cout &lt;&lt; &quot;Bob&quot; &lt;&lt; endl;else cout &lt;&lt; &quot;Alice\\n1&quot; &lt;&lt; endl;return 0;&#125; J Jazz it Up!此题题目要求， 的因子中不能含有平方形式，因为题目中已经说明 是一个无平方因子的数，那么只要 是无平方因子的数，并且 和 没有共同的因子即可。根据算术基本定理， 可以分解成若干个质数的积，所以 就直接可以是非 的因子的一个质数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127方法一：#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;math.h&gt;#include&lt;string.h&gt;using namespace std;const int maxn=1e5+10;int prime[maxn];bool isPrime[maxn];map&lt;int,int&gt;mp;int sieve(int n) &#123; //n就是筛子的大小，如1~100的表，那么n=100 int num=0; memset(isPrime,true,sizeof(isPrime)); isPrime[0]=isPrime[1]=false; for(int i=2; i&lt;=n; i++) &#123; //从2开始到n if(isPrime[i]) &#123; mp[i]=num; prime[num++]=i; for(int j=2; j*i&lt;=n; j++) &#123; isPrime[j*i]=false; &#125; &#125; &#125; return num;&#125;int main() &#123; int Punm=sieve(maxn); int n,flag=0; cin&gt;&gt;n; for(int i=0; i&lt;Punm&amp;&amp;prime[i]&lt;=sqrt(n); i++) &#123; flag=0;//这里是来对n进行质数分解 if(n%prime[i]==0) &#123; flag=1; while(n%prime[i]==0) &#123; //计算该因子的个数 n/=prime[i]; &#125; &#125; if(flag==1)prime[i]=-1; if(n==1)break; &#125; if(n!=1) &#123; //如果无法被根号n以内的质因子除尽 prime[mp[n]]=-1; &#125; for(int i=0;i&lt;Punm;i++)&#123; if(prime[i]&gt;0)&#123;cout&lt;&lt;prime[i]&lt;&lt;endl; break;//输出最小的那个质数 &#125; &#125;&#125;方法二（暴力）：#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+10;ll n,m;ll s[maxn];void prepare() &#123; for(int i=2; i&lt;=1e5; i++) &#123; s[i]=i*i;//存下平方之后的数，减少计算量 &#125;&#125;int main() &#123; prepare(); cin&gt;&gt;n; for(m=2; m&lt;n; m++) &#123; int flag=0;//标记是否有平方因子 ll ans=n*m; int k=2; for(k=2; k&lt;n; k++) &#123;//对于每一个小于等于ans的平方项s[k]，进行判断 if(s[k]&lt;=ans) &#123; if(ans%s[k]!=0) &#123; continue; &#125; else &#123; flag=1;//标记平方因子 break; &#125; &#125; else &#123; break; &#125; &#125; if(flag==0) &#123; cout&lt;&lt;m&lt;&lt;endl; break; &#125; &#125; return 0;&#125;方法三：标程#include&lt;cstdio&gt;#include&lt;cstring&gt;#define ll long longconst ll N=1e5+7;ll prime[N],ans,n,prime_tot = 0;bool prime_tag[N];void get_prime()&#123; for(int i = 2; i &lt; N; i++)&#123; if(!prime_tag[i])&#123; prime[prime_tot++] = i; &#125; for(int j = 0; j &lt; prime_tot &amp;&amp; i * prime[j] &lt; N; j++)&#123;prime_tag[i * prime[j]] = true; if(i % prime[j] == 0) break; &#125; &#125; prime_tag[1] = true;&#125;int main()&#123; get_prime(); scanf(&quot;%lld&quot;,&amp;n); for(ll i=0;i&lt;prime_tot;i++)&#123; if(n%prime[i])&#123;//原来直接在素数表中选择一个n余质数不为0的输出就可以了，巧妙 ans=prime[i]; break; &#125; &#125; printf(&quot;%lld\\n&quot;,ans);&#125; E Efficient Exchange 12345678910111213141516#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int dp[10005][2];int main()&#123;char s[10005];scanf(&quot;%s&quot;,s);dp[0][1]=1;dp[0][0]=0;for(int i=0;i&lt;strlen(s);i++)&#123; dp[i+1][0]=min(dp[i][0]+s[i]-&#x27;0&#x27;,dp[i][1]+10-s[i]+&#x27;0&#x27;); dp[i+1][1]=min(dp[i][0]+s[i]-&#x27;0&#x27;+1,dp[i][1]+10-s[i]+&#x27;0&#x27;-1);&#125;printf(&quot;%d&quot;,dp[strlen(s)][0]);return 0;&#125; 本来还想超出1000的，用面值1000的，只要算小于1000的部分，然后一位位的比较，发现情况太多了，然后写递归，写错了。","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"流水作业调度问题","slug":"流水作业调度问题","date":"2020-03-22T02:22:00.000Z","updated":"2022-02-26T03:51:21.590Z","comments":true,"path":"2020/03/22/流水作业调度问题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/22/%E6%B5%81%E6%B0%B4%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98/","excerpt":"","text":"一、问题描述N个作业{1,2,………,n}要在由两台机器M1和M2组成的流水线上完成加工。每个作业加工的顺序都是先在M1上加工，然后在M2上加工。M1和M2加工作业i所需的时间分别为ai和bi，1≤i≤n。流水作业高度问题要求确定这n个作业的最优加工顺序，使得从第一个作业在机器M1上开始加工，到最后一个作业在机器M2上加工完成所需的时间最少。 二、算法思路直观上，一个最优调度应使机器M1没有空闲时间，且机器M2的空闲时间最少。在一般情况下，机器M2上会有机器空闲和作业积压2种情况。最优调度应该是： 使M1上的加工是无间断的。即M1上的加工时间是所有ai之和，但M2上不一定是bi之和。 使作业在两台机器上的加工次序是完全相同的。则得结论：仅需考虑在两台机上加工次序完全相同的调度。 设全部作业的集合为N&#x3D;{1，2，…，n}。S是N的作业子集。在一般情况下，机器M1开始加工S中作业时，机器M2还在加工其他作业，要等时间t后才可利用。将这种情况下完成S中作业所需的最短时间记为T(S,t)。流水作业调度问题的最优值为T(N,0)。这个T(S,t)该如何理解?举个例子就好搞了 1、最优子结构T(N,0)&#x3D;min{ai + T(N-{i}, bi)}, i∈N。ai：选一个作业i先加工，在M1的加工时间。T(N-{i},bi}：剩下的作业要等bi时间后才能在M2上加工。注意这里函数的定义，因为一开始工作i是随机取的，M1加工完了ai之后，要开始加工bi了，这里M1是空闲的可以开始加工剩下的N-i个作业了，但此时M2开始加工bi，所以要等bi时间之后才能重新利用，对应到上面函数T(s,t)的定义的话，这里就应该表示成T(N-{i},bi), 所以最优解可表示为T(N,0)&#x3D;min{ai + T(N-{i}, bi)}, i∈N，即我们要枚举所有的工作i，使这个式子取到最小值。 继续分析T(S,t)可得： T(S,t)&#x3D;{ ai + T(S-{i}, bi+max{ t-ai ,0 } ) }, i∈S 其中：T(S-{i}, bi+max{ t-ai , 0 } )：剩下的作业等bi+max{t-ai,0}才能在M2加工；t为ai的上一次标号为i-1的b（i-1）加工的时间，至于这里是怎么推导出来的呢？见下面推导： 2、最优子结构性质问题是：虽然满足最优子结构性质，也在一定程度满足子问题重叠性质。N的每个非空子集都计算一次，共2n-1次，指数级的。为了解决这个问题引入Johnson不等式 3、Johnson不等式 推导公式的最后两步，作用是提出bi和aj，然后直接max三元素 4、算法描述假设有下列的7个作业：推测一下这个Johson法则为什么能够得到最小的作业时间？ Johson法则分出的第一组都是M2加工时间大于M1的，且按M1时间递增；分出的第二组都是M1加工时间大于M2的，且按M2时间递减。 由于M1加工是无间断的，决定时间长短的只是M2。按照Johson法则会发现，中间部分都是一些M2耗时大的作业，两头都是一些耗时小的作业，个人觉得这样安排会很好填充M2中的时间空隙。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;class JOB&#123;public: int key,index; bool job;&#125;;bool cmp(JOB a,JOB b)&#123; return a.key&lt;b.key;&#125;int func(int n,int a[],int b[],int c[])&#123; int i,j,k; JOB *d =new JOB[n]; for(i=0;i&lt;n;i++) &#123; if(a[i]&lt;b[i]) &#123;//把作业按a[i]&lt;b[i]和a[i]&gt;b[i]两类分开 d[i].job =true; d[i].key =a[i]; &#125; else &#123; d[i].job=false; d[i].key=b[i]; &#125; d[i].index=i; &#125; sort(d,n+d,cmp); j=0,k=n-1; for(i=0;i&lt;n;i++) &#123;//这地方很巧妙的把顺序排好了 if(d[i].job ==true) c[j++]=d[i].index; else c[k--]=d[i].index; &#125; j=a[c[0]]; k=j+b[c[0]]; for(i=1;i&lt;n;i++) &#123;//这地方遍历一遍求k，k就是完成所有作业最终的总时间 j=j+a[c[i]]; k= j&lt;k ? k+b[c[i]] : j+b[c[i]] ; &#125; delete d; return k;&#125;int main()&#123; int i,n,m,a[100],b[100],c[100]; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;m; for(i=0;i&lt;m;i++) &#123; cin&gt;&gt;a[i]; cin&gt;&gt;b[i]; &#125; cout&lt;&lt;func(m,a,b,c)&lt;&lt;endl; &#125; return 0;&#125;/*72472973*/结果为43","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[],"author":"aoyuehan"},{"title":"数据库笔记二","slug":"数据库笔记二","date":"2020-03-20T23:05:00.000Z","updated":"2022-02-26T03:52:51.361Z","comments":true,"path":"2020/03/21/数据库笔记二/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%E4%BA%8C/","excerpt":"","text":"关系数据理论为什么要学习关系数据理论 为了设计出合格的数据库以满足需求，使数据库更加高效有序针对一个具体问题如何设计出适合它的数据库模式。不合适的数据库模式会发生数据冗余，更新异常，插入异常，删除异常的问题。而学习关系数据理论可以帮助我们消除不合适的数据依赖，解决问题 函数依赖 范式 bc范式 函数依赖的公理化系统 模式的分解 第六章题目 题目一： 题目二：这地方在判断范式的时候可以直接看最小依赖集中的函数依赖关系就好了，因为和原来的函数依赖集是等价的。 题目三： 第七章数据库设计什么是数据库设计，数据库设计的基本步骤 需求分析 E-R模型及设计 拓展的E-R模型 概念结构设计","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[],"author":"aoyuehan"},{"title":"软件工程","slug":"软件工程","date":"2020-03-20T00:00:00.000Z","updated":"2022-02-26T03:52:52.303Z","comments":true,"path":"2020/03/20/软件工程/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"软件的启蒙-初识软件工程软件危机 软件工程 软件的声明周期 软件的过程模型 瀑布模型 快速原型模型 增量模型 螺旋模型 喷泉模型 统一开发模型 各种模型的比较 软件开发方法 结构化开发方法 面向对象开发方法 敏捷软件开发方法 软件的评估- 可行性分析组织分析 业务分析 可行性分析 可行性分析报告报告原文 软件的理解- 需求分析需求分析概述 需求分析建模 -功能模型 数据流图的定义数据流图主要是对系统的功能进行分析，建立功能模型。 数据流图的绘制 数据字典 需求分析模型- 数据模型 需求分析模型-行为模型 一个小问题 软件的设计-总体设计与详细设计总体设计概述 总结 第五章例题 第六章详细设计","categories":[{"name":"软件工程","slug":"软件工程","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[],"author":"aoyuehan"},{"title":"Arab Collegiate  contest 2015","slug":"Arab-Collegiate-contest-2015","date":"2020-03-19T14:22:00.000Z","updated":"2022-02-26T03:52:51.658Z","comments":true,"path":"2020/03/19/Arab-Collegiate-contest-2015/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/19/Arab-Collegiate-contest-2015/","excerpt":"","text":"D 分数的gcd和lcm两个分数的最大公约数的求法：1、将两个分数都变成最简分数2、将它们分母的最小公倍数作为分母3、将它们分子的最大公约数作为分子这样得到的数就是两个分数的最大公约数 两个分数的最小公倍数的求法：1、将两个分数都变成最简分数2、将它们分母的最大公约数作为分母3、将它们分子的最小公倍数作为分子这样得到的数就是两个分数的最小公倍数。 本来以为给出的数据就是最简形式了，而没有注意到还要约分。读题要细致 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll gcd(ll a, ll b)&#123; return b ? gcd(b, a % b) : a;&#125;ll lcm(ll a, ll b)&#123; return a*b/gcd(a,b);//可以把b放到最后乘，优化一下&#125;int main()&#123; ll T; cin&gt;&gt;T; while(T--)&#123; ll a, b, c, d; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d; ll x, y, n, m, tmp; tmp = gcd(a, b); a /= tmp, b /= tmp; tmp = gcd(c, d); c /= tmp, d /= tmp; x = gcd(a, c), y = lcm(b, d); n = lcm(a, c), m = gcd(b, d); cout&lt;&lt;x&lt;&lt;&quot;/&quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;n&lt;&lt;&quot;/&quot;&lt;&lt;m&lt;&lt;endl; &#125; return 0;&#125;开long long ，防爆int E 贪心 &amp;和|每一位单独考虑，就相当于一个01序列如果要使这个序列的结果为1，对于最右边的1，那这个1右边的符号都必须是或，不过这只是一个必要条件如果这个1的左边也是或，那么结果一定为1，这是充分条件，因为算的时候是从左往右算的，然后如果这个1左边的操作符里有或的话移一个过来肯定是优的，移到他的左边 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;fstream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;deque&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;#include &lt;map&gt;#include &lt;random&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;sstream&gt;#pragma GCC optimize(2)#define IOS ios_base::sync_with_stdio(0); cin.tie(0);#define Mod 1000000007#define eps 1e-6#define ll long long#define INF 0x3f3f3f3f#define MEM(x,y) memset(x,y,sizeof(x))#define maxn 100000 * 2 + 10using namespace std;ll a[maxn];int main()&#123; int T;cin&gt;&gt;T; while(T--) &#123; int num_and , num_or; cin&gt;&gt;num_and&gt;&gt;num_or; int n = num_and + num_or + 1; for(int i = 0 ; i &lt; n ; i++) cin&gt;&gt;a[i]; //sort(a , a + n); ll ans = a[0]; for(int i = 1 ; i &lt; n ; i++) &#123; if(num_and) &#123; ans &amp;= a[i]; num_and--; &#125; else &#123; ans |= a[i]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; J 输入一些字符串 然后输出另外相对应的值 12345678910111213141516171819202122232425#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;map&lt;string,string&gt;ss; int main()&#123; int n,k,t; cin&gt;&gt;n;string tmpa,tmpb,tmp; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;tmpa&gt;&gt;tmp&gt;&gt;tmpb; ss[tmpa]=tmpb; &#125; cin&gt;&gt;t; for(int i=0;i&lt;t;i++)&#123; cin&gt;&gt;k;//string s; for(int j=0;j&lt;k;j++)&#123; cin&gt;&gt;tmp; if(j==k-1)cout&lt;&lt;ss[tmp]; else cout&lt;&lt;ss[tmp]&lt;&lt;&#x27; &#x27;; //s.append(ss[tmp]) ; &#125;// cout&lt;&lt;s&lt;&lt;endl;//cout&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"最大字段和","slug":"最大字段和","date":"2020-03-19T09:22:26.000Z","updated":"2022-02-26T03:52:51.617Z","comments":true,"path":"2020/03/19/最大字段和/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/19/%E6%9C%80%E5%A4%A7%E5%AD%97%E6%AE%B5%E5%92%8C/","excerpt":"","text":"暴力做法思想：从序列首元素开始穷举所有可能的子序列。算法复杂度为O(n^3) 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int MaxSubsequenceSum(const int array[], int n)&#123; int tempSum, maxSum; maxSum = 0; for (int i = 0;i &lt; n;i++) // 子序列起始位置 &#123; for (int j = i;j &lt; n;j++) // 子序列终止位置 &#123; tempSum = 0; for (int k = i;k &lt; j;k++) // 子序列遍历求和 tempSum += array[k]; if (tempSum &gt; maxSum) // 更新最大和值 maxSum = tempSum; &#125; &#125; return maxSum;&#125;int main()&#123; const int a[] = &#123; 4, -3, 5, -2, -1, 2, 6, -2 &#125;; int maxSubSum = MaxSubsequenceSum(a, 8); cout &lt;&lt; &quot;The max subsequence sum of a is: &quot; &lt;&lt; maxSubSum &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 改进的蛮力算法 思想：直接在划定子序列时累加元素值，减少一层循环。 算法复杂度为O(n^2) 123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;int MaxSubsequenceSum(const int array[],int n)&#123; int tempSum, maxSum; maxSum = 0; for (int i = 0;i &lt; n;i++) &#123; tempSum = 0; for (int j = i;j &lt; n;j++) &#123; tempSum += array[j]; if (tempSum &gt; maxSum) maxSum = tempSum; &#125; &#125; return maxSum;&#125;int main()&#123; const int a[] = &#123; 4, -3, 5, -2, -1, 2, 6, -2 &#125;; int maxSubSum = MaxSubsequenceSum(a, 8); cout &lt;&lt; &quot;The max subsequence sum of a is: &quot; &lt;&lt; maxSubSum &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 分治递归的算法思想：将序列划分为左右两部分，则最大子段和可能在三处出现：左半部、右半部以及跨越左右边界的部分。递归的终止条件是：left &#x3D;&#x3D; right。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;int max3(int a, int b, int c) // 求三个数的最大值&#123; int max = a; if (b &gt; max) max = b; if (c &gt; max) max = c; return max;&#125;int MaxSubsequenceSum(const int array[], int left, int right) &#123; if (left == right) // 设置基准，即递归终止条件 return array[left]; int middle = (left + right) / 2; int leftMaxSubsequenceSum = MaxSubsequenceSum(array, left, middle); // 求左半部分最大子序列和 int rightMaxSubsquenceSum = MaxSubsequenceSum(array, middle + 1, right); // 求右半部分最大子序列和 // 处理左右边界问题：最大子序列跨越中间，包含左半部分最右一个数，同时包含右半部分最左一个数 int maxLeftBorderSum = 0; int maxRightBorderSum = 0; int tempSum = 0; // 临时求和变量 for (int i = middle;i &gt;= left;i--) &#123; tempSum += array[i]; if (tempSum &gt; maxLeftBorderSum) maxLeftBorderSum = tempSum; // 左边包含边界最大序列和 &#125; tempSum = 0; for (int i = middle + 1;i &lt; right;i++) &#123; tempSum += array[i]; if (tempSum &gt; maxRightBorderSum) maxRightBorderSum = tempSum; // 右边包含边界最大序列和 &#125; int maxBorderSum = maxRightBorderSum + maxLeftBorderSum; // 最大边界子序列和等于两部分边界之和 return max3(leftMaxSubsquenceSum, maxBorderSum, rightMaxSubsquenceSum); // 返回三个部分的最大子序列和&#125;int main()&#123; const int a[] = &#123; 4, -3, 5, -2, -1, 2, 6, -2 &#125;; int maxSubSum = MaxSubsequenceSum(a, 0, 7); cout &lt;&lt; &quot;The max subsequence sum of a is: &quot; &lt;&lt; maxSubSum &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 动态规划算法 O(n) 12345678910111213141516171819202122232425262728293031323334353637383940414243巧妙一点的：#include&lt;iostream&gt;using namespace std;int MaxSubsequenceSum(const int A[], int n)&#123; int tempSum = 0; int maxSum = 0; for (int j = 0;j &lt; n;j++) // 子问题后边界 &#123; tempSum = (tempSum + A[j]) &gt; A[j] ? (tempSum + A[j]) : A[j]; if (tempSum &gt; maxSum) // 更新最大和 maxSum = tempSum; &#125; return maxSum;&#125;int main()&#123; const int a[] = &#123; 4, -3, 5, -2, -1, 2, 6, -2 &#125;; int maxSubSum = MaxSubsequenceSum(a, 8); cout &lt;&lt; &quot;The max subsequence sum of a is: &quot; &lt;&lt; maxSubSum &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125;书上给出的：#include &lt;iostream&gt; using namespace std; int main() &#123; int a[10]=&#123;31, -41, 59, 26, -53, 58, 97, -93, -23, 84&#125;; int b=0,sum=a[0]; for(int i=0;i&lt;10;i++) &#123; if(b&gt;0) b+=a[i]; else b=a[i];//如果前面为零，如果相加，则影响后面结果，所以抛弃前面总和 if(b&gt;sum) sum=b; &#125; cout&lt;&lt;&quot;MaxSum:&quot;&lt;&lt;sum&lt;&lt;endl; return 0; &#125; 最大子矩阵问题一个ppt上的理解（wocao，为什么没早看到，书上的说法，看了一下午 orz） 我的理解： 将最大子矩阵的每一列各自加和，就可以得到一个一维数组：{a[i][k] +••••••+ a[j][k], •••••• , a[i][s] +••••+ a[j][s] }，这样的话，我们就把这个问题转换成了一个一维数组求最大子段和的问题了，也就是说，将一个二维数组的纵向元素相加，变成一个横向上的一维数组，就能使用一维的方法来解决这个问题了。 例题：ZOJ Problem Set - 1074 To the Max题意：把一个具有最大和的子矩阵作为最大子矩阵。输出最大值。 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main() &#123; long int xsum[502][502];//xsum[i][j]前 i 行 j列的前缀和 long int i,j,s,n,m,k; long long int ans,sum=0; memset(xsum,0,sizeof(xsum)); scanf(&quot;%ld&quot;,&amp;n); m=n;//n行m列的矩阵 for(i=1; i&lt;=n; i++) for(j=1; j&lt;=m; j++) &#123; scanf(&quot;%ld&quot;,&amp;s); xsum[i][j]=s+xsum[i-1][j];//xsum[i][j]前 i 行 j列的前缀和 &#125; for(i=1; i&lt;=n; i++) //枚举 从 子阵行高 按 最大子段 原理 求和 for(j=i; j&lt;=n; j++) &#123; ans=0; for(k=1; k&lt;=m; k++) &#123; ans+=xsum[j][k]-xsum[i-1][k]; if(ans&gt;sum)sum=ans;//先判断 防 全为负数情况 更新 最大值 if(ans&lt;0)ans=0;//当前小于0 则重新开始； &#125; &#125; printf(&quot;%lld\\n&quot;,sum); return 0;&#125; 最大m子段和 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std; const int maxn=5010;int n,m;int a[maxn]; int b[maxn][maxn];int MaxSubsum()&#123; if(n&lt;m||m&lt;1)return 0; for(int i=0;i&lt;=m;i++)&#123; b[i][0]=0; &#125; for(int j=1;j&lt;=n;j++)&#123; b[0][j]=0; &#125; for(int i=1;i&lt;=m;i++)&#123;//枚举分为第i段，的第j个字母 for(int j=i;j&lt;=n-m+i;j++)&#123; //n-m+i，确保后面的元素能够分为m-i段 if(j&gt;i)&#123; b[i][j]=b[i][j-1]+a[j-1]; for(int k=i-1;k&lt;j;k++)&#123;//枚举k从i-1到j-1，把b[i][j]看成一块求最大 if(b[i][j]&lt;b[i-1][k]+a[j-1])&#123; b[i][j]=b[i-1][k]+a[j-1]; &#125; &#125; &#125;else&#123; b[i][j]=b[i-1][j-1]+a[j-1]; &#125; &#125; &#125; int sum=0; for(int j=m;j&lt;=n;j++)&#123; if(sum&lt;b[m][j])sum=b[m][j]; &#125; return sum;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; cout&lt;&lt;MaxSubsum()&lt;&lt;endl;&#125; 123456789101112131415161718192021222324252627282930313233两行数组优化之后；#include&lt;bits/stdc++.h&gt;using namespace std; typedef long long ll;const int N=1e6+5; const int INF=0x3f3f3f3f;int n,m;ll a[N],dp[2][N]; //只保存上一行和当前行 int main() &#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) //n个数字，m子段和 &#123; for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,a+i); for(int i=0;i&lt;=n;i++) dp[0][i]=0,dp[1][i]=0; //关键！此题答案只允许正值 for(int i=1,k=1;i&lt;=m;i++,k^=1) //分为i段，k为两行之间的切换 &#123; dp[k][i-1]=-INF; //i==j时，杜绝与前一元素共伍 ll maxpre=-INF; //maxpre记录上一行的最大值 for(int j=i;j&lt;=n-m+i;j++) &#123; maxpre=max(maxpre,dp[k^1][j-1]); //随时更新上一行最大值 dp[k][j]=max(dp[k][j-1],maxpre)+a[j]; //*对情况1、2的选择 &#125; &#125; ll ans=-INF; for(int i=m;i&lt;=n;i++) //找到第m行的最大值，即为答案 ans=max(ans,dp[m&amp;1][i]); printf(&quot;%lld\\n&quot;,ans); &#125; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"Preliminaries for Benelux  contest 2019","slug":"Preliminaries-for-Benelux-contest-2019","date":"2020-03-18T06:41:00.000Z","updated":"2022-02-26T03:52:52.109Z","comments":true,"path":"2020/03/18/Preliminaries-for-Benelux-contest-2019/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/18/Preliminaries-for-Benelux-contest-2019/","excerpt":"","text":"A题意：给出r和c的值，代表一个二维表，然后再给出r个数和c个数，现在让你把这些数填进去，使得这r行的最大值恰好等于这r个数，使得这c列的最大值恰好也等于这c个数。原来只需要判断两个序列的最大值是否相等就好了。要是最大值相等，就能写出二维表。 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;const int maxn=1e6+10;int r[maxn];int c[maxn];int main() &#123; int rn,cn,tmp; cin&gt;&gt;rn&gt;&gt;cn; for(int i=0; i&lt;rn; i++) &#123; cin&gt;&gt;r[i]; &#125; for(int i=0; i&lt;cn; i++) &#123; cin&gt;&gt;c[i]; &#125; int maxc=-1; int maxr=-1; for(int i=0; i&lt;cn; i++) &#123; if(c[i]&gt;maxc)maxc=c[i]; &#125; for(int i=0; i&lt;rn; i++) &#123; if(r[i]&gt;maxr)maxr=r[i]; &#125; bool flag=false; if(maxr==maxc) &#123; cout&lt;&lt;&quot;possible&quot;&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; &#125;&#125; 字符串处理给你hey输出heey，给你heeeeey输出heeeeeeeeeey。记录一下中间e的个数，多输出一倍就好了。 1234567891011121314#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; string s;int cnt=0; cin&gt;&gt;s; for(int i=0;i&lt;s.length();i++)&#123; if(s[i]==&#x27;e&#x27;)cnt++; &#125; cout&lt;&lt;&#x27;h&#x27;; for(int i=0;i&lt;2*cnt;i++)cout&lt;&lt;&#x27;e&#x27;; cout&lt;&lt;&#x27;y&#x27; &lt;&lt;endl;&#125; 前缀和思想 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;const int maxn=1e6+10;long long a2[maxn];long long a[maxn];int main()&#123; int n,tmp; cin&gt;&gt;n; cin&gt;&gt;a[0];a2[0]=a[0]*a[0]; for(int i=1;i&lt;n;i++)&#123; cin&gt;&gt;tmp; a[i]=tmp+a[i-1];//前缀和 a2[i]=tmp*tmp+a2[i-1];//平方的前缀和 &#125;// for(int i=0;i&lt;n;i++)&#123;// cout&lt;&lt;a[i]&lt;&lt;&#x27; &#x27;;// &#125;cout&lt;&lt;endl;// for(int i=0;i&lt;n;i++)&#123;// cout&lt;&lt;a2[i]&lt;&lt;&#x27; &#x27;;// &#125;cout&lt;&lt;endl; long long ans=0; for(int k=0;k&lt;=n-2;k++)&#123;//枚举k的值，但是这个题得保证a和a2的项都得要 ans=max(ans,a2[k]*(a[n-1]-a[k])); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"java类型转换问题","slug":"java类型转换问题","date":"2020-03-18T00:46:00.000Z","updated":"2022-02-26T03:52:51.701Z","comments":true,"path":"2020/03/18/java类型转换问题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/18/java%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/","excerpt":"","text":"cast方法简介：cast方法的作用就是将一个对象装换为类或者接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//抽象出 一个父类 即使 没有这个也没事 可以返回object 这个万类之父public interface Tree &#123; //输出自己的品种 void sout(); //空对象模式 需要的 boolean isNUll();&#125;//具体的类public class AppleTree implements Tree &#123; @Override public void sout() &#123; System.out.println(&quot;我是苹果树&quot;); &#125; @Override public boolean isNUll() &#123; return false; &#125;&#125;//具体的类public class BananaTree implements Tree &#123; @Override public void sout() &#123; System.out.println(&quot;我是香蕉树&quot;); &#125; @Override public boolean isNUll() &#123; return false; &#125;&#125;public class CastMain &#123; public static void main(String[] args) &#123; AppleTree appleTree = new AppleTree(); Tree one = Tree.class.cast(appleTree); one.sout();//这一句话，就是将tree的对象强制向下转型为appletree对象 /* Tree one1=new AppleTree(); AppleTree appleTree1=(AppleTree)one1; 这样也能成功，但这和上面的cast方法大同小异 */ //强制类型转换父类，向上转型 Tree force = (Tree) appleTree; force.sout(); //这地方会出错 Tree two = BananaTree.class.cast(appleTree); two.sout(); &#125;&#125; 对于java的向下转型，强制向下转型，编译不会报错。但是在运行时，如果对象本身并非是该类型，强制转型，在运行时会报java.lang.ClassCastException。因此只有把子类型赋给父类的引用，然后把该引用向下转型的情况，才不会报错。 父类不能强制向下转型！向上转型则是安全的。 12345678910111213141516171819202122// 父类public class People &#123;&#125;//子类public class Man extends People &#123;&#125;//测试类public class Test&#123; public static void main(String [] args) throws Exception &#123; correctDown(); errorDown(); &#125; static void correctDown()&#123; People people=new Man(); System.out.println((Man) people); &#125; //类型转换错误，java.lang.ClassCastException: People cannot be cast to Man static void errorDown()&#123; People people=new People();//报错 System.out.println((Man) people); &#125;&#125;","categories":[{"name":"java interview","slug":"java-interview","permalink":"https://zouyunkai.github.io/myblog/categories/java-interview/"}],"tags":[],"author":"aoyuehan"},{"title":"V2ray","slug":"V2ray","date":"2020-03-17T11:37:00.000Z","updated":"2022-02-26T03:52:51.982Z","comments":true,"path":"2020/03/17/V2ray/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/17/V2ray/","excerpt":"","text":"https://www.stackcc.com/2019/04/02/v2raysetup/ https://www.stackcc.com/2018/12/31/registervultr/ https://www.huiyingwu.com/2572/ https://www.hijk.pw/v2rayn-config-tutorial/ https://covermusic.cn/v2ray-help https://zshttp.com/1310.html","categories":[],"tags":[],"author":"aoyuehan"},{"title":"Longest Common Subsequence ","slug":"Longest-Common-Subsequence","date":"2020-03-17T06:38:07.000Z","updated":"2022-02-26T03:52:51.609Z","comments":true,"path":"2020/03/17/Longest-Common-Subsequence/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/17/Longest-Common-Subsequence/","excerpt":"","text":"最长公共子序列简介 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXLEN 50void LCSLength(char *x, char *y, int m, int n, int c[][MAXLEN], int b[][MAXLEN])&#123; int i, j; for(i = 0; i &lt;= m; i++) c[i][0] = 0; for(j = 1; j &lt;= n; j++) c[0][j] = 0; for(i = 1; i&lt;= m; i++) &#123; for(j = 1; j &lt;= n; j++) &#123; if(x[i-1] == y[j-1]) &#123; c[i][j] = c[i-1][j-1] + 1; b[i][j] = 1; //如果使用&#x27;↖&#x27;、&#x27;↑&#x27;、&#x27;←&#x27;字符，会有警告，也能正确执行。 &#125; //本算法采用1,3,2三个整形作为标记 else if(c[i-1][j] &gt;= c[i][j-1]) &#123; c[i][j] = c[i-1][j]; b[i][j] = 2; &#125; else &#123; c[i][j] = c[i][j-1]; b[i][j] = 3; &#125; &#125; &#125;&#125;void PrintLCS(int b[][MAXLEN], char *x, int i, int j)&#123; if(i == 0 || j == 0) return; if(b[i][j] == 1) &#123; PrintLCS(b, x, i-1, j-1); printf(&quot;%c &quot;, x[i-1]); &#125; else if(b[i][j] == 2) PrintLCS(b, x, i-1, j); else PrintLCS(b, x, i, j-1);&#125;int main()&#123; char x[MAXLEN] = &#123;&quot;ABCBDAB&quot;&#125;; char y[MAXLEN] = &#123;&quot;BDCABA&quot;&#125;; int b[MAXLEN][MAXLEN]; //传递二维数组必须知道列数，所以使用MAXLEN这个确定的数 int c[MAXLEN][MAXLEN]; int m, n; m = strlen(x); n = strlen(y); LCSLength(x, y, m, n, c, b); PrintLCS(b, x, m, n); return 0;&#125; 省略b数组的方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string.h&gt;#define MAXLEN 50using namespace std;void LCSLength(char *x, char *y, int m, int n, int c[][MAXLEN]) &#123; //m为x串的长度，n为y串的长度，c数组记录最长公共子序列的长度 int i, j; for(i = 0; i &lt;= m; i++) c[i][0] = 0;//初始化数组为0，意思为最长公共子序列长度为0 for(j = 0; j &lt;= n; j++) c[0][j] = 0; for(i = 1; i&lt;= m; i++) &#123;//按照动态规划方程进行递推 for(j = 1; j &lt;= n; j++) &#123; //去到b数组 if(x[i-1] == y[j-1]) &#123; //因为数组从下标为0的地方开始存储，所以用 x[i-1] == y[j-1]来比较 c[i][j] = c[i-1][j-1] + 1;//两个字符相等，那么在原来的最长公共子序列的基础上+1 &#125; else if(c[i-1][j] &gt;= c[i][j-1]) &#123;//否则取 c[i-1][j]和c[i][j-1]的最大值作为c[i][j]的结果 c[i][j] = c[i-1][j]; &#125; else &#123; c[i][j] = c[i][j-1]; &#125; &#125; &#125;&#125;/*void PrintLCS(int c[][MAXLEN], char *x, int i, int j) &#123; //非递归版PrintLCS static char s[MAXLEN]; int k=c[i][j]; s[k]=&#x27;\\0&#x27;; while(k&gt;0)&#123; if(c[i][j]==c[i-1][j]) i--; else if(c[i][j]==c[i][j-1]) j--; else&#123; s[--k]=x[i-1]; i--;j--; &#125; &#125; printf(&quot;%s&quot;,s);&#125;*/void PrintLCS(int c[][MAXLEN], char *x, int i, int j) &#123;//注意c数组中的下标和x中数组的下标有-1的关系 if(i == 0 || j == 0) return; if(c[i][j] == c[i-1][j]) &#123; PrintLCS(c, x, i-1, j); &#125; else if(c[i][j] == c[i][j-1]) PrintLCS(c, x, i, j-1); else &#123; PrintLCS(c, x, i-1, j-1);//走到最开始的地方，向后跑，接着打印最长公共子序列 printf(&quot;%c &quot;,x[i-1]);//只有走斜线的时候才打印，而且打印的时候注意数组中的下标 &#125;&#125;int main() &#123; char x[MAXLEN]; char y[MAXLEN]; //char x[MAXLEN] = &#123;&quot; ACCGGTCGAGTGCGCGGAAGCCGGCCGAA&quot;&#125;; //算法导论上222页的DNA的碱基序列匹配 //char y[MAXLEN] = &#123;&quot; GTCGTTCGGAATGCCGTTGCTCTGTAAA&quot;&#125;; int c[MAXLEN][MAXLEN]; //仅仅使用一个c表 int m, n; cin&gt;&gt;x&gt;&gt;y; m = strlen(x); n = strlen(y); LCSLength(x, y, m, n, c); PrintLCS(c, x, m, n); return 0;&#125; 两个串中所有的最长公共子序列其实很好写的，就是从数组c中跑一遍呗，但是 找出所有路径的思想：仅用“↑” ，“←” ，“↖”是搜索不到所有的 LCS 的，因为C[i- 1,j] ≥C[i,j -1]，我们没有区分 C[i-1,j]&gt;C[i,j-1] 还是 C[i-1,j] ＝C[i,j-1]此时我们只是在单方向搜索， 就像是图的深度优先搜索， 走到底，找出一条路径。为了找出所有的 LCS，我们将 C[i- 1,j] ≥C[i,j -1]记做“←↑”。 三个串的最长公共子序列题意：给出三个字符串，求出三个公共最长子串长度。思路：首先可以确定不同于两个串的公共最长，重复两次。因为C对于A -B 的最长公共子串会造成影响A: abffggB:affggC:aa解法：首先维护b和c的状态，在这基础上对于每一个a串与二者的状态再进行讨论dp进阶之路的大神说：直接把dp[i][j][k]搞成一个字符串……然后状态直接对应方案…… 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cstring&gt;using namespace std;int dp[300][300][300];char a[1000];char b[1000];char c[1000];int main()&#123; memset(dp,0,sizeof(0)); gets(a); gets(b); gets(c); int lena=strlen(a); int lenb=strlen(b); int lenc=strlen(c); for(int i=1;i&lt;=lena;i++) &#123; for(int j=1;j&lt;=lenb;j++) &#123; for(int k=1;k&lt;=lenc;k++) &#123; if(a[i-1]==b[j-1]&amp;&amp;a[i-1]==c[k-1]) &#123; dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-1][k-1]+1); &#125; else dp[i][j][k]=max(max(dp[i-1][j][k],dp[i][j-1][k]),dp[i][j][k-1]); &#125; &#125; &#125; printf(&quot;%d\\n&quot;,dp[lena][lenb][lenc]); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485带输出的方式：#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int dp[300][300][300];char a[1000];char b[1000];char c[1000];int main()&#123; memset(dp,0,sizeof(0)); gets(a); gets(b); gets(c); int lena=strlen(a); int lenb=strlen(b); int lenc=strlen(c); for(int i=1;i&lt;=lena;i++) &#123; for(int j=1;j&lt;=lenb;j++) &#123; for(int k=1;k&lt;=lenc;k++) &#123; if(a[i-1]==b[j-1]&amp;&amp;a[i-1]==c[k-1]) &#123; dp[i][j][k]= dp[i-1][j-1][k-1]+1 ; &#125; else &#123; if(dp[i-1][j][k]&gt;dp[i][j-1][k]&amp;&amp;dp[i-1][j][k]&gt;dp[i][j][k-1]) &#123; dp[i][j][k]=dp[i-1][j][k]; &#125; else if(dp[i][j-1][k]&gt;dp[i-1][j][k]&amp;&amp;dp[i][j-1][k]&gt;dp[i][j][k-1]) &#123; dp[i][j][k]=dp[i][j-1][k]; &#125; else &#123; dp[i][j][k]=dp[i][j][k-1]; &#125; &#125; &#125; &#125; &#125; string s; int i=lena,j=lenb,k=lenc; while(i&gt;=0&amp;&amp;j&gt;=0&amp;&amp;k&gt;=0) &#123; if(dp[i][j][k]==dp[i-1][j-1][k-1]+1) &#123; s.push_back(a[i-1]); i--; j--; k--; &#125; else &#123; if(dp[i][j][k-1]&gt;dp[i][j-1][k]&amp;&amp;dp[i][j][k-1]&gt;dp[i-1][j][k]) &#123;k--; &#125; else if(dp[i-1][j][k]&gt;dp[i][j-1][k]&amp;&amp;dp[i-1][j][k]&gt;dp[i][j][k-1]) &#123; i--; &#125; else j--; &#125; &#125; reverse(s.begin(),s.end()); cout&lt;&lt;s&lt;&lt;endl; printf(&quot;%d\\n&quot;,dp[lena][lenb][lenc]); return 0;&#125; N个串的最长公共子序列 多维数组映射为一维数组的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using std::max;const int MAXF = 1000010;const int MAXN = 110;int n;int base[MAXN], len[MAXN], pos[MAXN];char ans;char f[MAXF];char words[MAXN][MAXN]; void solve()&#123; int idx = 0; for (int i = 0; i &lt; n; i++) &#123; idx += (pos[i] - 1) * base[i]; &#125; bool same = true, has_one = false; for (int i = 1; i &lt; n; i++) &#123; if (words[i][pos[i] - 1] != words[0][pos[0] - 1]) &#123; same = false; break; &#125; if (pos[i] == 1) &#123; has_one = true; &#125; &#125; if (same) &#123; if (has_one) &#123; f[idx] = 1; &#125; else &#123; int p_idx = idx; for (int i = 0; i &lt; n; i++) &#123; p_idx -= base[i]; &#125; f[idx] = f[p_idx] + 1; &#125; &#125; else &#123; for (int i = 0; i &lt; n; i++) &#123; if (pos[i] == 1) continue; f[idx] = max(f[idx], f[idx - base[i]]); &#125; &#125; ans = max(ans, f[idx]);&#125; void dp(int p)&#123; if (p == n) &#123; return solve(); &#125; for (int i = 1; i &lt;= len[p]; i++) &#123; pos[p] = i; dp(p + 1); &#125;&#125; int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%s&quot;, words[i]); len[i] = strlen(words[i]); &#125; base[0] = 1; for (int i = 1; i &lt; n; i++) &#123; base[i] = base[i - 1] * len[i - 1]; &#125; dp(0); printf(&quot;%d\\n&quot;, ans); return 0;&#125; 对于N个子串，找出一个长度最小的串，并分别求出这个最小串的子串，寻找是否剩下的字符串都存在这个子串（子串从大到小找） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; //将第一个字符串与最短的字符串交换void swap(string *pStr,int i)&#123; string temp; temp = *pStr; *pStr = *(pStr + i); *(pStr + i) = temp;&#125; int main()&#123; int N; cout &lt;&lt; &quot;请输入N(控制字符串个数):&quot;; cin &gt;&gt; N; cout &lt;&lt; &quot;请输入&quot; &lt;&lt; N &lt;&lt; &quot;个字符串&quot;&lt;&lt;endl; string *pStr; pStr = new string [N]; int i,min; int maxLen = 1000; //找出输入的字符串中长度最小的串，并把最小串序号记在min中 for(i = 0; i &lt; N; ++i)&#123; cin &gt;&gt; *(pStr + i); int len = (*(pStr +i)).length();// *操作符与调用函数的.操作符优先级问题，.优先级高于*，所以必须加上() if(len &lt; maxLen)&#123; maxLen = len; min = i; &#125; &#125; swap(pStr,min); /* for(i = 0; i &lt; N; ++i) cout &lt;&lt; *(pStr + i) &lt;&lt; endl; */ int len0 = pStr[0].length(); int j,k,maxlen= 0; string maxStr; string tmpStr; for(i = 0; i &lt; len0 &amp;&amp; maxlen &lt;= len0 - i -1; ++i) &#123; for(j = 0; j &lt; len0 &amp;&amp; maxlen &lt;= len0 - i -j - 1; ++j) &#123; tmpStr = pStr[0].substr(i,len0 - j);//对字符串数组中第一个子串，求出其可能的子串值，如果剩余子串长度小于maxlen则不用去求了，for循环中给出了限制 //将子串tmpStr与参与匹配的字符串比较，判断tmpStr是否为剩余串的子串，如果不是则break出循环 for(k = 1; k &lt; N; ++k) &#123; string::size_type pos1 = pStr[k].find(tmpStr); if(pos1 &lt; pStr[k].length()) continue; else break; &#125; if(k == N)//说明子串tmpStr是其他参与匹配的子串的子串 &#123; if(tmpStr.length() &gt; maxlen)//tmpStr如果是当前最大的子串，则记录下来 &#123; maxlen = tmpStr.length(); maxStr = tmpStr; &#125; &#125; &#125; &#125; cout &lt;&lt; &quot;最大公共子串为：&quot;; cout &lt;&lt; maxStr &lt;&lt;endl; delete []pStr; return 0;&#125; 最长公共子串问题两个字符串的最长公共子串我们定义dp[i][j]的含义是：字符串 [a1,a2,…,ai]与字符串[b1,b2,…,bj]的最长公共连续子串的最后一个字符与这个两个字符串的最后一个字符相等的情况下，这个LCS的长度(不好理解)。因此状态转移方程为： 注意观察，A[i]!&#x3D;B[j]的情况下，dp[i][j]也等于0，这是子序列和子串在状态转移方程上的区别。 那么，我们通过两层循环，计算出dp[][]的值，然后找到其中最大的值，就是LCS的长度了。 LCS的长度对应的dp[][]的两个下标为LCS末尾字符分别在字符串A和B中的下标，可以利用这个很容易地找到LCS的具体值，这貌似是最长公共子串比最长公共子序列稍微简单的地方。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std; //dp[i][j]:串(x1,x2,...,xi)与串(y1,y2,...,yj)，//d[i][j]表示这两个串结与最长公共子串结尾相同时，最长公共子串的长度 //状态转移方程如下： //若i=0或j=0，则dp[i][j] = 0//否则：// 若A[i]==B[j]，则dp[i][j] = dp[i-1][j-1] + 1// 若A[i]!=B[j]，则dp[i][j] = 0 //用于打印的函数，后面才用到 void print_substring(string str, int end, int length)&#123; int start = end - length + 1; for(int k=start;k&lt;=end;k++) cout &lt;&lt; str[k]; cout &lt;&lt; endl;&#125; int main()&#123; string A,B; cin &gt;&gt; A &gt;&gt; B; int x = A.length(); int y = B.length(); A = &quot; &quot; + A;//特殊处理一下，便于编程 B = &quot; &quot; + B; //回忆一下dp[][]的含义？ int **dp = new int* [x+1]; int i,j; for(i=0;i&lt;=x;i++) &#123; dp[i] = new int[y+1]; for(j=0;j&lt;=y;j++) dp[i][j] = 0; &#125; //下面计算dp[i][j]的值并记录最大值 int max_length = 0; for(i=1;i&lt;=x;i++) for(j=1;j&lt;=y;j++) if(A[i]==B[j]) &#123; dp[i][j] = dp[i-1][j-1] + 1; if(dp[i][j]&gt;max_length) max_length = dp[i][j]; &#125; else dp[i][j] = 0; //LCS的长度已经知道了，下面是根据这个最大长度和dp[][]的值， //找到对应的 LCS具体子串， 注意：可能有多个 int const arr_length = (x&gt;y?x:y) + 1; int end_A[arr_length]; //记录LCS在字符串A中结束的位置 int num_max_length = 0; //记录LCS的个数 for(i=1;i&lt;=x;i++) for(j=1;j&lt;=y;j++) if(dp[i][j] == max_length) end_A[num_max_length++] = i; cout &lt;&lt; &quot;the length of LCS(substring) is : &quot; &lt;&lt; max_length &lt;&lt; endl &lt;&lt; &quot; nums: &quot; &lt;&lt; num_max_length &lt;&lt; endl &lt;&lt; &quot;they are (it is): &quot; &lt;&lt; endl; for(int k=0;k&lt;num_max_length;k++) //输出每个具体的子串 print_substring(A, end_A[k], max_length); return 0;&#125; 1234567891011121314151617181920另一种巧妙的写法：class LongestSubstring &#123;public: int findLongest(string A, int n, string B, int m) &#123; if(n&lt;=0 || m&lt;=0) return 0; vector&lt;vector&lt;int&gt;&gt; dp(n+1,vector&lt;int&gt;(m+1,0)); int res = 0; //dp【i】【j】 代表的是A[i-1] B[j-1] for(int i=1;i&lt;=n;++i)&#123; for(int j=1;j&lt;=m;++j)&#123; if(A[i-1]==B[j-1])&#123; dp[i][j]=dp[i-1][j-1]+1; res = max(dp[i][j],res); &#125; &#125; &#125; return res; &#125;&#125;; 多个字符串求公共子串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX_LEN = 1004;//Notice, the test data is wrong. //The bound is 1004 but not 1000.const int MAX_STR = 100;struct SubStr &#123; const char* addr; int num;&#125;;char g_str[MAX_STR][MAX_LEN + 1];int g_strCnt;SubStr g_subStr[MAX_STR * MAX_LEN];int g_subStrCnt;int subStrCmp(const void* a, const void* b) &#123; return strcmp(((const SubStr*)a)-&gt;addr, ((const SubStr*)b)-&gt;addr);&#125;int commonLen(const SubStr&amp; a, const SubStr&amp; b) &#123; const char* i = a.addr; const char* j = b.addr; int len = 0; while (*i &amp;&amp; *j &amp;&amp; *i == *j) &#123; len++; i++; j++; &#125; return len;&#125;void printStr(const char* str, int len) &#123; for (int i = 0; i &lt; len; i++) &#123; printf(&quot;%c&quot;, *str); str++; &#125; printf(&quot;\\n&quot;);&#125;void initSubStr() &#123; g_subStrCnt = 0; for (int i = 0; i &lt; g_strCnt; i++) &#123; for (const char* j = g_str[i]; *j; j++) &#123; g_subStr[g_subStrCnt].addr = j; g_subStr[g_subStrCnt].num = i; g_subStrCnt++; &#125; &#125; qsort(g_subStr, g_subStrCnt, sizeof(SubStr), subStrCmp);&#125;int findLongest() &#123; int longest = 0; SubStr* head = g_subStr; SubStr* tail = g_subStr; const SubStr* end = g_subStr + g_subStrCnt; int half = g_strCnt / 2; int coverCnt = 0; int cover[MAX_STR]; memset(cover, 0, sizeof(cover)); while (head != end) &#123; //To find every pair of head and tail, //that in the range [tail, head] there are exactly half + 1 //strings are covered. while (coverCnt &lt;= half &amp;&amp; head != end) &#123; if (cover[head-&gt;num] == 0) &#123; coverCnt++; &#125; cover[head-&gt;num]++; head++; &#125; while (coverCnt &gt; half) &#123; cover[tail-&gt;num]--; if (cover[tail-&gt;num] == 0) &#123; coverCnt--; &#125; tail++; &#125; if (coverCnt == half) &#123; int len = commonLen(*(tail - 1), *(head - 1)); if (len &gt; longest) &#123; longest = len; &#125; &#125; &#125; return longest;&#125;//The work flow of this function is just like &quot;findLongest()&quot;.void printCommon(int longest) &#123; const SubStr* head = g_subStr; const SubStr* tail = g_subStr; const SubStr* pre = NULL; const SubStr* const end = g_subStr + g_subStrCnt; int half = g_strCnt / 2; int coverCnt = 0; int cover[MAX_STR]; memset(cover, 0, sizeof(cover)); while (head != end) &#123; while (coverCnt &lt;= half &amp;&amp; head != end) &#123; if (cover[head-&gt;num] == 0) &#123; coverCnt++; &#125; cover[head-&gt;num]++; head++; &#125; while (coverCnt &gt; half) &#123; cover[tail-&gt;num]--; if (cover[tail-&gt;num] == 0) &#123; coverCnt--; &#125; tail++; &#125; if (coverCnt == half) &#123; int len = commonLen(*(tail - 1), *(head - 1)); if (len == longest &amp;&amp; (pre == NULL || commonLen(*(tail - 1), *pre) &lt; longest ) ) &#123; printStr((tail - 1)-&gt;addr, longest); pre = tail - 1; &#125; &#125; &#125;&#125;bool input() &#123; bool hasNext = false; scanf(&quot;%d&quot;, &amp;g_strCnt); if (g_strCnt &gt; 0) &#123; hasNext = true; for (int i = 0; i &lt; g_strCnt; i++) &#123; scanf(&quot;%s&quot;, g_str[i]); &#125; &#125; return hasNext;&#125;void solve() &#123; initSubStr(); int len = findLongest(); if (len == 0) &#123; printf(&quot;?\\n&quot;); &#125; else &#123; printCommon(len); &#125;&#125;int main() &#123; int cnt = 0; while (input()) &#123; if (cnt &gt; 0) &#123; printf(&quot;\\n&quot;); &#125; solve(); cnt++; &#125; return 0;&#125; 参考参考2","categories":[],"tags":[],"author":"aoyuehan"},{"title":"java的几种对象","slug":"java的几种对象","date":"2020-03-17T04:39:00.000Z","updated":"2022-02-26T03:52:51.840Z","comments":true,"path":"2020/03/17/java的几种对象/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/17/java%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"java中的几种实体类对象(PO,VO,DAO,BO,POJO)一、PO :(persistant object )，持久对象可以看成是与数据库中的表相映射的java对象。使用Hibernate来生成PO是不错的选择。 二、VO :(value object) ，值对象通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要. PO只能用在数据层，VO用在商务逻辑层和表示层。各层操作属于该层自己的数据对象，这样就可以降低各层之间的耦合，便于以后系统的维护和扩展。 三、DAO :(Data Access Objects) ，数据访问对象接口DAO是Data Access Object数据访问接口，数据访问：顾名思义就是与数据库打交道。夹在业务逻辑与数据库资源中间。 J2EE开发人员使用数据访问对象（DAO）设计模式把底层的数据访问逻辑和高层的商务逻辑分开.实现DAO模式能够更加专注于编写数据访问代码. DAO模式是标准的J2EE设计模式之一.开发人员使用这个模式把底层的数据访问操作和上层的商务逻辑分开.一个典型的DAO实现有下列几个组件： 一个DAO工厂类； 一个DAO接口； 一个实现DAO接口的具体类； 数据传递对象（有些时候叫做值对象）. 具体的DAO类包含了从特定的数据源访问数据的逻辑。 四、BO :(Business Object)，业务对象层表示应用程序领域内“事物”的所有实体类。这些实体类驻留在服务器上，并利用服务类来协助完成它们的职责。 五、POJO :(Plain Old Java Objects)，简单的Java对象实际就是普通JavaBeans,使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接.其中有一些属性及其getter、setter方法的类,有时可以作为value object或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。 其他相关问题PO：Persistent Object 持久化对象。持久化对象，在Hibernate经常会遇见这样的概念。Hibernate实体状态有三种状态：瞬时态，持久态，游离态。 1）.瞬时态（暂态）：（Transient）实体在内存中自由存在，它与数据库记录无关。po在DB中无记录（无副本），po和session无关（手工管理同步）。 eg. Customer customer&#x3D;New Customer();customer.setName(“eric”);这里的Customer对象与数据库中的数据没有任何关联。 2）.持久态(Persistent):实体对象处于Hibernate框架的管理之中。 po在DB中有记录，po和session有关（session自动管理同步）。 3).游离态（脱管态）：（Detached）处于Persistent状态的实体对象，其对应的session实例关闭后，那么此时的实体对象处于Detached态。 po在DB中有记录，po和session无关（手工同步管理） 无名态：po处于游离态时被垃圾站回收了（垃圾回收机制），没有正本，只有DB中的副本。 po处于瞬时态时被垃圾站回收了，则死亡。（唯一可以死亡的状态） 实质上，这三种状态是：持久对象的正副本和同步的关系。","categories":[{"name":"java interview","slug":"java-interview","permalink":"https://zouyunkai.github.io/myblog/categories/java-interview/"}],"tags":[],"author":"aoyuehan"},{"title":"java Reflection","slug":"java-反射","date":"2020-03-16T23:16:00.000Z","updated":"2022-02-26T03:52:52.257Z","comments":true,"path":"2020/03/17/java-反射/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/17/java-%E5%8F%8D%E5%B0%84/","excerpt":"","text":"一、什么是反射 反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类的所以属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。 1、 反射机制的功能 Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类。 在运行时构造任意一个类的对象。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法。 生成动态代理。 2、实现反射机制的类JDK中，主要通过一下类实现java反射机 制，这些类抖位于java.lang.reflect包中。 Class：代表一个类 Filed：代表类的成员变量或者说成员属性 Method：代表类的方法 Constructor：代表类的构造方法 Array：提供了动态创建数组，以及访问数组元素的静态方法 1 获取Class对象主要有三种方式 都比较简单: 通过字节码文件获取(比如 类名.class) 对已创建的对象调用 getClass()方法 调用Class类中的静态方法 forName(String className) 第一种通过字节码文件获取Class对象是最简单的方式,但是正因为简单所以指向不明,一般用于当前包中的类 基本数据类型 以及void. 为了知道一个数据的类型,大家之前可能都用过getClass(),这个方法实际上就返回了一个Class对象. 第三种forName方法是最稳健的做法,className不光是类的名字而是一个包含完整包名的字符串,比如”cn.sxt.反射.User” 就像是导入类的写法. 2 获取属性Class类提供了四个获取属性的方法: getDeclaredField(String name) getDeclaredFields() getField(String name) getFields() getDeclaredField(String name)和 getField(String name) 方法返回的是一个Filed对象,需要提供指定属性的名称字符串.而getDeclaredFields() 和getFields() 返回的是所有属性的集合Filed对象数组 Filed[]。 Declared中文意思是声明 。有无Declared的区别在于:没有Declared的两个方法(getField(String name) 和getFields() )返回父类以及本类中public修饰的属性Filed对象而带着Declared的两个方法(getDeclaredField(String name) 和getDeclaredFields() )返回本类中的所有属性而不返回父类中的属性 3 获取方法与获取属性类似,Class提供了4种获取方法 返回的是Method对象或Method[]数组对象： getDeclaredMethod(String name, Class… parameterTypes) getDeclaredMethods() getMethod(String name, Class… parameterTypes) getMethods() getDeclaredMethods() 和getMethods() 返回Method[]数组对象getDeclaredMethod(String name, Class... parameterTypes) 和getMethod(String name, Class… parameterTypes) 返回指定方法名的Method对象 有无Declared的区别与上述类似:没有Declared的两个方法(getMethods()和getMethod() )返回父类以及本类中public修饰的方法Method对象.而带着Declared的两个方法(getDeclaredMethod() 和getDeclaredMethods() )返回本类中所有方法的Method对象而不返回父类中的方法 . 值得注意的是getDeclaredMethod() 和getDeclaredMethods()这次不是返回所有方法（属性中用declare返回public类型的所有属性）,而是指返回公共方法. 方法可以同名重载,所以获取方法中另外Class&lt;?&gt;… parameterTypes就是指定一个或多个形参类型的Class对象,举三个例子:1 一个类中有public void fun()方法,这个类的Class对象为class,为了获取这个fun的Method对象可以调用获取方法:Method m1&#x3D;class.getMethod(“fun”);或Method m1&#x3D;class.getMethod(“fun”,null);或者Method m1&#x3D;class.getMethod(“fun”,new class[]{}); 2 一个类中有public void fun(int num)方法,这个类的Class对象为class,为了获取这个fun的Method对象可以调用获取方法:Method m2&#x3D;class.getMethod(“fun”,int.class);Method m2&#x3D;class.getMethod(“fun”,new class[]{ int.class }); 3 一个类中有public void fun(int num1,int num2,String name)方法,这个类的Class对象为class,为了获取这个fun的Method对象可以调用获取方法:Method m3&#x3D;class.getMethod(“fun”,int.class,int.class,String.class);或者Method m3&#x3D;class.getMethod(“fun”,new class[]{ int.class,int.class,String.class }); 使用: method对象.invoke(调用方法的对象,参数…)值得注意的是通过反射调用静态方法时第一个参数 “调用方法的对象”既可以是类对象也可以是null. 4 获取构造器同样是四种方法: getDeclaredConstructor(Class… parameterTypes) getDeclaredConstructors() getConstructor(Class… parameterTypes) getConstructors() 获取构造器的方法返回的都是本类的构造器.这里有无Declared的区别在于:**有Declared的方法获得的是本类的所有构造器对象数组(包括private).没有Declared的方法获得的是本类中public修饰的构造器对象数组. ** 形参Class&lt;?&gt;… parameterTypes与方法获取的使用方式相同. 几种获取注解方法详解blog1 blog2 相关补充其中class类中除了有获取class类型的方法，获取属性，获取方法，获取构造器的方法外，还包括以下这一个图中的方法。其中可以通过以下方法 创建对象： 123Class&lt;?&gt; classBook = Class.forName(&quot;com.android.peter.reflectdemo.Book&quot;); Object objectBook = classBook.newInstance(); Book book = (Book) objectBook; 属性类、方法类、构造器类中包括的方法： 反射的实例1 下面分步说明以下如何通过反射获取我们需要的内容。 我们先随意写一个Customer类（就是一个PO类），然后看看如何通过反射对这个类进行操作。 1. Customer类 1234567891011121314151617181920212223242526272829303132public class Customer &#123; private Long id; private String name; private int age; public Customer() &#123;&#125; public Customer(String name,int age) &#123; this.name = name; this.age = age; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id=id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name=name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age=age; &#125;&#125; ReflectTester类 这个类用来演示Reflection API的基本使用方法。这里自定义的copy方法是用来创建一个和参数objcet同样类型的对象，然后把object对象中的所有属性拷贝到新建的对象中，并将其返回。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.lang.reflect.Field;import java.lang.reflect.Method;public class ReflectTester &#123; public Object copy(Object object) throws Exception&#123; //获得对象的类型 Class classType=object.getClass(); System.out.println(&quot;Class:&quot;+classType.getName()); //通过默认构造方法创建一个新的对象 Object objectCopy=classType.getConstructor(new Class[]&#123;&#125;).newInstance(new Object[]&#123;&#125;);//通过默认构造方法创建一个新的对象，即先调用Class类的getConstructor()方法获得一个Constructor对象，//它代表默认的构造方法，然后调用Constructor对象的newInstance()方法构造一个实例。 //获得对象的所有属性 Field fields[]=classType.getDeclaredFields(); for(int i=0; i&lt;fields.length;i++)&#123; Field field=fields[i]; String fieldName=field.getName(); String firstLetter=fieldName.substring(0,1).toUpperCase(); //获得和属性对应的getXXX()方法的名字 String getMethodName=&quot;get&quot;+firstLetter+fieldName.substring(1); //获得和属性对应的setXXX()方法的名字 String setMethodName=&quot;set&quot;+firstLetter+fieldName.substring(1); //获得和属性对应的getXXX()方法 Method getMethod=classType.getMethod(getMethodName,new Class[]&#123;&#125;); //获得和属性对应的setXXX()方法 Method setMethod=classType.getMethod(setMethodName,new Class[]&#123;field.getType()&#125;); //getMethod方法中有两个参数，一个为string类型的方法名，另一个是class类型的参数， //这个写的是class数组型参数，&#123;&#125;中间可以有好多个参数 //调用原对象的getXXX()方法 Object value=getMethod.invoke(object,new Object[]&#123;&#125;); System.out.println(fieldName+&quot;:&quot;+value); //调用拷贝对象的setXXX()方法 setMethod.invoke(objectCopy,new Object[]&#123;value&#125;); &#125; return objectCopy; &#125;&#125;然后测试方法：public static void main(String[] args) throws Exception &#123; Customer customer = new Customer(); customer.setId(10L); customer.setName(&quot;adam&quot;); customer.setAge(3); new ReflectTester().copy(customer);&#125; 输出结果，就是执行了copy对象方法之后的输出结果： 反射的实例2创建对象实例我们可以通过两种反射机制的方法来创建对应类的实例 Class对象调用newInstance()通过无参构造器创建对象实例,返回的是Object类型对象(相当于User对象向上自动转型了) Constructor对象调用newInstance(Object… initargs) 通过指定参数构造器创建对象实例,返回的也是Object类型对象 首先新建一个实验用的User类对象 12345678910111213141516171819202122232425262728293031public class User &#123; private int userId; //注意 这个成员变量都是私有的 在之后会用到暴力访问 public String name; private void show() &#123; //注意 show()为私有方法 在之后会用到暴力访问 System.out.println(&quot;私有方法&quot;); &#125; public User(int userId, String name) &#123; this.userId = userId; this.name = name; &#125; public User() &#123; &#125; public int getUserId() &#123; return userId; &#125; public void setuserId(int userId) &#123; this.userId = userId; &#125; public String getName() &#123; return name; &#125; @Override public String toString() &#123; //重写了toString方法 以便打印对象属性 return &quot;User [userId=&quot; + userId+ &quot;, name=&quot; + name + &quot;]&quot;; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 现在用第一种Class对象的方法创建User对象 12345678public class TestUser &#123; public static void main(String[] args) throws InstantiationException, IllegalAccessException &#123; //首先获得User类的Class对象（也可以使用类对象.getClass()方法） Class userClass=User.class; User user1=(User) userClass.newInstance(); //请注意Class类的newInstance返回的是Object类型对象,需要向下强制转换 System.out.println(user1); &#125;&#125; 运行结果为： 接着用第二种Constructor对象的方法创建User对象: 12345678910111213141516public class TestUser &#123; public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException &#123; //首先获得User的Class对象 Class userClass=User.class; //获得Constructor对象 Constructor con1=userClass.getConstructor(); //con1指向无参数构造器对象 Constructor con2=userClass.getConstructor(int.class,String.class); //con2指向两个参数的构造器对象 //开始创建对象 User u1=(User)con1.newInstance(); //需要向下强制转型 User u2=(User)con2.newInstance(20,&quot;朱同学&quot;); //需要向下强制转型 //上面这个地方如果添加参数也可以写为(因为方法参数为obj类型 //User u2=(User)con2.newInstance(new Object[]&#123; 20,&quot;朱同学&quot; &#125;); System.out.println(&quot;u1:&quot;+u1+&quot;\\nu2:&quot;+u2); &#125;&#125; 运行结果为： 执行方法首先要获得Method对象,对其调用invoke(Object obj,Object… args)方法执行你获得的Method对象对应的方法,第一个参数为调用方法的对象,之后的参数为提供给方法的实参,执行私有方法前,必须设置可以访问为真,不然抛出IllegalAccessException异常. 123456789101112131415161718public class TestUser &#123; public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException &#123; //首先获得User的Class对象,并创造User Class userClass=User.class; User user=(User) userClass.newInstance(); //获得Method对象 Method m1=userClass.getMethod(&quot;setUserId&quot;,int.class); Method m2=userClass.getDeclaredMethod(&quot;show&quot;,null); m2.setAccessible(true); //因为前面show方法为private类型 //执行私有方法前,必须设置可以访问为真,不然抛出IllegalAccessException异常 //使用invoke()开始调用方法 m1.invoke(user, 40); //第一个参数为调用方法的对象,之后的参数为提供给方法的实参 m2.invoke(user); //对于无参方法可以省略后面的部分 System.out.println(user); &#125;&#125; 运行结果为： 更改属性首先获得Field对象,对其调用set(Object obj, Object value) 方法设置新的值,第一个参数为设置属性的对象,第二个参数为设置的值,设置私有属性前,必须设置可以访问为真,不然抛出IllegalAccessException异常.值得一提的是可以通过反射机制修改final修饰的私有属性,前提是编译器没有对其进行内联优化,即声明变量时没有在同一语句为其赋值. 123456789101112131415public class TestUser &#123; public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException &#123; //首先获得User的Class对象,并创造User Class userClass=User.class; User user=(User) userClass.newInstance(); //获得Field对象 Field f1=userClass.getDeclaredField(&quot;userId&quot;); Field f2=userClass.getDeclaredField(&quot;name&quot;); f1.setAccessible(true); //设置私有属性前,必须设置可以访问为真,不然抛出IllegalAccessException异常 //开始设置属性 f1.set(user, 40); //第一个参数为设置属性的对象,第二个参数为设置的值 f2.set(user,&quot;朱同学&quot;); //类型不匹配会抛出IllegalArgumentException异常 System.out.println(user); &#125;&#125; 运行结果为： 实例操作3下面我们尝试着通过反射机制对一个jar包中的类进行分析，把类中所有的属性和方法提取出来，并写入到一个文件里中。 目录结构如下： ReflexDemo类 主要代码部分，通过反射获取类、属性及方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.io.File;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.net.URL;import java.net.URLClassLoader;import java.util.Enumeration;import java.util.jar.JarEntry;import java.util.jar.JarFile;/** * @ClassName: ReflexDemo * @Description: 通过反射获取类、属性及方法 * @author adamjwh * @date 2018年5月28日 * */public class ReflexDemo &#123; private static StringBuffer sBuffer; public static void getJar(String jar) throws Exception &#123; try &#123; File file = new File(jar); URL url = file.toURI().toURL(); URLClassLoader classLoader = new URLClassLoader(new URL[] &#123; url &#125;, Thread.currentThread().getContextClassLoader()); JarFile jarFile = new JarFile(jar); Enumeration&lt;JarEntry&gt; enumeration = jarFile.entries(); JarEntry jarEntry; sBuffer = new StringBuffer(); //存数据 while (enumeration.hasMoreElements()) &#123; jarEntry = enumeration.nextElement(); if (jarEntry.getName().indexOf(&quot;META-INF&quot;) &lt; 0) &#123; String classFullName = jarEntry.getName(); if (classFullName.indexOf(&quot;.class&quot;) &lt; 0) &#123; classFullName = classFullName.substring(0, classFullName.length() - 1); &#125; else &#123; // 去除后缀.class，获得类名 String className = classFullName.substring(0, classFullName.length() - 6).replace(&quot;/&quot;, &quot;.&quot;); Class&lt;?&gt; myClass = classLoader.loadClass(className); sBuffer.append(&quot;类名\\t：&quot; + className); System.out.println(&quot;类名\\t：&quot; + className); // 获得属性名 Class&lt;?&gt; clazz = Class.forName(className); Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) &#123; sBuffer.append(&quot;属性名\\t：&quot; + field.getName() + &quot;\\n&quot;); System.out.println(&quot;属性名\\t：&quot; + field.getName()); sBuffer.append(&quot;-属性类型\\t：&quot; + field.getType() + &quot;\\n&quot;); System.out.println(&quot;-属性类型\\t：&quot; + field.getType()); &#125; // 获得方法名 Method[] methods = myClass.getMethods(); for (Method method : methods) &#123; if (method.toString().indexOf(className) &gt; 0) &#123; sBuffer.append(&quot;方法名\\t：&quot; + method.toString().substring(method.toString().indexOf(className)) + &quot;\\n&quot;); System.out.println(&quot;方法名\\t：&quot; + method.toString().substring(method.toString().indexOf(className))); &#125; &#125; sBuffer.append(&quot;--------------------------------------------------------------------------------&quot; + &quot;\\n&quot;); System.out.println(&quot;--------------------------------------------------------------------------------&quot;); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sBuffer.append(&quot;End&quot;); System.out.println(&quot;End&quot;); WriteFile.write(sBuffer); //写文件 &#125; &#125;&#125; WriteFile类 进行写文件操作。 123456789101112131415161718192021222324import java.io.BufferedWriter;import java.io.File;import java.io.FileWriter;/** * @ClassName: WriteFile * @Description: 写文件操作 * @author adamjwh * @date 2018年5月28日 * */public class WriteFile &#123; private static String pathname = &quot;src/com/adamjwh/jnp/ex14/out.txt&quot;; public static void write(StringBuffer sBuffer) throws Exception &#123; File file = new File(pathname); BufferedWriter bw = new BufferedWriter(new FileWriter(file)); bw.write(sBuffer.toString()); bw.close(); &#125; &#125; Main类 这里我们需要在项目下新建一个lib文件夹，然后将要解析的jar包放入其中，比如这里我们放入jdk的dt.jar。目录结构如下： 1234567891011121314151617/** * @ClassName: Main * @Description: * @author adamjwh * @date 2018年5月28日 * */public class Main &#123; private static String jar = &quot;lib/dt.jar&quot;; public static void main(String[] args) throws Exception &#123; ReflexDemo.getJar(jar); &#125;&#125; 运行结果为：","categories":[{"name":"java interview","slug":"java-interview","permalink":"https://zouyunkai.github.io/myblog/categories/java-interview/"}],"tags":[],"author":"aoyuehan"},{"title":"Java中Comparable和Comparator接口的区别","slug":"Java中Comparable和Comparator接口的区别","date":"2020-03-16T11:38:00.000Z","updated":"2022-02-26T03:52:51.924Z","comments":true,"path":"2020/03/16/Java中Comparable和Comparator接口的区别/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/16/Java%E4%B8%ADComparable%E5%92%8CComparator%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Java中Comparable和Comparator接口的区别java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明已经存在的对象小于，等于，大于输入对象。Java提供了包含compare()和equals()两个方法的Comparator接口。 compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。 equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。 一个小的总结Comparable &amp; Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。 Comparator位于包java.util下，而Comparable位于包 java.lang下 Comparable 是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer 自己就可以完成比较大小操作，已经实现了Comparable接口） 自定义的类要在加入list容器中后能够排序，可以实现Comparable接口，在用Collections类的sort方法排序时，如果不指定Comparator，那么就以自然顺序排序， 这里的自然顺序就是实现Comparable接口设定的排序方式。 而 Comparator 是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。 可以说一个是自已完成比较，一个是外部程序实现比较的差别而已。 用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。 比如：你想对整数采用绝对值大小来排序，Integer 是不符合要求的，你不需要去修改 Integer 类（实际上你也不能这么做）去改变它的排序行为，只要使用一个实现了 Comparator 接口的对象来实现控制它的排序就行了。 两种方式，各有各的特点：使用Comparable方式比较时，我们将比较的规则写入了比较的类型中，其特点是高内聚。但如果哪天这个规则需要修改，那么我们必须修改这个类型的源代码。如果使用Comparator方式比较，那么我们不需要修改比较的类，其特点是易维护，但需要自定义一个比较器，后续比较规则的修改，仅仅是改这个比较器中的代码即可。 Comparable 简介Comparable 是排序接口。若一个类实现了Comparable接口，就意味着“该类支持排序”。此外，“实现Comparable接口的类的对象”可以用作“有序映射(如TreeMap)”中的键或“有序集合(TreeSet)”中的元素，而不需要指定比较器。接口中通过x.compareTo(y)来比较x和y的大小。若返回负数，意味着x比y小；返回零，意味着x等于y；返回正数，意味着x大于y。 Comparator 简介Comparator 是比较器接口。我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)；那么，我们可以建立一个“该类的比较器”来进行排序。这个“比较器”只需要实现Comparator接口即可。也就是说，我们可以通过“实现Comparator类来新建一个比较器”，然后通过该比较器对类进行排序。int compare(T o1, T o2)和上面的x.compareTo(y)类似，定义排序规则后返回正数，零和负数分别代表大于，等于和小于。 讲解Comparable简介 Comparable是排序接口。若一个类实现了Comparable接口，就意味着该类支持排序。实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。 此外，实现此接口的对象可以用作有序映射中的键或有序集合中的集合，无需指定比较器。 12345678package java.lang;import java.util.*;public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; T表示可以与此对象进行比较的那些对象的类型。 此接口只有一个方法compare，比较此对象与指定对象的顺序，如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 现在我们假设一个Person类，代码如下： 12345678910111213141516171819public class Person&#123; String name; int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125;&#125; 现在有两个Person类的对象，我们如何来比较二者的大小呢？我们可以通过让Person实现Comparable接口： 123456789101112131415161718192021222324252627282930313233343536373839public class Person implements Comparable&lt;Person&gt;&#123; String name; int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; @Override public int compareTo(Person p) &#123; return this.age-p.getAge(); &#125; public static void main(String[] args) &#123; Person[] people=new Person[]&#123;new Person(&quot;xujian&quot;, 20),new Person(&quot;xiewei&quot;, 10)&#125;; System.out.println(&quot;排序前&quot;); for (Person person : people) &#123; System.out.print(person.getName()+&quot;:&quot;+person.getAge()); &#125; Arrays.sort(people); System.out.println(&quot;\\n排序后&quot;); for (Person person : people) &#123; System.out.print(person.getName()+&quot;:&quot;+person.getAge()); &#125; &#125;&#125; Comparator简介 Comparator是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现Comparator接口即可。也就是说，我们可以通过实现Comparator来新建一个比较器，然后通过这个比较器对类进行排序。该接口定义如下： 1234567package java.util;public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2); boolean equals(Object obj); &#125; 注意：1、若一个类要实现Comparator接口：它一定要实现compare(T o1, T o2) 函数，但可以不实现 equals(Object obj) 函数。 2、int compare(T o1, T o2) 是“比较o1和o2的大小”。返回“负数”，意味着“o1比o2小”；返回“零”，意味着“o1等于o2”；返回“正数”，意味着“o1大于o2”。 现在假如上面的Person类没有实现Comparable接口，该如何比较大小呢？我们可以新建一个类，让其实现Comparator接口，从而构造一个“比较器”。 12345678public class PersonCompartor implements Comparator&lt;Person&gt;&#123; @Override public int compare(Person o1, Person o2) &#123; return o1.getAge()-o2.getAge(); &#125;&#125; 现在我们就可以利用这个比较器来对其进行排序： 12345678910111213141516171819202122232425262728293031323334public class Person&#123; String name; int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public int getAge() &#123; return age; &#125; public static void main(String[] args) &#123; Person[] people=new Person[]&#123;new Person(&quot;xujian&quot;, 20),new Person(&quot;xiewei&quot;, 10)&#125;; System.out.println(&quot;排序前&quot;); for (Person person : people) &#123; System.out.print(person.getName()+&quot;:&quot;+person.getAge()); &#125; Arrays.sort(people,new PersonCompartor()); System.out.println(&quot;\\n排序后&quot;); for (Person person : people) &#123; System.out.print(person.getName()+&quot;:&quot;+person.getAge()); &#125; &#125;&#125; Comparable和Comparator区别比较 Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。 Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。 两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。","categories":[{"name":"java interview","slug":"java-interview","permalink":"https://zouyunkai.github.io/myblog/categories/java-interview/"}],"tags":[{"name":"comparable and comparator","slug":"comparable-and-comparator","permalink":"https://zouyunkai.github.io/myblog/tags/comparable-and-comparator/"}],"author":"aoyuehan"},{"title":"蓝桥校赛2020_2","slug":"蓝桥校赛2020-2","date":"2020-03-15T06:25:00.000Z","updated":"2022-02-26T03:52:52.274Z","comments":true,"path":"2020/03/15/蓝桥校赛2020-2/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/15/%E8%93%9D%E6%A1%A5%E6%A0%A1%E8%B5%9B2020-2/","excerpt":"","text":"真题题目集连接校赛题目集连接 1200000中的约数的个数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;using namespace std;int main()&#123; int count=0; for (int i = 1; i &lt;=1200000; i++) &#123; if(1200000%i==0)&#123; count++; &#125; &#125; cout&lt;&lt;count;&#125;方法二：指数分解求约数的个数#include&lt;stdio.h&gt;#include&lt;string.h&gt;int zy[1000];int a[1000];int k;void zhi(int n)//存储n的质因数&#123; int i; for(i=2; i*i&lt;=n; i++) &#123; if(n%i==0) zy[k++]=i; while(n%i==0) n/=i; &#125; if(n&gt;1) zy[k++]=n;&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n) &#123; memset(a,0,sizeof(a)); memset(zy,0,sizeof(zy)); k=0; zhi(n); int i,j; int sum=1; for(i=0;i&lt;k;i++) &#123; int sun=0;//记录每个质因数的个数 while(n%zy[i]==0) &#123; sun++; n/=zy[i]; &#125; sum*=(sun+1);//将他们相乘 &#125; printf(&quot;%d\\n&quot;,sum); &#125; return 0;&#125; 1~2019中包包含数字9的数字的个数问题描述在1至2019中，有多少个数的数位中包括数字9？注意，有的数中的数位中包含多个9，这个数只算一次。例如，1999这个数包含三个数位9，但在计算时只算做一个数。题解枚举从1到2019中的每个数字，并检查其任一数位中是否是9，同时维护一个变量来统计个数即可。 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2019;int check(int i)&#123; while(i) &#123; if(i % 10 == 9) return 1; i /= 10; &#125; return 0;&#125;int main()&#123; int ans = 0; for(int i = 1; i &lt;= maxn; i++) if(check(i)) ans++; printf(&quot;%d&quot;, ans); return 0;&#125; 求一个十进制数的二进制表示123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;void printBinary(int arg)&#123; for (int i=31;i&gt;=0;i--)//高位到低位输出 &#123; int a; a=1&amp;arg&gt;&gt;i; cout&lt;&lt;a; if (i%8==0 &amp;&amp; i!=0) &#123; cout&lt;&lt;&quot;,&quot;; &#125; &#125; cout&lt;&lt;endl;&#125;int main()&#123; int arg; cin&gt;&gt;arg; printBinary(arg);&#125; 求递增三元组的中心问题描述 在数列 a[1], a[2], …, a[n] 中，如果对于下标 i, j, k 满足 0&lt;i&lt;j&lt;k&lt;n+1 且 a[i]&lt;a[j]&lt;a[k]，则称 a[i], a[j], a[k] 为一组递增三元组，a[j]为递增三元组的中心。 给定一个数列，请问数列中有多少个元素可能是递增三元组的中心。输入格式 输入的第一行包含一个整数 n。 第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。输出格式 输出一行包含一个整数，表示答案。样例输入51 2 5 3 5样例输出2样例说明 a[2] 和 a[4] 可能是三元组的中心。评测用例规模与约定 对于 50% 的评测用例，2 &lt;&#x3D; n &lt;&#x3D; 100，0 &lt;&#x3D; 数列中的数 &lt;&#x3D; 1000。 对于所有评测用例，2 &lt;&#x3D; n &lt;&#x3D; 1000，0 &lt;&#x3D; 数列中的数 &lt;&#x3D; 10000。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 本来以为把两边的一去，剩下的中间的个数就是答案，后来一想这个要求下标是有顺序的 就前面维护一个最小值，然后后面看看能找到比这个数大的嘛，跑一遍 #include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int tmp,ans=0; vector&lt;int&gt;v; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;tmp; v.push_back(tmp); &#125;// for(int i=0;i&lt;n;i++)cout&lt;&lt;v[i]&lt;&lt; &#x27; &#x27;; int min=v[0],xiabiao; for(int i=1;i&lt;n-1;i++)&#123; xiabiao=lower_bound(v.begin()+i+1,v.end(),v[i])-v.begin(); cout&lt;&lt;&quot;xiabiao;&quot;&lt;&lt;xiabiao&lt;&lt; &quot; min:&quot;&lt;&lt;min&lt;&lt;&quot; cishide i:&quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;v[i]&lt;&lt;&quot; ans:&quot;&lt;&lt;ans&lt;&lt;endl; if(v[i]&lt;v[xiabiao]&amp;&amp;v[i]&gt;min)ans++; if(v[i]&lt;min)min=v[i]; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;后来发现，这个lower_bound是二分求大于等于要找的数的一个位置，没有返回数组下标+1，这个要求数组是有序的才可以。 最后暴力解决：#include&lt;iostream&gt;using namespace std;const int N=1000;int main()&#123; int a[N],n,i,sum=0,j,k; cin&gt;&gt;n; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; &#125; for(i=0;i&lt;n-2;i++) &#123;//枚举下标i for(j=i+1;j&lt;n-1;j++) &#123;//枚举下标j for(k=j+1;k&lt;n;k++) &#123;//枚举下标k if(a[i]&lt;a[j] &amp;&amp; a[j]&lt;a[k]) &#123; sum++; a[j]=0; break; &#125; &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; 单调栈问题描述 给定一个序列 a_1, a_2, …, a_n。其中 a_1 是最大的数，没有其他数与 a_1 相等。 对于从第二个数开始的每个数 a_i，请找到位置在 a_i 之前且比 a_i 大的，位置上距离 a_i 最近的数 a_j。称 i-j 为 a_i 的前向距离。 对于给定的序列，请求出所有数的前向距离之和。输入格式 输入的第一行包含一个整数 n，表示序列的长度。 第二行包含 n 个正整数，为给定的序列。输出格式 输出一个整数，表示序列中所有数的前向距离之和。样例输入89 1 3 5 2 7 6 3样例输出14样例说明 序列中从第二项开始的前向距离依次为： 1, 2, 3, 1, 5, 1, 1 和为14。数据规模和约定 对于70%的评测用例，1 &lt;&#x3D; n &lt;&#x3D; 1000； 对于所有评测用例，1 &lt;&#x3D; n &lt;&#x3D; 100000，a_1 &lt;&#x3D; 1000000。 请注意答案可能很大，可能需要使用 long long 来保存。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt; #include &lt;iomanip&gt; #include &lt;stack&gt;using namespace std;typedef long long int ll; struct point&#123; ll a; ll g;&#125; p[100005];int main()&#123; stack&lt;ll&gt; s;//单调递减栈 下面大，上面小 ll n,d[100005],ans=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;p[i].a; d[p[i].a]=i; p[i].g=1; if(s.empty()||p[i].a&lt;s.top()) &#123;//栈空或者要加入的元素小于栈顶时入栈 s.push(p[i].a); &#125; while(p[i].a&gt;s.top()) &#123;//把栈顶中的数取出来，加上贡献 p[i].g+=p[d[s.top()]].g; s.pop(); &#125; if(p[i].a&lt;s.top()) s.push(p[i].a); //把这个元素加入到栈中，因为这一个元素的g不是1了， //比如本题中为2，所以当把该元素出栈的话，贡献变为p[i].g 为2； ans+=p[i].g; &#125; cout&lt;&lt;ans-1; return 0;&#125; dfs+回溯问题描述 小明和朋友们一起去郊外植树，他们带了一些在自己实验室精心研究出的小树苗。 小明和朋友们一共有 n 个人，他们经过精心挑选，在一块空地上每个人挑选了一个适合植树的位置，总共 n 个。他们准备把自己带的树苗都植下去。 然而，他们遇到了一个困难：有的树苗比较大，而有的位置挨太近，导致两棵树植下去后会撞在一起。 他们将树看成一个圆，圆心在他们找的位置上。如果两棵树对应的圆相交，这两棵树就不适合同时植下（相切不受影响），称为两棵树冲突。 小明和朋友们决定先合计合计，只将其中的一部分树植下去，保证没有互相冲突的树。他们同时希望这些树所能覆盖的面积和（圆面积和）最大。输入格式 输入的第一行包含一个整数 n ，表示人数，即准备植树的位置数。 接下来 n 行，每行三个整数 x, y, r，表示一棵树在空地上的横、纵坐标和半径。输出格式 输出一行包含一个整数，表示在不冲突下可以植树的面积和。由于每棵树的面积都是圆周率的整数倍，请输出答案除以圆周率后的值（应当是一个整数）。样例输入61 1 21 4 21 7 24 1 24 4 24 7 2样例输出12评测用例规模与约定 对于 30% 的评测用例，1 &lt;&#x3D; n &lt;&#x3D; 10； 对于 60% 的评测用例，1 &lt;&#x3D; n &lt;&#x3D; 20； 对于所有评测用例，1 &lt;&#x3D; n &lt;&#x3D; 30，0 &lt;&#x3D; x, y &lt;&#x3D; 1000，1 &lt;&#x3D; r &lt;&#x3D; 1000。 1 模拟正整数序列的数量问题描述 小明想知道，满足以下条件的正整数序列的数量： 1. 第一项为 n； 2. 第二项不超过 n； 3. 从第三项开始，每一项小于前两项的差的绝对值。 请计算，对于给定的 n，有多少种满足条件的序列。输入格式 输入一行包含一个整数 n。输出格式 输出一个整数，表示答案。答案可能很大，请输出答案除以10000的余数。样例输入4样例输出7样例说明 以下是满足条件的序列： 4 1 4 1 1 4 1 2 4 2 4 2 1 4 3 4 4评测用例规模与约定 对于 20% 的评测用例，1 &lt;&#x3D; n &lt;&#x3D; 5； 对于 50% 的评测用例，1 &lt;&#x3D; n &lt;&#x3D; 10； 对于 80% 的评测用例，1 &lt;&#x3D; n &lt;&#x3D; 100； 对于所有评测用例，1 &lt;&#x3D; n &lt;&#x3D; 1000。 123456789101112131415161718192021222324252627282930313233343536373839package 第十三次模拟;import java.util.Scanner;public class Demo8序列 &#123; public static int n=0,count=0; public static int [] []map ; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n =sc.nextInt(); sc.close(); map = new int [n+1][n+1]; for (int i = 1; i &lt;=n; i++) &#123; map[i][i]=1; map[i][0]=1; map[0][i]=1; &#125; for (int i = 1; i &lt;=n; i++) &#123; count+=f(n,i); count%=10000;// System.out.println(count); &#125; System.out.println(count);// System.out.println(f(4,2)); &#125; public static int f(int x,int y)&#123; if(map[x][y]!=0)&#123; return map[x][y]; &#125; for (int i = Math.abs(x-y)-1; i&gt;=0; i--) &#123; map[x][y]+=f(y,i); &#125; map[x][y]%=10000; map[y][x]=map[x][y]; return map[x][y]; &#125;&#125; 模拟递增数的个数问题描述 一个正整数如果任何一个数位不大于右边相邻的数位，则称为一个数位递增的数，例如1135是一个数位递增的数，而1024不是一个数位递增的数。 给定正整数 n，请问在整数 1 至 n 中有多少个数位递增的数？输入格式 输入的第一行包含一个整数 n。输出格式 输出一行包含一个整数，表示答案。样例输入30样例输出26评测用例规模与约定 对于 40% 的评测用例，1 &lt;&#x3D; n &lt;&#x3D; 1000。 对于 80% 的评测用例，1 &lt;&#x3D; n &lt;&#x3D; 100000。 对于所有评测用例，1 &lt;&#x3D; n &lt;&#x3D; 1000000。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475方法一：#include&lt;iostream&gt;using namespace std;int n;int count; void f(int num,int temp)&#123;//num这一位的下一位可以从temp往后填数 if(num&gt;n)&#123;//这地方不能等于，因为等于的话结果得算上， //若这地方写等于，下面就不能count++了 return;//num&gt;n是跳到上一层 &#125;else&#123; count++; &#125; for(int i=temp;i&lt;10;i++)&#123; f(num*10+i,i); &#125;&#125;int main()&#123; cin&gt;&gt;n; f(0,1); cout&lt;&lt;count-1&lt;&lt;endl;//这地方-1 是为了把0减去，因为求的是0~n &#125;方法二：递推#include&lt;iostream&gt;using namespace std;long long a[1000010];int main()&#123; long long n; a[0]=0; for(int i=1;i&lt;10;i++)a[i]=a[i-1]+1; for(long long i=10;i&lt;=1000000;i++)&#123; long long item=i; int f=0; long long pre=item%10; int t; //t为高一位数，pre低一位的数 item/=10; while(item)&#123; t=item%10; item/=10; if(t&gt;pre)&#123;//如果t&gt;pre 那么该数就是不满足的 f=1; break; &#125; else pre=t; &#125; if(f==0)&#123; a[i]=a[i-1]+1; &#125; else a[i]=a[i-1]; &#125; cin&gt;&gt;n; cout&lt;&lt;a[n]; return 0;&#125;方法三： public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); String string = &quot;&quot;; // 定义一个字符空串 int ans = 0; // 统计值 for (int i = 1; i &lt;= n; i++) &#123; char[] a = (i + &quot;&quot;).toCharArray(); // i+&quot;&quot; int强转字符类型 Arrays.sort(a); // 排序 for (int j = 0; j &lt; a.length; j++) &#123; string += a[j]; // 字符串拼接 &#125; if (Integer.parseInt(string)==i) &#123; // 强转int类型，=i说明数字一样，否则不做统计 ans++; &#125; string = &quot;&quot;; // 初始化 &#125; System.out.println(ans); &#125; 递增序列长度递增序列问题描述在数列 a[1], a[2], …, a[n] 中，如果 a[i] &lt; a[i+1] &lt; a[i+2] &lt; … &lt; a[j]，则称 a[i] 至 a[j] 为一段递增序列，长度为 j-i+1。给定一个数列，请问数列中最长的递增序列有多长。输入格式输入的第一行包含一个整数 n。第二行包含 n 个整数 a[1], a[2], …, a[n]，相邻的整数间用空格分隔，表示给定的数列。输出格式输出一行包含一个整数，表示答案。样例输入75 2 4 1 3 7 2样例输出3评测用例规模与约定对于 50% 的评测用例，2 &lt;&#x3D; n &lt;&#x3D; 100，0 &lt;&#x3D; 数列中的数 &lt;&#x3D; 1000。对于所有评测用例，2 &lt;&#x3D; n &lt;&#x3D; 1000，0 &lt;&#x3D; 数列中的数 &lt;&#x3D; 10000。题解设定一个计数器并初始化为1，遍历序列，比较当前元素与下一个元素 若当前元素小于下一元素，则计数器加1，继续遍历。 若当前元素大于等于下一元素，则子序列不满足递增，使用当前计数器的值去维护答案，将计数器重置为1。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1004;int a[maxn];int main()&#123; int n; cin&gt;&gt;n; int ans = 0, temp = 0; for(int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 0; i &lt; n; i++) &#123; if(a[i+1] &lt;= a[i]) &#123; if(temp &gt; ans) ans = temp; temp = 1; &#125; else temp++; &#125; printf(&quot;%d&quot;, ans); return 0;&#125; 元音字母判断就是一个串，分为四段如lanqiao，第一段为辅音，第二段为元音，第三段为辅音，第四段为元音，符合这样的要求就输出yes，否则no。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt; #include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; set&lt;char&gt;f;set&lt;char&gt;y; for(int i=&#x27;a&#x27;;i&lt;=&#x27;z&#x27;;i++) &#123; if(i==&#x27;a&#x27;||i==&#x27;e&#x27;||i==&#x27;i&#x27;||i==&#x27;o&#x27;||i==&#x27;u&#x27;) &#123; y.insert(i); &#125; else &#123; f.insert(i); &#125; &#125; string s; cin&gt;&gt;s;int p=0;int aa=0,bb=0,cc=0,dd=0; while(f.find(s[p])!=f.end()) &#123; aa=1; p++; &#125; while(y.find(s[p])!=y.end()) &#123; bb=1; p++; &#125; while(f.find(s[p])!=f.end()) &#123; cc=1; p++; &#125; while(y.find(s[p])!=y.end()) &#123; dd=1; p++; &#125; if(p==s.length()&amp;&amp;aa==1&amp;&amp;bb==1&amp;&amp;cc==1&amp;&amp;dd==1)cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; return 0;&#125;","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[],"author":"aoyuehan"},{"title":"asp实验四","slug":"asp实验四","date":"2020-03-14T12:38:00.000Z","updated":"2022-02-26T03:52:52.279Z","comments":true,"path":"2020/03/14/asp实验四/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/14/asp%E5%AE%9E%E9%AA%8C%E5%9B%9B/","excerpt":"","text":"实验项目名称 文件上传 一、实验内容1、 文件上传控件学习。理解文件上传流程，会使用上传控件把文件上传到服务器端，并在web.config中设置限制变量，并了解web.config的作用。2、 思考问题：同一文件多次上传会出现什么情况，例如多个用户登录并上传同一文件，如何解决？多个文件一起上传如何解决？web版本多文件上传 二、实验方法与步骤1、 web.config中设置限制变量代码为： 123456789101112131415&lt;configuration&gt; &lt;appSettings&gt; &lt;!--这里来设置上传文件的最大字节数 单位为kb--&gt; &lt;add key=&quot;PhysicsObjectLength&quot; value=&quot;3072&quot;/&gt; &lt;/appSettings&gt; &lt;system.web&gt; &lt;compilation debug=&quot;true&quot; targetFramework=&quot;4.7.2&quot;/&gt; &lt;!--这是设置 请求的 最大请求长度（默认4096kb）--&gt; &lt;httpRuntime targetFramework=&quot;4.7.2&quot; maxRequestLength=&quot;4096&quot;/&gt; &lt;/system.web&gt; &lt;/configuration&gt; 2、 编写代码实现文件上传按照此步骤编写 上传文件的按钮事件代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546protected void Button1_Click(object sender, EventArgs e) &#123; //1、判断文件是够存在 if (!this.FileUpload1.HasFile) return; //获取文件的大小，判断是否符合要求 double fileLength = this.FileUpload1.FileContent.Length / (1024.0 * 1024.0);//变成多少M //2、获取配置文件中上传文件大小的限制 double LimitedLength = Convert.ToDouble(System.Configuration. ConfigurationManager.AppSettings[&quot;PhysicsObjectLength&quot;]); LimitedLength = LimitedLength / 1024.0;//转换成mb //判断文件大小是否符合要求 if (fileLength &gt; LimitedLength) &#123; this.Literal1.Text = &quot;上传文件大小不能超过&quot; + LimitedLength + &quot;MB&quot;; this.Literal1.Text = &quot;&lt;script type=&#x27;text/javascript&#x27;&gt;alert(&#x27;上传文件大小不能超过&quot; + LimitedLength + &quot;MB&#x27;)&lt;/script&gt;&quot;; return; &#125; //3、获取文件名，判断文件扩展名是否符合要求 string fileName = this.FileUpload1.FileName; //判断文件是否为exe文件 if (fileName.Substring(fileName.LastIndexOf(&quot;.&quot;)).ToLower() == &quot;.exe&quot;) &#123; this.Literal1.Text = &quot;&lt;script type=&#x27;text/javascript&#x27;&gt;alert(&#x27;上传文件不能是exe文件 &#x27;)&lt;/script&gt;&quot;; return; &#125; //修改文件名 fileName = DateTime.Now.ToString(&quot;yyyyMMddhhssms&quot;) + &quot;_&quot; + fileName; //4、获取服务器文件夹路径 string path = Server.MapPath(&quot;~/UploadFiles&quot;); //5、上传文件 附件的大小 同一套程序不同用户 上传到同一个文件夹内如何解决重复问题；多附件同时上传；多线程来解决资源占用问题 try &#123; this.FileUpload1.SaveAs(path + &quot;/&quot; + fileName); this.Literal1.Text = &quot;&lt;script type=&#x27;text/javascript&#x27;&gt;alert(&#x27;文件长传成功 &#x27;)&lt;/script&gt;&quot;; &#125; catch (Exception ex) &#123; this.Literal1.Text = &quot;&lt;script type=&#x27;text/javascript&#x27;&gt;alert(&#x27;文件长传失败 &quot;+ex.Message+&quot;&#x27;)&lt;/script&gt;&quot;; &#125; &#125; 效果： 三、实验心得与体会1、在webconfig文件中设置 httpRuntime节点中的 maxRequestLength属性时，我自己独自开了一个httpRuntime节点添加进去了，后来发现在webconfig文件中这个httpRuntime节点只能出现一次，后来把两个属性都加在一个httpRuntime节点中就好了。2、 同一文件多次上传会出现什么情况，例如多个用户登录并上传同一文件，如何解决？同一文件多次上传会覆盖原来同名的文件，解决办法就是在上传的文件名上加上上传的时间，这样就不会出现上传文件名覆盖的问题了。 3、 要记住上传文件的这几步方法，然后再实际的应用中可以以此为基础拓展出更加快捷 简洁的文件上传实例。4、 可以在服务器上向Literal1.Text中写入脚本的方式来让浏览器实现一些效果，这是比较实用的。","categories":[{"name":"asp","slug":"asp","permalink":"https://zouyunkai.github.io/myblog/categories/asp/"}],"tags":[],"author":"aoyuehan"},{"title":"java 拷贝问题","slug":"java-拷贝问题","date":"2020-03-14T09:43:00.000Z","updated":"2022-02-26T03:52:51.228Z","comments":true,"path":"2020/03/14/java-拷贝问题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/14/java-%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98/","excerpt":"","text":"1.拷贝的引入（1）引用拷贝创建一个指向对象的引用变量的拷贝。 12345678Teacher teacher = new Teacher(&quot;Taylor&quot;,26);Teacher otherteacher = teacher;System.out.println(teacher);System.out.println(otherteacher);结果输出：blog.Teacher@355da254blog.Teacher@355da254 结果分析：由输出结果可以看出，它们的地址值是相同的，那么它们肯定是同一个对象。teacher和otherteacher的只是引用而已，他们都指向了一个相同的对象Teacher(“Taylor”,26)。 这就叫做引用拷贝。上述例子的图示： （2）对象拷贝创建对象本身的一个副本。 12345678Teacher teacher = new Teacher(&quot;Swift&quot;,26);Teacher otherteacher = (Teacher)teacher.clone();System.out.println(teacher);System.out.println(otherteacher);输出结果:blog.Teacher@355da254blog.Teacher@4dc63996 结果分析：由输出结果可以看出，它们的地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个新的引用变量,这就叫做对象拷贝。 对象拷贝的图示： println打印对象这个问题12345678910111213141516171819202122首先来看一看println（）的源码：public void println(Object x) &#123; String s = String.valueOf(x); synchronized (this) &#123; print(s); newLine(); &#125; &#125;再看valueOf()的源码：public static String valueOf(Object obj) &#123; return (obj == null) ? &quot;null&quot; : obj.toString(); &#125;系统自带的toString() 方法定义如下： public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode()); &#125;所以可以通过重写类的toString方法，来实现打印对象 浅拷贝注：深拷贝和浅拷贝都是对象拷贝 （1）定义：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。 简而言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象 （2）浅拷贝实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 public class ShallowCopy &#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Teacher teacher = new Teacher(); teacher.setName(&quot;Delacey&quot;); teacher.setAge(29); Student2 student1 = new Student2(); student1.setName(&quot;Dream&quot;); student1.setAge(18); student1.setTeacher(teacher); Student2 student2 = (Student2) student1.clone(); System.out.println(&quot;拷贝后&quot;); System.out.println(student2.getName()); System.out.println(student2.getAge()); System.out.println(student2.getTeacher().getName()); System.out.println(student2.getTeacher().getAge()); System.out.println(&quot;修改老师的信息后-------------&quot;); // 修改老师的信息 teacher.setName(&quot;Jam&quot;); System.out.println(student1.getTeacher().getName()); System.out.println(student2.getTeacher().getName()); &#125;&#125;class Teacher implements Cloneable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;class Student2 implements Cloneable&#123; private String name; private int age; private Teacher teacher; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Teacher getTeacher() &#123; return teacher; &#125; public void setTeacher(Teacher teacher) &#123; this.teacher = teacher; &#125; @Override public Object clone() throws CloneNotSupportedException &#123; //super.指的是调用父类（这里是调用Student2类的基类， //为object基类 ，因为类都隐式继承object类）的clone方法，实现浅克隆 Object object = super.clone(); return object; &#125;&#125;输出的结果为：拷贝后Dream18Delacey29修改老师的信息后-------------Jam //可见 两个学生的老师都指向修改老师 之后的同一个对象，为浅拷贝Jam 结果分析： 两个引用student1和student2指向不同的两个对象，但是两个引用student1和student2中的两个teacher引用指向的是同一个对象，所以说明是浅拷贝。上述例子的图示： 深拷贝（1）定义： 深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。 （2）实现深拷贝 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class DeepCopy &#123; public static void main(String[] args) throws Exception &#123; Teacher2 teacher = new Teacher2(); teacher.setName(&quot;Delacey&quot;); teacher.setAge(29); Student3 student1 = new Student3(); student1.setName(&quot;Dream&quot;); student1.setAge(18); student1.setTeacher(teacher); Student3 student2 = (Student3) student1.clone(); System.out.println(&quot;拷贝后&quot;); System.out.println(student2.getName()); System.out.println(student2.getAge()); System.out.println(student2.getTeacher().getName()); System.out.println(student2.getTeacher().getAge()); System.out.println(&quot;修改老师的信息后-------------&quot;); // 修改老师的信息 teacher.setName(&quot;Jam&quot;); System.out.println(student1.getTeacher().getName()); System.out.println(student2.getTeacher().getName()); &#125;&#125;class Teacher2 implements Cloneable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;class Student3 implements Cloneable &#123; private String name; private int age; private Teacher2 teacher; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Teacher2 getTeacher() &#123; return teacher; &#125; public void setTeacher(Teacher2 teacher) &#123; this.teacher = teacher; &#125; @Override public Object clone() throws CloneNotSupportedException &#123; // 浅复制时： // Object object = super.clone(); // return object; // 改为深复制： Student3 student = (Student3) super.clone(); // 本来是浅复制，现在将Teacher对象复制一份并重新set进来 student.setTeacher((Teacher2) student.getTeacher().clone()); return student; //jdk1.8新特性----接口可以有方法体，子类可以不用重写接口中已实现的方法 &#125;&#125;结果为：拷贝后Dream18Delacey29修改老师的信息后-------------JamDelacey 图解1（teacher姓名Delacey更改前）： 图解2（teacher姓名Jam更改后）： （3）利用序列化实现深拷贝 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class DeepCopyServiable &#123; public static void main(String[] args) throws Exception &#123; Teacher3 t = new Teacher3(); t.setName(&quot;Taylor&quot;); t.setAge(28); Student3 s1 = new Student3(); s1.setAge(20); s1.setName(&quot;blank space&quot;); s1.setTeacher(t); Student3 s2 = (Student3) s1.deepClone(); System.out.println(&quot;拷贝后:&quot;); System.out.println(s2.getName()); System.out.println(s2.getAge()); System.out.println(s2.getTeacher().getName()); System.out.println(s2.getTeacher().getAge()); System.out.println(&quot;---------------------------&quot;); t.setName(&quot;swift&quot;); System.out.println(&quot;修改后：&quot;); System.out.println(s1.getTeacher().getName()); System.out.println(s2.getTeacher().getName()); &#125;&#125;class Teacher3 implements Serializable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;class Student3 implements Serializable &#123; private String name; private int age; private Teacher3 teacher; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Teacher3 getTeacher() &#123; return teacher; &#125; public void setTeacher(Teacher3 teacher) &#123; this.teacher = teacher; &#125; public Object deepClone() throws Exception &#123; // 序列化 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); // 反序列化 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125;&#125;结果为：拷贝后:blank space20Taylor28---------------------------修改后：swiftTaylor （4）用复制构造函数的方法实现深拷贝，该方式较为简洁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114 package 类和对象;public class Main &#123; public static void main(String[] args) throws Exception &#123; Teacher4 teacher = new Teacher4(); teacher.setName(&quot;Delacey&quot;); teacher.setAge(29); Student4 student1 = new Student4(); student1.setName(&quot;Dream&quot;); student1.setAge(18); student1.setTeacher(teacher); Student4 student2 = new Student4(student1) ; System.out.println(&quot;拷贝后&quot;); System.out.println(student2.getName()); System.out.println(student2.getAge()); System.out.println(student2.getTeacher().getName()); System.out.println(student2.getTeacher().getAge()); System.out.println(&quot;修改老师的信息后-------------&quot;); // 修改老师的信息 teacher.setName(&quot;Jam&quot;); System.out.println(student1.getTeacher().getName()); System.out.println(student2.getTeacher().getName()); &#125;&#125;class Teacher4 implements Cloneable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Teacher4 (Teacher4 teacher4) &#123; //复制构造函数 this.name=teacher4.name; this.age=teacher4.age; &#125; public Teacher4() &#123; &#125;&#125;class Student4 &#123; private String name; private int age; private Teacher4 teacher; public String getName() &#123; return name; &#125; public Teacher4 getTeacher() &#123; return this.teacher; &#125; public void setTeacher(Teacher4 teacher2) &#123; this.teacher=teacher2; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Student4(Student4 student4) &#123; //复制构造函数 this.name=student4.name; this.age=student4.age; this.teacher=new Teacher4(student4.teacher); //将student4中的那个teacher用Teacher4中的拷贝构造函数 拷贝出一个新的来，并将引用赋给本类的teacher &#125; public Student4() &#123; &#125; &#125;结果为：拷贝后Dream18Delacey29修改老师的信息后-------------JamDelacey","categories":[{"name":"java interview","slug":"java-interview","permalink":"https://zouyunkai.github.io/myblog/categories/java-interview/"}],"tags":[{"name":"java 深浅拷贝","slug":"java-深浅拷贝","permalink":"https://zouyunkai.github.io/myblog/tags/java-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"}],"author":"aoyuehan"},{"title":"java SE note two","slug":"ava-SE-note-two","date":"2020-03-14T06:14:00.000Z","updated":"2022-02-26T03:52:52.842Z","comments":true,"path":"2020/03/14/ava-SE-note-two/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/14/ava-SE-note-two/","excerpt":"","text":"（面向对象一） 若对一个类不重写，它的equals()方法是如何比较的？比较是对象的地址。 请解释hashCode()和equals()方法有什么联系？考点：基础参考回答：Java对象的eqauls方法和hashCode方法是这样规定的：➀相等（相同）的对象必须具有相等的哈希码（或者散列码）。➁如果两个对象的hashCode相同，它们并不一定相同。 请解释Java中的概念，什么是构造函数？什么是构造函数重载？什么是复制构造函数？考察点：JAVA构造函数参考回答： 当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。 请说明Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？考察点：方法参考回答：Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况（与返回值无关，即重载的方法不能根据返回类型进行区分 ）。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 请说明重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？考察点：java重载参考回答：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 请说明Query接口的list方法和iterate方法有什么区别？考察点：接口参考回答：①list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用iterate()方法可以减少性能开销。② list()方法不会引起N+1查询问题，而iterate()方法可能引起N+1查询问题或者 ： 1.返回的类型不一样，list返回List，iterate返回iterator2.查询策略不同。获取数据的方式不一样，list会直接查询数据库，iterate会先到数据库中把id取出来，然后真正要遍历某个对象的时候先到缓存中找，如果找不到，以id为条件再发一条sql到数据库，这样如果缓存中没有数据，则查询数据库的次数为n+13.iterate会查询2级缓存，list只会缓存，但不会使用缓存（除非结合查询缓存）。4.list中返回的list中每个对象都是原本的对象，iterate中返回的对象是某某对象 请你谈一下面向对象的”六原则一法则”。 考察点：Java对象参考回答： –单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。） –开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。） –依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。） –里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。） –接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。） –合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。） –迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。 请说明如何通过反射获取和设置对象私有字段的值？考察点：类参考回答：可以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get&#x2F;set方法来获取&#x2F;设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得dog对象的主人的汽车的引擎的ID号。 12345678import java.lang.reflect.Method;class MethodInvokeTest &#123; public static void main(String[] args) throws Exception &#123; String str = &quot;hello&quot;; Method m = str.getClass().getMethod(&quot;toUpperCase&quot;); System.out.println(m.invoke(str)); // HELLO &#125;&#125; 请判断，两个对象值相同(x.equals(y) &#x3D;&#x3D; true)，但却可有不同的hash code，该说法是否正确，为什么？考察点：对象参考回答：不对，如果两个对象x和y满足x.equals(y) &#x3D;&#x3D; true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。 以下情况特殊，因为而且String类重写了Object的equals()方法 123String s1 = new String(&quot;hello&quot;); String s2 = new String(&quot;hello&quot;); System.out.println(s1 == s2); //输出 false System.out.println(s1.equals(s2));//输出 true 请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？考察点：类参考回答：一个内部类对象可以访问创建它的外部类对象的内容，内部类如果不是static的，那么它可以访问创建它的外部类对象的所有属性；内部类如果是sattic的，即为nested class，那么它只可以访问创建它的外部类对象的所有static属性一般普通类只有public或package的访问修饰，而内部类可以实现static，protected，private等访问修饰。当从外部类继承的时候，内部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明确地继承，就可以覆盖原来内部类的方法。 请说明JAVA语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？考察点：异常参考回答：Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。throw语句用来明确地抛出一个”异常”。throws用来标明一个成员函数可能抛出的各种”异常”。Finally为确保一段代码不管发生什么”异常”都被执行一段代码。可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，”异常“的框架就放到堆栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的try语句。 请说明Java的接口和C++的虚类的相同和不同处。考察点：接口参考回答：由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是public static,所有方法默认情况下是public，所有的变量都是public static final类型的，一个类可以实现多个接口。 请判断当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?考察点：对象参考回答：是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。 java中方法的参数传递只有值传递，参数为引用的时候传递的是该对象的地址 请你说说Static Nested Class 和 Inner Class的不同 考察点：声明参考回答： Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。Static-Nested Class 的成员, 既可以定义为静态的(static), 也可以定义为动态的(instance). Nested Class的静态成员(Method)只能对Outer Class的静态成员(static memebr)进行操作(ACCESS), 而不能Access Outer Class的动态成员(instance member).而 Nested Class的动态成员(instance method) 却可以 Access Outer Class的所有成员, 这个概念很重要, 许多人对这个概念模糊. 有一个普通的原则, 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS), 而动态方法( (instance method) 总是跟 instance object 相关联, 所以,静态方法(static method)永远不可以Access跟 object 相关的动态成员(instance member),反过来就可以, 一个CLASS的 instance object 可以 Access 这个 Class 的任何成员, 包括静态成员(static member). 面向对象（二） 请你讲讲abstract class和interface有什么区别?考察点：抽象类参考回答：声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型（就是实现了接口的类的引用赋值给接口对象，来实现多态）。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。 abstract class和interface有什么区别 抽象类和接口不能被直接实例化，二者实例化涉及到多态。如果抽象类要实例化，那么抽象类定义的变量必须指向一个子类对象，这个子类继承了抽象类并实现类抽象类的所有抽象方法，如果接口要实例化，那么接口定义的变量要指向一个子类对象，这个子类必须实现这个接口所有的方法 抽象类要被子类继承，接口要被子类实现 接口里面只能对方法进行声明，抽象类既可以对方法进行声明，也可以对方法进行实现。 抽象类里面的抽象方法必须全部被子类实现，如果子类不能全部实现，那么子类也必须是抽象类。接口里面的方法也必须被子类实现，如果子类不能实现，那么子类必须是抽象类 抽象类里面可以没有抽象方法 如果一个类里面有抽象方法，那么这个类一定是抽象类 抽象类中的方法都要被实现，所以抽象方法不能是静态的static，也不能是私有的private 接口（类）可以继承一个或多个接口，但类只能继承一个类 抽象级别：接口 &gt; 抽象类 &gt; 实现类 抽象类主要用来抽象类别，接口主要是用来抽象方法功能。当关注事物的本质的时候，用抽象类。当关注某种操作的时候，用接口。 抽象类的功能应该是远多于接口，但是定义抽象类的代价比较高。因为高级英语一个类只能继承一个父类，即在设计抽象类的时候必须要抽象出所有这个类的子类所具有的共同属性和方法；但是类（接口）可以继承多个接口，因此每个接口只需要将特定的动作方法抽象到这个接口即可。也就是说，接口的设计具有更大的可拓展性，而抽象类的设计必须十分谨慎。 JDK1.7接口只能由常量跟抽象方法，JDK1.8开始可以有默认方法和静态方法，JDK1.9在前面版本的基础上新增了私有方法和私有静态方法。默认方法使用default关键字修饰，需要些方法体来实现具体逻辑。实现类可以不重写默认方法，在需要的时候进行重写。静态方法使用static关键字修饰、定义，同样需要写方法体，实现具体的逻辑，但静态方法不可以被子类实现或继承。默认方法内部可以调用静态方法，但静态方法内部不能调用默认方法，因为静态方法只能调用静态方法。私有方法用private关键字修饰、定义，私有静态方法用private static关键字修饰、定义，private与private static方法只能接口自身内部调用，实现类或子类不可重写&#x2F;重载，两者都需要写方法体，实现具体逻辑。 java 8 新特性：接口中的类方法、默认方法、私有方法都可以有方法体的。 请说明Overload和Override的区别，Overloaded的方法是否可以改变返回值的类型?考察点：JAVA多态参考回答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。子类的对象使用这个方法时，将调用子类中被重写的方法，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。 请说明一下final, finally, finalize的区别。考察点：声明参考回答：final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。finally是异常处理语句结构的一部分，表示总是执行。finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。 请说明面向对象的特征有哪些方面考察点：JAVA特征参考回答：(1)抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。(2)继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。(3)封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。(4) 多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 请说明Comparable和Comparator接口的作用以及它们的区别。考察点：comparable接口参考回答：Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。Java提供了包含compare()和equals()两个方法的Comparator接口。 compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。 请说明Java是否支持多继承？考察点：JAVA多继承参考回答：Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。 -请你谈谈如何通过反射创建对象？ 考察点：类参考回答： 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance() 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance(“Hello”); 请你说明是否可以在static环境中访问非static变量？考察点：static变量参考回答： static变量在Java中是属于类的，它在所有的实例中的值是一样的，而实例变量是属于对象的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。 请解释一下extends 和super 泛型限定符考察点：JAVA泛型参考回答：（1）泛型中上界和下界的定义上界&lt;? extend Fruit&gt;下界&lt;? super Apple&gt; （2）上界和下界的特点上界的list只能get，不能add（确切地说不能add出除null之外的对象，包括Object）下界的list只能add，不能get 如果既想存，又想取，不用通配符就可以了 12345678910111213141516171819202122232425import java.util.ArrayList;import java.util.List; class Fruit &#123;&#125;class Apple extends Fruit &#123;&#125;class Jonathan extends Apple &#123;&#125;class Orange extends Fruit &#123;&#125; public class CovariantArrays &#123; public static void main(String[] args) &#123; //上界 List&lt;? extends Fruit&gt; flistTop = new ArrayList&lt;Apple&gt;(); flistTop.add(null); //add Fruit对象会报错 //flist.add(new Fruit()); Fruit fruit1 = flistTop.get(0); //下界 List&lt;? super Apple&gt; flistBottem = new ArrayList&lt;Apple&gt;(); flistBottem.add(new Apple()); flistBottem.add(new Jonathan()); //get Apple对象会报错 //Apple apple = flistBottem.get(0); &#125;&#125; （4）上界&lt;? extend Fruit&gt; ，表示所有继承Fruit的子类，但是具体是哪个子类，无法确定，所以调用add的时候，要add什么类型，谁也不知道。但是get的时候，不管是什么子类，不管追溯多少辈，肯定有个父类是Fruit，所以，我都可以用最大的父类Fruit接着，也就是把所有的子类向上转型为Fruit。 下界&lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。那么当我add的时候，我不能add Apple的父类，因为不能确定List里面存放的到底是哪个父类。但是我可以add Apple及其子类。因为不管我的子类是什么类型，它都可以向上转型为Apple及其所有的父类甚至转型为Object 。但是当我get的时候，Apple的父类这么多，我用什么接着呢，除了Object，其他的都接不住。 所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。具体来讲，我可以把Apple对象赋值给Fruit的引用，但是如果把Fruit对象赋值给Apple的引用就必须得用cast。 请你讲讲什么是泛型？考察点：JAVA泛型参考回答：泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用&#x2F;调用时传入具体的类型（类型实参）。 123456789101112131415161718192021public class GenericTest &#123; public static void main(String[] args) &#123; /* List list = new ArrayList(); list.add(&quot;qqyumidi&quot;); list.add(&quot;corn&quot;); list.add(100); */ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;qqyumidi&quot;); list.add(&quot;corn&quot;); //list.add(100); // 1 提示编译错误 for (int i = 0; i &lt; list.size(); i++) &#123; String name = list.get(i); // 2 System.out.println(&quot;name:&quot; + name); &#125; &#125; &#125; 采用泛型写法后，在&#x2F;&#x2F;1处想加入一个Integer类型的对象时会出现编译错误，通过List，直接限定了list集合中只能含有String类型的元素，从而在&#x2F;&#x2F;2处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。 java面向对象（三） 请说明静态变量存在什么位置?考察点：类参考回答：方法区 方法区是一种规范，而永久代是实现了方法区这个规范而存在的，是属于堆的逻辑空间，存储着类的元数据信息，静态变量，和运行时常量池，而1.8以后，将永久代取消，但是方法区这个规范还存在，多了个元空间实现方法区规范，属于本地内存存放类的元数据，常量池的引用，而常量池的实例数据存储还是在堆中。 Java中局部变量、实例变量和静态变量在方法区、栈内存、堆内存中的分配 Java中的变量根据不同的标准可以分为两类，以其引用的数据类型的不同来划分可分为“原始数据类型变量和引用数据类型变量”，以其作用范围的不同来区分可分为“局部变量，实例变量和静态变量”。 “变量是在内存中分配的保留区域的名称。换句话说，它是一个内存位置的名称”，也就是说我们通过这个变量名字就可以找到一个指向这个变量所引用的数据的内存指针，根据变量的类型我们可以知道这个指针之后的几个字节里存储了这个变量所引用的数据。 所以，了解变量在方法区、栈内存、堆内存中的分配要了解两部分内容，一个是“变量在内存中的分配”，另一个是“变量所引用的数据在内存中的分配”。以下简称为“变量分配”与“数据分配”。 原始数据类型变量：原始数据类型变量的“变量分配”与“数据分配”是在一起的（都在方法区或栈内存或堆内存） 引用数据类型变量引用数据类型变量的“变量分配”与“数据分配”不一定是在一起的 1234567891011121314151617181920212223242526272829303132333435示例代码：class Fruit &#123; static int x = 10; static BigWaterMelon bigWaterMelon_1 = new BigWaterMelon(x); int y = 20; BigWaterMelon bigWaterMelon_2 = new BigWaterMelon(y); public static void main(String[] args) &#123; final Fruit fruit = new Fruit(); int z = 30; BigWaterMelon bigWaterMelon_3 = new BigWaterMelon(z); new Thread() &#123; @Override public void run() &#123; int k = 100; setWeight(k); &#125; void setWeight(int waterMelonWeight) &#123; fruit.bigWaterMelon_2.weight = waterMelonWeight; &#125; &#125;.start(); &#125;&#125; class BigWaterMelon &#123; public BigWaterMelon(int weight) &#123; this.weight = weight; &#125; public int weight;&#125; 示例程序的内存分配图 同一种颜色代表变量和对象的引用关系 由于方法区和堆内存的数据都是线程间共享的，所以线程Main Thread，New Thread和Another Thread都可以访问方法区中的静态变量以及访问这个变量所引用的对象的实例变量。 栈内存中每个线程都有自己的虚拟机栈，每一个栈帧之间的数据就是线程独有的了，也就是说线程New Thread中setWeight方法是不能访问线程Main Thread中的局部变量bigWaterMelon_3，但是我们发现setWeight却访问了同为Main Thread局部变量的“fruit”，这是为什么呢？因为“fruit”被声明为final了。 当“fruit”被声明为final后，“fruit”会作为New Thread的构造函数的一个参数传入New Thread，也就是堆内存中Fruit$1对象中的实例变量val$fruit会引用“fruit”引用的对象，从而New Thread可以访问到Main Thread的局部变量“fruit”。内存分配及变量存储位置（堆、栈、方法区常量池、方法区静态区） 请你解释一下类加载机制，双亲委派模型，好处是什么？考察点：类参考回答：某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。 请你谈谈StringBuffer和StringBuilder有什么区别，底层实现上呢？考察点：类参考回答：StringBuffer线程安全，StringBuilder线程不安全，底层实现上的话，StringBuffer其实就是比StringBuilder多了Synchronized修饰符。 请说明String是否能能继承？考察点：String参考回答：不能，char数组用final修饰的。 请说明”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？考察点：static变量参考回答：“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。 请说明重载和重写的区别，相同参数不同返回值能重载吗？考察点：重载参考回答： 重载(Overloading)（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数&#x2F;类型。重载Overloading是一个类中多态性的一种表现。（2） Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。 重写（Overriding）（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。方法重写又称方法覆盖。（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。如需父类中原有的方法，可使用super关键字，该关键字引用了当前类的父类。（3）子类函数的访问修饰权限不能少于父类的。 请列举你所知道的Object类的方法并简要说明。考察点：面向对象参考回答： Object()默认构造方法。clone() 创建并返回此对象的一个副本。equals(Object obj) 指示某个其他对象是否与此对象“相等”。finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。getClass()返回一个对象的运行时类。hashCode()返回该对象的哈希码值。notify()唤醒在此对象监视器上等待的单个线程。notifyAll()唤醒在此对象监视器上等待的所有线程。toString()返回该对象的字符串表示。wait()导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。 wait(long timeout)导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。 wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。 请说明类和对象的区别考察点：面向对象参考回答： 1.类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。比如：“人”是一个类，而“教师”则是“人”的一个实例。 2.对象是函数、变量的集合体；而类是一组函数和变量的集合体，即类是一组具有相同属性的对象集合体。 请解释一下String为什么不可变？考察点：面向对象参考回答： 不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。 String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是 HashMap 中的键往往都使用字符串的原因。 请讲讲Java有哪些特性，并举一个和多态有关的例子。考察点：语言特性参考回答： 封装、继承、多态。多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 请你讲讲wait方法的底层原理考察点：基础参考回答： ObjectSynchronizer::wait方法通过object的对象中找到ObjectMonitor对象调用方法 void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) 通过ObjectMonitor::AddWaiter调用把新建立的ObjectWaiter对象放入到 _WaitSet 的队列的末尾中然后在ObjectMonitor::exit释放锁，接着 thread_ParkEvent-&gt;park 也就是wait。 wait方法是继承自Object类中的方法，当对象调用wait方法时，其实是让执行对象方法的当前线程等待（而不是对象等待），线程会被放入等待队列中并释放锁，只有当其他线程调用notify或者notifyAll方法时，这个线程才会从等待队列中被唤醒，然后重新去争用锁。","categories":[{"name":"java interview","slug":"java-interview","permalink":"https://zouyunkai.github.io/myblog/categories/java-interview/"}],"tags":[{"name":"java se","slug":"java-se","permalink":"https://zouyunkai.github.io/myblog/tags/java-se/"}],"author":"aoyuehan"},{"title":"asp实验三","slug":"asp实验三","date":"2020-03-13T14:32:00.000Z","updated":"2022-02-26T03:51:21.481Z","comments":true,"path":"2020/03/13/asp实验三/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/13/asp%E5%AE%9E%E9%AA%8C%E4%B8%89/","excerpt":"","text":"实验项目名称 session、 Cookie 、Application对象的使用。 一、实验内容1、学习ession实现典型用户登录，Cookie 的作用和用 法，Application对象。 2、学习3.1常用服务器控件1，3.2常用服务器控件2，用控件编写一个程序，把session、cookie、和application对象全都用上。 二、实验方法与步骤1、 session实现用户登录购物车界面代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public partial class session_ceshi : System.Web.UI.Page &#123; protected void Page_Load(object sender, EventArgs e) &#123; if (!IsPostBack) &#123; List&lt;string&gt; cart = new List&lt;string&gt;(); Session[&quot;cart&quot;] = cart; &#125; if (Session[&quot;currentUser&quot;] != null) &#123; this.Literal1.Text = &quot;欢迎你：&quot; + Session[&quot;currentUser&quot;].ToString(); &#125;else &#123; this.Literal1.Text = &quot;你还没有登录&quot;; &#125; &#125; protected void Button1_Click(object sender, EventArgs e) &#123; //判断用户是否登录 if (Session[&quot;currentUser&quot;] == null) &#123; Response.Redirect(&quot;session_ceshi_login.aspx&quot;); &#125; else &#123; foreach (Control item in form1.Controls) &#123; if(item is CheckBox) &#123; CheckBox ckb = (CheckBox)item; if (ckb.Checked) &#123; ((List&lt;string&gt;)Session[&quot;cart&quot;]).Add(ckb.Text); &#125; &#125; &#125; this.Button1.Text = &quot;添加成功&quot;; &#125; &#125; protected void Button2_Click(object sender, EventArgs e) &#123; Response.Redirect(&quot;index.aspx&quot;); &#125; protected void Button3_Click(object sender, EventArgs e) &#123; Session.Abandon(); &#125;&#125; 实验效果： 2、 cookie代码： 123456789101112131415161718192021222324252627282930public partial class cookie : System.Web.UI.Page &#123; protected void Page_Load(object sender, EventArgs e) &#123; if (!IsPostBack) &#123; if (Request.Cookies[&quot;UserName&quot;] != null) &#123; Response.Write(&quot;用户名：&quot; + Request.Cookies[&quot;UserName&quot;].Value); &#125; if (Request.Cookies[&quot;UserPhone&quot;] != null) &#123; Response.Write(&quot; 用户电话为：&quot; + Request.Cookies[&quot;UserName&quot;].Value); &#125; &#125; &#125; protected void Button1_Click(object sender, EventArgs e) &#123; //方法一： Response.Cookies[&quot;UserName&quot;].Expires = DateTime.Now.AddDays(1.0); Response.Cookies[&quot;UserName&quot;].Value = this.TextBox1.Text; //方法二： HttpCookie hcokies = new HttpCookie(&quot;UserPhone&quot;, &quot;123&quot;); hcokies.Expires= DateTime.Now.AddDays(1.0); Response.Cookies.Add(hcokies); &#125; &#125; 效果演示： 3、 application对象代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Global.asax文件：public class Global : HttpApplication &#123; void Application_Start(object sender, EventArgs e) &#123; // 在应用程序启动时运行的代码 RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); Application.Lock(); Application[&quot;UserVisit&quot;] = 0;//网站被访问的次数 Application[&quot;currentUsers&quot;] = 0;//在线人数 Application.UnLock(); &#125; protected void Session_Start(object sender, EventArgs e) &#123; //Application:服务端的状态保持机制。放在该对象中的数据是共享的。 与Cache相同，只是Cache本身就有加锁解锁的机制 Application.Lock(); //Application需要手动加锁解锁。 Application[&quot;UserVisit&quot;] = (int)Application[&quot;UserVisit&quot;]+1; Application[&quot;currentUsers&quot;] = (int)Application[&quot;currentUsers&quot;] + 1; Application.UnLock(); &#125; protected void Session_End(object sender, EventArgs e) &#123; //Application:服务端的状态保持机制。放在该对象中的数据是共享的。 与Cache相同，只是Cache本身就有加锁解锁的机制 Application.Lock(); //Application需要手动加锁解锁。 Application[&quot;currentUsers&quot;] = (int)Application[&quot;currentUsers&quot;] - 1; Application.UnLock(); &#125;&#125;测试界面：public partial class appliction_ceshi : System.Web.UI.Page &#123; protected void Page_Load(object sender, EventArgs e) &#123; if (!IsPostBack) &#123; this.Label1.Text = &quot;你是本站的第&quot; + Application[&quot;UserVisit&quot;].ToString()+&quot;访客 ，当前在线人数&quot; + Application[&quot;currentUsers&quot;]; &#125; &#125; protected void Button1_Click(object sender, EventArgs e) &#123; Session.Abandon(); &#125; &#125; 效果： 4、将三者合并起来做成了一个购物车网站，登录后可以看到该网站在线的人数（使用application对象），记录某个cookies，在一段时间内免登录。 5、 服务器端的控件 三、实验心得1、 2、Global.asax与Web.config的比较： Web.config是对程序中应用程序的配置，效用范围在它所在目录Global.asax是全局的，是整个网站总体的设置Global.asax是一个可选的文件，Web.config是一个必有的文件 其中Global.asax文件中包含以下方法：Application_Start（HttpApplication 类的第一个实例被创建时，该事件被触发。）、Session_Start（在一个新用户访问应用程序 Web 站点时，该事件被触发。）、Session_End（在 InProc 模式下运行时，当一个用户的会话超时、结束或他们离开应用程序 Web 站点时，该事件被触发。（会话结束或过期时，执行））、Application_BeginRequest（在接收到一个应用程序请求时触发）、Application_AuthenticateRequest（在安全模块建立起当前用户的有效的身份时，该事件被触发。）、Application_Error（当应用程序中遇到一个未处理的异常时，该事件被触发。）、Application_End（在HttpApplication 类的最后一个实例被销毁时，该事件被触发。）","categories":[{"name":"asp","slug":"asp","permalink":"https://zouyunkai.github.io/myblog/categories/asp/"}],"tags":[],"author":"aoyuehan"},{"title":"asp实验二","slug":"asp实验二","date":"2020-03-13T14:22:00.000Z","updated":"2022-02-26T03:51:21.481Z","comments":true,"path":"2020/03/13/asp实验二/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/13/asp%E5%AE%9E%E9%AA%8C%E4%BA%8C/","excerpt":"","text":"一、实验内容 掌握页面回发机制，会使用Request和Response对象包含的方法，会用viewstate存储同页面的变量，会用session存储不同页面的变量。 二、实验方法与步骤 1、 requset的使用：在index.aspx中写入测试网页的超链接，并设置姓名和年龄两个参数，点击主页中的链接，跳转到测试网页中，显示参数。在测试网页的page_load函数中编写代码 123456789string name = Request.QueryString[&quot;name&quot;]; string age = Request.QueryString[&quot;age&quot;]; Response.Write(&quot;姓名=&quot; + name + &quot;年龄&quot; + age + &quot;&lt;br&gt;&lt;br&gt;&quot;); Response.Write(&quot; 获取web服务器变量的集合：&quot;); string ie = Request.ServerVariables[&quot;HTTP_USER_AGENT&quot;]; string ie2 = Request.ServerVariables[&quot;HTTP_ACCEPT_LANGUAGE&quot;]; Response.Write(&quot; 浏览器版本信息：&quot; + ie + &quot;&lt;br&gt;&lt;br&gt;&quot;); Response.Write(&quot; 浏览器的语言：&quot; + ie2 + &quot;&lt;br&gt;&lt;br&gt;&quot;); 测试效果如下： 2、 response的使用1、 reponse.write()方法,向页面中写入内容。2、 重定向操作在一个页面的page_load函数写入代码：Response.Redirect(“request_ceshi.aspx?name&#x3D;小志&amp;age&#x3D;13”);使得页面在进入的时候跳转到request_ceshi.aspx这个页面 3、 viewState在页面中编写代码： 123456789101112131415161718public partial class viewstate_ceshi : System.Web.UI.Page &#123; protected void Page_Load(object sender, EventArgs e) &#123; if (!IsPostBack)//页面回发 &#123; ViewState[&quot;counter&quot;] = 0; &#125; &#125; protected void Button1_Click(object sender, EventArgs e) &#123; int count = (int)ViewState[&quot;counter&quot;]; count++; this.Literal1.Text = count.ToString(); ViewState[&quot;counter&quot;] = count; &#125; &#125; 效果如下： 4、设计一个购物车的，把选中的东西放到session 对象里，然后点击显示购物车，送session中读取内容，显示出来。部分代码： 12345678910111213141516171819202122232425262728293031public partial class session_ceshi : System.Web.UI.Page &#123; protected void Page_Load(object sender, EventArgs e) &#123; if (!IsPostBack) &#123; List&lt;string&gt; cart = new List&lt;string&gt;(); Session[&quot;cart&quot;] = cart; &#125; &#125; protected void Button1_Click(object sender, EventArgs e) &#123; foreach (Control item in form1.Controls) &#123; if(item is CheckBox) &#123; CheckBox ckb = (CheckBox)item; if (ckb.Checked) &#123; ((List&lt;string&gt;)Session[&quot;cart&quot;]).Add(ckb.Text); &#125; &#125; &#125; this.Button1.Text = &quot;添加成功&quot;; &#125; protected void Button2_Click(object sender, EventArgs e) &#123; Response.Redirect(&quot;index.aspx&quot;); &#125; 效果如下： 三、实验心得1、知道了request和response两个对象的使用，从浏览器向服务器发送request，服务器向浏览器发送response，从request中获取数据有querystring属性和params属性，两种方式。Response有write和redirect两个方法，用来向客户端浏览器中显示数据和重定向。2 使用viewstate方式，实现计数器，因为http协议是无状态的，不保存特定用户的请求，所以可以通过此方式来实现在页面中设置成员变量的目的。3 Session对象可以实现不同页面数据的交换，从而弥补了viewstate的缺陷。4 页面回发机制：通过判断页面是否回发，if（！ispostback）{这里就是初始化的内容， 在页面回发的时候就不会在执行这里面的内容了。}","categories":[{"name":"asp","slug":"asp","permalink":"https://zouyunkai.github.io/myblog/categories/asp/"}],"tags":[],"author":"aoyuehan"},{"title":"算法很美","slug":"算法很美","date":"2020-03-12T13:37:35.000Z","updated":"2022-02-26T03:52:52.601Z","comments":true,"path":"2020/03/12/算法很美/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/12/%E7%AE%97%E6%B3%95%E5%BE%88%E7%BE%8E/","excerpt":"","text":"1 位运算的奇巧淫技 2 查找与排序（上） 3 查找与排序（下） 4 多维数组和矩阵 5 字符串专题 6 数学问题 7 递归，DFS，剪枝，回溯等问题 8 贪心策略与动态规划 **位运算的奇巧淫技 ** 1.2如何找数组中唯一成对的那个数 详见C++语言零碎知识点汇总这篇文章中的&amp;和|的那一节 例如： 1&lt;&lt;n&#x3D;2^n ； n&lt;&lt;1&#x3D;2*n ；左移一位就相当于乘2；右移一位相当于除2 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;const int N=11;int main()&#123; //method1：利用^运算 int a[N]; for(int i=1;i&lt;N;i++)a[i]=N-i; a[0]=rand()%10; //定义重复的那个数 int x=0; for(int i=1;i&lt;=N-1;i++)x=(x^i); //^优先级高于=，所以不知道优先级的时候就加（） for(int i=0;i&lt;N;i++)x=x^a[i]; cout&lt;&lt;&quot;a数组为：&quot;&lt;&lt;endl; for(int i=0;i&lt;N;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; cout&lt;&lt;&quot;结果为：&quot;&lt;&lt;x&lt;&lt;endl; //method2：利用辅助空 cout&lt;&lt;&quot;method2：利用辅助空&quot;&lt;&lt;endl; int helper[N]; memset(helper,0,sizeof(helper)); //注意最后一个参数不是N，而是N*4(因为一个int类型的数占4个字节) //其中helper数组放在main函数里面一定要初始化为0 for(int i=0;i&lt;N;i++)helper[a[i]]++; // helper[a[i]]++;记住还有这种用法 cout&lt;&lt;&quot;helper数组为：&quot;&lt;&lt;endl; for(int i=0;i&lt;N;i++)&#123; cout&lt;&lt;helper[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; for(int i=0;i&lt;N;i++)&#123; if(helper[i]==2)&#123; cout&lt;&lt;&quot;结果为：&quot;&lt;&lt;i; break; &#125; &#125; &#125; /*例如：随机生成10个0~100各不相同的数：#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#define random(x) (rand()%x)void main()&#123; srand((int)time(0)); for(int x=0;x&lt;10;x++) printf(&quot;%d/n&quot;,random(100));&#125;*/ 1.4 计算一个二进制数中1的个数 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; //method：移动1中1的位置，与要比较的数进行比较 int n=5; int count=0; for(int i=0;i&lt;32;i++)&#123; if((n&amp;(1&lt;&lt;i))==(1&lt;&lt;i))count++; //if(n&amp;(1&lt;&lt;i)==(1&lt;&lt;i)) 要是这样写就错了，==优先级比^要高 &#125; cout&lt;&lt;count&lt;&lt;endl; //method 2:移动要比较的数，向右移与1比较 int count1=0; unsigned int n1=5; for(unsigned int i=0;i&lt;32;i++)&#123; //if(((n1&gt;&gt;&gt;i)&amp;1)==1)count1++; 为什么写&gt;&gt;&gt;不行 ，因为&gt;&gt;&gt;是带符号的，有可能不等于1 if(((n1&gt;&gt;i)&amp;1)==1)count1++; &#125; cout&lt;&lt;count1&lt;&lt;endl; //method3: 一个数减1之后与原来的自己进行与运算， //就会把减掉的那个1的位之后的数全变为0 int count2=0; int n2=5; while(n2!=0)&#123; n2=((n2-1)&amp;n2); count2++; &#125; cout&lt;&lt;count2&lt;&lt;endl;&#125; 1.5 判断整数是不是2的整数次方 1.6 将整数的奇偶位互换 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int m(int i)&#123; int ou=i&amp;0xaaaaaaaa; //和1010 1010 1010...做与运算出偶数位 int ji=i&amp;0x55555555; //和0101 0101 0101...做与运算出奇数 return (ou&gt;&gt;1)^(ji&lt;&lt;1); //连起来 &#125;int main()&#123; int a=9; int a1=0b01000000_00000000_00000000_00000000; int b=m(9); //结果应该为6 int b1=0b10000000_00000000_00000000_00000000; //其中a1奇偶互换之后应该为b1 cout&lt;&lt;b; &#125; 1.7 浮点数的二进制表示 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; double num=0.625; string sb=&quot;0.&quot;; while(num&gt;0)&#123; double r=num*2; //判断整数部分 if(r&gt;=1)&#123; sb.append(&quot;1&quot;); num=r-1; &#125;else&#123; sb.append(&quot;0&quot;); num=r; &#125; &#125; if(sb.length()&gt;34)&#123; cout&lt;&lt;&quot;error&quot;; return 0; &#125; cout&lt;&lt;sb&lt;&lt;endl;&#125; 1.8 出现k次与出现1次 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; //方法一：在multiset中找到出现一次的数 multiset&lt;int&gt; s; int a[16]=&#123;2,2,2,9,7,7,7,3,3,3,6,6,6,0,0,0&#125;; s.insert(a,a+16); if(s.find(2)!=s.end())cout&lt;&lt;&quot; 2 is existent&quot;&lt;&lt;endl&lt;&lt;s.count(2)&lt;&lt;endl; for(multiset&lt;int&gt;::iterator it=s.begin(); it != s.end(); it++)&#123; if(s.count(*it)==1) &#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125; &#125; //方法二： 将所有数转为k进制，然后相应的位做不进位加法， //最后得到的数就是出现一次的那个数 （因为k个k进制的数做不进位加法，结果为0） &#125; 查找与排序（上） 详见这篇文章 递归 recursive functions 2.1 什么是递归 123456789101112131415161718192021222324252627/*找重复： 1，找到一种划分方法 2，找到递推公式或者等价代换找变化的量： 变化的量通常作为参数（如果递归起来比较费劲，或者难想，那么有可能是该参数找的不对）找出口： 依照边界，找到问题的出口*//*f1(n):求n的阶乘*找重复：n*(n-1)的阶乘，求n-1的阶乘是原问题的重复(规模更小)，即子问题*找变化：变化的量应该作为参数*找边界：根据参数的变化趋势，对边界进行控制，适时终止递归 */int f1(int n)&#123; if(n==1)return 1; return n*f1(n-1);&#125;//打印i到j之间的值 void f2(int i,int j)&#123; if(i&gt;j) return ; cout&lt;&lt;i; f2(i+1,j);&#125; 2.3 斐波那锲是把问题划分为多个子问题（此时是看那个有没有递推公式，或者等价转换等），这多个子问题之间还是有包含关系的，这与前面的切蛋糕思维不一样（自己解决一小部分，然后剩下的看成一个小问题）。 2.4 递推求最大公约数 1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int gcd(int m,int n)&#123; if(n==0) return m; return gcd(n,m%n);&#125;int main()&#123; int m=5;int n=10; cout&lt;&lt;gcd(m,n);&#125; 2.7 二分查找的递归解法首先切蛋糕思维是单分支，而斐波那锲和汉诺塔是双分支，而二分查找是类似于双分支的单分支（剪枝），其每次只会选择一条路径走下去。 全范围内二分查找 等价于三个问题：左边找（递归）,中间比,右边找（递归） 注意：左查找和右查找只选其一 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;//二分查找的非递归形式int binSearch(int nums[],int k)&#123; int i = 0;//j是数组最后一个下标的位置，如int a[5]，j最大为4（因为没有a[5]这个值 int j = sizeof(nums) / sizeof(nums[0])-1; int mid; while(i&lt;=j)&#123; mid = i+((j-i)&gt;&gt;1);//防止溢出,而且使用位运算更加高效//mid = ((i+j)&gt;&gt;&gt;1); if(nums[mid]==k)&#123; return mid; &#125;else if(nums[mid]&gt;k)&#123; j = mid-1; &#125;else&#123; i = mid+1; &#125; &#125; return -1;&#125;//二分查找的递归形式，其中k，i，j参数是必要的，不然的话怎么调用传值int binSearch_1(int nums[],int k,int i,int j)&#123;//其中nums是有序数组，k为要查找的值，i为要查找的数组的起始下标，j为终点下标 if(i&gt;j) return -1; int mid =i+((j-i)&gt;&gt;1); if(nums[mid]==k)&#123; return mid; &#125;else if(nums[mid]&gt;k) &#123; return binSearch_1(nums,k,i,mid-1); &#125;else &#123; return binSearch_1(nums,k,mid+1,j); &#125;&#125;int main()&#123; int a[]=&#123;1,2,3,4,5&#125;; cout&lt;&lt;binSearch_1(a,5,0,4); //结果为4，即数组下表的最后一个，a[4]&#125; 2.10常见函数的复杂度计算首先现在的计算机的计算速度是1s计算10^8 2.13 三种典型递归形式的算法的性能分析 递归求阶乘的算法分析 斐波那锲算法复杂度为o（2^n）（八皇后问题那种就是8^n） 求最大公约数的复杂度为o（2lgn） 2.16 小白上楼梯 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int f(int n)&#123; if(n==0)return 1;//这地方要return 1，因为最后一次调用f(n-1)的时候要返回1 if(n==1)return 1; if(n==2)return 2; return f(n-1)+f(n-2)+f(n-3);&#125;int main()&#123; int n; cin&gt;&gt;n; cout&lt;&lt;f(n);&#125; 2.17 旋转数组的最小数字 从中间插入刀，那么就会一边有序，一边无序；而且如果begin的值小于end的值，说明数组本身没有旋转 12345678910111213141516171819202122232425262728293031323334public class 旋转数组的最小数字 &#123;public static void main(String[] args) &#123; // TODO Auto-generated method stub int []arr = &#123;5,1,2,3,4&#125;; System.out.println(&quot;最小数字为&quot;+min(arr));&#125;/** * 活用二分查找 * @param arr * @return */static int min(int arr[])&#123; int begin = 0; int end = arr.length - 1; // 考虑没有旋转这种特殊的旋转 if (arr[begin] &lt; arr[end]) return arr[begin]; while(begin+1&lt;end)&#123; int mid = begin + ((end-begin)&gt;&gt;1); // 要么左侧有序，要么右侧有序 // 下面这行代码有个bug 假如数组为 1 1 1 0 1 这种数组应该在程序的入口检测一下 // 假如左侧和中间相等了 那么就应该用顺序查找最小值了。 if (arr[mid] &gt;= arr[begin]) &#123; // 左侧有序 begin = mid; &#125;else &#123; end = mid; &#125; &#125; return arr[end];&#125;&#125; 查找与排序（下） 3.1 分治法的介绍 3.8 _调整数组顺序-奇数在左偶数在右 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182法一：模式匹配：归并排序：奇数放左边，偶数放右边。需另外开辟空间。 #includeusing namespace std;void mergeSortOddEven(int arr[],int low, int high)&#123; int length=high-low+1; int ref[length]; int left=low; int right=high; int current=low;//Copy到ref数组 for(int i=0;i&lt;length;i++)&#123; ref[i]=arr[i];&#125;while(current&lt;length)&#123; if(ref[current]%2==0)&#123; arr[right--]=ref[current++]; &#125; if((ref[current]%2)!=0)&#123; arr[left++]=ref[current++]; &#125;&#125; &#125;int main()&#123;int arr[]=&#123;2,4,6,1,7,2,8,3,7,3,6&#125;;mergeSortOddEven(arr,0,10);for(int i=0;i&lt;11;i++)&#123; cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;&#125;return 0;&#125;法二：模式匹配：快速排序：左右两指针，不满足则交换元素。#includeusing namespace std;void quickSortOddEven(int arr[],int low, int high)&#123; int length=high-low+1; int left=low; int right=high; while(left&lt;right)&#123; while(arr[left]%2==1)&#123; left++; &#125; while(arr[right]%2==0)&#123; right--; &#125; if(left&lt;right)&#123; swap(arr[left],arr[right]); &#125;&#125; &#125;int main()&#123;int arr[]=&#123;2,4,6,1,7,2,8,3,7,3,6&#125;;quickSortOddEven(arr,0,10);for(int i=0;i&lt;11;i++)&#123; cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;&#125;return 0;&#125; 3.9 最快效率求出乱序数组中第k小的数 第k个元素：以尽量高的效率，求出一个乱序数组中按数值顺序的第k个元素值。时间复杂度： 平均：O（n）；最差：O（n²）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#includeusing namespace std;//三点中值法int partition(int A[],int p,int r)&#123;//优化： 在p、r、mid之间，选一个中间值作为主元int midIndex=p+((r-p)&gt;&gt;1); //中间下标int midValueIndex=-1; //中值的下标if(A[p]&lt;=A[midIndex]&amp;&amp;A[p]&gt;=A[r])&#123; midValueIndex=p;&#125; else if(A[r]&lt;=A[midIndex]&amp;&amp;A[r]&gt;=A[p])&#123; midValueIndex=r;&#125; else&#123; midValueIndex=midIndex; &#125;swap(A[p],A[midValueIndex]);int pivot=A[p];int left=p+1;//扫描指针 int right=r; //右侧指针 while(left&lt;=right)&#123; //left不停往右走，直到遇到大于主元的元素 while(A[left]&lt;=pivot) left++; //循环退出时，left一定是指向第一个大于主元的位置 while(A[right]&gt;pivot) right--; //循环退出时，right一定是指向最后一个小于等于主元的位置 if(left&lt;right)&#123; swap(A[right],A[left]); &#125; &#125; //while退出时，两者交错，且right指向的是最后一个小于等于主元的位置，也就是主元应该待的位置 swap(A[p],A[right]);return right; //返回主元在交换完成后的下标&#125;int selectK(int A[],int p,int r,int k)&#123; int q=partition(A,p,r); //主元下标 int qK=q-p+1; //主元是第几个元素(排好序后) if(qK==k)&#123; return A[q]; &#125; else if(qK&gt;k)&#123; return selectK(A,p,q-1,k); &#125; else&#123; return selectK(A,q+1,r,k-qK); &#125;&#125;int main()&#123; int arr[]=&#123;2,4,6,1,7,2,8,3,7,3,6&#125;; cout&lt;&lt;selectK(arr,0,10,5); return 0;&#125; 发帖水王（一个数组中某个元素出现的个数大于等于数组个数的一半） 两种解法：法一（消除法，两个不同的数就互相消除,这种方法是第一个和第二个比，第三个和第四个比，…）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149public class MoreThanHalf &#123;public static void main(String[] args) &#123; f(new int[]&#123;5,6,6,6,2,3,6&#125;);&#125;// 不同的数，进行消除，O(N)public static void f(int arr[])&#123; //候选数 先定位第一个元素 int candidate = arr[0]; // 出现的次数 int nTimes = 1; // 扫描数组 for (int i = 1; i &lt; arr.length; i++) &#123; // 两两消减为0，应该把现在的元素作为候选值 if (nTimes==0 ) &#123; candidate = arr[i]; nTimes = 1; continue; &#125; // 如果遇到和候选值相同的，次数加一 if (arr[i]==candidate) &#123; nTimes++; // 不同的数，进行消减 &#125;else &#123; nTimes--; &#125; &#125; //System.out.println(nTimes); if (nTimes==0) &#123; System.out.println(-1); &#125;else &#123; System.out.println(candidate); &#125;&#125;&#125;加强版水王（出现个数等于数组个数的一半）public class MoreThanHalf &#123;public static void main(String[] args) &#123; //进行测试数据要满足测试条件 不然结果会错误 f(new int[]&#123;6,6,6,5,6,1,2,3,4,6&#125;);&#125;// 不同的数，进行消除，O(N)public static void f(int arr[])&#123; //候选数 先定位第一个元素 int candidate = arr[0]; // 出现的次数 int nTimes = 1; int countOfLast = 1; // 统计这个元素出现的次数 // 扫描数组 for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i-1]==arr[arr.length-1]) &#123; countOfLast++; &#125; // 两两消减为0，应该把现在的元素作为候选值 if (nTimes==0 ) &#123; candidate = arr[i]; nTimes = 1; continue; &#125; // 如果遇到和候选值相同的，次数加一 if (arr[i]==candidate) &#123; nTimes++; // 不同的数，进行消减 &#125;else &#123; nTimes--; &#125; &#125; //System.out.println(nTimes); if (countOfLast==arr.length/2) &#123; System.out.println(arr[arr.length-1]); &#125;else &#123; System.out.println(candidate); &#125;&#125;&#125;法二（这个与上面那个不同的就是i--，还有那个大的if-else语句，这种方法是第一个和第二个比，第二个和第三个比，第三个和第四个比....）：（https://www.jianshu.com/p/79bca265f7b2）int findK(int* arr,int arrLen)&#123;int value=arr[0];int count=1;for(int i=1;i&lt;arrLen;i++)&#123; if(count==0)&#123; i--;//避免value的赋值跳过那个使count等于0的与value比较的数组元素 ,网上其它人的代码就是少了这条语句 value=arr[i]; count++; &#125; else&#123; if(value==arr[i])//count!=0 &amp;&amp; value==arr[i] count++; else//count!=0&amp;value!=arr[i] count--; &#125;&#125;return value;&#125;加强版水王问题（出现的次数正好是数组个数的一半）：int findK(int* arr,int arrLen)&#123;int value=arr[0];int count=1;int countOfLast=0;//统计最后的元素arr[n-1]出现的个数for(int i=1;i&lt;arrLen;i++)&#123; //增加最后一个元素的计数步骤 if(arr[i]==arr[arrLen-1]) countOfLast++; if(count==0)&#123; i--;//避免value的赋值跳过那个使count等于0的与value比较的数组元素 value=arr[i]; count++; &#125; else&#123; if(value==arr[i])//count!=0 &amp;&amp; value==arr[i] count++; else//count!=0&amp;value!=arr[i] count--; &#125;&#125;//增加最后一个元素的计数步骤if(arr[0]=arr[arrLen-1]) countOfLast++;//如果最后一个元素出现次数是n/2,则这个元素就是要找的数 if(countOfLast==arrLen/2) return arr[arrLen-1];else return value;&#125; 多维数组和矩阵 4.1 基础题：顺时针打印二维数组 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;void print(int matrix[][5],int rowlength,int collength) &#123;//二维数组传参数一定要知道一维的下标是多少 int leftUpRow = 0, leftUpCol = 0, rightDownRow = rowlength - 1, rightDownCol = collength - 1; while (leftUpRow &lt;= rightDownRow &amp;&amp; leftUpCol &lt;= rightDownCol) &#123; int r = leftUpRow, c = leftUpCol; //上面一条边 while (c &lt;= rightDownCol) &#123; cout&lt;&lt;matrix[r][c++]&lt;&lt;” “; &#125; //恢复 c = rightDownCol; r++; //右边的一条边 while (r &lt;= rightDownRow) &#123; cout&lt;&lt;matrix[r++][c]&lt;&lt;” “; &#125; //恢复 r = rightDownRow; c–; //下面一条边 while (c &gt;= leftUpCol) &#123; cout&lt;&lt;matrix[r][c–]&lt;&lt;” “; &#125; // 恢复 c = leftUpCol; r–; while (r &gt; leftUpRow) &#123; cout&lt;&lt;matrix[r–][c]&lt;&lt;” “; &#125; leftUpRow++; leftUpCol++; rightDownRow–; rightDownCol–;&#125;&#125;int main() &#123; int matrix[5][5] = &#123; &#123;1, 2, 3, 4, 100&#125;, &#123;5, 6, 7, 8, 101&#125;, &#123;9, 10, 11, 12, 102&#125;, &#123;13, 14, 15, 16, 103&#125;, &#123;104, 105, 106, 107, 103&#125;, &#125;; print(matrix,5,5);&#125; 4.2 基础题：将0所在的行列清零这样的话，不能扫一下行，如果有0的话就把这一行置为0，这样的方法会使全部的矩阵置为0应该开另一个数组存行出现0的下标，另一个数组存列开出现0的下标，然后在这样扫一遍把原来数组的行或列置为0 4.3 Z型打印矩阵 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;void print(int matrix[4][4],int rlen,int clen)&#123; int r=0,m=rlen; int c=0,n=clen; bool l2r=true;//从左到右 while(r&lt;m&amp;&amp;c&lt;n)&#123; //从左下到右上的斜线 if(l2r)&#123; cout&lt;&lt;matrix[r][c]&lt;&lt;” “; //现在在第一行，列未到边界，这是只能向右走 if(r==0&amp;&amp;n-1)&#123; l2r=!l2r; c++; continue; &#125;else if(r&gt;0&amp;&amp;c==n-1)&#123; //现在在最后一列，只能向下走 l2r=!l2r; r++; continue; &#125;else&#123; //继续走上坡 r–; c++; &#125; &#125;else&#123;//反，走下坡 cout&lt;&lt;matrix[r][c]&lt;&lt;” “; //走到第一列，只能往下走 if(c==0&amp;&amp;r&lt;m-1)&#123; l2r=!l2r; r++; continue; &#125;else if(r==m-1)&#123; //到最后一行，只能往右走 l2r=!l2r; c++; continue; &#125;else&#123; r++; c–; &#125; &#125; &#125;&#125;int main()&#123;int matrix[3][4] = &#123;&#123;1, 2, 3, 4&#125;,&#123;5, 6, 7, 8&#125;,&#123;9, 10, 11, 12&#125;,// &#123;13, 14, 15, 16&#125;,&#125;;print(matrix,3,4);&#125; 4.4 求边界为1的最大子方阵 优化前O(n^4) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include&lt;bits/stdc++.h&gt;using namespace std;int solve(int A[3][3],int length)&#123;int N=length;int n=length;//n为最大子方阵的值while (n &gt; 0) &#123;//最上面那一行顶点for (int i = 0; i &lt; N; i++) &#123;if (i + n &gt; N) break;for (int j = 0; j &lt; N; j++) &#123; if (j + n &gt; N) break; //检查四个边 int r = i, c = j; while (c &lt; j + n) &#123; if (A[r][c++] == 0) goto l3; &#125; c--;//恢复，不然的话会越界 while (r &lt; i + n) &#123; if (A[r++][c] == 0) goto l3; &#125; r--; while (c &gt;= j) &#123; if (A[r][c--] == 0) goto l3; &#125; c++; while (r &gt;= i) &#123; if (A[r--][c] == 0) goto l3; &#125; return n; l3: continue; &#125; &#125; n--;&#125;return 0; &#125;int main()&#123;int a[3][3] = &#123;&#123;0, 1, 1&#125;,&#123;0, 1, 1&#125;,&#123;0, 1, 0&#125;&#125;;cout&lt;&lt;solve(a,3);&#125;优化之后O(n^3)#include&lt;bits/stdc++.h&gt;using namespace std;const int l=100;int rec[l][l][2];void generatehelpRec(int A[l][l],int length)&#123;//产生一个rec数组，其存放右和下方元素个数为1的个数，这样就产生了一个表，然后//能产生那个方阵的条件在 check中判断，这样时间复杂度就是o(n^3) int N=length; int row=N-1; //初始化rec的最后一行 for(int j=N-1;j&gt;=0;j–)&#123; int value=A[row][j]; if(value==1)&#123; if(j==N-1)&#123; rec[row][j][0]=1; &#125;else&#123; rec[row][j][0]=rec[row][j+1][0]+1; &#125; rec[row][j][1]=1; &#125; &#125; row–; for(int i=row;i&gt;=0;i–)&#123; //因为row–，此时是倒数第二行 ，初始化rec剩下的数组 for(int j=N-1;j&gt;=0;j–)&#123; int value=A[i][j]; if(value==1)&#123; if(j==N-1)&#123; rec[i][j][0]=1; &#125;else&#123; rec[i][j][0]=rec[i][j+1][0]+1; &#125; rec[i][j][1]=rec[i+1][j][1]+1; &#125; &#125; &#125;&#125;//以常数阶判断是否能组成方阵int check(int i,int j,int n)&#123; if(rec[i][j][0]&gt;=n&amp;&amp;rec[i][j][1]&gt;=n&amp;&amp;rec[i][j+n-1][1]&gt;=n&amp;&amp;rec[i+n-1][j][0]&gt;=n)&#123; return true; &#125; return false;&#125;//n从N到0判断最大子方阵的阶数int solve(int A[l][l],int length)&#123;int N=length;int n=N; while(n&gt;0)&#123; for(int i=0;i&lt;N;i++)&#123; if(i+n&gt;N)break;//判断一下边界，能优化一点 for(int j=0;j&lt;N;j++)&#123; if(j+n&gt;N)break; if(check(i,j,n)) return n; &#125; &#125; n–; &#125; return 0;&#125;int main()&#123;int a[l][l];int n;cin&gt;&gt;n;//n阶方阵for(int i=0;i&lt;n;i++)&#123;for(int j=0;j&lt;n;j++)cin&gt;&gt;a[i][j];&#125;cout&lt;&lt;endl;generatehelpRec(a,n);for(int i=0;i&lt;n;i++)&#123;for(int j=0;j&lt;n;j++)cout&lt;&lt;rec[i][j][0]&lt;&lt;” “&lt;&lt;rec[i][j][1]&lt;&lt;” “;cout&lt;&lt;endl;&#125;cout&lt;&lt;endl;cout&lt;&lt;solve(a,n);&#125; 4.7 子数组的最大累加和 为什么那暴力有时回比递推法多1那？？？？？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;//个数最多为n*(n+1)/2void findByForce(int arr[],int length)&#123;int maxSum=arr[0];for(int j=0;j&lt;length;j++)&#123;//控制子数组的最大长度 int sum=arr[0];//为第i项的和 int maxOfJ=sum;//从第j项起和的最大值 for(int i=j+1;i&lt;length;i++)&#123; //数组的尾指针，后移实现遍历最长数组中的不同子数组 sum+=arr[i]; if(sum&gt;maxOfJ)&#123;//第一次就是第j+1和第j项相比 maxOfJ=sum; &#125; &#125; //单独比较一下每个元素的值和maxSum的值的大小 if(maxOfJ&gt;maxSum)&#123; maxSum=maxOfJ; &#125;&#125;cout&lt;&lt;maxSum&lt;&lt;endl;&#125;//递推法O(n)int left;int right;int findByDp(int arr[],int length)&#123; if(length==0)return 0; int sumJ=arr[0];//前j个元素的最大贡献 int max=sumJ; int right=0,left=0;//left为最大子序列的左端点,right为右端点 for(int j=1;j&lt;length;j++)&#123; if(sumJ&gt;=0)&#123; sumJ+=arr[j]; &#125; else&#123; sumJ=arr[j]; left=j;//更新一下left &#125; if(sumJ&gt;max)&#123; max=sumJ; right=j; &#125; &#125; return max;&#125;int main()&#123;int arr[]=&#123;1,-3,5,5,-2,-1,0,0&#125;;int arr1[]=&#123;0,0,1&#125;;cout&lt;&lt;”暴力破解”&lt;&lt;endl;findByForce(arr,8);cout&lt;&lt;”递推法”&lt;&lt;endl;cout&lt;&lt;findByDp(arr,8);&#125; 4.8求解矩阵的子矩阵的最大累加和 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;const int ll=100;int findByDp(int arr[],int length)&#123; if(length==0)return 0; int sumJ=arr[0];//前j个元素的最大贡献 int max=sumJ; int right=0,left=0;//left为最大子序列的左端点,right为右端点 for(int j=1;j&lt;length;j++)&#123; if(sumJ&gt;=0)&#123; sumJ+=arr[j]; &#125; else&#123; sumJ=arr[j]; &#125; if(sumJ&gt;max)&#123; max=sumJ; &#125; &#125; return max;&#125;//就是把每一列的和当做一维数组来处理int maxSum(int matrix[ll][ll],int m,int n)&#123;int beginRow=0;int sums[n];int max=0;while(beginRow&lt;m)&#123; //从起始行到第n行 for(int i=beginRow;i&lt;n;i++)&#123; //按列累加 for(int j=0;j&lt;n;j++)&#123; sums[j]+=matrix[i][j]; &#125; //这地方就是用了上一题中思想，把二维数组转化为一位数组求解 int t=findByDp(sums,n); //这地方找前n个位置的对吗 if(t&gt;max)max=t; &#125; // memset(sums,0,sizeof(sums)); 为什么写memset不可以那 for(int k=0;k&lt;n;k++)&#123; sums[k]=0;&#125; beginRow++; &#125; return max;&#125;int main()&#123;int a[ll][ll];int m,n;cin&gt;&gt;m&gt;&gt;n;for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++) cin&gt;&gt;a[i][j];&#125; cout&lt;&lt;maxSum(a,m,n);&#125; 4.9 矩阵的运算矩阵的乘法不满足交换律 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int N=100;int a[N][N];int b[N][N];int c[N][N];void multi(int a[][N],int b[][N],int a_row,int b_col,int n)&#123;//普通的三层for循环实现矩阵乘法，第二三层for循环可颠倒 for(int i=1;i&lt;=a_row;i++) //矩阵ab，遍历a的第i行 for(int k=1;k&lt;=n;k++) //遍历a的第j列,b的第j行 for(int j=1;j&lt;=b_col;j++)//n为a的列或者b的行数 c[i][j]+=a[i][k]*b[k][j];&#125;int main()&#123;int a_row,b_col,n;cin&gt;&gt;a_row&gt;&gt;b_col&gt;&gt;n;for(int i=1;i&lt;=a_row;i++)&#123; for(int k=1;k&lt;=n;k++)&#123; cin&gt;&gt;a[i][k]; &#125;&#125; for(int i=1;i&lt;=n;i++)&#123; for(int k=1;k&lt;=b_col;k++)&#123; cin&gt;&gt;b[i][k]; &#125;&#125; multi(a,b,a_row,b_col,n); for(int i=1;i&lt;=a_row;i++)&#123; for(int k=1;k&lt;=b_col;k++)&#123; cout&lt;&lt;c[i][k]; &#125; cout&lt;&lt;endl;&#125;&#125; 4.9 矩阵快速幂的问题 字符串专题 － 5.1判断两个字符串是否有重复的字符 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int N=256;int help[N];//这种思想要知道，就是扫描一遍，然后在辅助的数组中存放数据//在辅助数组的数据中找到问题的答案int main()&#123;string s;cin&gt;&gt;s;bool flag=true;int k;for(int i=0;i&lt;sizeof(s);i++)&#123; k=s[i]-&#x27;0&#x27;; help[k]++; if(help[k]==2)&#123; //可以在这里判断，直接找到问题的答案 flag=false; break; &#125;&#125;if(flag==false)cout&lt;&lt;&quot;有重复&quot;;else cout&lt;&lt;&quot;无重复&quot;;&#125; -5.2字符串翻转 1234567891011121314151617181920212223242526272829对于char []类型的数据：#include#includeusing namespace std;int main()&#123; char s[]=”123456”;//不能是string类型； strrev(s); cout&lt;&lt;s&lt;&lt;endl; return 0;&#125;对于string类型的数据：#include#include#includeusing namespace std;int main()&#123;string s[]=”123456”;reverse(s.begin(),s.end());cout&lt;&lt;s&lt;&lt;endl;return 0;&#125; 5.3 走出思维误区：变形词问题 解法1：这种题可以先对字符串排序之后，判断两个字符串是否相等；解法2：声明一个help数组（ascii码），然后扫描s1，扫描到一个字符，在相应的位置+1，然后扫s2，扫到一个字符在相应的位置-1，最后如果help数组中有不是0的位置，那么就返回false，否则返回true。 这道题的一个变形题是：判断两个串是否属于一个字符集解法1：是用一个help，并全初始化为0， s1中出现的一个字符，就在help相应的位置变为1,； 然后扫s2，若扫描到的字符对应的help中相应的位置为0，则返回false，否则返回true；解法2：就是用一下map，map相应的操作和help相同。 5.5 压缩字符串？？？ 5.6 旋转词解法1、判断s1和s2是否等长2、如果不等长，建一个s1 + s1的字符串3、判断s2 是否在s1 + s1中。 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;bool solution(string s1, string s2)&#123; if(s1.length() != s2.length())&#123; return false;&#125;int len = s1.length();string ds1 = s1 + s1; for (int i = 0; i &lt; len; i++)&#123; if (ds1.substr(i, i + len)==s2) return true; &#125; return false;&#125;int main()&#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; cout&lt;&lt;solution(s1,s2);&#125; -5.8 将字符串按单词进行翻转 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string s1,s2,s3; // s1=”xiao liu z x”; getline(cin,s1); //注意cin和scanf都不能输入带空格的字符串 //可以使用getline(cin,str)或者scanf(“%[^\\n]]”,str)或者gets(字符数组名); stringstream ss; ss&lt;&lt;s1; int count=0; while(ss&gt;&gt;s2)&#123; reverse(s2.begin(),s2.end()); if(count==0)s3.append(s2); else s3.append(“ “+s2); &#125; cout&lt;&lt;s3;&#125; 5.11最短摘要的生成 https://www.cnblogs.com/pangxiaodong/archive/2011/09/08/2171551.html 数学问题 6.1 巧用进制解决天平称重问题 二进制可以代表取和不取，如每一位上为1就代表取相应的2^n个相应的砝码 本体思想就是三进制0代表不取这个砝码，1代表取这个砝码，2可以+1转换为进位和-1，其中-1代表放天平的另一边。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;string i2s(int num)&#123; //int类型转字符串string a;stringstream ss;ss&lt;&lt;num;ss&gt;&gt;a;return a;&#125;string zhuanhuan(long long num,int base)&#123;//进制转换 string ans=””; do&#123; int i=num%base; if(i&gt;=0&amp;&amp;i&lt;=9)ans+=i+’0’; else ans+=i-10+’a’; num/=base; &#125;while(num!=0); //reverse(ans.begin(),ans.end()); return ans;&#125;int main()&#123;long long num;cin&gt;&gt;num;string san=zhuanhuan(num,3);string ans=””;vector v;std::vector::iterator it=v.begin();for(int i=0;i&lt;san.length();i++)&#123;//因为没有反转，此时从低位往高位走 if(san[i]==’2’)&#123; v.push_back(-1); if(i==san.length()-1)&#123; v.push_back(1); &#125; else&#123; ++san[i+1]; &#125; &#125;else if(san[i]==’3’)&#123; v.push_back(0); if(i==san.length()-1)&#123; v.push_back(1); &#125; else&#123; ++san[i+1]; &#125; &#125;else&#123; v.push_back(san[i]-‘0’); &#125;&#125;reverse(v.begin(),v.end()); for(int i=0;i&lt;v.size();i++)&#123; if(v[i]==1)&#123; ans.append(“+”).append(i2s(pow(3,v.size()-i-1))); &#125; if(v[i]==-1)&#123; ans.append(“-“).append(i2s(pow(3,v.size()-i-1))); &#125; &#125; if(ans[0]==’+’)ans.erase(0,1); cout&lt;&lt;ans;&#125; 6.2 nim游戏 洛谷取火柴棒问题 1、桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。你们是聪明人，每一步都是最优解。这样的游戏有一个结论：如果石子的数量为4的倍数，一定是对手赢，否则，就是先手赢。 结论：一个Nim游戏中的状态是必败状态当且仅当每个子游戏的异或和为0，否则是必胜态。通过必胜态一定可以通过一步操作变成必败状态。 2、桌子上有一堆石头，两人对战，从任意一堆石子中取出任意数量的石子，至少取一颗，至多取这堆石子中剩下的个数。 拿掉最后一块石头的人就是获胜者。你作为先手。（这一题也是那个异或来求，因为你是先手，所以你面对着异或之后为0的情况就能赢；这题与洛谷上的那个取火柴棒的问题是有点不同的） 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;bool solve(int a[],int length)&#123; int res=0; for(int i=0;i&lt;length;i++)&#123; res^=a[i]; &#125;//因为先手面对着0的情况，则一定会赢;面对非零情况，则会输，所以要返回res！=0； return res!=0;&#125;int main()&#123; int a[]=&#123;3,10,15&#125;; bool res=solve(a,3); cout&lt;&lt;res;&#125; 6.3 解题nim问题 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;const int N=100;int data[N][N];int caseNum,length;string deal(int A[],int length)&#123; int len=sizeof(A)/sizeof(A[0]); //求数组长度的做法 sort(A,A+len); //因为测试数据有可能是乱序的 int res=0; if((len&amp;1)==1)&#123;//当len为奇数时就把第一个看为一份，为偶数就两两一份来当做nim问题异或 for (int i = 0; i &lt; len; i += 2) &#123; res ^= (i == 0) ? (A[0] - 1) : (A[i] - A[i - 1] - 1); &#125; &#125;else &#123; for (int i = 1; i &lt; len; i += 2) &#123; res ^= (A[i] - A[i - 1] - 1); &#125;&#125; if (res == 0) &#123; return “Bob will win\\n”; &#125; else &#123; return “Georgia will win\\n”; &#125;&#125;int main()&#123;cin&gt;&gt;caseNum;for(int i=0;i&lt;caseNum;i++)&#123; int k; cin&gt;&gt;k; for(int j=0;j&lt;k;j++) cin&gt;&gt;data[i][j];&#125;for(int l=0;l&lt;caseNum;l++)&#123; string res=deal(data[l],length); cout&lt;&lt;res;&#125;&#125; 结论的应用很重要 6.4 必备的求和公式 6.5 欧几里得算法 6.6 扩展欧几里得算法 123456789101112131415161718192021222324252627282930313233扩展欧几里得gcd(a,b)return b==0?a我们观察到：欧几里德算法停止的状态是： a’= gcd ， b’ = 0 ，(a’,b’是递归最后一层时参数的值)那么，这是否能给我们求解 x y 提供一种思路呢？a’x + b’y = gcd 此时x=1,y为任意数因为，这时候，只要 a = gcd 的系数是 1 ，那么只要 b 的系数是 0 或者其他值（无所谓是多少，反正任何数乘以 0 都等于 0 但是a 的系数一定要是 1），这时，我们就会有： a’1 + b’0 = gcd当然这是最终状态，但是我们是否可以从最终状态反推到最初的状态呢？假设当前我们要处理的是求出 a 和 b的最大公约数，并求出 x 和 y 使得 a*x + b*y= gcd ……(1式)，---&gt;要求的而我们已经求出了下一个状态：b 和 a%b 的最大公约数，并且求出了一组x1 和y1 使得： b*x1 + (a%b)*y1 = gcd (2式) ，--&gt;下一个状态那么这两个相邻的状态之间是否存在一种关系呢？a%b = k ==&gt; a = b*(a/b) +k &quot;/&quot;舍掉余数的除法 ==&gt; k=a-(a/b)*b我们知道： a%b = a - (a/b)*b（这里的 “/” 指的是整除，例如 5/2=2 , 1/3=0），那么，我们可以进一步得到： gcd = b*x1 + (a-(a/b)*b)*y1 = b*x1 + a*y1 – (a/b)*b*y1 = a*y1 + b*(x1 – a/b*y1) ……(3式)对比之前我们的状态,式(3)和式(1)：求一组 x 和 y 使得：a*x + b*y = gcd ，是否发现了什么？这里： x = y1 y = x1 – a/b*y1这就是递推式,注意x,y是递归过程中的上一层,x1,y1是下一层(下一个状态)得到的值 6.6 扩展欧几里得算法求贝祖等式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll x,y;/** 扩展欧几里得 传入a，b调用完成后x，y是ax+by=gcd(a,b)的解/ ll exgcd(ll a,ll b)&#123; if(b==0)&#123; x=1; y=0; return a; &#125; ll res=exgcd(b,a%b); //x,y已经被下一层递归更新了,ppt中所说的x0和y0 ll x1=x; //备份x x=y; //更新x y=x1-a/by; //更新y return res; &#125;/exgcd模板void exgcd(int a,int b,int&amp; d,int&amp; x,int&amp; y)&#123; if(!b)&#123;d=a,x=1,y=0;return;&#125; exgcd(b,a%b,d,y,x); y-=x(a/b);&#125;/ll linerEquation(ll a,ll b,ll m)&#123;ll d=exgcd(a,b); if(m%d!=0)&#123; cout&lt;&lt;” no ans”; &#125;else&#123; long n=m/d; x=n; y*=n; return d; &#125;&#125;int main()&#123; ll a,b,m; //求解ax+by=m cin&gt;&gt;a&gt;&gt;b&gt;&gt;m; linerEquation(a,b,m); cout&lt;&lt;x&lt;&lt;” “&lt;&lt;y;&#125; 6.8 求解同余方程 模可以看为一个圈，就比如 poj1061 青蛙的约会（同余方程的求解） 1234567891011121314151617181920212223242526272829303132333435363738#include#include&lt;math.h&gt;using namespace std;#define ll long longint flag=0;void exgcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)&#123; if(!b)&#123; d=a,x=1,y=0;return; &#125; exgcd(b,a%b,d,y,x);y-=x*(a/b);&#125;void linearEquation (ll d,ll m,ll &amp;x,ll &amp;y)&#123; if(m%d!=0)&#123; flag=1; &#125; else&#123; x=(m/d); y=(m/d); &#125;&#125;int main()&#123; ll x,y,m,n,l;//m，n为青蛙a，b一次跳的距离 cin&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;l; ll a=m-n; long b=l; m=y-x; //此时的m是ax+by=m中的m ll d=0;//d=gcd（a，b） exgcd(a,b,d,x,y); linearEquation(d,m,x,y); b/=d; b=abs(b);//运算之后b就是那个要x要变为最小的正解的最小正倍数 x=(x%b+b)%b; //让x变为那个最小的正解 if(flag==1)cout&lt;&lt;”Impossible”&lt;&lt;endl; else cout&lt;&lt;x&lt;&lt;endl;&#125; 模的逆元 1.乘法逆元（在维基百科中也叫倒数，当然是 mod p后的,其实就是倒数不是吗？）:如果ax≡1 (mod p),且gcd(a,p)&#x3D;1（a与p互质），则称a关于模p的乘法逆元为x。为什么可以用扩展欧几里得求得逆元？ *我们都知道模就是余数，比如12%5&#x3D;12-52&#x3D;2，18%4&#x3D;18-4*4&#x3D;2。（&#x2F;是程序运算中的除）那么ax≡1 (mod p)即ax-yp&#x3D;1.把y写成+的形式就是ax+py&#x3D;1，为方便理解下面我们把p写成b就是ax+by&#x3D;1。就表示x是a的模b乘法逆元，y是b的模a乘法逆元。然后就可以用扩展欧几里得求了。知道.逆元怎么算之后，那么乘法逆元有什么用呢？做题时如果结果过大一般都会让你模一个数，确保结果不是很大，而这个数一般是1e9+7，而且这个数又是个素数，加减乘与模运算的顺序交换不会影响结果，但是除法不行。有的题目要求结果mod一个大质数，如果原本的结果中有除法，比如除以a,那就可以乘以a的逆元替代。（除一个数等于乘它的倒数，虽然这里的逆元不完全是倒数，但可以这么理解，毕竟乘法逆元就是倒数的扩展）。 模的运算规则 %运算法则 乘法的,因为( a%p) (b%p)这个有可能会大于p，所以对总结果再%p(ab) %p&#x3D; （ ( a%p) *(b%p) ）%p 除法的 （b^(-1）表示b的逆元)(a&#x2F;b) %p&#x3D;（ ( a *b^(-1)%p) ）%p 乘方(a^b) % p &#x3D; ((a % p)^b) % p 6.11 同余方程组 6.12 ？？ 6.13 ？？ 6.14 快速幂运算 － 其中矩阵和斐波那锲是有关系的 即： 1234567891011121314151617181920212223242526const int N=10;int tmp[N][N];void multi(int a[][N],int b[][N],int n)&#123; memset(tmp,0,sizeof tmp); for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) for(int k=0;k&lt;n;k++) tmp[i][j]+=a[i][k]b[k][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) a[i][j]=tmp[i][j];&#125;int res[N][N];void Pow(int a[][N],int n)&#123; memset(res,0,sizeof res);//n是幂，N是矩阵大小 for(int i=0;i&lt;N;i++) res[i][i]=1; while(n) &#123; if(n&amp;1) multi(res,a,N);//res=resa;复制直接在multi里面实现了； multi(a,a,N);//a=a*a n&gt;&gt;=1; &#125;&#125; 递归，DFS，剪枝，回溯等问题 7.1 递归（本质上是数学归纳，可以从简单的例子，一步一步的递推，直到找到问题的答案）： 递推就是一种由少到多，递推可以分为递归（由少到多，由简到繁，归一）和迭代两种表现形式，递归比迭代有更强的表达能力，其中有记忆性的递归就叫动态规划。 7.2 双管齐下的解决递归问题： 7.3 机器人走方格 7.5 硬币表示某个面值 其中走楼梯，机器人走格子，硬币表示某个面值这三题都是逐步生成结果类问题之数值型 7.6 合法括号（逐步生成结果之非数值型）其中每种每个类型都能分解成另三种情况，但是有重复的，所以就可以用set集合来去重。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;//迭代形式set&lt;string&gt; parenthesis1(int n)&#123; set&lt;string&gt;res; res.insert(&quot;()&quot;); if(n==1)&#123; return res; &#125; for(int i=2;i&lt;=n;i++)&#123; set&lt;string&gt;res_new; for(set&lt;string&gt;::iterator it=res.begin();it!=res.end();it++)&#123; res_new.insert(*it+&quot;()&quot;); res_new.insert(&quot;()&quot;+*it); res_new.insert(&quot;(&quot;+*it+&quot;)&quot;); &#125; res=res_new; &#125; return res;&#125; //递归公式求解 set&lt;string&gt; parenthesis(int n)&#123; set&lt;string&gt;s_n; if(n==1)&#123; s_n.insert(&quot;()&quot;); return s_n; &#125; set&lt;string&gt;s_n_1=parenthesis(n-1); for(set&lt;string&gt;::iterator it=s_n_1.begin();it!=s_n_1.end();it++)&#123; s_n.insert(&quot;()&quot;+*it); s_n.insert(*it+&quot;()&quot;); s_n.insert(&quot;(&quot;+*it+&quot;)&quot;); &#125; return s_n;&#125; int main()&#123; int n; cin&gt;&gt;n; set&lt;string&gt;s; s=parenthesis(n); //s=parenthesis1(n); for(set&lt;string&gt;::iterator it=s.begin();it!=s.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125;&#125; -7.6 子集的生成子集就是一个选和不选的问题，括号是加左加右还是加中间的问题。c++实现生成子集 1234567891011121314151617181920212223242526272829303132/*算法思想 例如求4个元素 3 2 1 0 的子集。 那么用二进制的1代表每一位是否选中。十进制 二进制 0 0000 代表空集1 0001 代表&#123;0&#125;2 0010 代表&#123;1&#125;3 0011 代表&#123;0,1&#125;4 0100 代表&#123;2&#125; ...15 1110 代表&#123;3,2,1&#125;16 1111 代表&#123;3,2,1,0&#125; 如果n很大的话可以用字符串模拟二进制 */# include &lt;stdio.h&gt;# include &lt;algorithm&gt;using namespace std;//二进制法求子集 void print_subset(int n,int s)&#123; for(int i=0;i&lt;n;i++)&#123; if(s &amp; (1&lt;&lt;i)) //1左移i位，监测s的哪一位为1，为1的话输出 printf(&quot;%d &quot;,i); &#125; printf(&quot;\\n&quot;);&#125; int main() &#123; int n=3; for(int i=0;i&lt;(1&lt;&lt;n);i++)&#123;//1左移n位等价于2^n-1.因为子集个数2^n-1 print_subset(n,i); &#125; return 0;&#125; 比如有一个集合{0,1,2…n-1}那么我们可以进行如下操作： 12345678空集.............................0只含有第i个元素的集合&#123;i&#125;............1&lt;&lt;i含有全部n个元素的集合&#123;0,1...n-1&#125;....(1&lt;&lt;n)-1//含有n个元素的全集判断第i个元素是否属于集合S...........if(S&gt;&gt;i&amp;1)向集合中加入第i个元素S∪&#123;i&#125;..........s|1&lt;&lt;i从集合中取出第i个元素...............s&amp;~(1&lt;&lt;i)集合S和T的并集S∪T.................S|T集合S和T的交集S∩T.................S&amp;T 比如 只含有第i个元素的集合为什么可以表示成1&lt;&lt;i 举个例子 比如只含有第2个元素的集合 那么 1&lt;&lt;2&#x3D;2^2 二进制表示就是100 第0个元素没有 因为在第0位置为0 第1个元素没有因为在第1位置为0 第2个元素为1 表示有第二个元素 所以就这样表示（它是倒着来的）。 比如 含有全部n个元素的集合{0,1…n-1}….(1&lt;&lt;n)-1&#x2F;&#x2F;含有n个元素的全集 举个例子 含有全部3个元素的集合 {0，1，2} 那么(1&lt;&lt;3)-1 &#x3D; 7&#x3D;111(二进制) 是不是对应二进制位置都为1 比如 判断第i个元素是否属于集合S………..if(S&gt;&gt;i&amp;1) 举个例子 比如一个集合s{1 2 3} 判断它的第2个元素是否属于s 将它的二进制111 右移2位得到001 与1位与 得到1 说明第二个元素属于集合s。 这第0个元素也代表一个确切的元素，而不一定就是为0，没有东西（空集），比如上面那个s集合，第0个元素,111（代表全集）右移0位和1与运算，得到1，代表1在集合内 贪心策略与动态规划 8.1快速渡河问题 123456789101112131415161718192021222324252627282930313233//#include&lt;iostream&gt;//#include&lt;algorithm&gt;//using namespace std;int speed[1010];输入后，按从小到大排序 void f(int n) &#123; int left = n; int ans = 0; while (left &gt; 0) &#123; if (left == 1) &#123;//只有1人 ans += speed[0]; break; &#125; else if (left == 2) &#123;//只有两人 ans += speed[1]; break; &#125; else if (left == 3) &#123;//有三人 ans += speed[2] + speed[0] + speed[1]; break; &#125; else &#123; //1，2出发，1返回，最后两名出发，2返回 int s1 = speed[1] + speed[0] + speed[left - 1] + speed[1]; //1，3出发，1返回，1，4出发，1返回，1，2过河 int s2 = speed[left - 1] + speed[left - 2] + 2 * speed[0]; //其中s1和s2中都少写一个b，是因为在left==2的时候加上了 ans += min(s1, s2); left -= 2;//左侧是渡河的起点，left代表左侧的剩余人数 &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 8.2 区间调度问题有n项工作,每项工作分别在si时间开始,在ti时间结束.对于每项工作,你都可以选择参与与否.如果选择了参与,那么自始至终都必须全程参与.此外,参与工作的时间段不能重复(即使是开始的瞬间 和结束的瞬间的重叠也是不允许的).你的目标是参与尽可能多的工作,那么最多能参与多少项工作呢?1≤n≤1000001≤si≤ti≤10^9 输入:第一行:n第二行:n个整数空格隔开,代表n个工作的开始时间第三行:n个整数空格隔开,代表n个工作的结束时间 样例输入:51 3 1 6 83 5 2 9 10样例输出:3 说明:选取工作1,3,5 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;//方法二：按左端点从大到小来排列 using namespace std;const int maxn=110;struct Inteval&#123; int x,y;//开区间的左右端点 &#125;I[maxn];bool cmp(Inteval a,Inteval b)&#123; if(a.x!=b.x)return a.x&gt;b.x;//先按左端点从大到小排 else return a.y&lt;b.y;//左端点相同按右端点从小到大排列 &#125;int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n!=0)&#123; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;I[i].x&gt;&gt;I[i].y; &#125; sort(I,I+n,cmp);//把区间排序 int ans=1;int lastX=I[0].x; for(int i=1;i&lt;n;i++)&#123; id(I[i].y&lt;=lastX)&#123;//若果该区间右端点在lastX的左边 lastX=I[i].x;//以I[i]作为新选中的区间 ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; /*方法一java实现的：private static int f(int n, Job[] jobs) &#123; int cnt = 1; int y = jobs[0].t; for (int i = 0; i &lt; n; i++) &#123; if (jobs[i].s &gt; y) &#123; cnt++; y = jobs[i].t; &#125; &#125; return cnt; &#125; */ 8.3 区间选点问题-POJ1201数轴上有n个闭区间[ai,bi]。取尽量少的点，使得每个区间内都至少有一个点（不同区间内含的点可以是同一个）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//用树状数组才可以不超时public class Case04_区间选点问题II &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); Interval[] intervals = new Interval[n]; for (int i = 0; i &lt; n; i++) &#123; intervals[i] = new Interval(sc.nextInt(), sc.nextInt(), sc.nextInt()); &#125; Arrays.sort(intervals);//按区间右端点排序 int max = intervals[n - 1].t;//右端最大值 int[] axis = new int[max + 1]; int[] c = new int[max + 2]; // int[] sums = new int[max + 1]; for (int i = 0; i &lt; n; i++) &#123; //1.查阅区间中有多少个点 int s = intervals[i].s;//起点 int t = intervals[i].t;//终点 int cnt = sum(t + 1, c, max + 1) - sum(s, c, max + 1);//sum(axis,s,t);//sums[t] - sums[s - 1];//效率低 // 2.如果不够，从区间右端开始标记，遇标记过的就跳过 intervals[i].c -= cnt; while (intervals[i].c &gt; 0) &#123; if (axis[t] == 0) &#123; axis[t] = 1; update(t + 1, 1, c, max + 1); intervals[i].c--; t--; &#125; else &#123; t--; &#125; &#125; &#125; System.out.println(sum(max + 2, c, max + 1)); &#125; /** * 更新树状数组c，注意i是项数，不是下标，而是下标+1*/ private static void update(int i, int delta, int[] c, int n) &#123; for (; i &lt;= n; i += lowbit(i)) &#123; c[i] += delta; &#125; &#125; /** * 前i项和，注意：i不是下标 * @param i * @return */ private static int sum(int i, int[] c, int n) &#123; int sum = 0; if (i &gt; n) i = n; for (; i &gt; 0; i -= lowbit(i)) &#123; sum += c[i]; &#125; return sum; &#125; /** * 它通过公式来得出k，其中k就是该值从末尾开始1的位置。 * 然后将其得出的结果加上x自身就可以得出当前节点的父亲节点的位置 * 或者是x减去其结果就可以得出上一个父亲节点的位置。 * 比如当前是6，二进制就是0110，k为2，那么6+2=8，C(8)则是C(6)的父亲节点的位置； * 相反，6-2=4，则是C(6)的上一个父亲节点的位置。*/ static int lowbit(int x) &#123; return x - (x &amp; (x - 1)); &#125; private static class Interval implements Comparable&lt;Interval&gt; &#123; int s; int t; int c; public Interval(int s, int t, int c) &#123; this.s = s; this.t = t; this.c = c; &#125; @Override public int compareTo(Interval other) &#123; int x = this.t - other.t; if (x == 0) return this.s - other.s; else return x; &#125; &#125;&#125; 8.4 区间覆盖问题 -poj2376选最少的区间片段覆盖这一整个区域，问最少的区间数是多少？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Case05_区间覆盖问题 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); int T = sc.nextInt(); Job[] jobs = new Job[N]; for (int i = 0; i &lt; N; i++) &#123; jobs[i] = new Job(sc.nextInt(), sc.nextInt()); &#125; Arrays.sort(jobs); int start = 1;//要覆盖的目标点，end覆盖该点的所有区间中右端点最右 int end = 1; int ans = 1; for (int i = 0; i &lt; N; i++) &#123; int s = jobs[i].s; int t = jobs[i].t; if (i == 0 &amp;&amp; s &gt; 1) break; if (s &lt;= start) &#123;//当前区间有可能覆盖start end = max(t, end);//更新更右的端点 &#125; else &#123;//开始下一个区间 ans++;//上一个目标覆盖已经达成，计数加1 start = end + 1;//更新起点，设置一个新的覆盖目标 if (s &lt;= start) &#123; end = max(t, end); &#125; else &#123; break; &#125; &#125; if (end &gt;= T) &#123;//当前的end超越了线段的右侧 break; &#125; &#125; if (end &lt; T) System.out.println(-1); else System.out.println(ans); &#125; private static class Job implements Comparable&lt;Job&gt; &#123; int s; int t; public Job(int s, int t) &#123; this.s = s; this.t = t; &#125; /**按照区间起点排序*/ @Override public int compareTo(Job other) &#123; int x = this.s - other.s; if (x == 0) return this.t - other.t; else return x; &#125; &#125;&#125; 字典序最小的问题（POJ - 3617）字典序最小问题给一个定长为N的字符串S,构造一个字符串T,长度也为N。起初，T是一个空串，随后反复进行下列任意操作 从S的头部删除一个字符，加到T的尾部 从S的尾部删除一个字符，加到T的尾部目标是最后生成的字符串T的字典序尽可能小1≤N≤2000字符串S只包含大写英文字母输入：字符串S输出：字符串T 要求每80个字符换行输出 12345678910111213141516171819202122232425262728293031323334353637public class Case06_字典序最小问题 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int N = sc.nextInt(); StringBuilder ss = new StringBuilder(); for (int i = 0; i &lt; N; i++) &#123; ss.append(sc.next()); &#125; // String s = sc.nextLine(); f(ss.toString()); &#125; private static void f(String s) &#123; String s1 = new StringBuilder(s).reverse().toString(); int N = s.length(); StringBuilder rs = new StringBuilder(); int cnt = 0; while (rs.length() &lt; N) &#123; if (s.compareTo(s1) &lt;= 0) &#123; rs.append(s.charAt(0)); s = s.substring(1); &#125; else &#123; rs.append(s1.charAt(0)); s1 = s1.substring(1); &#125; //字符满80个就换行 if (rs.length() % 80 == 0) &#123; System.out.println(rs.substring(cnt * 80, (cnt + 1) * 80)); cnt++; &#125; &#125; //余数部分 if (rs.length() &gt; cnt * 80) &#123; System.out.println(rs.substring(cnt * 80)); &#125; &#125; 背包问题 背包问题 123456789101112131415161718192021222324252627282930313233/** * 给出n个物体，第i个物体重量为wi。选择尽量多的物体，不能取一部分，使得总重量不超过C。 * 01背包 */public class Case07_最优装载问题 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] w = new int[n]; for (int i = 0; i &lt; n; i++) &#123; w[i] = sc.nextInt(); &#125; int C = sc.nextInt(); Arrays.sort(w); int ans = f(n, w, C); System.out.println(ans); &#125; private static int f(int n, int[] w, int c) &#123; int sum = 0; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; sum += w[i]; if (sum &lt;= c) &#123; cnt++; &#125; else &#123; break; &#125; &#125; return cnt; &#125;&#125; 部分背包（部分指的是一个物体可以取一部分） 有n个物体，第i个物体的重量为wi，价值为vi。在总重量不超过C的情况下让总价值尽量高。 每一个物体都可以只取走一部分，价值和重量按比例计算。 求最大总价值 注意：每个物体可以只拿一部分，因此一定可以让总重量恰好为C。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Case08_部分背包问题 &#123; public static void main(String[] args) &#123; int[] w = &#123;1, 2, 3, 4, 5&#125;;//背包中物体的重量 int[] v = &#123;3, 4, 3, 1, 4&#125;;//物体的价值 int n = w.length; double C = 10;//背包的容量 Obj[] objs = new Obj[n]; for (int i = 0; i &lt; n; i++) &#123; objs[i] = new Obj(w[i], v[i]); &#125; Arrays.sort(objs); double c = C; double maxValue = 0; for (int i = n - 1; i &gt;= 0; i--) &#123; if (objs[i].w &lt;= c) &#123;//每一次判断一下当前背包的容量是否还可以继续装一个物体 maxValue += objs[i].v; c -= objs[i].w; &#125; else &#123; maxValue += objs[i].v * (c / objs[i].w);//取全部的会超重，所以只取一部分 break;//取完这一部分，就装满了 &#125; &#125; System.out.println(maxValue); &#125; private static class Obj implements Comparable&lt;Obj&gt; &#123; int w; int v; public Obj(int w, int v) &#123; this.w = w; this.v = v; &#125; public double getPrice() &#123; return v / (double) w; &#125; public int compareTo(Obj o) &#123; if (this.getPrice() == o.getPrice()) return 0; else if (this.getPrice() &lt; o.getPrice()) return -1; else return 1; &#125; &#125;&#125; 乘船问题有n个人，第i个人重量为wi。每艘船的最大载重量均为C，且最多只能乘两个人。用最少的船装载所有人。 求需要船的数量 贪心策略：考虑最轻的人i，如果每个人都无法和他一起坐船（重量和超过C），则唯一的方案是每个人坐一艘 否则，他应该选择能和他一起坐船的人中最重的一个j 123456789101112131415161718192021222324252627 public class Case09_乘船问题 &#123; public static void main(String[] args) &#123; int[] w = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;; int n = w.length; int c = 10; Arrays.sort(w); int cntOfPerson = n; int cntOfBoat = 0; int p1 = 0;//两个指针分别指向头和尾 int p2 = n - 1; while (cntOfPerson &gt; 0) &#123; if (p1 + p2 &gt; c) &#123; p2--;//如果两个人的重量大于c，那么只能中的那个人自己走 cntOfPerson--; cntOfBoat++; &#125; else &#123; p1++; p2--; cntOfPerson -= 2; cntOfBoat++; &#125; &#125; System.out.println(cntOfBoat); &#125;&#125; 以上贪心策略的总结 动态规划 什么是动态规划 01背包问题的三种解法：其中dp解法的图表为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/*有n个重量和价值分别为wi，vi的物品，从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和的最大值。 1≤n≤100 1≤wi，vi≤100 1≤W≤10000输入： n=4 (w,v)=&#123;(2,3),(1,2),(3,4),(2,2)&#125; W=5输出： 7（选择第0，1，3号物品）因为对每个物品只有选和不选两种情况，所以这个问题称为01背包。 */public class Case10_01背包问题 &#123; static int[] w = &#123;2, 1, 3, 2&#125;;//重量表 static int[] v = &#123;3, 2, 4, 2&#125;;//价值表 static int n = 4;//物品数量 static int W = 5;//背包的承重极限 public static void main(String[] args) &#123; int ww = W; int ans = dfs(0, ww); System.out.println(&quot;方法一:&quot;+ans); rec = new int[n][W + 1]; for (int i = 0; i &lt; n; i++) &#123; Arrays.fill(rec[i], -1); &#125; ww = W; ans = m(0, ww); System.out.println(&quot;方法二:&quot;+ans); System.out.println(&quot;方法三:&quot;+dp()); &#125; /**方法一：dfs * 2^n的复杂度 */ static int dfs(int i, int ww) &#123;//深搜的做法，每一个递归树都找一下 if (ww &lt;= 0) return 0;//装不进去 if (i == n) return 0;//没东西可选了 int v2 = dfs(i + 1, ww);//不选择当前物品 if (ww &gt;= w[i]) &#123; int v1 = v[i] + dfs(i + 1, ww - w[i]);//选择当前物品 return max(v1, v2); &#125; else &#123; return v2; &#125; &#125; /**方法二： * 记忆型递归 */ static int[][] rec;//记录的是递归树中某个节点的值 static int m(int i, int ww) &#123; if (ww &lt;= 0) return 0; if (i == n) return 0; //1.计算之前先查询 if (rec[i][ww] &gt;= 0) return rec[i][ww]; int v2 = m(i + 1, ww);//不选择当前物品 int ans; if (ww &gt;= w[i]) &#123; int v1 = v[i] + m(i + 1, ww - w[i]);//选择当前物品 ans = max(v1, v2); &#125; else &#123; ans = v2; &#125; //2.计算之后做保存 rec[i][ww] = ans; return ans; &#125; //方法三：dp static int dp() &#123; int[][] dp = new int[n][W + 1]; //初始化dp表的第一行 for (int i = 0; i &lt; W + 1; i++) &#123;//i为每一列的值，就是容量的大小 if (i &gt;= w[0]) &#123;// 每种容量-0号物品，大于0就表示要的起 dp[0][i] = v[0]; &#125; else &#123; dp[0][i] = 0; &#125; &#125; // 其他行，下面的for中i为行号 for (int i = 1; i &lt; n; i++) &#123; // j是列，也是背包的剩余容量 for (int j = 0; j &lt; W + 1; j++) &#123; if (j &gt;= w[i]) &#123;//要得起 int i1 = v[i] + dp[i - 1][j - w[i]];//选择当前物品即i号物品的价值+上一步剩余容量所能达到的最大价值 int i2 = dp[i - 1][j];//不选本件物品所能达到的最大价值 dp[i][j] = max(i1, i2);//取两者的最大值 &#125; else &#123; dp[i][j] = dp[i - 1][j];//要不起，就直接赋值为j所能取得最大价值 &#125; &#125; &#125; return dp[n - 1][W];//最后一个单元格的值就是最终结果 &#125; 钢条切割问题 算法导论1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*Serling公司购买长钢条，将其切割为短钢条出售。切割工序本身没有成本支出。公司管理层希望知道最佳的切割方案。假定我们知道Serling公司出售一段长为i英寸的钢条的价格为pi(i=1,2,…，单位为美元)。钢条的长度均为整英寸。| 长度i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 || - | - | - | - | - | - | - | - | - | - |价格pi | 1 | 5 | 8 | 16 | 10 | 17 | 17 | 20 | 24 | 30 |钢条切割问题是这样的：给定一段长度为n英寸的钢条和一个价格表pi(i=1,2,…n)，求切割钢条方案，使得销售收益rn最大。注意，如果长度为n英寸的钢条的价格pn足够大，最优解可能就是完全不需要切割。 */public class Case11_钢条切割 &#123; static int n = 10; static int[] p = &#123;1, 5, 8, 16, 10, 17, 17, 20, 24, 30&#125;; static int[] vs = new int[n + 1]; /**记忆性递归 * @param x 钢条的长度 */ static int r(int x) &#123; if (x == 0) &#123; return 0; &#125; int ans = 0; for (int i = 1; i &lt;= x; i++) &#123; if (vs[x - i] == -1)//先查，没有的话再递归 vs[x - i] = r(x - i); int v = p[i - 1] + vs[x - i];//保留一段为整段，然后剩下的进行递归来求解，很巧妙 ans = max(v, ans); &#125; vs[x] = ans;//递归之后，赋值 return ans; &#125; static int dp() &#123; vs[0] = 0; for (int i = 1; i &lt;= n; i++) &#123;//拥有的钢条长度 for (int j = 1; j &lt;= i; j++) &#123;//保留j为整段 vs[i] = max(p[j - 1] + vs[i - j], vs[i]); &#125; //区别01背包中只有取和不取两种状态，而这个里为取一段和剩下一段来递归的两种分解方式 &#125; return vs[n]; &#125; public static void main(String[] args) &#123; Arrays.fill(vs, -1); int ans = r(n); System.out.println(ans); Arrays.fill(vs, 0); ans = dp(); System.out.println(ans); &#125;&#125; 数字三角形可以把一个二维数组简化为一个一维数组，因为上面这一个值的大小不取决于它的左侧，所以覆盖了没有影响，这就是滚动数组。其中数字三角形是位置在改变，而钢条切割是长度在变，01背包是容量在变 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** * 数字三角形(POJ1163)&lt;br&gt; * * 在数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。&lt;br&gt; * 路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。&lt;br&gt; * 三角形的行数大于1小于等于100，数字为 0 - 99&lt;br&gt; * 输入格式：&lt;br&gt; * 5 //表示三角形的行数 接下来输入三角形&lt;br&gt; * 7&lt;br&gt; * 3 8&lt;br&gt; * 8 1 0&lt;br&gt; * 2 7 4 4&lt;br&gt; * 4 5 2 6 5&lt;br&gt; * 要求输出最大和&lt;br&gt; * * @author zhengwei * */public class Case12_POJ1163_数字三角形 &#123; public static void main(String[] args) &#123; // int[][] triangle = &#123; // &#123;7&#125;, // &#123;3, 8&#125;, // &#123;8, 1, 0&#125;, // &#123;2, 7, 4, 4&#125;, // &#123;4, 5, 2, 6, 5&#125;, // &#123;4, 5, 2, 6, 5, 7&#125;, // &#123;4, 13, 12, 88, 6, 6, 5&#125;, // &#123;3, 8, 7, 11, 9, 22, 66, 3&#125;, // &#125;; // Instant now = Instant.now(); // System.out.println(maxSumUsingRecursive(triangle, 0, 0)); // System.out.println(&quot;持续时间为：&quot; + Duration.ofMillis(Instant.now().toEpochMilli() - now.toEpochMilli()).getSeconds()); // now = Instant.now(); // System.out.println(maxSumUsingMemory(triangle, 0, 0, new int[8][8])); // System.out.println(&quot;持续时间为：&quot; + Duration.ofMillis(Instant.now().toEpochMilli() - now.toEpochMilli()).getSeconds()); Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[][] triangle = new int[n][]; for (int i = 0; i &lt; n; i++) &#123; triangle[i] = new int[i + 1]; for (int j = 0; j &lt; i + 1; j++) &#123; triangle[i][j] = sc.nextInt(); &#125; &#125; System.out.println(maxSumUsingDp(triangle, 0, 0)); &#125; /** * * @param triangle * 数字三角形 * @param i * 起点行号 * @param j * 起点列号 * @return 计算出的最大和 */ public static int maxSumUsingRecursive(int[][] triangle, int i, int j) &#123; int rowIndex = triangle.length; if (i == rowIndex - 1) &#123; return triangle[i][j]; &#125; else &#123; //顶点的值+max(左侧支线的最大值，右侧支路的最大值) return triangle[i][j] + max(maxSumUsingRecursive(triangle, i + 1, j), maxSumUsingRecursive(triangle, i + 1, j + 1)); &#125; &#125; /** * 记忆型递归 * @param triangle * @param i * @param j * @return */ public static int maxSumUsingMemory(int[][] triangle, int i, int j, int[][] map) &#123; int rowIndex = triangle.length; int value = triangle[i][j]; if (i == rowIndex - 1) &#123; &#125; else &#123; //缓存有值，便不递归 int v1 = map[i + 1][j]; if (v1 == 0) &#123; v1 = maxSumUsingMemory(triangle, i + 1, j, map); &#125; //缓存有值，便不递归 int v2 = map[i + 1][j + 1]; if (v2 == 0) &#123; v2 = maxSumUsingMemory(triangle, i + 1, j + 1, map); &#125; value = value + max(v1, v2); &#125; //放入缓存 map[i][j] = value; return value; &#125; public static int maxSumUsingDp(int[][] triangle, int i, int j) &#123; int rowCount = triangle.length;//行数 int columnCount = triangle[rowCount - 1].length;//最后一行的列数 int[] dp = new int[columnCount];//利用滚动数组来做 for (int k = 0; k &lt; columnCount; k++) &#123; dp[k] = triangle[rowCount - 1][k];//初始化最后一行 &#125; for (int k = rowCount - 2; k &gt;= 0; k--) &#123; for (int l = 0; l &lt;= k; l++) &#123; dp[l] = triangle[k][l] + max(dp[l], dp[l + 1]); &#125; &#125; return dp[0]; &#125;&#125; 最长间断子序列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * 求最大公共子序列问题 * AB34C * A1BC2 结果为 ABC * 更多案例请看测试用例 * */public class Case13_LCS &#123; public static void main(String[] args) &#123; Case13_LCS obj = new Case13_LCS(); // System.out.println(obj.solution(&quot;AB34C&quot;, &quot;A1BC2&quot;)); // Assertions.assertThat(obj.solution(&quot;3563243&quot;, &quot;513141&quot;)).isEqualTo(&quot;534&quot;); // Assertions.assertThat(obj.solution(&quot;3069248&quot;, &quot;513164318&quot;)).isEqualTo(&quot;3648&quot;);//断言 ArrayList ans = obj.dfs(&quot;AB34C&quot;, &quot;A1BC2&quot;); System.out.println(ans); System.out.println(obj.dfs(&quot;3563243&quot;, &quot;513141&quot;)); System.out.println(obj.dfs(&quot;3069248&quot;, &quot;513164318&quot;)); System.out.println(obj.dfs(&quot;123&quot;, &quot;456&quot;)); &#125; //用dfs来暴力求解 ArrayList&lt;Character&gt; dfs(String s1, String s2) &#123; int len1 = s1.length(); int len2 = s2.length(); ArrayList&lt;Character&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; len1; i++) &#123; //求以i字符开头的公共子序列 ArrayList&lt;Character&gt; list = new ArrayList&lt;&gt;(); //和s2的每个字符比较 for (int j = 0; j &lt; len2; j++) &#123; if (s1.charAt(i) == s2.charAt(j)) &#123;//如果相同 list.add(s1.charAt(i)); list.addAll(dfs(s1.substring(i + 1), s2.substring(j + 1))); break; &#125; &#125; if (list.size() &gt; ans.size()) &#123; ans = list; &#125; &#125; return ans; &#125; /** * 生成动规表 * @param s1 * @param s2 * @return */ String solution(String s1, String s2) &#123; int len1 = s1.length(); int len2 = s2.length(); int[][] dp = new int[len1 + 1][len2 + 1]; // 动规数组 int flag = 0; // 初始化第一列 //O(M) for (int i = 1; i &lt;= len1; i++) &#123; if (flag == 1) &#123;//如果历史上有过1或者比较的两者相等的时候就为1 dp[i][1] = 1; &#125; else if (s1.charAt(i - 1) == s2.charAt(0)) &#123; dp[i][1] = 1; flag = 1; &#125; else &#123; dp[i][1] = 0; &#125; &#125; flag = 0; //初始化第一行 //O(N) for (int j = 1; j &lt;= len2; j++) &#123; if (flag == 1) &#123; dp[1][j] = 1; &#125; else if (s2.charAt(j - 1) == s1.charAt(0)) &#123; dp[1][j] = 1; flag = 1; &#125; else &#123; dp[1][j] = 0; &#125; &#125; //O(M*N) for (int i = 2; i &lt;= len1; i++) &#123; // M for (int j = 2; j &lt;= len2; j++) &#123; // N int maxOfLeftAndUp = Math.max(dp[i - 1][j], dp[i][j - 1]); if (s1.charAt(i - 1) == s2.charAt(j - 1)) &#123; // dp[i][j] = Math.max(maxOfLeftAndUp, dp[i - 1][j - 1] + 1); dp[i][j] = dp[i - 1][j - 1] + 1;//若果比较的两个字符相等，那么等于左上角的数值+1 &#125; else &#123;//如果比较的不相等，那么等于上，左上，左三者的最大值 dp[i][j] = maxOfLeftAndUp; &#125; &#125; &#125; // Util.printMatrix(dp); return parseDp(dp, s1, s2); &#125; /** * 解析动态规划表，得到最长公共子序列 * @param dp * @param s1 * @param s2 * @return */ private String parseDp(int[][] dp, String s1, String s2) &#123; int M = s1.length(); int N = s2.length(); StringBuilder sb = new StringBuilder(); while (M &gt; 0 &amp;&amp; N &gt; 0) &#123; // 比左和上大，一定是当前位置的字符相等 if (dp[M][N] &gt; Math.max(dp[M - 1][N], dp[M][N - 1])) &#123; sb.insert(0, s1.charAt(M - 1)); M--; N--; &#125; else &#123; // 一定选择的是左边和上边的大者，因为比较的两者不相同的时候贡献来自左上角 if (dp[M - 1][N] &gt; dp[M][N - 1]) &#123; M--; //往上移 &#125; else &#123; N--; // 往左移 &#125; &#125; &#125; return sb.toString(); &#125;&#125; 完全背包问题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 物品数量无限 * 完全背包问题 * 首先在初始化最后一行的时候有所不同：初始化时，当只考虑一件物品a时，state[row][j] = values[row]*j/weight[row] * 然后在递推的时候有些不同：state[row][j] = max&#123;state[row+1][j],state[row][j-weight[row]]+values[row]&#125;，即不抓时用现在的容量去匹配下面行 * 要抓的时候，先抓到这个物品的价值，然后用剩下的容量去匹配同一行，为什么匹配同一行，这是因为剩下的容量可以重复抓当前物品（不限数量） * * 同时必须理解，抓一个之后用剩余的容量重新考虑当前可选的所有物品其实包含了抓2个甚至更多的情况！！！ * @author zhengwei */public class Case14_完全背包问题 &#123; static int[] values = &#123;9, 5, 3, 1&#125;; static int[] weights = &#123;7, 4, 3, 2&#125;; static int n = 4; static int total = 10; public static void main(String[] args) &#123; dp(); &#125; static int[][] state = new int[n][total + 1];//不同的物品范围下不同的容量能装出来的最大价值 /*** * 递推 */ static void dp() &#123; // row 行号 int row = n - 1;//此数组从下往上进行赋值的，从上往下也是一样的 //v是容量 int v = 1; int w = weights[row]; for (; v &lt; total + 1; v++) &#123; state[row][v] = values[row] * v / w;//dp数组的含义为当前当前这么大的容量所能取物品的最大价值 &#125; for (int r = row - 1; r &gt;= 0; r--) &#123; //r 当前处理的行，也是当前处理的物品 w = weights[r]; for (int c = 1; c &lt; total + 1; c++) &#123; //c 当前处理的容量 //背包的容量还足以取本物品时 if (c &gt;= w) &#123; // 要要取本物品 int v1 = values[r] + state[r][c - w];//其实这个state[r][c - w]就包括了取一次，取两次 // 不取本物品 int v2 = state[r + 1][c]; state[r][c] = Math.max(v1, v2); &#125; else &#123; // 不能抓 state[r][c] = state[r + 1][c]; &#125; &#125; &#125; System.out.println(state[0][total]); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"蓝桥杯算法","slug":"蓝桥杯算法","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%97%E6%B3%95/"}],"author":"aoyuehan"},{"title":"反汇编","slug":"反汇编","date":"2020-03-12T10:54:00.000Z","updated":"2022-02-26T04:29:56.803Z","comments":true,"path":"2020/03/12/反汇编/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/12/%E5%8F%8D%E6%B1%87%E7%BC%96/","excerpt":"","text":"","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[],"author":"aoyuehan"},{"title":"汇编笔记","slug":"汇编笔记","date":"2020-03-12T10:45:00.000Z","updated":"2022-02-26T03:51:21.587Z","comments":true,"path":"2020/03/12/汇编笔记/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/12/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第一章的几次作业 mov和add的用法这一题中的ds：0000和0000:0010是同一个物理地址，是等价的。 栈的应用 一次测验 课堂派测验三 补充：当sp为0的时候，再次压栈发生栈顶超界，即当sp&#x3D;0的时候，在压栈的时候ss的值不变，sp变为0-2&#x3D;fffe，所以会超界。 测验2 测验1 总结笔记1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111. 1个CPU的寻址能力为8KB，那么它的地址总线宽度为 13。解析：一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N。这样的CPU最多可以寻址2的N次方个内存单元。8 KB=2^13 bit一根地址总线寻址为2^1=210根地址总线就是2^10=1024byte=1KB13根就是2^13=8KBN根就是2^Nbit是位byte是字节但是在cpu中一个byte就是一个位2. 1KB的存储器有 1024 个存储单元？存储单元的编号从 0 到 1023。解析：微型机存储器的存储单元可以存储一个字节，即八个二进制位。每个存储单元从0开始顺序编号。1 KB = 1024 B3. 1KB的存储器可以存储 2^13 个bit，1024 个byte。解析：8 bit = 1 byte,1024 byte = 1 KB = 1024 * 8 bit = 2^13 bit4. 1GB，1MB，1KB分别是 2^30,2^20,2^10 byte。解析：1 KB = 1024 byte = 2^10 byte1 MB = 1024 KB = 2^10 KB = 2^20 byte1 GB = 1024 MB = 2^10 MB = 2^20 KB = 2^30 byte5. 8080、8088、80286、80386的地址总线宽度分别为16根、20根、24根、32根，则它们的寻址能力分别为： 64 (KB)、 1 (MB)、 16 (MB)、 4 (GB)。解析：8080：2^16 byte = 2^6 KB = 64 KB8088：2^20 byte = 2^10 KB = 1 MB80286：2^24 byte = 2^4 MB = 16 MB80386：2^32 byte = 2^2 GB = 4 GB6. 8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根，则它们一次可以传送的数据为：1 (B)、1 (B)、2 (B)、2 (B)、4 (B)。解析：一根数据总线传送一位二进制数据。7. 从内存中读取1024字节的数据，8086至少要读 512 次，80386至少要读 256 次。解析：8086（数据总线宽度：16）：1024 * 8 / 16 = 51280386（数据总线宽度：32）：1024 * 8 / 32 = 2568. 在存储器中，数据程序以 二进制 形式存放。解析：指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。 1、 只对al操作，就算是溢出了，也不会改变ah中的值；例如：若AX=D882H add al,6 AX=D888H ；0x88+0x88=0F10,只把10放到al中add al,al AX=D810H2、十六进制字母的前面要加0；十六进制hexadecimal,可以缩写为hexAAh 可以是一个常数，同时也是合法的变量名0AAh 不可以是变量，一定是个常数①十进制整数。例如，123、一456、0。②八进制整数。以0开头的整数是八进制数。例如，0123表示8进制数123&lt;8)，等于十进制数83。③十六进制整数。以ox或0x开头的整数是十六进制数。例如，0x1． 3、给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为 ？到 ？ 物理地址＝SA*16+EA EA的变化范围为0h~ffffh 物理地址范围为(SA*16+0h)~(SA*16+ffffh) 现在SA=0001h,那么寻址范围为 (0001h*16+0h)~(0001h*16+ffffh) =0010h~1000fh 4、有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻址到此单元，则SA 应满足的条件是：最小为 1001H 最大为 2000H ；最大值： （很多人最大值很容易算出来，但是最小值卡住了，很纳闷为什么是1001H）我们可以根据原题列出一个式子: X * 10H + 0H = 20000H我们之前是乘以16，但是那个16是十进制的，因为整个式子里都是16进制，加入个10进制去算会出错的所以呢，我们把16转换为16进制的数，就是10H段地址 = 物理地址 - 偏移地址 除以 10HX =（20000H - 0H） / 10H求得结果是2000H因为我们要求的是最大的段地址，所以就用上最小的偏移地址配合他，也就是0H最小值：SA * 16 + FFFFH = 20000H 段最小值那么就要用最大偏移地址来配合它。SA * 16 = 20000H - FFFFHSA * 16 = 10001H 我们求得了这个段地址，但是还要除以10H，或者转换为10进制，再除以10进制的16（那为什么不是1000H呢？下面是答案……）段地址要为16(10H)的倍数,20000H - FFFF = 10001H 10001H十进制是65537，除以16是4096.0625 有小数说明不是倍数，不能整除20000H - FFFE = 10002H 10002H十进制是65538，除以16是4096.125 有小数说明不是倍数，不能整除20000H - FFFD = 10003H 10001H十进制是65539，除以16是4096.1875 有小数说明不是倍数，不能整除20000H - FFFC = 10004H 10001H十进制是65540，除以16是4096.25 有小数说明不是倍数，不能整除20000H - FFFB = 10005H 10001H十进制是65541，除以16是4096.3125 有小数说明不是倍数，不能整除20000H - FFFA = 10006H 10001H十进制是65542，除以16是4096.375 有小数说明不是倍数，不能整除（这些的值都不是16的倍数）我们不断减小值，因为FFFF是最大，不能再大了，所以只能减小，直到....... （要直到除以16是整数为止）20000H - FFF0 = 1 0010H 1 0010H十进制是65552，除以16是4097，可以整除这时10010H满足16(10H)的倍数了物理地址减去 [可以被16整除的最大偏移地址,在这一题中也就是FFF0H] 的结果，除以16(10H)等于最小段地址20000H - FFF0H / 10H = 1001H ，于是这个1001H这个苦逼的孩子就是答案了。。。提示，反过来思考一下，当段地址给定为多少，CPU无论怎么变化偏移地址都无法寻到20000H单元？•根据上面一题的答案，小于1001H，或者大于2000H都无法寻到20000H单元 第九章的基础知识","categories":[{"name":"窥探计算机底层的奥秘","slug":"窥探计算机底层的奥秘","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%AA%A5%E6%8E%A2%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%A5%A5%E7%A7%98/"}],"tags":[],"author":"aoyuehan"},{"title":"java regex ","slug":"java-regex","date":"2020-03-12T03:16:00.000Z","updated":"2022-02-26T03:52:52.480Z","comments":true,"path":"2020/03/12/java-regex/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/12/java-regex/","excerpt":"","text":"简介java.util.regex 包主要包括以下三个类： Pattern 类： pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher 类： Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 PatternSyntaxException： PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 正则表达式语法在其他语言中，\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。在 Java 中，\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。而单个的\\是转义字符，如\\n代表回车；replaceAll算法的实现运用了正则表达式，所以这里经历了两次转化，即是replaceAll(“\\\\“)转化出“\\”提交给正则表达式，正则表达式再转化一次获得“\\”,同理，用8个反斜杠表示“\\” 所以，在其他的语言中（如Perl），一个反斜杠 \\ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \\ 代表其他语言中的一个 \\，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\\\。 Matcher 类的方法 start 和 end 方法 Start 方法返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引，end 方法最后一个匹配字符的索引加 1。下面是一个对单词 “cat” 出现在输入字符串中出现次数进行计数的例子： 12345678910111213141516171819202122232425262728293031323334353637import java.util.regex.Matcher;import java.util.regex.Pattern; public class RegexMatches&#123; private static final String REGEX = &quot;\\\\bcat\\\\b&quot;; private static final String INPUT = &quot;cat cat cat cattie cat&quot;; public static void main( String args[] )&#123; Pattern p = Pattern.compile(REGEX);//用compile方法获得一个Pattern的对象 Matcher m = p.matcher(INPUT); // 正则表达式的对象获取 matcher 方法（将原串作为参数）获得一个Matcher对象 int count = 0; while(m.find()) &#123;//如果Matcher对象还有能匹配的内容 count++; System.out.println(&quot;Match number &quot;+count); System.out.println(&quot;start(): &quot;+m.start()); System.out.println(&quot;end(): &quot;+m.end()); &#125; &#125;&#125;结果：Match number 1start(): 0end(): 3Match number 2start(): 4end(): 7Match number 3start(): 8end(): 11Match number 4start(): 19end(): 22 matches 和 lookingAt 方法matches 和 lookingAt 方法都用来尝试匹配一个输入序列模式。它们的不同是 matches 要求整个序列都匹配，而lookingAt 不要求。lookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。这两个方法经常在输入字符串的开始使用。 1234567891011121314151617181920212223242526272829303132333435import java.util.regex.Matcher;import java.util.regex.Pattern; public class RegexMatches&#123; private static final String REGEX = &quot;foo&quot;; private static final String INPUT = &quot;fooooooooooooooooo&quot;; private static final String INPUT2 = &quot;ooooofoooooooooooo&quot;; private static Pattern pattern; private static Matcher matcher; private static Matcher matcher2; public static void main( String args[] )&#123; pattern = Pattern.compile(REGEX); matcher = pattern.matcher(INPUT); matcher2 = pattern.matcher(INPUT2); System.out.println(&quot;Current REGEX is: &quot;+REGEX); System.out.println(&quot;Current INPUT is: &quot;+INPUT); System.out.println(&quot;Current INPUT2 is: &quot;+INPUT2); System.out.println(&quot;lookingAt(): &quot;+matcher.lookingAt()); System.out.println(&quot;matches(): &quot;+matcher.matches()); System.out.println(&quot;lookingAt(): &quot;+matcher2.lookingAt()); //lookingAt也许从第一个字符开始匹配 &#125;&#125;结果：Current REGEX is: fooCurrent INPUT is: foooooooooooooooooCurrent INPUT2 is: ooooofoooooooooooolookingAt(): truematches(): falselookingAt(): false replaceFirst 和 replaceAll 方法 replaceFirst 和 replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。 12345678910111213141516171819202122import java.util.regex.Matcher;import java.util.regex.Pattern; public class RegexMatches&#123; private static String REGEX = &quot;dog&quot;; private static String INPUT = &quot;The dog says meow. &quot; + &quot;All dogs say meow.&quot;; private static String REPLACE = &quot;cat&quot;; public static void main(String[] args) &#123; Pattern p = Pattern.compile(REGEX); // get a matcher object Matcher m = p.matcher(INPUT); INPUT = m.replaceAll(REPLACE); System.out.println(INPUT); &#125;&#125;结果：The cat says meow. All cats say meow. appendReplacement 和 appendTail 方法Matcher 类也提供了appendReplacement 和 appendTail 方法用于文本替换： 1234567891011121314151617181920212223import java.util.regex.Matcher;import java.util.regex.Pattern; public class RegexMatches&#123; private static String REGEX = &quot;a*b&quot;; private static String INPUT = &quot;aabfooaabfooabfoobkkk&quot;; private static String REPLACE = &quot;-&quot;; public static void main(String[] args) &#123; Pattern p = Pattern.compile(REGEX); // 获取 matcher 对象 Matcher m = p.matcher(INPUT); StringBuffer sb = new StringBuffer(); while(m.find())&#123; m.appendReplacement(sb,REPLACE); &#125; m.appendTail(sb); System.out.println(sb.toString()); &#125;&#125;结果：-foo-foo-foo-kkk 简要说明一下两个方法的用法：appendReplacement方法：sb是一个StringBuffer，replaceContext待替换的字符串，这个方法会把匹配到的内容替换为replaceContext，并且把从上次替换的位置到这次替换位置之间的字符串也拿到，然后，加上这次替换后的结果一起追加到StringBuffer里（假如这次替换是第一次替换，那就是只追加替换后的字符串啦）。appendTail方法：sb是一个StringBuffer，这个方法是把最后一次匹配到内容之后的字符串追加到StringBuffer中。 PatternSyntaxException 类的方法PatternSyntaxException 是一个非强制异常类，它指示一个正则表达式模式中的语法错误。PatternSyntaxException 类提供了下面的方法来帮助我们查看发生了什么错误。 常用的正则模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * 常用正则表达式模式实例 */ public static void main(String[] args) &#123; //匹配11位的手机号 String str = &quot;13624426496&quot;; Pattern pattern = Pattern.compile(&quot;^1\\\\d&#123;10&#125;$&quot;); //^ $ 开始和结束，\\d等效于[0-9] Matcher matcher = pattern.matcher(str); if(matcher.find()) System.out.println(&quot;start:&quot; + matcher.start() + &quot;,end:&quot; + matcher.end()); System.out.println(&quot;******************** 分割线&lt;-- 用户名--&gt;*******************&quot;); /** * 3-20位的用户名，字母开头 * */ pattern = Pattern.compile(&quot;^[a-zA-Z]\\\\w&#123;2,19&#125;$&quot;); // \\w等效于[0-9a-zA-Z_] matcher = pattern.matcher(&quot;zifangsky&quot;); System.out.println(matcher.matches()); //true matcher = pattern.matcher(&quot;0zifangsky&quot;); System.out.println(matcher.matches()); //false matcher = pattern.matcher(&quot;z01234567890123456789&quot;); System.out.println(matcher.matches()); //false System.out.println(&quot;******************** 分割线&lt;-- 密码--&gt;*******************&quot;); /** * 6-20位的密码，必须同时包含大写字母，小写字母和数字 * 形如：(?=.*\\\\d)，最后不会取出()里面的内容，但是必须满足()里面的条件。如： * &#x27;Windows (?=95|98|NT|2000)&#x27; 匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。 * 也就是说这里实际上取的是&#123;6,20&#125;前面的那个 . * */ pattern = Pattern.compile(&quot;^((?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z])).&#123;6,20&#125;$&quot;); matcher = pattern.matcher(&quot;zifangsky&quot;); System.out.println(matcher.matches()); //false matcher = pattern.matcher(&quot;zifangskyA2&quot;); System.out.println(matcher.matches()); //true System.out.println(&quot;******************** 分割线&lt;-- email--&gt;*******************&quot;); /** * Email正则表达式 * 以[a-zA-Z_]开始，后面可以跟上.[a-zA-Z_]也可以没有，然后是@，接着是一位的数字或者字母， * 再跟上.[a-zA-Z_]或者没有，最后是.以及2位以上的域名后缀 * */ pattern = Pattern.compile(&quot;^\\\\w+(\\\\.\\\\w+)*@[a-zA-Z0-9]+(\\\\.[a-zA-Z0-9]+)*(\\\\.[a-zA-Z]&#123;2,&#125;)$&quot;); matcher = pattern.matcher(&quot;983836259@qq.com&quot;); System.out.println(matcher.matches()); //true matcher = pattern.matcher(&quot;zifangsky.test_korea@co.kr&quot;); System.out.println(matcher.matches()); //true System.out.println(&quot;******************** 分割线&lt;-- 上传文件--&gt;*******************&quot;); /** * 上传文件格式验证 * 一位以上的[a-zA-Z_]，而且是固定的几种后缀 * */ pattern = Pattern.compile(&quot;^\\\\w+\\\\.(?i)(jpg|png|gif|zip|rar|txt|7z)$&quot;); //(?i) 忽略后面字符的大小写检查，如果后面有(?-i)表示忽略大小写到此结束 matcher = pattern.matcher(&quot;201511241314235.jpg&quot;); System.out.println(matcher.matches()); //true matcher = pattern.matcher(&quot;test.php%00.jpg&quot;); System.out.println(matcher.matches()); //false System.out.println(&quot;******************** 分割线&lt;-- IP--&gt;*******************&quot;); /** * IP地址正则表达式 * IP地址每部分分为三种情况：1, [01]开头 2, 2[0-4]开头 3, 25[0-5]这种 * 然后用符号|来区分，最后将这三种情况用()包含起来，后面紧跟着 . * */ pattern = Pattern.compile(&quot;^([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])\\\\.([01]?\\\\d\\\\d?|2[0-4]\\\\d|25[0-5])$&quot;); matcher = pattern.matcher(&quot;67.128.198.255&quot;); System.out.println(matcher.matches()); //true matcher = pattern.matcher(&quot;115.12.254.302&quot;); System.out.println(matcher.matches()); //false System.out.println(&quot;******************** 分割线&lt;-- 日期格式--&gt;*******************&quot;); /** * 日期格式校验，如：yyyy-mm-dd * 年：19或者20开头，而且是4位 * 月：[1-9]，或者1[012] * 日：跟上面类似 * */ pattern = Pattern.compile(&quot;^((19|20)\\\\d\\\\d)-(0?[1-9]|1[012])-(0?[1-9]|[12]\\\\d|3[01])$&quot;); // matcher = pattern.matcher(&quot;2015-11-24&quot;); System.out.println(matcher.matches()); //true matcher = pattern.matcher(&quot;1949-10-01&quot;); System.out.println(matcher.matches()); //true System.out.println(&quot;******************** 分割线&lt;-- ***--&gt;*******************&quot;); /** * 这里只验证位数，15位或18位，并且18位时最后一位可能是 x * */ pattern = Pattern.compile(&quot;^\\\\d&#123;15&#125;|\\\\d&#123;17&#125;(\\\\d|x)$&quot;); matcher = pattern.matcher(&quot;201354061912145&quot;); System.out.println(matcher.matches()); //true matcher = pattern.matcher(&quot;20101820011001578x&quot;); System.out.println(matcher.matches()); //true System.out.println(&quot;******************** 分割线&lt;-- HTML标签--&gt;*******************&quot;); /** * 这里只是简单的验证，一般来说有三种情况： * &lt;div&gt;xxxx&lt;/div&gt; * &lt;input /&gt; * &lt;input type=&quot;text&quot; name=&quot;xxx&quot;&gt; * */ pattern = Pattern.compile(&quot;^&lt;[a-zA-Z]+&gt;.*&lt;/[a-zA-Z]+&gt;|&lt;[a-zA-Z]+( *.*)*/?&gt;$&quot;); //( *.*)这里有个空格 matcher = pattern.matcher(&quot;&lt;&lt;div&gt;xxxx&lt;/div&gt;&quot;); System.out.println(matcher.matches()); //false matcher = pattern.matcher(&quot;&lt;input type=\\&quot;text\\&quot; name=\\&quot;xxx\\&quot;&gt;&quot;); System.out.println(matcher.matches()); //true System.out.println(&quot;******************** 分割线&lt;-- 汉字--&gt;*******************&quot;); /** * 只能输入汉字 * */ pattern = Pattern.compile(&quot;^[\\u4e00-\\u9fa5]+$&quot;); matcher = pattern.matcher(&quot;汉字&quot;); System.out.println(matcher.matches()); //true &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[正则表达式]文本框输入内容控制整数或者小数：^[0-9]+\\.&#123;0,1&#125;[0-9]&#123;0,2&#125;$只能输入数字：&quot;^[0-9]*$&quot;。只能输入n位的数字：&quot;^\\d&#123;n&#125;$&quot;。只能输入至少n位的数字：&quot;^\\d&#123;n,&#125;$&quot;。只能输入m~n位的数字：。&quot;^\\d&#123;m,n&#125;$&quot;只能输入零和非零开头的数字：&quot;^(0|[1-9][0-9]*)$&quot;。只能输入有两位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;。只能输入有1~3位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$&quot;。只能输入非零的正整数：&quot;^\\+?[1-9][0-9]*$&quot;。只能输入非零的负整数：&quot;^\\-[1-9][]0-9&quot;*$。只能输入长度为3的字符：&quot;^.&#123;3&#125;$&quot;。只能输入由26个英文字母组成的字符串：&quot;^[A-Za-z]+$&quot;。只能输入由26个大写英文字母组成的字符串：&quot;^[A-Z]+$&quot;。只能输入由26个小写英文字母组成的字符串：&quot;^[a-z]+$&quot;。只能输入由数字和26个英文字母组成的字符串：&quot;^[A-Za-z0-9]+$&quot;。只能输入由数字、26个英文字母或者下划线组成的字符串：&quot;^\\w+$&quot;。验证用户密码：&quot;^[a-zA-Z]\\w&#123;5,17&#125;$&quot;正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。验证是否含有^%&amp;&#x27;,;=?$\\&quot;等字符：&quot;[^%&amp;&#x27;,;=?$\\x22]+&quot;。只能输入汉字：&quot;^[\\u4e00-\\u9fa5]&#123;0,&#125;$&quot;验证Email地址：&quot;^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$&quot;。验证InternetURL：&quot;^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$&quot;。验证电话号码：&quot;^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$&quot;正确格式为：&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX&quot;。验证身份证号（15位或18位数字）：&quot;^\\d&#123;15&#125;|\\d&#123;18&#125;$&quot;。验证一年的12个月：&quot;^(0?[1-9]|1[0-2])$&quot;正确格式为：&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;12&quot;。验证一个月的31天：&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;正确格式为；&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;31&quot;。匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）String.prototype.len=function()&#123;return this.replace(/[^\\x00-\\xff]/g,&quot;aa&quot;).length;&#125;匹配空行的正则表达式：\\n[\\s| ]*\\r匹配html标签的正则表达式：&lt;(.*)&gt;(.*)&lt;\\/(.*)&gt;|&lt;(.*)\\/&gt;匹配首尾空格的正则表达式：(^\\s*)|(\\s*$)应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现，如下：String.prototype.trim = function()&#123;return this.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;);&#125;利用正则表达式分解和转换IP地址：下面是利用正则表达式匹配IP地址，并将IP地址转换成对应数值的Javascript程序：function IP2V(ip)&#123;re=/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)/g //匹配IP地址的正则表达式if(re.test(ip))&#123;return RegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1&#125;else&#123;throw new Error(&quot;Not a valid IP address!&quot;)&#125;&#125;不过上面的程序如果不用正则表达式，而直接用split函数来分解可能更简单，程序如下：var ip=&quot;10.100.20.168&quot;ip=ip.split(&quot;.&quot;)alert(&quot;IP值是：&quot;+(ip[0]*255*255*255+ip[1]*255*255+ip[2]*255+ip[3]*1))匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*匹配网址URL的正则表达式：http://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?利用正则表达式限制网页表单里的文本框输入内容：用正则表达式限制只能输入中文：onkeyup=&quot;value=value.replace(/[^\\u4E00-\\u9FA5]/g,&#x27;&#x27;)&quot; onbeforepaste=&quot;clipboardData.setData(&#x27;text&#x27;,clipboardData.getData(&#x27;text&#x27;).replace(/[^\\u4E00-\\u9FA5]/g,&#x27;&#x27;))&quot;用正则表达式限制只能输入全角字符： onkeyup=&quot;value=value.replace(/[^\\uFF00-\\uFFFF]/g,&#x27;&#x27;)&quot; onbeforepaste=&quot;clipboardData.setData(&#x27;text&#x27;,clipboardData.getData(&#x27;text&#x27;).replace(/[^\\uFF00-\\uFFFF]/g,&#x27;&#x27;))&quot;用正则表达式限制只能输入数字：onkeyup=&quot;value=value.replace(/[^\\d]/g,&#x27;&#x27;) &quot;onbeforepaste=&quot;clipboardData.setData(&#x27;text&#x27;,clipboardData.getData(&#x27;text&#x27;).replace(/[^\\d]/g,&#x27;&#x27;))&quot;用正则表达式限制只能输入数字和英文：onkeyup=&quot;value=value.replace(/[\\W]/g,&#x27;&#x27;) &quot;onbeforepaste=&quot;clipboardData.setData(&#x27;text&#x27;,clipboardData.getData(&#x27;text&#x27;).replace(/[^\\d]/g,&#x27;&#x27;))&quot;","categories":[{"name":"java interview","slug":"java-interview","permalink":"https://zouyunkai.github.io/myblog/categories/java-interview/"}],"tags":[],"author":"aoyuehan"},{"title":"java SE note One","slug":"java-SE-note-One","date":"2020-03-12T02:31:00.000Z","updated":"2022-02-26T03:52:51.991Z","comments":true,"path":"2020/03/12/java-SE-note-One/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/12/java-SE-note-One/","excerpt":"","text":"面试知识点思维导图 Java基础(一) java特性 正则表达式（详见另一篇java regex文章）Java中的String类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java中可以用Pattern类表示正则表达式对象，它提供了丰富的API进行各种正则表达式操作，如： 1234567891011121314import java.util.regex.Matcher;import java.util.regex.Pattern;class RegExpTest &#123; public static void main(String[] args) &#123; String str = &quot;成都市(成华区)(武侯区)(高新区)&quot;; Pattern p = Pattern.compile(&quot;.*?(?=\\\\()&quot;); Matcher m = p.matcher(str);//利用Pattern对象的matcher方法得到Matcher对象 if(m.find()) &#123; System.out.println(m.group()); &#125; &#125;&#125;结果：成都市 请你简单描述一下正则表达式及其用途。参考回答：在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。计算机处理的信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大的工具，绝大多数语言都提供了对正则表达式的支持。 请你比较一下Java和JavaSciprt？参考回答：JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。下面对两种语言间的异同作如下比较： 基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。 解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率） 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。 请你说明一下，在Java中如何跳出当前的多重嵌套循环？参考回答：在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好） &amp;和&amp;&amp;的区别？答：&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username !&#x3D; null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 12345678910111213代码实例：public class Test2&#123; public static void main(String[] args)&#123; int i=3; if((i++&gt;5)&amp;&amp;(i++&lt;9))&#123; System.out.println(i); System.out.println(&quot;恭喜，执行完了条件语句！&quot;); &#125; System.out.println(i); &#125;&#125;结果为i=4；说明没有执行i++&lt;9,所以出现了短路现象。 int和Integer有什么区别？参考回答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class）,Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int是java的原始数据类型，Integer是java为int提供的封装类。，int的包装类就是Integer，从Java 5开始引入了自动装箱&#x2F;拆箱机制，使得二者可以相互转换。Java 为每个原始类型提供了包装类型： 原始类型: boolean，char，byte，short，int，long，float，double 包装类 型：Boolean，Character，Byte，Short，Integer，Long，Float，Double 1234567891011class AutoUnboxingTest &#123; public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象，两个对象相比较 ，==比较他们的引用 syso（a==b.intval()）；//结果为true，一个为int，一个为integer，会准换位int来比较值的大小 System.out.println(a.equals(b)); //结果为true System.out.println(a == c); // true a自动拆箱成int类型再和c比较 &#125;&#125; 引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为null，而原始类型实例变量的缺省值与它们的类型有关。使用原始类型无须调用 new，也无须创建对象。这节省了时间和空间;两者混合使用会出现意外的结果（因为一个为原始类型，一个为引用类型） integer的大于127与小于128使用&#x3D;&#x3D;比较integer i&#x3D;127;integer j &#x3D;127;system.out.println(i&#x3D;&#x3D;j);i&#x3D;128;j&#x3D;128;system.out.println(i&#x3D;&#x3D;j); i&#x3D;new integer(127);j&#x3D;new integer(127);system.out.println(i&#x3D;&#x3D;j);输出结果为 true、false、false。这是因为jvm的缓存机制导致的。jvm在运行时创建了一个缓存区域，并创建了一个integer的数组。这个数组存储了-128至127的值。因此如果integer的值在-128至127之间，则是去缓存里面获取。因此上面的i和j指向的是同一个内存地址。因为128超过了这个缓存区域，因此第二次赋值的时候是重新开辟了两个内存地址。第三次因为使用了new关键字，在java中。new关键字是开辟内存空间。因此第三次赋值是开辟了新的内存空间，此时发现即便i与j都是127，但内存地址不再相同 我们在web应用开发过程中经常遇到输出某种编码的字符，如iso8859-1等，请你讲讲如何输出一个某种编码的字符串？考察点：数据类型参考回答： 1234567891011Public String translate (String str) &#123; String tempStr = “”; try &#123; tempStr = new String(str.getBytes(“ISO-8859-1″), “GBK”); tempStr = tempStr.trim(); &#125; catch (Exception e) &#123; System.err.println(e.getMessage()); &#125; return tempStr;&#125; 请你说明String 和StringBuffer的区别考察点：数据类型参考回答：JAVA 平台提供了两个类：String和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String类提供了数值不可改变的字符串。而这个StringBuffer类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。典型地，你可以使用StringBuffers来动态构造字符数据。 请说明String是最基本的数据类型吗?考察点：数据类型参考回答：基本数据类型包括byte、int、char、long、float、double、boolean和short。 java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类。 java基础（二） 请你谈谈大O符号(big-O notation)并给出不同数据结构的例子考察点：JAVA notation参考回答：大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。大O符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和 性能来选择最好的实现。大O符号可以对大量数据的性能给出一个很好的说明。 同时，大O符号表示一个程序运行时所需要的渐进时间复杂度上界。其函数表示是：对于函数f(n),g(n),如果存在一个常数c，使得f(n)&lt;&#x3D;c*g(n),则f(n)&#x3D;O(g(n)); 大O描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。大O还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使用大O符号基于时间，内存，性能选择最好的实现。大O符号可以对大量数据性能给予一个很好的说明。 请你讲讲数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？考察点：Array参考回答：Array和ArrayList的不同点：Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。Array大小是固定的，ArrayList的大小是动态变化的。ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。 请你解释什么是值传递和引用传递？考察点：JAVA引用传递参考回答：值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量;对于字符串来说，改变形参会改变实参。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。 所以对引用对象进行操作会同时改变原对象.一般认为,java内的传递都是值传递. 请你讲讲Java支持的数据类型有哪些？什么是自动拆装箱？考察点：JAVA数据类型参考回答：Java语言支持的8种基本数据类型是：byteshortintlongfloatdoublebooleanchar自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成Double，等等。反之就是自动拆箱。 请你解释为什么会出现4.0-3.6&#x3D;0.40000001这种现象？考察点：计算机基础参考回答：原因简单来说是这样：2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。 double的4-3.6是0.399999 float的4-3.6是4.00001 解决方法是使用BigDecimal类 float:单精度类型,精度是8位有效数字（其余部分四舍五入），取值范围是10的-38次方到10的38次方，float占用4个字节的存储空间。 double:双精度类型，精度是17位有效数字，取值范围是10的-308次方到10的308次方，double占用8个字节的存储空间。 若不声明的，默认小数都用double来表示，所以如果要用float的话，则应该在其后加上f 一个十进制的数在内存中是怎么存的？ 以该十进制数的对应二进制的补码的形式 请你说说Lamda表达式的优缺点。考察点：Java基础参考回答：优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。 缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。 你知道java8的新特性吗，请简单介绍一下考察点：java8参考回答：Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。 方法引用− 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。默认方法− 默认方法就是一个在接口里面有了一个实现的方法。新工具− 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。Date Time API − 加强对日期与时间的处理。Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。 请你说明符号“&#x3D;&#x3D;”比较的是什么？考点：基础参考回答：“&#x3D;&#x3D;”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“&#x3D;&#x3D;”操作将返回true，否则返回false。“&#x3D;&#x3D;”如果两边是基本类型，就是比较数值是否相等。 请你解释Object若不重写hashCode()的话，hashCode()如何计算出来的？考点：基础参考回答：Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。hashcode的底层实现 请你解释为什么重写equals还要重写hashcode？考点：java基础参考回答： **object的equals默认是比较内存地址，hashcode默认是内存地址的哈希值;**HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址的hash值，这样即便有相同含义的两个对象，比较也是不相等的。HashMap中的比较key是这样的，先求出key的hashcode(),比较其值是否相等，若相等再比较equals(),若相等则认为他们是相等的。若equals()不相等则认为他们不相等。如果只重写hashcode()不重写equals()方法，当比较equals()时只是看他们是否为同一对象（即进行内存地址的比较）,所以必定要两个方法一起重写。HashMap用来判断key是否相等的方法，其实是调用了HashSet判断加入元素 是否相等。重载hashCode()是为了对同一个key，能得到相同的Hash Code，这样HashMap就可以定位到我们指定的key上。重载equals()是为了向HashMap表明当前对象和key上所保存的对象是相等的，这样我们才真正地获得了这个key所对应的这个键值对。 请你介绍一下map的分类和常见的情况考点：java基础参考回答： java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap. Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。 Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。 Hashtable与 HashMap类似,它继承自Dictionary类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写Hashtable,因此也导致了 Hashtable在写入时会比较慢。 LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。 TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。 一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列. 关键字 请你讲讲Java里面的final关键字是怎么用的？ 考察点：关键字参考回答： 当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。 “使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。“ 对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 请你谈谈关于Synchronized和lock 考察点：java关键字参考回答： synchronized是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。 Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 请你介绍一下volatile？考察点：java关键字参考回答：volatile关键字是用来保证有序性和可见性的。这跟Java内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高CPU的执行效率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知道对不对了，所以有happens-before规则，其中有条就是volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先Java内存模型分为，主内存，工作内存。比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中，线程B此时读到的还是i的旧值。加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。Lock指令对Intel平台的CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。 请你介绍一下Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？考点：java关键字参考回答：synchronized修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。 **synchronized的修饰对象有以下几种： 1、修饰一个类，其作用的范围是synchronized后面括号括起来的部分， 作用的对象是这个类的所有对象。 2、修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法， 作用的对象是调用这个方法的对象； 3、修改一个静态的方法，其作用的范围是整个静态方法， 作用的对象是这个类的所有对象； 4、修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码， 作用的对象是调用这个代码块的对象； ** 关于java基本类型的一些知识 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Assign &#123;public static void main(String[] args) &#123;//1.Declare and Assign int a; a=100; System.out.println(&quot;a=&quot;+a); int b=100; System.out.println(&quot;b=&quot;+b); int c=a; System.out.println(&quot;c=&quot;+c); //2.boolean boolean flag=true; //boolean flag=1; 在java中不允许boolean型 赋数值 System.out.println(&quot;flag=&quot;+flag); //3.text type // char cA=&#x27;A&#x27;; 和char cA=65; 等价 //char cA=&quot;A&quot;; 不对，因为cA被定义为char类型，不是string类型 char cA=65; System.out.println(&quot;cA=&quot;+cA); String s1=&quot;Hello world&quot;; String s2=&quot;Hello \\n world&quot;; System.out.println(&quot;s1=&quot;+s1); System.out.println(&quot;s2=&quot;+s2); //4.integer type byte iA=100; //byte iB=200; byte是8位带符号二进制数的取值范围是[-128, 127]，赋200会溢出 short iC=1000; int iD=10000; long iE=1000; //int iF=10000L; 给int类型赋long类型，不允许高精度赋值给低精度，即在把容量大的类型转换为容量小的类型时必须使用强制类型转换 System.out.println(&quot;iA=&quot;+iA+&quot;\\n&quot; +&quot;iC=&quot;+iC+&quot;\\n&quot; +&quot;iD=&quot;+iD+&quot;\\n&quot; +&quot;iE=&quot;+iE+&quot;\\n&quot;); //5.floating-point type float fA=3.14F; //float fB=3.14; 正确的形式为float fB=3.14f;或float fB=3.14F; double fC=3.14; double fD=3.14D; double fE=2E2; double fF=123.4E+306D; System.out.println(&quot;fA=&quot;+fA+&quot;\\n&quot; +&quot;fC=&quot;+fC+&quot;\\n&quot; +&quot;fD=&quot;+fD+&quot;\\n&quot; +&quot;fE=&quot;+fE+&quot;\\n&quot; +&quot;fF=&quot;+fF+&quot;\\n&quot;); &#125; &#125; 运行结果：","categories":[{"name":"java interview","slug":"java-interview","permalink":"https://zouyunkai.github.io/myblog/categories/java-interview/"}],"tags":[{"name":"java se","slug":"java-se","permalink":"https://zouyunkai.github.io/myblog/tags/java-se/"}],"author":"aoyuehan"},{"title":"训练23 UCF 2013 Contest","slug":"训练23-UCF-2013-Contest","date":"2020-03-11T13:09:22.000Z","updated":"2022-02-26T03:52:51.222Z","comments":true,"path":"2020/03/11/训练23-UCF-2013-Contest/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/11/%E8%AE%AD%E7%BB%8323-UCF-2013-Contest/","excerpt":"","text":"A. The Suffix Game给你一个串，如果串的最后相等就删除这个字母，直到剩下一个字母或者两个串的最后那个字母不相同的时候停止。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n;int cnt =1; while(n--)&#123; string s1,s2,s3,s4; int lens1,lens2; cin&gt;&gt;s1&gt;&gt;s2; lens1=s1.length();lens2=s2.length(); while(lens1&gt;1&amp;&amp;lens2&gt;1)&#123; if(s1[lens1-1]==s2[lens2-1])&#123; lens1--;lens2--; &#125;else&#123; break; &#125; &#125; s3=s1.substr(0,lens1); s4=s2.substr(0,lens2); cout&lt;&lt;&quot;Game #&quot;&lt;&lt;cnt++&lt;&lt;&#x27;:&#x27;&lt;&lt;endl; cout&lt;&lt;&quot; &quot;&lt;&lt;&quot;The input words are &quot;&lt;&lt;s1&lt;&lt;&quot; and &quot;&lt;&lt;s2&lt;&lt;&#x27;.&#x27;&lt;&lt;endl; cout&lt;&lt;&quot; &quot;&lt;&lt;&quot;The words entered in the notebook are &quot;&lt;&lt;s3&lt;&lt;&quot; and &quot;&lt;&lt;s4&lt;&lt;&#x27;.&#x27;&lt;&lt;endl&lt;&lt;endl; &#125; &#125; B. Counting Triangles给你一些点，问这些点所能组成的三角形的个数是多少；本来想到排列组合，可是发现有斜率相同的怎么处理呀（就没法处理了），最后竟然是暴力解决。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;set&gt;using namespace std; int main()&#123; std::ios::sync_with_stdio(false); std::cin.tie(0); int n; scanf(&quot;%d&quot;,&amp;n);int cnt =1; while(n--)&#123; int tmpx[110],tmpy[110],casen; scanf(&quot;%d&quot;,&amp;casen); for(int i=0;i&lt;casen;i++)&#123; scanf(&quot;%d&quot;,&amp;tmpx[i]);scanf(&quot;%d&quot;,&amp;tmpy[i]); &#125; int a,b,c;long long ans=0; for(int i=0;i&lt;casen;i++)&#123; for(int j=i+1;j&lt;casen;j++)&#123; for(int k=j+1;k&lt;casen;k++)&#123; if( (tmpx[j]-tmpx[i])*(tmpy[k]-tmpy[i])!=(tmpx[k]-tmpx[i])*(tmpy[j]-tmpy[i]) )&#123; //点1和点2的斜率不能于点1和点3的斜率的时候就能组成三角形 ans++; &#125; &#125; &#125; &#125; cout&lt;&lt;&quot;Test case #&quot;&lt;&lt;cnt++&lt;&lt;&quot;: &quot; ; cout&lt;&lt;ans&lt;&lt;&quot; triangle(s) can be formed.&quot; &lt;&lt;endl&lt;&lt;endl; &#125;&#125; tips：判断三点共线的方式还有点斜式方程，两点组成一条直线，然后把第三个点带进去，看是否在直线上。 C. UCF Hold-em Poker题意：给你7张牌，然后判断这里面有二张相同的，三张相同的，四张相同的，三张相同的+二张相同的，或者什么都没有。 然后输出相应的形式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int num[20];int main()&#123; int n; cin&gt;&gt;n;int cnt =1; while(n--)&#123; string s ; cin&gt;&gt;s ; memset(num,0,sizeof(num)); for(int i=0;i&lt;7;i++)&#123; if(s[i]==&#x27;T&#x27;)num[10]++; else if(s[i]==&#x27;J&#x27;)num[11]++; else if(s[i]==&#x27;Q&#x27;)num[12]++; else if(s[i]==&#x27;K&#x27;)num[13]++; else if(s[i]==&#x27;A&#x27;)num[14]++; else num[s[i]-&#x27;0&#x27;]++; &#125; bool dui=false,si=false,san=false; for(int i=2;i&lt;15;i++)&#123; if(num[i]==4)si=true; else if(num[i]==3)san=true; else if(num[i]==2)dui=true; else&#123; &#125; //cout&lt;&lt;&quot;num &quot;&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;num[i]&lt;&lt;endl; &#125; // cout&lt;&lt;si&lt;&lt;&#x27; &#x27;&lt;&lt;san&lt;&lt;&#x27; &#x27;&lt;&lt;dui&lt;&lt;endl; cout&lt;&lt;&quot;UCF Hold-em #&quot;&lt;&lt;cnt++&lt;&lt;&quot;: &quot;&lt;&lt;s&lt;&lt;endl; if(dui&amp;&amp;san)&#123; cout&lt;&lt;&quot;Best possible hand: FULL HOUSE&quot;&lt;&lt;endl&lt;&lt;endl; &#125;else if(si)&#123; cout&lt;&lt;&quot;Best possible hand: FOUR OF A KIND&quot;&lt;&lt;endl&lt;&lt;endl; &#125;else if(dui)&#123; cout&lt;&lt;&quot;Best possible hand: TWO OF A KIND&quot;&lt;&lt;endl&lt;&lt;endl; &#125;else if(san)&#123; cout&lt;&lt;&quot;Best possible hand: THREE OF A KIND&quot;&lt;&lt;endl&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;Best possible hand: BUST&quot;&lt;&lt;endl&lt;&lt;endl; &#125; &#125; &#125;","categories":[],"tags":[],"author":"aoyuehan"},{"title":"算法分析与设计 第三章 动态规划","slug":"算法分析与设计-第三章-动态规划","date":"2020-03-10T13:26:00.000Z","updated":"2022-02-26T03:51:21.593Z","comments":true,"path":"2020/03/10/算法分析与设计-第三章-动态规划/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/10/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"详见我的另一篇文章动态规划（mooc课程上讲的）动规介绍 矩阵连乘（加括号）问题 本实验的算法思路是： 1、计算最优值算法MatrixChain()：建立两张表（即程序中的m和s，利用二维指针存放），一张表存储矩阵相乘的最小运算量，主对角线上的值为0，依次求2个矩阵、3个矩阵…、直到n个矩阵相乘的最小运算量，其中每次矩阵相乘的最小运算量都在上一次矩阵相乘的最小运算量的基础上求得，最后一次求得的值即为n个矩阵相乘的最小运算量；另一张表存储最优断开位置。 2、输出矩阵结合方式算法Traceback()：矩阵结合即是给矩阵加括号，打印出矩阵结合方式，由递归过程Traceback()完成。分三种情况： （1）只有一个矩阵，则只需打印出A1； （2）有两个矩阵，则需打印出（A1A2）； （3）对于矩阵数目大于2，则应该调用递归过程Traceback()两次，构造出最优加括号方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#ifndef MATRIX_H#define MATRIX_Hclass Matrix&#123;public: Matrix(); //构造函数 ~Matrix(); //析构函数 bool Run(); //运行接口函数private: int W; //记录矩阵的个数 int **m; //存放最优值，即最小运算量 int **s; //断开位置 int *p; //存放 bool Input(); //处理输入 bool MatrixChain();//计算最优值算法 void Traceback(int i,int j,int **s); //输出矩阵加括号的方式&#125;;#endif#define N 50#include &lt;iostream.h&gt;#include &lt;stdlib.h&gt;#include &quot;Matrix.h&quot;//构造函数，作变量初始化工作，为指针分配内存空间Matrix::Matrix()&#123; W=0; m = new int*[N]; s = new int*[N]; for(int i=0; i&lt;N ; i++) &#123; m[i] = new int[N]; s[i] = new int[N]; &#125; p = new int[N];&#125;//析构函数，释放内存Matrix::~Matrix()&#123; for(int i=0; i&lt;N ; i++) &#123; delete []m[i]; delete []s[i]; &#125; delete []m; delete []s; delete []p;&#125;//处理键盘输入bool Matrix::Input()&#123; int w; cout&lt;&lt;&quot;矩阵个数：&quot;; cin&gt;&gt;w; W = w; cout&lt;&lt;&quot;输入矩阵A1维数&quot;&lt;&lt;&quot;：&quot;; cin&gt;&gt;p[0]&gt;&gt;p[1]; for(int i=2 ; i&lt;=W ; i++) &#123; int m = p[i-1]; cout&lt;&lt;&quot;输入矩阵A&quot;&lt;&lt;i&lt;&lt;&quot;维数：&quot;; cin&gt;&gt;p[i-1]&gt;&gt;p[i]; if(p[i-1] != m) &#123; cout&lt;&lt;endl&lt;&lt;&quot;维数不对，矩阵不可乘！&quot;&lt;&lt;endl; exit(1); &#125; //cout&lt;&lt;endl; &#125; if(p!=NULL) return true; else return false;&#125;//计算最优值算法bool Matrix::MatrixChain()&#123; if(NULL == p) return false; for(int i=1;i&lt;=W;i++) m[i][i]=0; for(int r=2;r&lt;=W;r++)//循环W-1次 for(int i=1;i&lt;=W-r+1;i++) &#123;//求出每次斜线上的值 斜线上的个数为W-r+1个 int j=i+r-1;//纵坐标的值 m[i][j] = m[i+1][j] + p[i-1]*p[i]*p[j]; s[i][j] = i;//s数组记录此元素之前划分（）的位置 for(int k=i+1;k&lt;j;k++) &#123;//找一个中间值k 最小化m[i][j]的值 int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]; if(t&lt;m[i][j]) &#123; m[i][j] = t; s[i][j] = k; &#125; &#125; &#125; return true;&#125;//输出矩阵结合方式，加括号void Matrix::Traceback(int i,int j,int **s)&#123; if(i == j) &#123; cout&lt;&lt;&quot;A&quot;&lt;&lt;i; &#125; else if(i+1 == j) &#123; cout&lt;&lt;&quot;(A&quot;&lt;&lt;i&lt;&lt;&quot;A&quot;&lt;&lt;j&lt;&lt;&quot;)&quot;; &#125; else &#123; cout&lt;&lt;&quot;(&quot;; Traceback(i,s[i][j],s); Traceback(s[i][j]+1,j,s); cout&lt;&lt;&quot;)&quot;; &#125;&#125;bool Matrix::Run()&#123; if(Matrix::Input()) &#123; if(Matrix::MatrixChain()) &#123; Matrix::Traceback(1,W,s); cout&lt;&lt;endl; return true; &#125; else return false; &#125; else return false;&#125;#include &quot;Matrix.h&quot;void main()&#123; Matrix m; m.Run();&#125; 算石子之和问题描述 在一条直线上有n堆石子，每堆有一定的数量，每次可以将两堆相邻的石子合并，合并后放在两堆的中间位置，合并的费用为两堆石子的总数。求把所有石子合并成一堆的最小花费。输入格式 输入第一行包含一个整数n，表示石子的堆数 接下来一行，包含n个整数，按顺序给出每堆石子的大小 。输出格式 输出一个整数，表示合并的最小花费。样例输入51 2 3 4 5样例输出33 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,s[101]=&#123;0&#125;,f[101][101];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;s[i]); s[i]+=s[i-1]; &#125; for(int i=n-1;i&gt;=1;i--) for(int j=i+1;j&lt;=n;j++) &#123; f[i][j]=f[i][i]+f[i+1][j]+s[j]-s[i-1]; for(int k=i+1;k&lt;=j-1;k++) f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+s[j]-s[i-1]); &#125; printf(&quot;%d&quot;,f[1][n]); return 0;&#125;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,s[101],f[101][101];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;s[i]); s[i]+=s[i-1]; &#125; for(int len=2;len&lt;=n;len++) for(int i=1;i&lt;=n-len+1;i++)//n-len+1为了防止越界 &#123; int j=i+len-1; f[i][j]=f[i][i]+f[i+1][j]+s[j]-s[i-1]; for(int k=i+1;k&lt;j;k++) f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]+s[j]-s[i-1]); &#125; printf(&quot;%d&quot;,f[1][n]); return 0;&#125;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int n,s[101],f[101][101];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;s[i]); s[i]+=s[i-1]; &#125; for(int j=2;j&lt;=n;j++) for(int i=1;i&lt;=n-j+1;i++) &#123; f[i][j]=f[i][1]+f[i+1][j-1]+s[i+j-1]-s[i-1]; for(int k=2;k&lt;=j-1;k++) f[i][j]=min(f[i][j],f[i][k]+f[i+k][j-k]+s[i+j-1]-s[i-1]); &#125; printf(&quot;%d&quot;,f[1][n]); return 0;&#125; 一圈石子的和（洛谷P1880 石子合并，类似矩阵连乘加括号）题目描述 在一个园形操场的四周摆放N堆石子,现要将石子有次序地合并成一堆.规定每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。 试设计出1个算法,计算出将N堆石子合并成1堆的最小得分和最大得分. 12345678910111213141516171819202122232425#include &quot;bits/stdc++.h&quot;using namespace std;int a[201],f1[201][201],f2[201][201],w[201];//f1最小值，f2最大值，w前缀和int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]), a[n+i]=a[i]; for(int i=1;i&lt;=2*n;i++) w[i]=w[i-1]+a[i];//前缀和预处理 for(int i=2*n-1;i&gt;=1;i--) for(int j=i+1;j&lt;=2*n;j++) &#123; int mn=2e9,mx=0; for(int k=i;k &lt; j;k++) &#123; mn=min(mn,f1[i][k]+f1[k+1][j]+w[j]-w[i-1]);//D行 mx=max(mx,f2[i][k]+f2[k+1][j]+w[j]-w[i-1]); &#125; f1[i][j]=mn;f2[i][j]=mx; &#125; int mx=0,mn=1e+9; for(int i=1;i&lt;=n;i++)&#123; mx=max(mx,f2[i][i+n-1]); mn=min(mn,f1[i][i+n-1]); &#125; printf(&quot;%d\\n%d&quot;,mn,mx); return 0;&#125;","categories":[{"name":"算法分析与设计","slug":"算法分析与设计","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}],"tags":[],"author":"aoyuehan"},{"title":"计算方法","slug":"计算方法","date":"2020-03-10T07:37:00.000Z","updated":"2022-02-26T03:52:52.012Z","comments":true,"path":"2020/03/10/计算方法/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/10/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/","excerpt":"","text":"计算方法笔记tips：选了这门课是我大学里面选课中做过的最差的决定，啊草，orz，咬舌自尽。 第一章绪论和第二章误差绪论 误差浮点数 从计算量的大小看算法的重要性 一个不稳定算法的例子 误差的来源和分析 有效数字 【第二章误差】后两节和【第三章插值法与数值微分】前三节数值运算的误差估计 近似计算中需要注意的问题 多项式插值函数的唯一性 lagrange插值函数 多项式插值的余项 tips：罗尔定理 解线性方程组的直接法高斯消去 矩阵的LU分解 LU分解的一些定理 对称正定分解的唯一性 平方根法 解线性方程组的迭代法（上）向量范数 引理 (Hölder) 不等式 Minkovski 不等式 向量范数的等价和收敛 矩阵的范数和收敛 算子范数 matlab求范数 解线性方程组的迭代法（下）算子范数的性质 线性方程租条件数和误差分析 常用迭代形式 线性方程组迭代收敛的条件 特殊判敛法 考试题变式","categories":[{"name":"计算方法","slug":"计算方法","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"}],"tags":[],"author":"aoyuehan"},{"title":"传递闭包问题","slug":"传递闭包问题","date":"2020-03-08T10:42:00.000Z","updated":"2022-02-26T03:51:21.535Z","comments":true,"path":"2020/03/08/传递闭包问题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/08/%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"概念传递闭包是什么东西呢？就是形如一个集合，如果元素&lt;x,y&gt;、&lt;y,z&gt;在集合里，那么元素&lt;x,z&gt;也在集合里。放到图里就是说如果点x到y可到达，那么x和y就有一条边相连。放到矩阵里就是&lt;x,y&gt;是1。那么这个集合本身就是一个传递闭包。这就是离散数学中的关系，如果x与y满足关系R，y与z满足关系R，关系R具有传递性的话，那么可以得到x与z满足关系R。 图论 Warshall首先我们先说下图论，一般图存储可以使用邻接矩阵，或邻接表，一般使用邻接矩阵在稠密图比较省空间。 我们来说下有向图，一般的有向图也是图，图可以分为稠密图，稀疏图，那么从意思上，稠密图就是点的边比较多，稀疏图就是边比较少的图。为什么稠密图放在矩阵比较省空间，因为邻接表在边之间存储需要多余的指针，而矩阵不需要。 对于有向图来说： floyd传递闭包n头牛比赛，m种比赛结果，最后问你一共有多少头牛的排名被确定了，其中如果a战胜b，b战胜c，则也可以说a战胜c，即可以传递胜负。求能确定排名的牛的数目。思路：如果一头牛被x头牛打败，打败y头牛，且x+y&#x3D;n-1，则我们容易知道这头牛的排名就被确定了，所以我们只要将任何两头牛的胜负关系确定了，在遍历所有牛判断一下是否满足x+y&#x3D;n-1，将满足这个条件的牛数目加起来就是所求解。抽象为简单的floyd传递闭包算法，在加上每个顶点的出度与入度 （出度+入度&#x3D;顶点数-1，则能够确定其编号）。传递闭包的定义：G的传递闭包定义为G*&#x3D;(V,E*),其中E&#x3D;{(i,j):图G中存在一条从i到j的路径}。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;using namespace std;const int maxn=205;int n, m;int e[maxn][maxn]=&#123;0&#125;;int s[maxn][2]=&#123;0&#125;;void floyd()&#123; for(int k=1;k&lt;=n;k++) &#123; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; e[i][j]=(e[i][j]||(e[i][k]&amp;&amp;e[k][j])); &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++) &#123; int x, y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); e[x][y]=1; &#125; floyd(); for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=n;j++) &#123; s[i][0]+=e[i][j]; s[j][1]+=e[i][j]; &#125; &#125; int ans=0; for(int i=1;i&lt;=n;i++) &#123; if(s[i][0]+s[i][1]==n-1) &#123; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 题目二：http://acm.hdu.edu.cn/showproblem.php?pid=1704题意：给出一些排名，求最少需要询问多少次才能确定总体排名。本题属于求传递闭包问题，用Floyd算法即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt; using namespace std;const int N = 505; int map[N][N];int n,m; void Floyd()&#123; for(int k=1; k&lt;=n; k++) for(int i=1; i&lt;=n; i++) if(map[i][k]) for(int j=1; j&lt;=n; j++) if(map[k][j]) map[i][j] = 1;&#125; int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; int cnt = 0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) map[i][j] = (i == j); while(m--) &#123; int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); map[u][v] = 1; &#125; Floyd(); for(int i=1; i&lt;=n; i++) for(int j=i+1; j&lt;=n; j++) if(!(map[i][j] || map[j][i])) cnt++; printf(&quot;%d\\n&quot;,cnt); &#125; return 0;&#125; tips：省赛2019 L题 Media","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"训练22 cfabc3_6","slug":"训练22-cfabc3-6","date":"2020-03-07T13:49:06.000Z","updated":"2022-02-26T03:52:52.074Z","comments":true,"path":"2020/03/07/训练22-cfabc3-6/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/07/%E8%AE%AD%E7%BB%8322-cfabc3-6/","excerpt":"","text":"Balloons CodeForces - 998A题意：给出n个数列，表示有n袋气球，分给两个人，每个人至少有一袋，而且，两个人的气球总数不能一样，输出其中任意一个人所分得的气球袋数，以及这袋气球的下标。 思路：如果只有一袋气球，或者有两袋气球，并且这两袋气球的量一样的话，那么不可能按要求分气球，输出-1，否则，给任意一个人最小的那袋气球，其他全部分给另外一个人即可。 123456789101112131415161718#include &quot;iostream&quot;using namespace std;int a[1005];int main()&#123; ios::sync_with_stdio(false); int n,sum=0,Min=0xfffffff,t; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123;cin&gt;&gt;a[i];sum+=a[i];if(Min&gt;a[i])&#123;Min=a[i],t=i;&#125;&#125; if(n==1) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else&#123; if(Min==(sum-Min)) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else&#123; cout&lt;&lt;1&lt;&lt;endl&lt;&lt;t&lt;&lt;endl; &#125; &#125; return 0;&#125; https://vjudge.net/contest/360958#problem/A https://vjudge.net/contest/361143#problem 今晚D题题解：设ans为结果看L和R的二进制，设L最高位的1对应的值位A，R最高位的1对应的值位B(比如5的二进制是101，最高位的1对应的是2^2&#x3D;4）若A&#x3D;&#x3D;B，ans这一位上的异或值必然是0，所以让L和R都减去最高位，重新找最高位的1。若A!&#x3D;B，那么B肯定大于A，也就是说R的二进制比L的二进制长，然后，可以这样想：首先ans在B这一位上肯定应该是1，因为要使结果最大。因为左端点二进制的长度是小于右端点的，所以可以让第一个数除了B这一位是0，后面的位都是1(这个数一定能取到)；让第二个数除了B这一位是1，后面的位都是0(这个数也一定能取到)，即让第一个数是B-1，第二个数是B此时B^(B-1)就是最大的结果例如，假设L是101(二进制)，R是10010(二进制)，那么B是10000(二进制)，让第一个数为1111，第二个数为10000，结果就是11111，肯定就最大了。","categories":[],"tags":[],"author":"aoyuehan"},{"title":"训练21 UCF 2012  Contest","slug":"训练21-UCF-2012-Contest","date":"2020-03-05T14:52:00.000Z","updated":"2022-02-26T03:51:21.617Z","comments":true,"path":"2020/03/05/训练21-UCF-2012-Contest/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/05/%E8%AE%AD%E7%BB%8321-UCF-2012-Contest/","excerpt":"","text":"B How Old Are You Mr.String?题意：给你两个串，问大小规则为如果s1的z的数量大于s2的，则s1的串更老，否则判断s1中的y的数量和s2中y的数量，若s1的多，则s1的老，否则依次向下比较。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main() &#123; int zimu[27];//记录第一个字符串中出现的字母次数 int zimu1[27]; string s1,s2; int n ,tmp,cnt=0; cin&gt;&gt;n; while(n-- ) &#123; bool flag1=false,flag2=false; cin&gt;&gt;s1&gt;&gt;s2;cnt++; memset(zimu,0,sizeof(zimu)); memset(zimu1,0,sizeof(zimu1)); for(int i=0; i&lt;s1.length(); i++) &#123; tmp=s1[i]-&#x27;a&#x27;;//把相应的字母顺序存起来 zimu[tmp]++; &#125; for(int i=0; i&lt;s2.length(); i++) &#123; tmp=s2[i]-&#x27;a&#x27;; zimu1[tmp]++; &#125; for(int i=25;i&gt;=0;i--)&#123; if(zimu[i]&lt;zimu1[i])&#123; flag1=true;//比较大小 break; &#125;else if(zimu[i]&gt;zimu1[i])&#123; flag2=true; break; &#125; &#125; if(flag1)&#123;//输出结果 cout&lt;&lt;&quot;Data set #&quot; &lt;&lt;cnt&lt;&lt;&quot;: First string is younger&quot;&lt;&lt;endl&lt;&lt;endl; &#125;else if(flag2)&#123; cout&lt;&lt;&quot;Data set #&quot; &lt;&lt;cnt&lt;&lt;&quot;: First string is older&quot;&lt;&lt;endl&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;Data set #&quot; &lt;&lt;cnt&lt;&lt;&quot;: The two strings are the same age&quot;&lt;&lt;endl&lt;&lt;endl; &#125; &#125;&#125; C-leen Up The Powers That Be题意 ：给你一个数的底数和指数，底数相同的可以合并，然后然你输出按底数从小到大输出，有格式要注意。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3fusing namespace std;const int maxn = 25;struct node&#123; int a, b;///a -&gt; 底数, b -&gt; 指数 int x, y;///x -&gt; a的位数, y -&gt; b的位数&#125;P[maxn];int t, n;bool cmp(node a, node b)&#123; return a.a &lt; b.a;&#125;int work(int x)&#123;//判断这个数的位数 int ans = 0; while(x)&#123; ans++; x /= 10; &#125; return ans;&#125;void solve(int k)&#123; printf(&quot;Prime Factorization #%d:\\n&quot;, k); int i = 0, j = 0; while(P[i].a == -1) i++, j++; for(; i &lt; n; i++)&#123; while(P[i].x--) cout &lt;&lt; &quot; &quot;;//输出指数时先输出底数对应的空格数 cout &lt;&lt; P[i].b; &#125; cout &lt;&lt; endl; for(; j &lt; n; j++)&#123; cout &lt;&lt; P[j].a; while(P[j].y--) cout &lt;&lt; &quot; &quot;;//输出底数时先输出指数对应的空格数 &#125; cout &lt;&lt; endl; cout &lt;&lt; endl;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; t; for(int Case = 1; Case &lt;= t; Case++)&#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; P[i].a &gt;&gt; P[i].b; for(int j = 0; j &lt; i; j++)&#123; if(P[i].a == P[j].a)&#123; P[j].b += P[i].b; P[i].a = -1; break; &#125; &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; if(P[i].a != -1)&#123;//有两个相同的a的时候，只需要算一个a就好了，这个a就是不等于-1的那个 P[i].x = work(P[i].a); P[i].y = work(P[i].b); &#125; &#125; sort(P, P + n, cmp); solve(Case); &#125; return 0;&#125; H 三个数比较大小12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e5;int set1[maxn];int main()&#123; int n,cnt=0;cin&gt;&gt;n; getchar();string s ;int tmp; while(n--)&#123; cnt++; getline(cin,s); stringstream ss; //我以为给你一行数 不限制大小，其实题意为3个数 ss&lt;&lt;s ;int i=0; while(ss&gt;&gt;tmp)&#123; set1[i++]=tmp; &#125; sort(set1,set1+i,greater&lt;int&gt;()); cout&lt;&lt;&quot;Data set #&quot;&lt;&lt;cnt&lt;&lt;&quot;: &quot;&lt;&lt;endl; cout&lt;&lt;&quot; Original order:&quot;;//原来输入的顺序，我以为这地方是从大大小，一直找不出错误来 for(int j=0;j&lt;i;j++)&#123; cout&lt;&lt; &quot; &quot;&lt;&lt;set1[j]; &#125; cout&lt;&lt;endl; cout&lt;&lt;&quot; Smallest to largest:&quot;; for(int j=i-1;j&gt;=0;j--)&#123;//输出递增序，因为从大到小排列的，所以倒着输出，才是从小到大 cout&lt;&lt; &quot; &quot;&lt;&lt;set1[j]; &#125; cout&lt;&lt;endl&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"算法 第二章课后作业","slug":"算法第二章课后作业","date":"2020-03-05T10:26:00.000Z","updated":"2022-02-26T03:52:51.819Z","comments":true,"path":"2020/03/05/算法第二章课后作业/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/05/%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"时间复杂度分析按量级递增排序：常量阶O(1) &lt; 对数阶O(logn) &lt; 线性阶O(n) &lt; 线性对数阶O(nlogn) &lt; 平方阶O(n²)…立方阶O(n³)…k方阶 &lt; 指数阶O( 2^n) &lt; 阶乘阶O(n!) 其中，O( 2^n)和O(n!)为非多项式量级，其他的为多项式量级。我们把时间复杂度为非多项式量级的算法问题叫作NP（Non-Deterministic Polynomial，非确定多项式）问题。 解答： 要先计算出这段时间做出来的问题的大小，然后再换算到不同的问题规模上。 习题 2.2 第二题解析 特别注意第五问中的那种写法，若果while的条件改为left&lt;right，那么必须要在while结束之后再特判一下left指针指向的值是否与要查找的x的值相等；而当while的条件为left&lt;&#x3D;right的时候，只需要在while中判断mid就好了 解答： 习题2-3 二分的改写设a[0:n-1]是已排好序的数组，请改写二分搜索算法，使得当x不在数组中时，返回小于x的最大元素位置i和大于x的最小元素位置j。当搜索元素在数组中时，i和j相同，均为x在数组中的位置。输入格式: 输入有两行：第一行是n值和x值； 第二行是n个不相同的整数组成的非降序序列，每个整数之间以空格分隔。 输出格式:输出小于x的最大元素的最大下标i和大于x的最小元素的最小下标j。当搜索元素在数组中时，i和j相同。 提示：若x小于全部数值，则输出：-1 0 若x大于全部数值，则输出：n-1的值 n的值 输入样例:在这里给出一组输入。例如：6 52 4 6 8 10 12输出样例:在这里给出相应的输出。例如：1 2 思路：就是用两个数i和j，分别记录小于x和大于x那个最大最小位置，如果x在数组a中，那么会执行i&#x3D;j&#x3D;middle，输出结果。如果i和j不在数组中，最后一次left和right指针修改后，两指针交错，跳出while循环，此时的left和right的位置就是要求的结果，i&#x3D;left，j&#x3D;right，然后输出i和j的值。 伪代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;int BIN(int a[], int key, int n) &#123; int left = 0; int right = n - 1; int i = 0; int j = 0; while (left &lt;= right) &#123; int middle = (left + right) / 2; if (key == a[middle]) &#123; i = j = middle; cout &lt;&lt; i &lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl; //cout &lt;&lt; t; return middle; &#125; if (key &gt; a[middle])left = middle + 1; else &#123; right = middle - 1; &#125; &#125; i = right; j = left; cout &lt;&lt; i&lt;&lt;&quot; &quot;&lt;&lt; j&lt;&lt;endl; return -1;&#125;int main() &#123; int n; int x; cin &gt;&gt; n&gt;&gt; x; int *a = new int [n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; BIN(a, x, n); system(&quot;pause&quot;);&#125; tips：伪代码样例： 2-12设子数组a[0:k]和a[k+1:n-1]已排好序(0&lt;&#x3D;k&lt;&#x3D;n-1)，试设计一个合并这两个子数组为排好序的数组a[0:n-1]的算法。要求算法在最坏情况下所用的计算时间为O(n)，且只用到O(1)的辅助空间。分析思路：从a[0:k]的第一个元素开始依次与数组a[k+1:n-1]中的元素做比较，找出较小的一个元素，将其余a[0:k]中的元素都向右移动，将较小元素放在第一个位置上，依此类推，就能得到一个有序的新数组，且在最坏情况下的时间复杂度为O(n)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;int main()&#123; int a[8]; int n=8; int i=0; int k=3; int j=k+1; printf(&quot;请输入要排序的两个数组：&quot;); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; int binarySearch(int a[],const int x,int left,int right); void shiftRight(int a[],int s,int t); void print(int a[],int n); while(i&lt;j&amp;&amp;j&lt;n)&#123; int p=binarySearch(a,a[i],j,n-1); if(p&gt;=j) shiftRight(a,i,p); j=p+1; i=i+(p-j+1)+1; &#125; printf(&quot;排序后的新数组为：&quot;); print(a,n); return 0;&#125; int binarySearch(int a[],const int x,int left,int right)&#123; int middle; while(left&lt;=right)&#123; middle=(left+right)/2; if(x==a[middle]) left=middle+1; else right=middle-1; &#125; if(x&gt;a[middle]) return middle; else return middle-1;&#125;void shiftRight(int a[],int s,int t)&#123; int tmp=a[t]; for(int j=t;j&gt;s;j--)&#123; a[j]=a[j-1]; &#125; a[s]=tmp;&#125;void print(int a[],int n)&#123; for(int i=0;i&lt;n;i++)&#123; printf(&quot;%d &quot;,a[i]); &#125;&#125; 2-20对一个随机化算法,为什么我们只分析其平均下的性能，而不分析其最坏情况下的性能 ？？因为用随机函数全部或部分地抵消最坏输入的作用,使算法的时间效率不完全依赖于输入的好坏，随机化算法有一个共同的性质:没有一个特别的输入会使算法执行出现最坏情况 最坏情况可以表现在执行流程中(主要是时间效率),也可以表现在执行结果中。所以这样只需分析其平均情况下的性能就好了。 众数问题给定含有n个元素的多重集合S，每个元素在S中出现的次数称为该元素的重数。多重集合S中重数最大的元素称为众数。例如{1，2，2，2，3，5}。多重集合S的众数为2，其重数为3。数据输入：输入第一行为多重集S中元素的个数n；在接下来的n行中，每行有一个自然数。结果输出：输出由两行，第一行为众数，第二行时重数 方法一：分治法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int main() &#123; int n; cin&gt;&gt;n;//元素个数 int a[n]; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125;//数组用于存放元素 int l=0;//数组的首个标号 int r=n-1;//数组的最后一个标号 int largest=0;//重数的初始化 int elem=-1;//众数的初始化 mode(a,l,r,largest,elem);//调用函数 cout&lt;&lt;elem&lt;&lt;endl&lt;&lt;largest&lt;&lt;endl;//输出众数和重数 return 0;&#125;//用于求数组的中位数的函数↓int median(int *a,int l,int r) &#123; return a[(l+r)/2];&#125;//以med来划分数组↓ ！！！关键函数void split(int *a,int med,int l,int r,int &amp;l1,int &amp;r1) &#123; for(l1=l; l1&lt;=r; l1++) &#123; if(a[l1]==med) break; &#125;//l1表示首个等于med的数组下标 for(r1=l1+1; r1&lt;=r; r1++) &#123; if(a[r1]!=med) break; &#125; r1--;&#125;//r1表示最后一个等于med的数组下标void mode(int *a,int l,int r,int &amp;largest,int &amp;elem) &#123; int l1,r1;//分割后左边子数组的右界和右边子数组的左界 int med=median(a,l,r);//midian函数用于找到数组的中位数 split(a,med,l,r,l1,r1);//以med中位数来分割数组 if(largest&lt;r1-l1+1) &#123; largest=r1-l1+1; elem=med; &#125;//每次递归更新众数和重数的值 if(l1-l&gt;largest) mode(a,l,l1-1,largest,elem);//判断左边是否值得递归（只有l1-1大于largest才有必要搜寻） if(r-r1&gt;largest) mode(a,r1+1,r,largest,elem);//判断右边是否值得递归&#125; 方法二：c++的STL的pair声明一个pair&lt;int,int&gt;p ，p.first代表集合里的一个元素，p.second代表这个元素出现的次数，遍历一遍就可以找到结果。 方法三：桶排序直接找到数量最多的输出即可 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; int a[100000]; memset(a, 0, sizeof(a)); int imax = 0; int x; cin&gt;&gt;n; for(int i = 0; i &lt; n; i++) &#123; cin&gt;&gt;x; a[x]++; if(imax &lt; a[x]) &#123; imax = a[x]; &#125; &#125; for(int i = 0; ; i++) // 出现多个众数，输出最小的那个 &#123; if(imax == a[i]) &#123; cout&lt;&lt;i&lt;&lt;endl&lt;&lt;a[i]&lt;&lt;endl; break; // 输出后必须break &#125; &#125; return 0;&#125;","categories":[{"name":"算法分析与设计","slug":"算法分析与设计","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}],"tags":[],"author":"aoyuehan"},{"title":"国王挖金矿 动规","slug":"国王挖金矿-动规","date":"2020-03-05T06:48:00.000Z","updated":"2022-02-26T03:51:21.550Z","comments":true,"path":"2020/03/05/国王挖金矿-动规/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/05/%E5%9B%BD%E7%8E%8B%E6%8C%96%E9%87%91%E7%9F%BF-%E5%8A%A8%E8%A7%84/","excerpt":"","text":"动态规划入门问题之国王挖金矿（01背包） 问题引入有一个国家，所有的国民都非常老实憨厚，某天他们在自己的国家发现了十座金矿，并且这十座金矿在地图上排成一条直线，国王知道这个消息后非常高兴，他希望能够把这些金子都挖出来造福国民，首先他把这些金矿按照在地图上的位置从西至东进行编号，依次为0、1、2、3、4、5、6、7、8、9，然后他命令他的手下去对每一座金矿进行勘测，以便知道挖取每一座金矿需要多少人力以及每座金矿能够挖出多少金子，然后动员国民都来挖金子。 题目补充1：挖每一座金矿需要的人数是固定的，多一个人少一个人都不行。国王知道每个金矿各需要多少人手，金矿i需要的人数为 peopleNeeded[i]。 题目补充2：每一座金矿所挖出来的金子数是固定的，当第i座金矿有peopleNeeded[i]人去挖的话，就一定能恰好挖出gold[i]个金子。否则一个金子都挖不出来。 题目补充3：开采一座金矿的人完成开采工作后，他们不会再次去开采其它金矿，因此一个人最多只能使用一次。 题目补充4：国王在全国范围内仅招募到了10000名愿意为了国家去挖金子的人，因此这些人可能不够把所有的金子都挖出来，但是国王希望挖到的金子越多越好。 题目补充5：这个国家的每一个人都很老实（包括国王），不会私吞任何金子，也不会弄虚作假，不会说谎话。 题目补充6：有很多人拿到这个题后的第一反应就是对每一个金矿求出平均每个人能挖出多少金子，然后从高到低进行选择，这里要强调这种方法是错的，如果你也是这样想的，请考虑背包模型，当有一个背包的容量为10，共有3个物品，体积分别是3、3、5，价值分别是6、6、9，那么你的方法取到的是前两个物品，总价值是12，但明显最大值是后两个物品组成的15。 题目补充7：我们只需要知道最多可以挖出多少金子即可，而不用关心哪些金矿挖哪些金矿不挖。 那么，国王究竟如何知道在只有10000个人的情况下最多能挖出多少金子呢？国王是如何思考这个问题的呢？ **就是给出金矿的个数，和挖金矿的总人数，一个金矿有多少金子，每一个金矿要多少人挖，要不挖，要不就不挖；挖的话就一定挖完。 ** 思路第九号金矿处所能得到的最大金矿量取决于第八个金矿所能取出来的最大金矿量，因为第八个金矿量如果是从第0个，第1个一直到第八个金矿所能得到的最大的金矿量，那么第九个金矿所得到的的最大金矿量&#x3D;max（第八个金矿所得到的金矿量+第九个金矿挖出来的金子，第八个金矿所得到的金矿量）；这就是一种最优子结构 （至于为什么从第九个金矿处开始，好像就是因为如果实际上给你n个金矿，0这个地方当做边界，是可以少给函数传一个参数；不倒着来也可以的，但是不如倒着来好像一些） 边界就是第0个金矿，若果人数还足以挖第0个金矿，那么第0个金矿所能得到的最大金矿量就是第0个金矿挖出的金矿量； 否则人数不足以挖第0个金矿，第0个金矿所能得到的最大金矿量就是0 ； 记忆性递归 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576方法一：记忆性递归 #include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;const int max_n = 100;//程序支持的最多金矿数const int max_people = 10000;//程序支持的最多人数int n;//金矿数int peopleTotal;//可以用于挖金子的人数int peopleNeed[max_n];//每座金矿需要的人数int gold[max_n];//每座金矿能够挖出来的金子数int maxGold[max_people][max_n];//maxGold[i][j]保存了i个人挖前j个金矿能够得到的最大金子数，等于-1时表示未知//初始化数据void init() &#123; cin&gt;&gt;peopleTotal&gt;&gt;n; for(int i=0; i&lt;n; i++) cin&gt;&gt;peopleNeed[i]&gt;&gt;gold[i]; for(int i=0; i&lt;=peopleTotal; i++) for(int j=0; j&lt;n; j++) maxGold[i][j] = -1;//等于-1时表示没有得到该时的最大值 &#125;//获得在 有people个人和前mineNum个金矿时能够得到的最大金子数，注意“前多少个”也是从0开始编号的int GetMaxGold(int people, int mineNum) &#123; //如果这个问题曾经计算过 递归前先查 if(maxGold[people][mineNum] != -1) &#123; //获得保存起来的值 return maxGold[people][mineNum]; &#125; if(mineNum == 0) &#123; // 边界 //当给出的人数足够开采这座金矿 if(people &gt;= peopleNeed[mineNum]) &#123; //得到的最大值就是这座金矿的金子数 maxGold[people][mineNum]= gold[mineNum];//返回前先记录 return maxGold[people][mineNum]; &#125; else &#123; //否则这唯一的一座金矿也不能开采 //得到的最大值为0个金子 return 0; &#125; &#125; else &#123; //没有存下maxGold且不是边界的时候递归 if(people &gt;= peopleNeed[mineNum]) &#123; //如果人数够了本次可以开采的，考虑开采与不开采两种情况，取最大值 maxGold[people][mineNum] = max(GetMaxGold(people - peopleNeed[mineNum],mineNum -1) + gold[mineNum], GetMaxGold(people,mineNum - 1)); //返回前先记录再返回 return maxGold[people][mineNum]; &#125; else &#123; maxGold[people][mineNum]=GetMaxGold(people,mineNum - 1); return maxGold[people][mineNum]; &#125; &#125;&#125;int main( ) &#123; //初始化数据 init(); //输出给定peopleTotal个人和n个金矿能够获得的最大金子数，再次提醒编号从0开始，所以最后一个金矿编号为n-1 cout&lt;&lt;GetMaxGold(peopleTotal,n-1); return 0;&#125;/*测试数据 100 577 9222 2229 8750 4699 90133*/ debug： 第一次写的时候出现这个问题，为什么这一个地方的结果会这么大呐，原来是因为在mineNum &#x3D;&#x3D; 0时，我直接返回了此时的结果，没有存到maxGold[people][mineNum]，所以才会出现这样的问题，不过也好奇呀，没有记录，为啥会出现这样的数呐？？ 如果屏幕面前的小伙伴知道了可以在下方留言orz。记忆性递归 一定要注意取之前先找备忘录，返回之前要记录备忘录，然后在返回 动态规划有上面的记忆性递归，可以将递归改为递推，然后就成了动态规划了. 首先看个小例子：有数据： 至于动态规划方法的实现，这个问题的参数有两个，也就是存在两个输入维度，怎么能实现自底向上的递推呢？ **我们先画出如下表格，表格的第一列代表给定前1-5座金矿（这里金矿的编号从1开始，从0开始也无所谓，改个参数起始值就好了）**的情况，也就是N的取值。表格的第一行代表给定的工人数，也就是W的取值。表格中其余的空白格，代表给定N和W值对应的黄金获得数，也就是f(N，W)。下面让我们来逐行填写表格中的空白。 初始化第一行， 1金矿时，是400金，5工人。所以前4个格子都是0，因为人数不够。后面格子都是400，因为只有这一座金矿可挖。 第2座金矿有500金，5工人。第二行前4个格子是W &lt; 5, 所以F（N，W）&#x3D; F（N - 1，W）&#x3D; 0。 第2行后6个格子计算，因为W &gt;&#x3D;5，所以根据F（N，W）&#x3D; MAX（F(N-1，W)，F(N-1,W-5)+500），第5-9个格子的值是500。 需要注意的是第2行第10个格子，也就是N&#x3D;2,W&#x3D;10的时候，F(N-1,W)&#x3D;400，F(N-1,W-5)&#x3D;400,MAX(400，400+500) &#x3D; 900。 第3座金矿有200金，需要3工人。第3行计算方法和前面一样。 4. 第4座金矿有300金，需要4工人，计算方法同上。 5. 第5座金矿有350金，需要3工人，计算方法同上。 发现下一行的结果都是由上一行的结果推来的，所以这样的话，可以开一个preResults和results数组，分别存一下就好了。参考 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253方法二： 动态规划 #include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;const int max_n = 100;//程序支持的最多金矿数const int max_people = 10000;//程序支持的最多人数int n;//金矿数int peopleTotal;//可以用于挖金子的人数int peopleNeed[max_n];//每座金矿需要的人数int gold[max_n];//每座金矿能够挖出来的金子数int preResults[max_people] ;// 前一行的结果 ，preResults[i]代表在第j个人的时候能取得的最大金子量 int results[max_people] ;//当前行的结果 //初始化数据void init() &#123; cin&gt;&gt;peopleTotal&gt;&gt;n; for(int i=0; i&lt;n; i++) cin&gt;&gt;peopleNeed[i]&gt;&gt;gold[i];&#125;int getMostGold()&#123; for(int i=0;i&lt;=peopleTotal;i++)&#123;//初始化第一行，即第0个金矿，总共有i个人挖时的最大金子量 if(i&lt;peopleNeed[0])&#123; preResults[i]=0; &#125;else&#123; preResults[i]=gold[0]; &#125; &#125; for(int i=1;i&lt;n;i++)&#123;//第几个金矿，金矿从0开始计数 for(int j=0;j&lt;=peopleTotal;j++) &#123;//对于有多少个人来挖的最大金子量 if(j&lt;peopleNeed[i])&#123; results[j]=preResults[j]; &#125;else&#123; results[j]=max(preResults[j],preResults[j-peopleNeed[i]]+gold[i]); &#125; &#125; for(int j=0;j&lt;=peopleTotal;j++)&#123; preResults[j]=results[j];//省空间，才用两行来解决问题 //cout&lt;&lt;results[j]&lt;&lt;&#x27; &#x27;; &#125; //cout&lt;&lt;endl; &#125; return results[peopleTotal];&#125; int main( ) &#123; //初始化数据 init(); //输出给定peopleTotal个人和n个金矿能够获得的最大金子数，再次提醒编号从0开始，所以最后一个金矿编号为n-1 cout&lt;&lt;getMostGold(); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859看上面的程序，因为多开了一个数组，开销很大，滚动数组优化一下：#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;const int max_n = 100;//程序支持的最多金矿数const int max_people = 10000;//程序支持的最多人数int n;//金矿数int peopleTotal;//可以用于挖金子的人数int peopleNeed[max_n];//每座金矿需要的人数int gold[max_n];//每座金矿能够挖出来的金子数int preResults[max_people] ;// 前一行的结果 ，preResults[i]代表在第j个人的时候能取得的最大金子量 int results[max_people] ;//当前行的结果 //初始化数据void init() &#123; cin&gt;&gt;peopleTotal&gt;&gt;n; for(int i=0; i&lt;n; i++) cin&gt;&gt;peopleNeed[i]&gt;&gt;gold[i];&#125;int getMostGold()&#123; for(int i=0;i&lt;=peopleTotal;i++)&#123;//初始化第一行，即第0个金矿，总共有i个人挖时的最大金子量 if(i&lt;peopleNeed[0])&#123; preResults[i]=0; &#125;else&#123; preResults[i]=gold[0]; &#125; &#125; for(int i=1;i&lt;n;i++)&#123;//第几个金矿，金矿从0开始计数 for(int j=peopleTotal;j&gt;=0;j--) &#123;//对于有多少个人来挖的最大金子量 if(j&lt;peopleNeed[i])&#123; preResults[j]=preResults[j];//滚动数组的方式，倒着来 &#125;else&#123; preResults[j]=max(preResults[j],preResults[j-peopleNeed[i]]+gold[i]); &#125; &#125; &#125; return preResults[peopleTotal];&#125; int main( ) &#123; //初始化数据 init(); //输出给定peopleTotal个人和n个金矿能够获得的最大金子数，再次提醒编号从0开始，所以最后一个金矿编号为n-1 cout&lt;&lt;getMostGold(); return 0;&#125;/*测试数据 100 577 9222 2229 8750 4699 90133*/ debug： 发现怎么 都是92 呐，细心发现之后，原来是递推的时候写错了 1234if(j&lt;peopleNeed[i])&#123; preResults[j]=preResults[j];//滚动数组的方式，倒着来 &#125;else&#123; preResults[j]=max(preResults[j],preResults[jpeopleNeed[i]]+gold[i]);//这地方写为gold[j] 手贱&#125; 好啦，这就是一道动态规划 （0 1背包的裸题） 相信你已经学会了，可以看看我的背包问题总结，orz，up up up。","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"国王挖金子","slug":"国王挖金子","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%9B%BD%E7%8E%8B%E6%8C%96%E9%87%91%E5%AD%90/"}],"author":"aoyuehan"},{"title":"一个小问题 计算机网络结构的划分","slug":"一个小问题-计算机网络结构的划分","date":"2020-03-04T14:39:00.000Z","updated":"2022-02-26T03:52:52.381Z","comments":true,"path":"2020/03/04/一个小问题-计算机网络结构的划分/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/04/%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%92%E5%88%86/","excerpt":"","text":"这个答案我还没改的地方是， ，网站服务器链接一个交换机，其他交换机串联并入子网就可以其实这个和我当初画的一样， 其实这题有歧义 这样连出来的话 判题服务器好像也和队伍主机连接了。 不纠结了 这一题一定要知道那个 交换机是端到端传输的，而集线器不是。","categories":[{"name":"计算计网络","slug":"计算计网络","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%AE%A1%E7%AE%97%E8%AE%A1%E7%BD%91%E7%BB%9C/"}],"tags":[],"author":"aoyuehan"},{"title":"acm省赛2019","slug":"acm省赛2019","date":"2020-03-03T08:26:40.000Z","updated":"2022-02-26T03:52:51.825Z","comments":true,"path":"2020/03/03/acm省赛2019/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/03/03/acm%E7%9C%81%E8%B5%9B2019/","excerpt":"","text":"A Calandar 规律 模拟题目大意： 有一个神奇的星球，在那里，一年有12个月，每月都有30天。并且在那个星球上一周只有五天。给你今天的日期和星期，问你一个目标日期是星期几。分析： 仔细思考便容易发现所要求的日期是星期几和月份根本没有关系（一周五天，每个月都是30天，一个月正好是6次循环），和年份，和月份都没有关系了。只要求出两个日的关系，再输出对应的星期即可。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int crrday,disday,temp; string cday; scanf(&quot;%*d%*d%d&quot;,&amp;crrday); cin&gt;&gt;cday;//%*d忽略输入的这个数 scanf(&quot;%*d%*d%d&quot;,&amp;disday); if(cday==&quot;Monday&quot;) temp=0; if(cday==&quot;Tuesday&quot;) temp=1; if(cday==&quot;Wednesday&quot;) temp=2; if(cday==&quot;Thursday&quot;) temp=3; if(cday==&quot;Friday&quot;) temp=4; if(crrday&lt;=disday) temp=(temp+(disday-crrday)%5)%5; else temp=(temp+5-(crrday-disday)%5)%5; //cout&lt;&lt;&quot;Test temp : &quot;&lt;&lt;temp&lt;&lt;endl; if(temp==0) printf(&quot;Monday\\n&quot;); if(temp==1) printf(&quot;Tuesday\\n&quot;); if(temp==2) printf(&quot;Wednesday\\n&quot;); if(temp==3) printf(&quot;Thursday\\n&quot;); if(temp==4) printf(&quot;Friday\\n&quot;); &#125; return 0;&#125; B – Flipping Game（动规 计数dp）题意：给两个长度为n的01串，每次挑选第一个串其中的m位翻转（0变成1,1变成0,m位不用连续）问经过k次的后得到第二个串的方案数。 若两个串的某一位相同，则该位经过了偶数次翻转，否则经过了奇数次的翻转。 dp[i][j]表示经过了i轮翻转后奇数位数等于j的方案数，偶数的位数等于n-j。从0-m枚举k，表示j个奇数位中有k个翻转成了偶数，(n-j)个偶数位中有(m-k)位翻转成了奇数位，所以dp[i+1][j-k+(m-k)]+&#x3D;dp[i][j]*C[j][k]*C[n-j][m-k] ; 初始值的设置很巧妙。看上去这题似乎有两种正确的初始值设置方法：dp[0][0]&#x3D;1,求dp[k][num_odd] OR dp[0][num_odd]&#x3D;1,求dp[k][0]。可是经过试验发现两种的答案不一样。仔细想想，我们的dp过程中只记录了奇数位的个数，并没有具体统计哪位是奇数，因此我们最后得到的dp[k][num_odd]是所有的奇数位数等于答案的方案数，可是显然他们无法和要求的第二个串完全匹配。因此把初始值dp[0][num_odd]设成1求dp[k][0]才是正确的。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define LL long longLL dp[105][105],C[105][105];const int mod= 998244353;void init()&#123; for (int i=0;i&lt;=100;i++) C[i][0]=1; for (int i=1;i&lt;=100;i++)&#123; for (int j=1;j&lt;=i;j++)&#123; C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod; &#125; &#125;&#125;int main()&#123; init(); int T; cin&gt;&gt;T; while (T--)&#123; int n,q,m; cin&gt;&gt;n&gt;&gt;q&gt;&gt;m; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; int odd=0,even=0; for (int i=0;i&lt;n;i++)&#123; if (s1[i]==s2[i]) even++; else odd++; &#125; memset(dp,0,sizeof(dp)); dp[0][odd]=1; for (int i=0;i&lt;=q;i++)&#123; for (int j=0;j&lt;=n;j++)&#123; for (int k=0;k&lt;=m;k++)&#123; if (j&gt;=k &amp;&amp; (n-j)&gt;=(m-k))&#123; dp[i+1][j-k+(m-k)]+=dp[i][j]*C[j][k] %mod *C[n-j][m-k] %mod; dp[i+1][j-k+(m-k)]%=mod; &#125; &#125; &#125; &#125; cout&lt;&lt;dp[q][0]&lt;&lt;endl; &#125;&#125; C Wandering Robot题意：有一个机器人，会根据输入的命令走路，U代表向上，D代表向下，L代表向左，R代表向右，求：按给出的命令执行 k 遍的过程中，到达原点最远的距离是多少。两点距离：(x1, y1) 和 (x2, y2)按 | x1-x2 | + | y1-y2 | 计算。本来也打算用第一次得到的最大值，然后偏移之后得到最后k次之后的最大值，可是好像这样做是不对的。 大胆猜想 最大值只会出现在第一组和最后一组中，（千万不要忘记第一组，因为只有两组数据的话，有可能之后的结果都没有超过第一组的最大值） 一种情况如下图，在第一遍就出现最大值，以后没有超过的情况 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;algorithm&gt; using namespace std;typedef long long ll; int main()&#123; int T, n, k; char a[100010]; while( ~scanf(&quot;%d&quot;, &amp;T) ) &#123;//注意这种有多次T的情况下的多组输入 while(T--) &#123; scanf(&quot;%d %d&quot;, &amp;n, &amp;k); scanf(&quot; %s&quot;, a); ll x = 0, y = 0, max1 = 0; for(int i = 0; i &lt;= n-1; i++) //求第一遍最大值 &#123; if(a[i] == &#x27;U&#x27;) y++; else if(a[i] == &#x27;D&#x27;) y--; else if(a[i] == &#x27;L&#x27;) x--; else if(a[i] == &#x27;R&#x27;) x++; max1 = max(max1, abs(x)+abs(y)); &#125; x *= (k-1), y *= (k-1); for(int i = 0; i &lt;= n-1; i++) //求第k遍最大值 &#123; if(a[i] == &#x27;U&#x27;) y++; else if(a[i] == &#x27;D&#x27;) y--; else if(a[i] == &#x27;L&#x27;) x--; else if(a[i] == &#x27;R&#x27;) x++; max1 = max(max1, abs(x)+abs(y)); &#125; printf(&quot;%lld\\n&quot;, max1); &#125; &#125; return 0;&#125; tips:多组输入的情况还有就是那种 要求把给出的数据在输出一下，在给出答案的那种输出格式。 D - Game on a Graph连通图的性质：n个点必须要有n-1条边才能成为连通图 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;char ob[100005];int main()&#123; int t,n, x,y,z; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n;//输入的人数 for(int i=0;i&lt;n;i++) cin&gt;&gt;ob[i]; cin&gt;&gt;x&gt;&gt;y;//输入图的点数和边数 for(int i=0;i&lt;y;i++) cin&gt;&gt;z&gt;&gt;z;//抵消数据 y=(y-x+1)%n;//n个点必须要有n-1条边才能成为连通图 if(ob[y]==&#x27;1&#x27;)cout&lt;&lt;2&lt;&lt;endl; else cout&lt;&lt;1&lt;&lt;endl; &#125;&#125; F- Stones in the Bucket给你一堆石头的个数，每次可以进行两种操作，把一个桶中的一块石头拿走或者把一块石头拿到另一个桶中，问最后使得所有桶石头数目一样需要进行多少次操作。 题解：本来先for一下，得到总数，然后总数开始减少，知道减少到可以整除，然后结果就为减去的数量+原数组中比平均值多出来的那部分，好像这样算，算重了一些。 改进为：原数组中比平均值多出来的那部分-减去的数量。自己的算法这样太麻烦了，而且2次o(n)可能会超时，没想到原来平均值可以直接用&#x2F;来求，取整。 写出简单的伪代码，一定加以证明算法的正确性，不要感觉自己想明白了就开始写，后来发现这还有没考虑到的问题，而且怎么抽象，如本题的那个求平均值，就可以直接利用除法来求得，不用非得等到减少到取余得整的时候 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int num[1000005];int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; int n; scanf(&quot;%d&quot;,&amp;n); long long int sum=0; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%lld&quot;,&amp;num[i]); sum+=num[i]; &#125; sum/=n;//这样直接就得到了平均值 long long int ans=0; for(int i=1;i&lt;=n;i++) &#123; if(num[i]&gt;sum) ans+=num[i]-sum; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125; H Tokens on the Segments(ZOJ 4120)题目大意： 在二维坐标系中给出n条线段，第i条线段的两个端点分别为（li,i）和（ri,i）,每个整数点都可以被标记，但是被标记的点x坐标不能相同，求至少有一个点被标记的线段最多有多少条（好好读题意理解题意，刚开始的时候我看成了，可以用一个点标记的线段的最多数量是多少，后来发现也是读错了） 基本思路：贪心+优先队列1.要使标记的线段最多，一条线段上只需标记一个点2.尽可能标记短的线段，使更多线段可以被标记3. 先对所有线段按左端点从小到大，左端点相同时按右端点从小到大的顺序进行排序4.可选线段中左端点最小，且在与它左端点相同的所有线段中右端点最小的线段，标记左端点，对于与它左端点相同的其他线段则只能标记该点之后的点-&gt;优先队列5.队首线段左端点可标记则出队，计数器加一，若队首线段左端点已被标记，则将该线段左端点加一后再入队（保证左端点小于等于右端点） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;struct Segment&#123; int l,r;//左右端点x坐标 bool operator&lt;(Segment a) const &#123; if(l==a.l) return r&gt;a.r; return l&gt;a.l; &#125;&#125;;priority_queue&lt;Segment&gt; q;int main()&#123; int T,n,ans,x,y; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; ans=0; while(!q.empty())//清空队列 q.pop(); scanf(&quot;%d&quot;,&amp;n); while(n--) &#123; Segment t; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); t.l=x; t.r=y; q.push(t);//将所有线段加入队列 &#125; int k=0;//k记录上一个被标记的点的x坐标 while(!q.empty()) &#123; Segment u=q.top(); q.pop(); if(u.l==k)//若左端点已被标记，则左端点x坐标加一 &#123; u.l++; if(u.l&lt;=u.r)//得到的新线段符合要求则入队 q.push(u); &#125; else//若左端点没被标记，则k记为左端点，计数器加一 &#123; k=u.l; ans++; &#125; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; L - Median根据所有点的大小状态可以建立一个有向图。分析可知：一个数可以是中值数，当且仅当小于该数字的总个数小于”小于中值数的个数”,并且大于该数字的总个数也小于”大于中值数的个数”。转化为图论语言即：目标点为中值点，当且仅当该节点的前继节点总数小于n&#x2F;2，并且该节点的后继节点总数也小于n&#x2F;2。样例数据很走心的提醒了我们这个图可能成环。通过以上分析可以写出算法:1.判断成环2.对于每个点，分别求前继和后继节点数，并判断是否在目标范围内 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int maxn=100+5;int from[maxn][maxn],to[maxn][maxn]; //来去指向int fcnt[maxn],tcnt[maxn]; //入度出度数量int pre[maxn],aft[maxn]; //前继后继数目int in[maxn]; //入度数目副本int ans[maxn]; //答案bool vis[maxn]; //访问标记int m,n;void predfs(int u)&#123; //标计所有前继节点 if(vis[u]) return; vis[u]=true; for(int i=0;i&lt;fcnt[u];i++) predfs(from[u][i]);&#125;void aftdfs(int u)&#123; //标记所有后继节点 if(vis[u]) return; vis[u]=true; for(int i=0;i&lt;tcnt[u];i++) aftdfs(to[u][i]);&#125;bool iscir()&#123; //拓扑排序判断环 for(int i=0;i&lt;n;i++) in[i]=fcnt[i]; queue&lt;int&gt; q; memset(vis,false,sizeof(vis)); for(int i=0;i&lt;n;i++)&#123; if(in[i]==0)&#123; q.push(i); &#125; &#125; while(!q.empty())&#123; int u=q.front(); q.pop(); if(vis[u]) continue; vis[u]=true; for(int i=0;i&lt;tcnt[u];i++)&#123; int v=to[u][i]; if(vis[v])&#123; while(!q.empty()) q.pop(); return true; &#125; if(in[v]&gt;0) in[v]--; if(in[v]==0) q.push(v); &#125; &#125; for(int i=0;i&lt;n;i++)&#123; if(!vis[i]) return true; &#125; return false;&#125;int main()&#123; int t; int u,v; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); memset(fcnt,0,sizeof(fcnt)); memset(tcnt,0,sizeof(tcnt)); memset(ans,0,sizeof(ans)); for(int i=0;i&lt;m;i++)&#123; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); u--; v--; from[v][fcnt[v]]=u; to[u][tcnt[u]]=v; tcnt[u]++; fcnt[v]++; &#125; if(!iscir())&#123; memset(pre,0,sizeof(pre)); for(int i=0;i&lt;n;i++)&#123; memset(vis,false,sizeof(vis)); predfs(i); for(int i=0;i&lt;n;i++)&#123; if(vis[i]) pre[i]++; &#125; pre[i]--; &#125; memset(aft,0,sizeof(aft)); for(int i=0;i&lt;n;i++)&#123; memset(vis,false,sizeof(vis)); aftdfs(i); for(int i=0;i&lt;n;i++)&#123; if(vis[i]) aft[i]++; &#125; aft[i]--; &#125; int med=(n+1)/2; for(int i=0;i&lt;n;i++)&#123; if(aft[i]&lt;med&amp;&amp;pre[i]&lt;med) ans[i]=1; &#125; &#125; for(int i=0;i&lt;n;i++) printf(&quot;%d&quot;,ans[i]); putchar(&#x27;\\n&#x27;); &#125; return 0;&#125; 题意：一个序列有n个数，数值未知，给出m对大小关系，求对于每个数是否可以生成一个序列满足这个这个数为中位数，可以该位置输出1，反之输出0。 思路：考虑二元关系，可以建立有向图，考虑到数据范围很小，可以用floyed传递闭包，对于那些没有确定关系的数，他们的关系可以任意假设，所以只需要保证大（小）于他的元素个数少于n&#x2F;2即可。感谢题目提供的特判提醒 另外进行特判时，必须在floyed传递闭包之后，因为这个wa了好几发。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071？？？？？#include &lt;iostream&gt;#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=105;int a[maxn][maxn],ma[maxn],mi[maxn];int main()&#123; int T; cin&gt;&gt;T; while(T--) &#123; memset(a,0,sizeof(a)); memset(ma,0,sizeof(ma)); memset(mi,0,sizeof(mi)); int n,m,flag=0; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for (int i=1; i&lt;=m; i++) &#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); if (u==v) flag=1; a[u][v]=1; &#125; for (int k=1; k&lt;=n; k++) &#123; for (int i=1; i&lt;=n; i++) &#123; for (int j=1; j&lt;=n; j++) &#123; a[i][j]=a[i][j]||(a[i][k]&amp;&amp;a[k][j]); &#125; &#125; &#125; for (int i=1; i&lt;=n; i++) &#123; for (int j=1; j&lt;=n; j++) &#123; if (a[i][j]&amp;&amp;a[j][i]) &#123; flag=1; break; &#125; &#125; if (flag) break; &#125; if (flag) &#123; for (int i=1; i&lt;=n; i++) putchar(48); putchar(10); continue ; &#125; for (int i=1; i&lt;=n;i++) &#123; for (int j=1; j&lt;=n; j++) &#123; if (a[i][j]) ma[i]++,mi[j]++; &#125; &#125; for (int i=1; i&lt;=n; i++) &#123; if (ma[i]&lt;=n/2 &amp;&amp; mi[i]&lt;=n/2) putchar(49); else putchar(48); &#125; putchar(10); &#125; return 0;&#125; 求传递闭包问题http://acm.hdu.edu.cn/showproblem.php?pid=1704题意：给出一些排名，求最少需要询问多少次才能确定总体排名。本题属于求传递闭包问题，用Floyd算法即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt; using namespace std;const int N = 505; int map[N][N];int n,m; void Floyd()&#123; for(int k=1; k&lt;=n; k++) for(int i=1; i&lt;=n; i++) if(map[i][k]) for(int j=1; j&lt;=n; j++) if(map[k][j]) map[i][j] = 1;&#125; int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; int cnt = 0; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=n; j++) map[i][j] = (i == j); while(m--) &#123; int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); map[u][v] = 1; &#125; Floyd(); for(int i=1; i&lt;=n; i++) for(int j=i+1; j&lt;=n; j++) if(!(map[i][j] || map[j][i])) cnt++; printf(&quot;%d\\n&quot;,cnt); &#125; return 0;&#125; M Sekiro对一个数字求若干次除2取上界确实是有点水…直接暴力,循环特判一下 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;#define ll long long using namespace std;int main()&#123; ll t,n,m; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; while(m--) &#123; n=(n%2)?n/2+1:n/2; if(n==1||n==0)//必须得要，不然会超时，这点在交之前就应该想到 break; &#125; cout&lt;&lt;n&lt;&lt;endl; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"训练20 ICPC  NCNA Contest 2017","slug":"训练20-ICPC-NCNA-Contest-2017","date":"2020-02-29T12:16:26.000Z","updated":"2022-02-26T03:52:51.589Z","comments":true,"path":"2020/02/29/训练20-ICPC-NCNA-Contest-2017/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/29/%E8%AE%AD%E7%BB%8320-ICPC-NCNA-Contest-2017/","excerpt":"","text":"C Urban Design题意：先给你s组 直线，给出直线的两个端点，然后在给你t组点对（即（x1,y1）,(x2,Y2)），然后问你每一组的点对是否在一条直线的两段，如果在一条之间的两边，则会被设计为商业区和住宅区两种，然后问你t组点对是否被设计为不同的形式，相同输出same，否则输出different。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.io.StreamTokenizer;public class Main &#123; public static void main(String[] args) throws IOException &#123; StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in))); PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out)); in.nextToken(); int s = (int) in.nval; int a[][] = new int[s][4]; for (int i = 0; i &lt; s; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; in.nextToken(); a[i][j] = (int) in.nval; &#125; &#125; in.nextToken(); int t = (int) in.nval; for (int i = 0; i &lt; t; i++) &#123; int b[] = new int[4]; for (int j = 0; j &lt; 4; j++) &#123; in.nextToken(); b[j] = (int) in.nval; &#125; boolean f = true; for (int[] c : a) &#123;//通过叉积判断两点是否在直线同侧 f = f ^ ((c[2] - c[0]) * (b[3] - c[1]) - (c[3] - c[1]) * (b[2] - c[0]) &lt; 0) ^ ((c[2] - c[0]) * (b[1] - c[1]) - (c[3] - c[1]) * (b[0] - c[0]) &lt; 0); //这里的异或运算用的巧妙，因为在一条线的两段，最终结果为false，在两条线的两边， //最终结果为true，这正好和图中的结论一致。 &#125; if (f == true) &#123; out.println(&quot;same&quot;); out.flush(); &#125; else &#123; out.println(&quot;different&quot;); out.flush(); &#125; &#125; &#125;&#125; tips：向量运算 点乘公式 叉积运算： 判断一个点是否在一条线的两段 I Racing Around the Alphabet 模的意义题意：被坑了一次，读错了题，写错了，一直调不对。本题给出一句名言，然后给出一个由字母和空格和‘构成的圆环，然后从这句名言的第一个字母到最后一个字母，每次捡起字母要1秒，然后到下一个字母，在捡起来，然后。。。； 其中圆环的直径为60m，人的速度为15m每秒。问最少的时间为多少。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112我的方法：#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;map&gt;using namespace std;string s; int n;double ans;//把A到B看做为一个单元,ans记录走完一句话后的所有单元数 int yuan[28][28];//用来求两个字母间的间隔 map&lt;char ,int &gt;mp;int main()&#123; double per=3.14159265354*60/28;//从A到B，这种的单位长度 cin&gt;&gt;n;getchar(); int tmp=0; int tmpmax,tmpmin; for(int i=0;i&lt;28;i++)&#123; for(int j=0;j&lt;28;j++)&#123; if(i==j)&#123; yuan[i][j]=0; yuan[j][i]=0; &#125;else&#123; if(i&gt;j)&#123; tmpmax=i;tmpmin=j; &#125;else&#123; tmpmax=j;tmpmin=i; &#125; tmp=min((tmpmax-tmpmin),(tmpmin+28-tmpmax)); yuan[i][j]=tmp;yuan[j][i]=tmp; //这一部就是为了求两个字母间最少隔多少步 &#125; &#125; &#125; char tmpp; for(int i=0;i&lt;26;i++)&#123; tmpp=(char)(i+65); mp[tmpp]=i;//字母到yuan数组下标的映射 &#125; tmpp=(char)32; mp[tmpp]=26;//空格 对应着yuan数组中的26 tmpp=(char)39;mp[tmpp]=27;//’对应yuan数组中的27 while(n--)&#123; ans=0; getline(cin,s); int len=s.length(); for(int i=1;i&lt;len;i++)&#123; //如果比较的两个元素其中一个为空格或‘，就不统计 //if(s[i]==&#x27; &#x27;||s[i-1]==&#x27; &#x27;||(s[i-1]-&#x27;0&#x27;)==39||(s[i]-&#x27;0&#x27;)==39)continue; ans+=yuan[mp[s[i] ]][mp[s[i-1] ]]; &#125; //cout&lt;&lt;ans&lt;&lt;endl;//ans为走完所有字母间总的步数 printf(&quot;%.10lf\\n&quot;,(double)(per*ans*1.0/15)+len);//所有步数为per*ans &#125;&#125;苏用方法：#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;map&gt;using namespace std;const double pi=3.1415926535898;int main()&#123; map&lt;int,char&gt;m; m[&#x27;A&#x27;]=1; m[&#x27;B&#x27;]=2; m[&#x27;C&#x27;]=3; m[&#x27;D&#x27;]=4; m[&#x27;E&#x27;]=5; m[&#x27;F&#x27;]=6; m[&#x27;G&#x27;]=7; m[&#x27;H&#x27;]=8; m[&#x27;I&#x27;]=9; m[&#x27;J&#x27;]=10; m[&#x27;K&#x27;]=11; m[&#x27;L&#x27;]=12; m[&#x27;M&#x27;]=13; m[&#x27;N&#x27;]=14; m[&#x27;O&#x27;]=15; m[&#x27;P&#x27;]=16; m[&#x27;Q&#x27;]=17; m[&#x27;R&#x27;]=18; m[&#x27;S&#x27;]=19; m[&#x27;T&#x27;]=20; m[&#x27;U&#x27;]=21; m[&#x27;V&#x27;]=22; m[&#x27;W&#x27;]=23; m[&#x27;X&#x27;]=24; m[&#x27;Y&#x27;]=25; m[&#x27;Z&#x27;]=26; m[&#x27; &#x27;]=27; char c=&#x27;\\&#x27;&#x27;; m[c]=28; int t; cin&gt;&gt;t; getchar(); double L=pi*60/28; while (t--) &#123; string a; getline(cin,a); int len=0; int n=a.length();//捡字母所要的时间 for (int i=1; i&lt;n; i++) len+=min(abs(m[a[i]]-m[a[i-1]]), 28-abs(m[a[i]]-m[a[i-1]])); printf(&quot;%.10f\\n&quot;,(double)len*L/15+n); &#125;&#125; H 找规律 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int a[70];long long quan[70];int main()&#123; int n;long long ans=0;char tmp; cin&gt;&gt;n;quan[0]=1; for(int i=1;i&lt;=60;i++)&#123; quan[i]=quan[i-1]*2; &#125;// for(int i=0;i&lt;=62;i++)&#123;// cout&lt;&lt;quan[i] &lt;&lt;&#x27; &#x27;;// &#125; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;tmp; //cout&lt;&lt;tmp; if(tmp==&#x27;O&#x27;)&#123; a[i]=1; &#125;else &#123; a[i]=0; &#125; &#125; for(int i=n-1;i&gt;=0;i--)&#123; //从下往上计算这个豹猫对应的权 if(a[i]==1)ans+=quan[n-1-i]; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; J Lost Map题意：给出邻接矩阵，然后求出最小生成树中一条边的两个节点最小生成树的MST性质+并查集 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e7 + 100;const int MAXM = 4e3 + 100;struct Edge&#123; int u, v, w; bool operator &lt; (const Edge &amp;oth) const &#123; return w &lt; oth.w; &#125;&#125;p[MAXN];int fa[MAXM], n, M, X;int find_(int x) &#123; if (x != fa[x]) x = fa[x] = find_(fa[x]); return x;&#125;void unite(int x, int y) &#123; x = find_(x); y = find_(y); if (x != y) fa[x] = y;&#125;int main()&#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) //初始化每个父亲都是自己 fa[i] = i; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; int wi; scanf(&quot;%d&quot;, &amp;wi); if (j &lt; i) continue; // 只存一次即可 p[X++] = &#123; i, j, wi &#125;; &#125; &#125; sort(p, p + X); // 按照边权从小到大排序 for (int i = 0; i &lt; X; i++) &#123; if (M == n - 1) // 树生成好直接退出 break; int ui = find_(p[i].u), vi = find_(p[i].v); if (ui != vi) &#123; // 加入集合 M++; unite(ui, vi); printf(&quot;%d %d\\n&quot;, p[i].u, p[i].v); &#125; &#125; return 0;&#125;","categories":[],"tags":[],"author":"aoyuehan"},{"title":"训练19 联盟周赛 UCF Local Contest 2015","slug":"训练19-联盟周赛","date":"2020-02-28T12:44:39.000Z","updated":"2022-02-26T03:52:51.627Z","comments":true,"path":"2020/02/28/训练19-联盟周赛/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/28/%E8%AE%AD%E7%BB%8319-%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9B/","excerpt":"","text":"A题目大意给定长度为 10 的数列，若数列中只含有 18，输出 Mack。若只含有 17，输出 Zack。若同时含有 18 和 17，输出 both。若不含 18 和 17，输出 none。 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int main()&#123; int n;int num[20]; bool flag1,flag2; cin&gt;&gt;n; while(n--)&#123; flag1=false; flag2=false; for(int i=0;i&lt;10;i++)&#123; cin&gt;&gt;num[i]; &#125; for(int i=0;i&lt;10;i++)&#123; if(num[i]==18)flag1=true; if(num[i]==17)flag2=true; &#125; for(int i=0;i&lt;10;i++)&#123;//这地方比较坑的就是还得把数据在输出来，注意看输出 i==9?cout&lt;&lt;num[i]&lt;&lt;endl:cout&lt;&lt;num[i]&lt;&lt;&#x27; &#x27;; &#125; if(flag1&amp;&amp;flag2)cout&lt;&lt;&quot;both&quot;&lt;&lt;endl&lt;&lt;endl; else if(flag1)cout&lt;&lt;&quot;mack&quot;&lt;&lt;endl&lt;&lt;endl; else if(flag2)cout&lt;&lt;&quot;zack&quot;&lt;&lt;endl&lt;&lt;endl; else cout&lt;&lt;&quot;none&quot;&lt;&lt;endl&lt;&lt;endl; &#125;&#125; B 排名问题 有相同的名次题目大意在奥运会上，有金银铜三种奖牌。比较两个国家的名次时有两种规则。第一种(count)：所有奖牌的总数多者胜。第二种(color)：金牌多者胜。若金牌数目相同，则银牌多者胜。若银牌数目仍相同，则铜牌多者胜。现在分别给出美国和俄罗斯金银铜牌的数量，若按两种规则都是美国胜，输出 both。若只有按第一种规则美国胜，输出 count。若只有按第二种规则美国胜，输出 color。若按两种规则美国都败，输出 none。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;int main()&#123; int n;int num[20]; bool flag1,flag2; cin&gt;&gt;n; while(n--)&#123; int tot1=0,tot2=0; flag1=false; flag2=false; for(int i=0;i&lt;6;i++)&#123; cin&gt;&gt;num[i]; if(i&lt;=2)&#123; tot1+=num[i];//各自累加奖牌数 &#125;else &#123; tot2+=num[i]; &#125; &#125; for(int i=0;i&lt;3;i++)&#123; if(num[i]&gt;num[i+3])&#123; flag2=true;break; &#125; if(num[i]&lt;num[i+3])break; //这地方必须得跳，因为只有相等的时候才能进入下一层for循环 &#125; if(tot1&gt;tot2)flag1=true; for(int i=0;i&lt;6;i++)&#123;//输出输入，注意看输出的结果 i==5?cout&lt;&lt;num[i]&lt;&lt;endl:cout&lt;&lt;num[i]&lt;&lt;&#x27; &#x27;; &#125; if(flag1&amp;&amp;flag2)cout&lt;&lt;&quot;both&quot;&lt;&lt;endl&lt;&lt;endl; else if(flag1)cout&lt;&lt;&quot;count&quot;&lt;&lt;endl&lt;&lt;endl; else if(flag2)cout&lt;&lt;&quot;color&quot;&lt;&lt;endl&lt;&lt;endl; else cout&lt;&lt;&quot;none&quot;&lt;&lt;endl&lt;&lt;endl; &#125;&#125; C. Brownies vs. Candies vs. Cookies题目大意有 N 块蛋糕要依次分给 M 组学生，若当前组学生的人数小于等于蛋糕的数量，就要把每块蛋糕切成两半，若仍不够分，就再把每块蛋糕切成两半，如此重复直到蛋糕数量大于当前组的学生人数为止。分别输出分给每组学生蛋糕后，剩余的蛋糕数量。 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int main() &#123; int n,cnt=1;int stun,bro; cin&gt;&gt;n; while(cnt&lt;=n) &#123; cin&gt;&gt;stun&gt;&gt;bro; cout&lt;&lt;&quot;Practice #&quot;&lt;&lt;cnt&lt;&lt;&quot;: &quot;&lt;&lt;stun&lt;&lt;&#x27; &#x27;&lt;&lt;bro&lt;&lt;endl; cnt++; int num,curstu; cin&gt;&gt;num; while(num--) &#123; cin&gt;&gt;curstu; while(bro&lt;=curstu) &#123; bro*=2;//每次翻倍，知道能够当前人数的，而且还余下 &#125; bro=bro-curstu; cout&lt;&lt;curstu&lt;&lt;&#x27; &#x27;&lt;&lt;bro&lt;&lt;endl; &#125;cout&lt;&lt;endl; &#125;&#125; D. Lemonade Stand题目大意你在经营一家卖柠檬水的店。制作一杯柠檬水需要消耗𝑦个柠檬和𝑡盎司糖。柠檬是一个个卖的，糖是 5 磅每包卖的(1 磅 &#x3D; 16 盎司)。给出接下来的𝑒(𝑒 ≤ 1000)天里，每天将要卖出的柠檬水的数量，以及这一天的每个柠檬和每包糖的价格，你可以在任意天采购任意数量的柠檬和糖，并且在一天之内是先采购柠檬和糖再售卖柠檬水的。询问满足这𝑒天的需求的情况下，购入柠檬和糖的最少总价。题解贪心。若在当天原材料够了，则不再购入。否则在当天及以前该原材料价格最低的时候购入 恰好满足当天需求的量。时间复杂度𝑃(𝑒)。**而且注意题意，这细节很重要，如：一天之内是先采购柠檬和糖再售卖柠檬水的，如果没搞懂，就会错。而且 柠檬和糖是可以分开买，随便在某一天买，这也是个很重要的细节，所以做题之前理解好题意，然后依照步骤来写，注意小细节，考虑全。** 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;int Num[1005],A[1005],B[1005];int T,Day,N,M,Ans;int main() &#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; Ans=0; scanf(&quot;%d%d%d&quot;,&amp;Day,&amp;N,&amp;M); int CountA=0,CountB=0; int MinA=2147483647,MinB=2147483647; for(register int i=1; i&lt;=Day; ++i) &#123; scanf(&quot;%d%d%d&quot;,&amp;Num[i],&amp;A[i],&amp;B[i]); MinA=min(MinA,A[i]); MinB=min(MinB,B[i]); if(CountA&lt;Num[i]*N) &#123;//维护柠檬最小的价钱来买入，不够就买 int AddA=Num[i]*N-CountA;//AddA是要买入柠檬的数量 ；CountA是柠檬的现有量 CountA+=AddA; Ans+=AddA*MinA;//总价钱加上买入的钱 &#125; if(CountB&lt;Num[i]*M) &#123;//买入糖 int AddB=(Num[i]*M-CountB-1)/80+1;//因为买入的糖不足80，也要买入一袋 //这个-1的作用就是当现在没有糖了，新买入的糖为80，这样就会买入两袋 CountB+=AddB*80; Ans+=AddB*MinB; &#125; CountA-=Num[i]*N; CountB-=Num[i]*M; &#125; printf(&quot;%d\\n&quot;,Ans); &#125; return 0;&#125;","categories":[],"tags":[],"author":"aoyuehan"},{"title":"asp笔记","slug":"asp笔记","date":"2020-02-28T09:06:10.000Z","updated":"2022-02-26T03:51:21.486Z","comments":true,"path":"2020/02/28/asp笔记/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/28/asp%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第一章环境配置 详见IIS配置第二章 js第三章request response viewState session实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445主页的界面：&lt;body&gt; &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt; &lt;div&gt; &lt;asp:CheckBox ID=&quot;CheckBox1&quot; runat=&quot;server&quot; Text=&quot;衣服&quot;/&gt;&lt;br /&gt; &lt;asp:CheckBox ID=&quot;CheckBox2&quot; runat=&quot;server&quot; Text=&quot;裤子&quot;/&gt;&lt;br /&gt; &lt;asp:CheckBox ID=&quot;CheckBox3&quot; runat=&quot;server&quot; Text=&quot;衬衣&quot;/&gt;&lt;br /&gt; &lt;asp:CheckBox ID=&quot;CheckBox4&quot; runat=&quot;server&quot; Text=&quot;鞋子&quot;/&gt;&lt;br /&gt; &lt;asp:CheckBox ID=&quot;CheckBox5&quot; runat=&quot;server&quot; Text=&quot;上衣&quot;/&gt;&lt;br /&gt;&amp;nbsp;&amp;nbsp; &lt;br /&gt; &lt;asp:Button ID=&quot;Button1&quot; runat=&quot;server&quot; Text= &quot;将所选的商品添加到购物车&quot; OnClick=&quot;Button1_Click&quot; Width=&quot;277px&quot; /&gt; &lt;asp:Button ID=&quot;Button2&quot; runat=&quot;server&quot; Text= &quot;显示购物车&quot; OnClick=&quot;Button2_Click&quot; /&gt; &lt;/div&gt; &lt;/form&gt;&lt;/body&gt;主页的后台：public partial class session_ceshi : System.Web.UI.Page &#123; protected void Page_Load(object sender, EventArgs e) &#123; if (!IsPostBack) &#123; List&lt;string&gt; cart = new List&lt;string&gt;(); Session[&quot;cart&quot;] = cart; &#125; &#125; protected void Button1_Click(object sender, EventArgs e) &#123; foreach (Control item in form1.Controls) &#123; if(item is CheckBox) &#123; CheckBox ckb = (CheckBox)item; if (ckb.Checked) &#123; //将点击的内容存到session中 ((List&lt;string&gt;)Session[&quot;cart&quot;]).Add(ckb.Text); &#125; &#125; &#125; this.Button1.Text = &quot;添加成功&quot;; &#125; protected void Button2_Click(object sender, EventArgs e) &#123;//到这个页面中去显示session中的内容 Response.Redirect(&quot;index.aspx&quot;); &#125; &#125; session实现购物车用户登录 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253购物车界面代码：public partial class session_ceshi : System.Web.UI.Page &#123; protected void Page_Load(object sender, EventArgs e) &#123; if (!IsPostBack) &#123; List&lt;string&gt; cart = new List&lt;string&gt;(); Session[&quot;cart&quot;] = cart; &#125; if (Session[&quot;currentUser&quot;] != null) &#123; this.Literal1.Text = &quot;欢迎你：&quot; + Session[&quot;currentUser&quot;].ToString(); &#125;else &#123; this.Literal1.Text = &quot;你还没有登录&quot;; &#125; &#125; protected void Button1_Click(object sender, EventArgs e) &#123; //判断用户是否登录 if (Session[&quot;currentUser&quot;] == null) &#123; Response.Redirect(&quot;session_ceshi_login.aspx&quot;); &#125; else &#123; foreach (Control item in form1.Controls) &#123; if(item is CheckBox) &#123; CheckBox ckb = (CheckBox)item; if (ckb.Checked) &#123; ((List&lt;string&gt;)Session[&quot;cart&quot;]).Add(ckb.Text); &#125; &#125; &#125; this.Button1.Text = &quot;添加成功&quot;; &#125; &#125; protected void Button2_Click(object sender, EventArgs e) &#123; Response.Redirect(&quot;index.aspx&quot;); &#125; protected void Button3_Click(object sender, EventArgs e) &#123; Session.Abandon(); &#125;&#125; 效果： cookie的使用 12345678910111213141516171819202122232425262728293031public partial class cookie : System.Web.UI.Page &#123; protected void Page_Load(object sender, EventArgs e) &#123; if (!IsPostBack) &#123; if (Request.Cookies[&quot;UserName&quot;] != null) &#123; Response.Write(&quot;用户名：&quot; + Request.Cookies[&quot;UserName&quot;].Value); &#125; if (Request.Cookies[&quot;UserPhone&quot;] != null) &#123; Response.Write(&quot; 用户电话为：&quot; + Request.Cookies[&quot;UserName&quot;].Value); &#125; &#125; &#125; protected void Button1_Click(object sender, EventArgs e) &#123; //方法一： Response.Cookies[&quot;UserName&quot;].Expires = DateTime.Now.AddDays(1.0); Response.Cookies[&quot;UserName&quot;].Value = this.TextBox1.Text; //方法二： HttpCookie hcokies = new HttpCookie(&quot;UserPhone&quot;, &quot;123&quot;); hcokies.Expires= DateTime.Now.AddDays(1.0); Response.Cookies.Add(hcokies); &#125; &#125; application对象的使用 Global.asax与Web.config的比较 Web.config是对程序中应用程序的配置，效用范围在它所在目录Global.asax是全局的，是整个网站总体的设置Global.asax是一个可选的文件，Web.config是一个必有的文件 12345678其中Global.asax文件中包含以下方法：Application_Start（HttpApplication 类的第一个实例被创建时，该事件被触发。）、Session_Start（在一个新用户访问应用程序 Web 站点时，该事件被触发。）、Session_End（在 InProc 模式下运行时，当一个用户的会话超时、结束或他们离开应用程序 Web 站点时，该事件被触发。（会话结束或过期时，执行））、Application_BeginRequest（在接收到一个应用程序请求时触发）、Application_AuthenticateRequest（在安全模块建立起当前用户的有效的身份时，该事件被触发。）、Application_Error（当应用程序中遇到一个未处理的异常时，该事件被触发。）、Application_End（在HttpApplication 类的最后一个实例被销毁时，该事件被触发。） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Global.asax文件：public class Global : HttpApplication &#123; void Application_Start(object sender, EventArgs e) &#123; // 在应用程序启动时运行的代码 RouteConfig.RegisterRoutes(RouteTable.Routes); BundleConfig.RegisterBundles(BundleTable.Bundles); Application.Lock(); Application[&quot;UserVisit&quot;] = 0;//网站被访问的次数 Application[&quot;currentUsers&quot;] = 0;//在线人数 Application.UnLock(); &#125; protected void Session_Start(object sender, EventArgs e) &#123; //Application:服务端的状态保持机制。放在该对象中的数据是共享的。 与Cache相同，只是Cache本身就有加锁解锁的机制 Application.Lock(); //Application需要手动加锁解锁。 Application[&quot;UserVisit&quot;] = (int)Application[&quot;UserVisit&quot;]+1; Application[&quot;currentUsers&quot;] = (int)Application[&quot;currentUsers&quot;] + 1; Application.UnLock(); &#125; protected void Session_End(object sender, EventArgs e) &#123; //Application:服务端的状态保持机制。放在该对象中的数据是共享的。 与Cache相同，只是Cache本身就有加锁解锁的机制 Application.Lock(); //Application需要手动加锁解锁。 Application[&quot;currentUsers&quot;] = (int)Application[&quot;currentUsers&quot;] - 1; Application.UnLock(); &#125;&#125;测试界面：public partial class appliction_ceshi : System.Web.UI.Page &#123; protected void Page_Load(object sender, EventArgs e) &#123; if (!IsPostBack) &#123; this.Label1.Text = &quot;你是本站的第&quot; + Application[&quot;UserVisit&quot;].ToString()+&quot;访客 ，当前在线人数&quot; + Application[&quot;currentUsers&quot;]; &#125; &#125; protected void Button1_Click(object sender, EventArgs e) &#123; Session.Abandon(); &#125; &#125; 常用的服务器控件 文件上传 sever对象拓展学习 验证控件 非空验证 比较验证 范围验证 正则验证 汇总 母版页 站点地图 项目实践用户退出 数据绑定 DataList GridView","categories":[],"tags":[],"author":"aoyuehan"},{"title":"计网","slug":"计网","date":"2020-02-28T03:16:00.000Z","updated":"2022-02-26T03:52:52.394Z","comments":true,"path":"2020/02/28/计网/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/28/%E8%AE%A1%E7%BD%91/","excerpt":"","text":"第三章 数据通信基础 数据和信号 数据通信系统 带宽 误码率 时延 信道容量 有线传输介质双绞线 同轴电缆 光纤 无线传输介质 多路复用技术 FDM TDM CDM 波分复用 交换技术 电路交换 面向连接的技术 报文交换和分组交换 差错控制技术 局域网 局域网概述 以太网技术 mac地址与帧格式其中 以太网MAC帧中，数据字段的长度至少是（ 46 ）字节。最多为1500字节。因为根据CSMA&#x2F;CD要求，为保证碰撞检测以太网最小帧长为64字节，其中以太网帧头+帧尾共18字节，所以以太网的data(IP,arp,rarp数据报) 至少为46字节，而arp或者rarp为28字节，为达到46字节需要填充18字节（pad） wireshark实践 CSMA&#x2F;CD 争用期的概念 二进制指数退避算法 接收端和发送端的处理 局域网的拓展 集线器和交换机 以太交换机 前三章阿帕网是因特网的前身，它是一种分组交换网 计算机网络从逻辑上是由终端系统和（ 通信子网）两个部分组成。 物理层透明的传输比特流；网络层 数据包(packet)数据链路层 数据帧(frame)物理层 比特流(bit) 物理层:利用传输介质为通信的网络结点之间建立 维护和释放物理连接,实现比特流的透明传输,进而为数据链路层提供数据传输服务数据链路层:在物理层提供服务的基础上,在通信的实体间建立数据链路连接,传输以帧(frame)为单位的数据包,并采取差错控制和流量控制的方法,使有差错的物理线路变成无差错的数据链路网络层:控制着通信子网的运行,为以分组(packet)为单位的数据包通过通信子网选择适当的路由,并实现拥塞控制 网络互连等功能传输层:向用户通过可靠的端到端(end-to-end)的数据传输服务,实现为上层屏蔽低层的数据传输问题会话层:负责维护通信中两个结点之间的会话连接的建立 维护和断开,以及数据的交换表示层:用于处理在两个通信系统中交换信息的表示方式,主要包括数据格式变换 数据的加密与解密 数据压缩与恢复等功能应用层:为应用程序通过网络服务,它包含了各种用户普通使用的协议 TCP&#x2F;IP体系结构的应用层对应于OSI-RM体系结构的上三层。TCP／IP体系结构中的应用层对应IS0／OSI体系结构的 会话层、表示层和应用层 网络协议是“水平”的概念；服务是垂直的 在计算机网络体系结构中，网络层传输的基本单位是（ 分组 ） TCP&#x2F;IP协议栈呈漏斗状，其中位于漏斗最窄地方的是TCP协议。 与多模光纤传输模式相比，单模光纤的传输特点有（ ABC ）。A 模间色散很小，适用于远距离传输B 耦合光能量小，传输频带较宽C 光纤与光源、光纤与光纤间接口较困难D 传输设备较便宜解答：虽然单模光纤的制作比多模光纤便宜，但是转换设备要贵好多好多 与多模光纤相比，单模光纤的主要特点是传输距离长、成本高、芯线细 在数据传输中，需要建立连接的是：（ D )。A.数据报交换B.信元交换C.报文交换D.电路交换 关于数据交换，下列叙述不正确的是( C )。A．电路交换是面向连接B．分组交换比报文交换具有更好的网络响应速度C．报文交换无存储转发过程D．分组交换有存储转发过程要明确报文是一份完整的信息，而分组是报文分组的简称，又叫信息包，将报文划分为若干格式化信息单位作为网络层的数据传输单元。分组交换方式：将一份完整的报文划分为若干组，每个分组独立的从源节点发送到目的节点，目的节点收到这些分组后，再组装成源报文。而存储转发是指每个节点均设有缓冲区，分组到达某节点后，先存储在缓冲区中，等待输出链路空闲时在转发到下一个节点。 在数据传输中，（ C ）交换的传输延迟最小。A . 报文B . 分组C . 电路D . 信元 原始IEEE802.3的物理层规范主要包括：10Base-2、10Base-5、10Base-F和10Base-T等（其中base为基带传输；10Base-2中2代表最大延伸距离接近200m，5为500m；10Base-2中的10代表传播速率为10Mbps；10Base-T中T代表双绞线）。其中10Base-2是细缆以太网，最大传输距离为200m；10Base-5是粗缆以太网，最大传输距离为500m；10Base-F是光纤以太网，最大传输距离为 2000m；10Base-T是双绞线以太网，最大传输距离为100m。 若某通信链路的数据传输速率为2400bps，采用4相位调制，则该链路的波特率是______。 A．600波特B．1200波特C．4800波特D．9600波特正确答案B答案解析解析: 每秒能传输的二进制比特数称为数据传输速率R，其单位为比特&#x2F;秒(bps)。波特率B是指单位时间内能传输的码元个数，其单位为波特(baud)。一个数字脉冲称为一个码元。一个码元所取的有效离散值个数为Ⅳ，则R&#x3D;B・log2N。依题意，该通信链路采用4相位调制，即一个码元有4种有效离散值，例如数字脉冲的相移分别为0°、90°、180°、270°，则一个码元对应于两位二进制信息。R&#x3D;2400bps，N&#x3D;4，则B&#x3D;R&#x2F;log2N&#x3D;2400&#x2F;log24&#x3D;2400&#x2F;2&#x3D;1200baud。 对一个带宽为4kHz的无噪声信道，若采用256种电平传输，为使数据不失真，需要的通信能力为 （64kb&#x2F;s ） 采用相―幅调制（PAM）技术在带宽为32kHz的无噪声信道上传输数字信号，每种相位对应一种电平幅度。若要达到192kb&#x2F;s的数据速率，至少要有（ 8 ）种不同的相位。对于无噪声的信道可利用奈奎斯特公式C&#x3D;2Wlog2N来计算信道容量，其中W指信道带宽。题目中已给出W&#x3D;32kHz，C&#x3D;192kb&#x2F;s，因此：另外，试题中已给出“每种相位对应一种电平幅度”，则该相幅调制技术(PAM)需要的相位个数N&#x3D;2^3&#x3D;8。 第四章检测CSMA&#x2F;CD 适用于有线网络，而 CSMA&#x2F;CA 则广泛应用于无线局域网因为无线电波能够向所有的方向传播，并且其传播距离受限，使得在无线局域网不能简单地使用有线局域网的CSMA&#x2F;CD协议，而是采用了在CSMA基础上增加了冲突避免机制和确认机制，即IEEE 802.11使用的CSMA&#x2F;CA协议。 以太网交换机实质上就是一个多端口的( 网桥 ) 中继器和集线器工作在物理层，路由器工作在网络层，只有网桥是工作在数据链路层的网络设备。 使用单个集线器构成的以太网在物理上和逻辑上的拓扑结构分别是 星型，总线型 1、对于100Mbps的以太网交换机，当输出端口无排队，以直通交换方式转发一个以太网帧（不包括前导码及帧开始标志）时，引入的转发延迟至少是 0.48 μs在直通方式中，交换机收到MAC帧时，不待收完整，就按帧首部中的目的MAC地址来判别转发端口，引入的转发延迟约是6个字节的MAC地址的发送时延，即 0.48 μs ;发送时延：6&#x2F;（100000bits&#x2F;8）&#x3D;0.00048s2、对于100Mbps的以太网交换机，当输出端口无排队，以无碎片方式转发一个以太网帧（不包括前导码及帧开始标志）时，引入的转发延迟至少是5.12 μs无碎片直通方式，以太网最小帧的长度为64字节（含帧头、尾），设置一个64字节的FIFO缓冲，相对可减少出错帧的转发率（凡小于64字节的帧均不转发）。无碎片直通方式较之直通方式提供了较好的差错检验，所以引入的转发延迟是64个字节的发送时延。64&#x2F;（100000bits&#x2F;8）&#x3D;0.00512s 判断mac地址因为是该主机收到的帧，则帧首部中的目的MAC地址即为该主机的MAC地址。 网桥和以太网交换机可以划分冲突域，但是不可以划分广播域。路由器和三层交换机既可以划分冲突域，也可以划分广播域。 集线器工作在物理层，它相当于一根总线，通过它连接的所有主机处在一个冲突域中。所以，集线器不可以连接不同的冲突域。 判断冲突域传播域答案为2，1(1)所谓冲突域是指在该域内某一时刻只能有一个站点发送数据；如果两个站点同时发送数据会引起冲突，则这两个站点处于同一个冲突域内，网桥的每个端口所连网络构成一个独立的冲突域，对于集线器来说，不能隔离冲突域，所以本图中，冲突域是2个。(2)在以太网中，能够接收到任意站点发送的广播帧的所有站点的集合称为一个广播域，网桥的所有端口互连的工作站构成一个广播域，所以本图中广播域只有1个。 若该10台计算机接到了10Mb&#x2F;s的集线器上，则每台计算机的平均带宽为（ 1 ）Mbps。解答： 因为通过集线器组成的以太网是一个共享式的局域网，多个用户共享带宽。即10&#x2F;10得到1；若有5台计算机连到了一台10Mbps的集线器上，则每台计算机的平均带宽为( 2 )Mbps。 IEEE 802标准中将局域网的数据链路层分为两个子层，分别是逻辑链路控制子层和（ MAC 或 媒体访问控制 或 媒体接入控制 或 介质访问控制 或 介质接入控制 ）子层。 设利用IEEE802.3协议局域网传送ASCII码信息“NJUPT”，若每个字母的ASCII码占一个字节，把待传送的数据封装成MAC帧格式，需要填充的字节数是 41。以太网帧中数据字段的长度是46－1500字节，当数据字段的内容小于46个字节的时候，必须进行填充。采用填充无用字符的方式保证有效帧的长度不小于64字节，由于题目中“NJUPT”的ASCII码占据5个字节，则还需填充46-5&#x3D;41字节。 下列介质访问控制方法中，可能发生冲突(碰撞)的是 （B） A. CDMA B. CSMA C. TDMA D. FDMA解答：(1)基于信道划分的媒体访问控制方法的优点在于，用户使用各自划分的信道通信，不会和别的用户发生冲突。可以采用频分多路复用、时分多路复用、波分多路复用和码分多路复用等方法。(2) 基于随机访问的媒体访问控制方式下，所有的用户可随机地向信道中发送信息。用户在发送数据时可能发生冲突。以太网中使用的就是这种媒体访问控制方法。 争用期争用期&#x3D;两倍的传播时延，传播时延&#x3D;10微秒，所以争用期&#x3D;20微秒。 网卡从网络上每收到一个MAC帧就首先用硬件检查MAC帧中的MAC地址。如果是发往本站的帧则收下，然后再进行其他的处理。否则就将此帧丢弃，不再进行其他的处理。这样做就不浪费主机的处理机和内存资源。“发往本站的帧”包括以下三种帧：单播帧（一对一），就是48个比特的MAC地址都一致，才能接受该数据。广播帧（一对全体），只要是某个站点收到这个数据帧，就应该接受该数据。多播帧（一对多），收到该数据的站点要判定，如果是在这个多播组中，则接受该数据。 最短冲突时延 当主机A和主机B同时向对方发送数据时，信号在信道中发生冲突后，冲突信号继续向两个方向传播。这种情况下两台主机均检测到冲突需要经过的时间最短。时间为t&#x3D;( 2×10^3m)&#x2F;(2×10^8m&#x2F;s)&#x3D;10微秒。 某以太网拓扑如图所示，MAC1到MAC4为四台主机的MAC地址简写，若交换机当前转发表为空，则主机MAC1向主机MAC2发送第1个数据帧时，交换机会把该数据帧转发至 （端口2、端口3和端口4） 因为当时转发表为空，则目的MAC地址MAC2不在转发表中，则交换机会向除了源端口以外的所有端口，也就是端口2、3、4转发该帧，这样的话，不管MAC2主机和哪个端口相连，它都可以收到。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计网笔记","slug":"计网笔记","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/"}],"author":"aoyuehan"},{"title":"棋盘覆盖问题 分治法","slug":"棋盘覆盖问题-分治法","date":"2020-02-27T09:49:00.000Z","updated":"2022-02-26T03:52:51.045Z","comments":true,"path":"2020/02/27/棋盘覆盖问题-分治法/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/27/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98-%E5%88%86%E6%B2%BB%E6%B3%95/","excerpt":"","text":"递归与分治算法 分治法概念：顾名思义就是用我们平常所说的“分而治之”的思想来解决复杂的，难以直接解决的问题。（如：问题规模为n的hanoi问题是难以直接解决的，所以可以分解为两个问题规模为n-1的两个hanoi问题····，直至分解到问题规模为1，即使问题规模小到能够方便的直接求解为止，具体问题具体分析） 分治法求解问题的基本策略：其中，分治法与递归经常同时用在算法的设计之中，因为分治法分解的子问题往往是原问题的较小规模，这就自然 导致了递归技术的应用。算法架构：（其中，ADHOC()是一个c语言函数，adhoc的意思是 特别的&#x2F;地； 临时的； 特设的； ） 分治法主要分三步：分解 —–&gt; 求解 ——&gt; 合并（1）分解：将一个大规模问题分解为有限个小规模的问题（小问题之间相互独立，并且它们的问题性质和原始问题的问题性质相同、独立），其实这点和递归有异曲同工之妙,其中小问题的规模为问题最小单位，分解的时候也是递归地分解；（2）求解：一般地，我们可以递归地求解这n个小问题；（3）合并： 分治法的应用 汉诺塔问题算法（递归分治算法）： 例 棋盘覆盖问题： *实现的基本原理是将2^k ** 2^k的棋盘分成四块2^(k - 1) × 2^(k - 1)的子棋盘，特殊方格一定在其中的一个子棋盘中，如果特殊方格在某一个子棋盘中，继续递归处理这个子棋盘，直到这个子棋盘中只有一个方格为止如果特殊方格不在某一个子棋盘中，将这个子棋盘中的相应的位置设为骨牌号，将这个无特殊方格的了棋盘转换为有特殊方格的子棋盘，然后再递归处理这个子棋盘。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt; using namespace std; int tile = 1;//全局变量 骨牌编号 int Board[4][4];//棋盘 void ChessBoard(int tr,int tc,int dr,int dc,int size); int main() &#123; for(int i=0; i&lt;4; i++) &#123; for(int j=0; j&lt;4; j++) &#123; Board[i][j] = 0; &#125; &#125; ChessBoard(0,0,2,3,4); for(int i=0; i&lt;4; i++) &#123; for(int j=0; j&lt;4; j++) &#123; cout&lt;&lt;Board[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; &#125; /** * tr : 棋盘左上角的行号，tc棋盘左上角的列号 * dr : 特殊方格左上角的行号，dc特殊方格左上角的列号 * size ：size = 2^k ，棋盘规格为2^k*2^k */ void ChessBoard(int tr,int tc,int dr,int dc,int size) &#123; if(size == 1) &#123; return; &#125; int t = tile++;//L型骨牌编号 int s = size/2;//分割棋盘 //覆盖左上角子棋盘 if(dr&lt;tr+s &amp;&amp; dc&lt;tc+s)//特殊方格在此棋盘中 &#123; ChessBoard(tr,tc,dr,dc,s); &#125; else//特殊方格不在此棋盘中 //把这个左上角的棋盘的右下角的那个小格当做特殊棋盘 &#123; //用编号为t的骨牌覆盖右下角 Board[tr+s-1][tc+s-1] = t; //覆盖其余方格 ChessBoard(tr,tc,tr+s-1,tc+s-1,s); &#125; //覆盖右上角子棋盘 if(dr&lt;tr+s &amp;&amp; dc&gt;=tc+s)//特殊方格在此棋盘中 &#123; ChessBoard(tr,tc+s,dr,dc,s); &#125; else//特殊方格不在此棋盘中 &#123; //用编号为t的骨牌覆盖左下角 Board[tr+s-1][tc+s] = t; //覆盖其余方格 ChessBoard(tr,tc+s,tr+s-1,tc+s,s); &#125; //覆盖左下角子棋盘 if(dr&gt;=tr+s &amp;&amp; dc&lt;tc+s)//特殊方格在此棋盘中 &#123; ChessBoard(tr+s,tc,dr,dc,s); &#125; else//特殊方格不在此棋盘中 &#123; //用编号为t的骨牌覆盖右上角 Board[tr+s][tc+s-1] = t; //覆盖其余方格 ChessBoard(tr+s,tc,tr+s,tc+s-1,s); &#125; //覆盖右下角子棋盘 if(dr&gt;=tr+s &amp;&amp; dc&gt;=tc+s)//特殊方格在此棋盘中 &#123; ChessBoard(tr+s,tc+s,dr,dc,s); &#125; else//特殊方格不在此棋盘中 &#123; //用编号为t的骨牌覆盖左上角 Board[tr+s][tc+s] = t; //覆盖其余方格 ChessBoard(tr+s,tc+s,tr+s,tc+s,s); &#125; &#125; 参考blog","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"棋盘覆盖","slug":"棋盘覆盖","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96/"}],"author":"aoyuehan"},{"title":"FFT 快速傅里叶变换","slug":"FFT-快速傅里叶变换","date":"2020-02-26T12:43:00.000Z","updated":"2022-02-26T03:52:51.986Z","comments":true,"path":"2020/02/26/FFT-快速傅里叶变换/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/26/FFT-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/","excerpt":"","text":"FFT 快速傅里叶变换通常用来优化两个多项式的乘积 其中的一种做法就是暴力卷积1234567891011121314151617181920212223242526272829#include&lt;algorithm&gt;#include&lt;cstdio&gt;#define Maxn 1000500using namespace std;inline int read()&#123;//快读 register int X=0; register char ch=0; while(ch&lt;48||ch&gt;57)ch=getchar(); while(ch&gt;=48&amp;&amp;ch&lt;=57)X=X*10+(ch^48),ch=getchar(); return X;&#125;int n,m;long long f[Maxn],g[Maxn],s[Maxn];void mul(long long *s,long long *f,long long *g)&#123; for (int k=0;k&lt;n+m-1;k++) for (int i=0;i&lt;=k;i++) s[k]+=f[i]*g[k-i];//第i位和第k-i位的乘积贡献给s[ks] &#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m);n++;m++; for (int i=0;i&lt;n;i++)f[i]=read(); for (int i=0;i&lt;m;i++)g[i]=read(); mul(s,f,g); for (int i=0;i&lt;n+m-1;i++)printf(&quot;%lld &quot;,s[i]); return 0;&#125; 多项式的两种表示方法我们通常表示一个n−1次多项式是利用系数表示法like this:f(x)&#x3D;a0+a1x+a2x^2+…+an−1x^（n−1）点值表示法即为将多项式用坐标系上的若干个点表示我们对这个多项式代入不同的值{x1,x2,…,xn}我们就可以得到n个点(x1,f(x1)),(x2,f(x2)),…,(xn,f(xn))实际上只要保证代入的n个数互不相同，那么这n个点就对应了唯一的f(x)（类似n元一次方程组？）点值表示法它的优势在哪呢？，用点值表示法计算多项式为O（n）我们如果想要求出两个多项式相乘，系数表示法就很麻烦，而点值表示法却只需要将相同的x对应的点值相乘就行了 n次单位根 复数的运算： 复数相乘时,模长相乘,幅角相加！ n次单位根的概念n次单位根(n为正整数)是n次幂为1的复数。 n次单位根的性质 FFT FFT 的算法流程。“把系数表达转换为点值表达”的算法叫做DFT把两个点值表示的多项式相乘“把点值表示的结果 转换为系数表达的结果”的算法叫做IDFT(DFT的逆运算) IFFT 证明方法：单位根反演或范德蒙德矩阵求逆其中 样例代码二进制翻转优化“分”，合并的时候避免了数组拷贝，用原来的f数组。&#x2F;边&gt;&gt;，运算更快。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#define Maxn 1350000using namespace std;const double Pi=acos(-1);int n,m;struct CP&#123;//复数 CP (double xx=0,double yy=0)&#123;x=xx,y=yy;&#125; double x,y; CP operator + (CP const &amp;B) const &#123;return CP(x+B.x,y+B.y);&#125; CP operator - (CP const &amp;B) const &#123;return CP(x-B.x,y-B.y);&#125; CP operator * (CP const &amp;B) const &#123;return CP(x*B.x-y*B.y,x*B.y+y*B.x);&#125;&#125;f[Maxn&lt;&lt;1],p[Maxn&lt;&lt;1];int tr[Maxn&lt;&lt;1];void fft(CP *f,bool flag)&#123; for (int i=0;i&lt;n;i++)// if (i&lt;tr[i])swap(f[i],f[tr[i]]); //枚举区间长度 for(int p=2;p&lt;=n;p&lt;&lt;=1)&#123; int len=p&gt;&gt;1;//待合并的长度，/运算比&gt;&gt;要慢 CP tG(cos(2*Pi/p),sin(2*Pi/p)); if(!flag)tG.y*=-1;//p次单位根 for(int k=0;k&lt;n;k+=p)&#123;//枚举起始点 CP buf(1,0);//遍历一个子问题并合并 for(int l=k;l&lt;k+len;l++)&#123; CP tt=buf*f[len+l]; f[len+l]=f[l]-tt;//蝴蝶变换求fl和fr两部分，上下两行不能交换顺序 f[l]=f[l]+tt; buf=buf*tG; &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=0;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;f[i].x); for (int i=0;i&lt;=m;i++)scanf(&quot;%lf&quot;,&amp;p[i].x); for(m+=n,n=1;n&lt;=m;n&lt;&lt;=1); for(int i=0;i&lt;n;i++)//二进制翻转，优化分时的操作 tr[i]=(tr[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); fft(f,1);fft(p,1);//DFT for(int i=0;i&lt;n;++i)f[i]=f[i]*p[i];//点值法计算两个多项式的乘积 fft(f,0); for(int i=0;i&lt;=m;++i)printf(&quot;%d &quot;,(int)(f[i].x/n+0.49)); return 0;&#125; 优化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960更加优化的算法：#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#define Maxn 1350000using namespace std;const double Pi=acos(-1);inline int read()&#123; register char ch=0; while(ch&lt;48||ch&gt;57)ch=getchar(); return ch-&#x27;0&#x27;;&#125;int n,m;struct CP&#123; CP (double xx=0,double yy=0)&#123;x=xx,y=yy;&#125; double x,y; CP operator + (CP const &amp;B) const &#123;return CP(x+B.x,y+B.y);&#125; CP operator - (CP const &amp;B) const &#123;return CP(x-B.x,y-B.y);&#125; CP operator * (CP const &amp;B) const &#123;return CP(x*B.x-y*B.y,x*B.y+y*B.x);&#125;&#125;f[Maxn&lt;&lt;1];//只用了一个复数数组 int tr[Maxn&lt;&lt;1];void fft(CP *f,bool flag)&#123; for (int i=0;i&lt;n;i++) if (i&lt;tr[i])swap(f[i],f[tr[i]]); for(int p=2;p&lt;=n;p&lt;&lt;=1)&#123; int len=p&gt;&gt;1; CP tG(cos(2*Pi/p),sin(2*Pi/p)); if(!flag)tG.y*=-1; for(int k=0;k&lt;n;k+=p)&#123; CP buf(1,0); for(int l=k;l&lt;k+len;l++)&#123; CP tt=buf*f[len+l]; f[len+l]=f[l]-tt;//因为用到一个f数组，所以这一句和下面一句不能颠倒 f[l]=f[l]+tt; buf=buf*tG; &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=0;i&lt;=n;i++)f[i].x=read(); for (int i=0;i&lt;=m;i++)f[i].y=read(); for(m+=n,n=1;n&lt;=m;n&lt;&lt;=1); for(int i=0;i&lt;n;i++) tr[i]=(tr[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); fft(f,1); for(int i=0;i&lt;n;++i)f[i]=f[i]*f[i]; fft(f,0); for(int i=0;i&lt;=m;++i) printf(&quot;%d &quot;,(int)(f[i].y/n/2+0.49)); return 0;&#125; tips：洛谷参考简单版的介绍fft合并时的操作二进制翻转介绍 例题gym 100783c","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"FFT","slug":"FFT","permalink":"https://zouyunkai.github.io/myblog/tags/FFT/"}],"author":"aoyuehan"},{"title":"数据库概论笔记一","slug":"数据库概论","date":"2020-02-25T10:12:00.000Z","updated":"2022-02-26T03:51:21.558Z","comments":true,"path":"2020/02/25/数据库概论/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/","excerpt":"","text":"数据库系统的核心：数据模型**数据模型分为两类（两个不同的层次） **（1 ） 概念模型，也称信息模型它是按用户的观点来对数据和信息建模，用于数据库设计。（2 ） 逻辑模型和物理模型 逻辑模型主要包括网状模型 、 层次模型 、 关系模型 、 面向对象数据模型 、 对象关系数据模型 、 半结构化数据模型等。 按计算机系统的观点对数据建模 ，用于DBMS 实现。 物理模型是对数据最底层的抽象描述数据在系统内 （ 磁盘上 ） 的表示方式和存取方法。 数据模型是严格定义的一组概念的集合精确地描述了系统的静态特性、动态特性和完整性约束条件(Integrity Constraints) 。 数据模型由三部分组成1 数据结构– 描述系统的静态特性（层次结构，网状，关系）2 数据操作– 描述系统的动态特性（查询，更新）3 完整性约束 关系模型 （1）数据模型 关系必须是规范化的，满足一定的规范条件最基本的规范条件：关系的每一个分量必须是一个不可分的数据项 ，不允许表中还有表 。 （2）数据操作是集合操作 ，关系 操作对象和操作结果都是关系：查询、插入、删除、更新（3）数据完整性 数据系统的结构 模式 外模式 内模式 映射关系 数据系统的组成 关系数据结构和关系的完整性关系代数 选择 投影 连接 其中连接操作涉及选择和笛卡尔积，不涉及投影。 除运算 实例运算 关系演算 元组关系演算 域关系演算 QBE语言 sql语句 使用 ESCAPE 关键字定义转义符。在模式中，当转义符置于通配符之前时，该通配符就解释为普通字符。例如，要搜索在任意位置包含字符串 5% 的字符串，请使用：WHERE ColumnA LIKE ‘%5&#x2F;%%’ ESCAPE ‘&#x2F;‘ 即‘&#x2F;’为转义字符，第二个‘%’为普通字符，第一、第三个为通配符。 sql中的连接 等值连接 自身连接 外连接 多表连接 嵌套查询 几种查询的方式： 1带有in谓词的子查询 带有比较运算符的子查询 使用ANY和ALL谓词的子查询 使用带EXISTS谓词的子查询 查询数据库及格的学生的学号和成绩 12345678910111213141516/*方法一：查询数据库及格的学生的学号和成绩*/SELECT Sno,GradeFROM SC,CourseWHERE Grade&gt;=60 and Course.Cname=&#x27;数据库&#x27; and Course.Cno=SC.Cno ;/*方法二:select Sno,Gradefrom SCwhere Grade&gt;=60 and SC.Cno IN ( select Cno from Course where Cname = &#x27;数据库&#x27; );*/ 集合查询 数据的更新和空值的处理 插入数据 修改数据 删除数据 空值的处理 视图 建立视图 删除视图 查询视图 更新视图 视图的作用 数据库安全概述 TCSEC&#x2F;TDI标准 CC标准 数据库安全控制 用户身份鉴别 存取控制 自主存取控制 权限的授予 权限的回收 创建数据库模式的权限 数据库的角色 强制存取控制方法 视图机制 审计 数据加密 数据库完整性 完整性简介 实体完整性 参照完整性规则 用户自定义约束 约束命令子句和断言 触发器 new和old的使用 问题 组合主键首先一个表是不能有两个主键的。但是可以有两个字段组合成一个主键，这就是为什么有时候表里为什么会有两个字段都有主键的标志，那是因为他们组合成了一个主键了。 12 alter table tablename add constraint pk_name primary key (col1,col2)col1,col2代表两个列。 例如：","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"aoyuehan"},{"title":"数据库笔记（一）","slug":"数据库笔记一","date":"2020-02-25T10:12:00.000Z","updated":"2022-04-03T13:18:45.522Z","comments":true,"path":"2020/02/25/数据库笔记一/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%E4%B8%80/","excerpt":"","text":"数据库系统的核心：数据模型**数据模型分为两类（两个不同的层次） **（1 ） 概念模型，也称信息模型它是按用户的观点来对数据和信息建模，用于数据库设计。（2 ） 逻辑模型和物理模型 逻辑模型主要包括网状模型 、 层次模型 、 关系模型 、 面向对象数据模型 、 对象关系数据模型 、 半结构化数据模型等。 物理模型是对数据最底层的抽象描述数据在系统内 （ 磁盘上 ） 的表示方式和存取方法。 数据模型是严格定义的一组概念的集合精确地描述了系统的静态特性、动态特性和完整性约束条件(Integrity Constraints) 。 数据模型由三部分组成1、 数据结构– 描述系统的静态特性（层次结构，网状，关系）2、 数据操作– 描述系统的动态特性（查询，更新）3、 完整性约束 关系模型 （1）数据模型 关系必须是规范化的，满足一定的规范条件最基本的规范条件：关系的每一个分量必须是一个不可分的数据项 ，不允许表中还有表 。 （2）数据操作是集合操作 ，关系 操作对象和操作结果都是关系：查询、插入、删除、更新（3）数据完整性 数据系统的结构 模式 外模式 内模式 映射关系 数据系统的组成 关系数据结构和关系的完整性关系代数 选择 投影 连接 ​ 其中连接操作涉及选择和笛卡尔积，不涉及投影。 除运算 实例运算 关系演算 元组关系演算 域关系演算 QBE语言 sql语句 使用 ESCAPE 关键字定义转义符。在模式中，当转义符置于通配符之前时，该通配符就解释为普通字符。例如，要搜索在任意位置包含字符串 5% 的字符串，请使用：WHERE ColumnA LIKE ‘%5&#x2F;%%’ ESCAPE ‘&#x2F;‘ 即‘&#x2F;’为转义字符，第二个‘%’为普通字符，第一、第三个为通配符。 sql中的连接 等值连接 自身连接 外连接 多表连接 嵌套查询 几种查询的方式： 1、带有in谓词的子查询 带有比较运算符的子查询 先运行外层的sql语句，显示扫描到表x的一条记录，然后运行where语句，找到学号为x.sno的该学生所有成绩的平均值，然后外层的该cno对应的某门的grade大于内层的该同学的平均成绩，则显示出来，否则不显示该cno 使用ANY和ALL谓词的子查询 使用带EXISTS谓词的子查询 查询数据库及格的学生的学号和成绩 12345678910111213141516/*方法一：查询数据库及格的学生的学号和成绩*/SELECT Sno,GradeFROM SC,CourseWHERE Grade&gt;=60 and Course.Cname=&#x27;数据库&#x27; and Course.Cno=SC.Cno ;/*方法二:select Sno,Gradefrom SCwhere Grade&gt;=60 and SC.Cno IN ( select Cno from Course where Cname = &#x27;数据库&#x27; );*/ 集合查询 数据的更新和空值的处理 插入数据 修改数据 删除数据 空值的处理 视图 建立视图 删除视图 查询视图 更新视图 视图的作用 数据库安全概述 TCSEC&#x2F;TDI标准 CC标准 数据库安全控制 用户身份鉴别 存取控制 自主存取控制 权限的授予 权限的回收 创建数据库模式的权限 数据库的角色 强制存取控制方法 视图机制 审计 数据加密 数据库完整性 完整性简介 实体完整性 参照完整性规则 用户自定义约束 约束命令子句和断言 触发器 new和old的使用 问题 组合主键首先一个表是不能有两个主键的。但是可以有两个字段组合成一个主键，这就是为什么有时候表里为什么会有两个字段都有主键的标志，那是因为他们组合成了一个主键了。 12 alter table tablename add constraint pk_name primary key (col1,col2)col1,col2代表两个列。 例如：","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"author":"aoyuehan"},{"title":"算法分析与设计笔记 第二章 递归与分治","slug":"算法分析与设计笔记","date":"2020-02-25T08:27:00.000Z","updated":"2022-02-26T03:52:51.764Z","comments":true,"path":"2020/02/25/算法分析与设计笔记/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/25/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/","excerpt":"","text":"主定理解释0： 解释一： 解释二： 实例分析实例一：实例二： tips：主定理 参考文章tips：对数运算 二分搜索给定已按升序排好序的n个元素a[0:n-1]，现要在这n个元素中找出一特定元素x。很显然此问题（1）分解出的子问题相互独立，即在a[i]的前面或后面查找x是独立的子问题；而且（2）分解出来的子问题（分解出来的是相同的子问题）的规模变小了，（3）并且子问题的解可以合并成原问题的解，（4）子问题分解到一定程度就很容易解决，因此满足分治法的第四个适用条件。 12345678910111213template&lt;class Type&gt; //函数模板，其中class也可写作typename，有自动类型推到调用和手动类型显示调用两种形式 int BinarySearch(Type a[], const Type&amp; x, int l, int r)&#123;//时间复杂度为O(logn) while (r &gt;= l)&#123; //这里是大于等于 int m = (l+r)/2; if (x == a[m]) return m; if (x &lt; a[m]) r = m-1; //如果找的值在a[m]的左边，则修改右指针的值 //且r等于m的左侧的第一个值，即r=m-1 else l = m+1; &#125; return -1;//没找到，返回-1&#125; tips：函数模板、类模板 循环赛日程表问题： 设有n&#x3D;2^k个运动员，要进行网球循环赛。现在要设计一个满足以下要求的比赛日程表 （1）每个选手必须与其他n-1个选手各赛一场 （2）每个选手一天只能赛一次 （3）循环赛一共进行n-1天将比赛日程表设计成n行n列，表中除了第一列，其他n-1列才是我们要的，数组下标行列都从0开始，第i行j列代表第（i+1）位选手在第j天的对手： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;#define N 50 //打印盒子 void print(int n,int game[][N])&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; cout &lt;&lt; game[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; &#125; //递归函数 void arrange(int p,int q,int t,int arr[][N])&#123; //规格为4及以上，它的左上角和右上角要递归 if(t&gt;=4)&#123; arrange(p,q,t/2,arr); arrange(p,q+t/2,t/2,arr); &#125; //填左下角 for(int i=p+t/2;i&lt;p+t;i++)&#123; for(int j=q;j&lt;q+t/2;j++)&#123; arr[i][j]=arr[i-t/2][j+t/2]; &#125; &#125; //填右下角 for(int i=p+t/2;i&lt;p+t;i++)&#123; for(int j=q+t/2;j&lt;q+t;j++)&#123; arr[i][j]=arr[i-t/2][j-t/2]; &#125; &#125; &#125; //主函数int main()&#123; int n; int game[N][N]; cout &lt;&lt; &quot;请输入选手人数:&quot; &lt;&lt; endl; cin &gt;&gt; n; //初始化第一行,其他全为0 for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(i==0) game[i][j]=j+1; else game[i][j]=0; &#125; &#125; //递归 arrange(0,0,n,game); //打印输出循环赛日程表 print(n,game); system(&quot;pause&quot;); return 0;&#125; 最快效率求出乱序数组中第k小的数详见算法很美的第3.9 棋盘覆盖问题见我的另一篇文章 大整数乘法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220/** 利用分治法实现大整数乘法 第二种方式，复杂度O(n^1.59)*/#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;//string类型转换成int类型int string_to_num(string k) &#123; //string字符串变整数型例如str=&quot;1234&quot;，转换为整数的1234. int back; stringstream instr(k); instr&gt;&gt;back; return back;&#125;//整形数转换为string类型string num_to_string(int intValue) &#123; string result; stringstream stream; stream &lt;&lt; intValue;//将int输入流 stream &gt;&gt; result;//从stream中抽取前面放入的int值 return result;&#125;//在字符串str前添加s个零string stringBeforeZero(string str,int s) &#123; for(int i=0; i&lt;s; i++) &#123; str.insert(0,&quot;0&quot;); &#125; return str;&#125;//两个大整数字符串相加，超出计算机表示范围的数也能实现相加(本函数可以实现大整数加法运算)string stringAddstring(string str1,string str2) &#123;//假定str1和str2是相等的长度，不相等时在前面自动补零，使两个字符串长度相等 if (str1.size() &gt; str2.size()) &#123; str2 = stringBeforeZero(str2,str1.size() - str2.size()); &#125; else if (str1.size() &lt; str2.size()) &#123; str1 = stringBeforeZero(str1,str2.size() - str1.size()); &#125; string result; int flag=0;//前一进位是否有标志,0代表无进位，1代表有进位 for(int i=str1.size()-1; i&gt;=0; i--) &#123; int c = (str1[i] - &#x27;0&#x27;) + (str2[i] - &#x27;0&#x27;) + flag;//利用ASCII码对字符进行运算,这里加上flag代表的是:当前一位有进位时加1，无进位时加0 flag = c/10;//c大于10时，flag置为1，否则为0 c %= 10;//c大于10时取模，否则为其本身 result.insert(0,num_to_string(c));//在result字符串最前端插入新生成的单个字符 &#125; if (0 != flag) &#123; //最后一为(最高位)判断，如果有进位则再添一位 result.insert(0,num_to_string(flag)); &#125; return result;&#125;/*两个大整数字符串相减，超出计算机表示范围的数也能实现相减(在这里比较特殊，第一个参数一定大于第二个参数,因为：a1*b0+a0*b1=(a1+a0)*(b1+b0)-(a1*b1+a0*b0) &gt; 0 ,所以(a1+a0)*(b1+b0) &gt; (a1*b1+a0*b0)这个函数的两个参数，第一个代表的其实就是(a1+a0)*(b1+b0)，第二个代表的其实就是(a1*b1+a0*b0)所以本函数里不用考虑最终得到结果为负数的情况，至于计算有关大整数负数相乘的问题可以通过其他途径判断*/string stringSubtractstring(string str1,string str2) &#123;//对传进来的两个数进行修剪，如果前面几位有0则先去掉，便于统一处理 while (&#x27;0&#x27; == str1[0]&amp;&amp;str1.size()&gt;1) &#123; str1=str1.substr(1,str1.size()-1); &#125; while (&#x27;0&#x27; == str2[0]&amp;&amp;str2.size()&gt;1) &#123; str2=str2.substr(1,str2.size()-1); &#125;//使两个字符串长度相等 if (str1.size() &gt; str2.size()) &#123; str2 = stringBeforeZero(str2,str1.size() - str2.size()); &#125; string result; for(int i=str1.size()-1; i&gt;=0; i--) &#123; int c = (str1[i] - &#x27;0&#x27;) - (str2[i] - &#x27;0&#x27;);//利用ASCII码进行各位减法运算 if (c &lt; 0) &#123; //当不够减时向前一位借位，前一位也不够位时再向前一位借位，依次如下 c +=10; int prePos = i-1; char preChar = str1[prePos]; while (&#x27;0&#x27; == preChar) &#123; str1[prePos]=&#x27;9&#x27;; prePos -= 1; preChar = str1[prePos]; &#125; str1[prePos]-=1; &#125; result.insert(0,num_to_string(c));//在result字符串最前端插入新生成的单个字符 &#125; return result;&#125;//在字符串str后跟随s个零string stringFollowZero(string str,int s) &#123; for(int i=0; i&lt;s; i++) &#123; str.insert(str.size(),&quot;0&quot;); &#125; return str;&#125;//分治法大整数乘法实现函数string IntMult(string x,string y) &#123; //递归函数//对传进来的第一个数进行修剪，如果前面几位有0则先去掉，便于统一处理 while (&#x27;0&#x27; == x[0]&amp;&amp;x.size()&gt;1) &#123; x=x.substr(1,x.size()-1); &#125;//对传进来的第二个数进行修剪，如果前面几位有0则先去掉，便于统一处理 while (&#x27;0&#x27; == y[0]&amp;&amp;y.size()&gt;1) &#123; y=y.substr(1,y.size()-1); &#125; /*这里的f变量代表在两个数据字符串长度不想等或者不是2的指数倍的情况下， 所要统一的长度，这样做是为了让数据长度为2的n次方 的情况下便于利用分治法处理 */ int f=4; /*当两字符串中有任意一个字符串长度大于2时都要通过与上面定义的f值进 行比较，使其达到数据长度为2的n次方，实现方式是在前面 补0，这样可以保证数据值大小不变 */ if (x.size()&gt;2 || y.size()&gt;2) &#123; if (x.size() &gt;= y.size()) &#123; //第一个数长度大于等于第二个数长度的情况 while (x.size()&gt;f) &#123; //判断f值 f*=2; &#125; if (x.size() != f) &#123; x = stringBeforeZero(x,f-x.size()); y = stringBeforeZero(y,f-y.size()); &#125; &#125; else &#123; //第二个数长度大于第一个数长度的情况 while (y.size()&gt;f) &#123; //判断f值 f*=2; &#125; if (y.size() != f) &#123; x = stringBeforeZero(x,f-x.size()); y = stringBeforeZero(y,f-y.size()); &#125; &#125; &#125; if (1 == x.size()) &#123; //数据长度为1时,在前面补一个0(这里之所以会出现长度为1的数据是因为前面对数据修剪过) x=stringBeforeZero(x,1); &#125; if (1 == y.size()) &#123; //数据长度为1时,在前面补一个0(这里之所以会出现长度为1的数据是因为前面对数据修剪过) y=stringBeforeZero(y,1); &#125; if (x.size() &gt; y.size()) &#123; //最后一次对数据校正，确保两个数据长度统一 y = stringBeforeZero(y,x.size()-y.size()); &#125; if (x.size() &lt; y.size()) &#123; //最后一次对数据校正，确保两个数据长度统一 x = stringBeforeZero(x,y.size()-x.size()); &#125; int s = x.size(); string a1,a0,b1,b0; if( s &gt; 1) &#123; a1 = x.substr(0,s/2); a0 = x.substr(s/2,s-1); b1 = y.substr(0,s/2); b0 = y.substr(s/2,s-1); &#125; string result; if( s == 2) &#123; //长度为2时代表着递归的结束条件 int na = string_to_num(a1); int nb = string_to_num(a0); int nc = string_to_num(b1); int nd = string_to_num(b0); result = num_to_string((na*10+nb) * (nc*10+nd)); &#125; else &#123; //长度不为2时利用分治法进行递归运算 /*************************************************** 小提示: c = a*b = c2*(10^n) + c1*(10^(n/2)) + c0; a = a1a0 = a1*(10^(n/2)) + a0; b = b1b0 = b1*(10^(n/2)) + b0; c2 = a1*b1; c0 = a0*b0; c1 = (a1 + a0)*(b1 + b0)-(c2 + c0); ****************************************************/ string c2 = IntMult(a1,b1);// (a1 * b1) string c0 = IntMult(a0,b0);// (a0 * b0) string c1_1 = stringAddstring(a1,a0);// (a1 + a0) string c1_2 = stringAddstring(b1,b0);// (b1 + b0) string c1_3 = IntMult(c1_1,c1_2);// (a1 + a0)*(b1 + b0) string c1_4 = stringAddstring(c2,c0);// (c2 + c0) string c1=stringSubtractstring(c1_3,c1_4);// (a1 + a0)*(b1 + b0)-(c2 + c0) string s1=stringFollowZero(c1,s/2);// c1*(10^(n/2)) string s2=stringFollowZero(c2,s);// c2*(10^n) result = stringAddstring(stringAddstring(s2,s1),c0);// c2*(10^n) + c1*(10^(n/2)) + c0 //这样就是用到了方法二中的 XY=AC2^n+(((A-B)(D-C)+AC+BD)2^(n/2)+BD 这个公式 &#125; return result;&#125;void main() &#123; int f=1; while (1 == f) &#123; string A,B,C,D; string num1,num2; string r; cout&lt;&lt;&quot;大整数乘法运算(分治法实现)&quot;&lt;&lt;endl; cout&lt;&lt;&quot;请输入第一个大整数(任意长度):&quot;; cin&gt;&gt;num1; int i=0;//判断第一个输入的数据是否合法,当字符串中包含非数字字符时提示用户重新输入 for(i=0 ; i &lt; num1.size(); i++) &#123; if (num1[i]&lt;&#x27;0&#x27; || num1[i]&gt;&#x27;9&#x27;) &#123; cout&lt;&lt;&quot;您输入的数据不合法,请输入有效的整数!&quot;&lt;&lt;endl; cin&gt;&gt;num1; i=-1; &#125; &#125; cout&lt;&lt;&quot;请输入第二个大整数(任意长度):&quot;; cin&gt;&gt;num2;//判断第二个输入的数据是否合法,当字符串中包含非数字字符时提示用户重新输入 for(i=0 ; i &lt; num2.size(); i++) &#123; if (num2[i]&lt;&#x27;0&#x27; || num2[i]&gt;&#x27;9&#x27;) &#123; cout&lt;&lt;&quot;您输入的数据不合法,请输入有效的整数!&quot;&lt;&lt;endl; cin&gt;&gt;num2; i=-1; &#125; &#125; r=IntMult(num1,num2);//对求得的结果进行修剪，去掉最前面的几个0 while (&#x27;0&#x27; == r[0]&amp;&amp;r.size()&gt;1) &#123; r=r.substr(1,r.size()-1); &#125; cout&lt;&lt;&quot;两数相乘结果为:&quot;&lt;&lt;endl; cout&lt;&lt;num1&lt;&lt;&quot; &quot;&lt;&lt;&quot;*&quot;&lt;&lt;&quot; &quot;&lt;&lt;num2&lt;&lt;&quot; &quot;&lt;&lt;&quot;=&quot;&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl&lt;&lt;endl; &#125;&#125; tips：大整数乘法讲解和代码发现一个写的很好的blog讲大整数乘法 FFT 快速傅里叶变换见另一篇blog 矩阵相乘的strassen算法 朴素的算法： Strassen算法鉴于上面的分治法方案无法有效提高算法的效率，要想提高算法效率，由主定理方法可知必须想办法将2中递归式中的系数8减少。Strassen提出了一种将系数减少到7的分治法方 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305#ifndef STRASSEN_HH#define STRASSEN_HHtemplate&lt;typename T&gt;class Strassen_class&#123;public: void ADD(T** MatrixA, T** MatrixB, T** MatrixResult, int MatrixSize ); void SUB(T** MatrixA, T** MatrixB, T** MatrixResult, int MatrixSize ); void MUL( T** MatrixA, T** MatrixB, T** MatrixResult, int MatrixSize );//朴素算法实现 void FillMatrix( T** MatrixA, T** MatrixB, int length);//A,B矩阵赋值 void PrintMatrix(T **MatrixA,int MatrixSize);//打印矩阵 void Strassen(int N, T **MatrixA, T **MatrixB, T **MatrixC);//Strassen算法实现&#125;;template&lt;typename T&gt;void Strassen_class&lt;T&gt;::ADD(T** MatrixA, T** MatrixB, T** MatrixResult, int MatrixSize )&#123; for ( int i = 0; i &lt; MatrixSize; i++) &#123; for ( int j = 0; j &lt; MatrixSize; j++) &#123; MatrixResult[i][j] = MatrixA[i][j] + MatrixB[i][j]; &#125; &#125;&#125;template&lt;typename T&gt;void Strassen_class&lt;T&gt;::SUB(T** MatrixA, T** MatrixB, T** MatrixResult, int MatrixSize )&#123; for ( int i = 0; i &lt; MatrixSize; i++) &#123; for ( int j = 0; j &lt; MatrixSize; j++) &#123; MatrixResult[i][j] = MatrixA[i][j] - MatrixB[i][j]; &#125; &#125;&#125;template&lt;typename T&gt;void Strassen_class&lt;T&gt;::MUL( T** MatrixA, T** MatrixB, T** MatrixResult, int MatrixSize )&#123; for (int i=0;i&lt;MatrixSize ;i++) &#123; for (int j=0;j&lt;MatrixSize ;j++) &#123; MatrixResult[i][j]=0; for (int k=0;k&lt;MatrixSize ;k++) &#123; MatrixResult[i][j]=MatrixResult[i][j]+MatrixA[i][k]*MatrixB[k][j]; &#125; &#125; &#125;&#125;/*c++使用二维数组，申请动态内存方法申请int **A;A = new int *[desired_array_row];for ( int i = 0; i &lt; desired_array_row; i++) A[i] = new int [desired_column_size];释放for ( int i = 0; i &lt; your_array_row; i++) delete [] A[i];delete[] A;*/template&lt;typename T&gt;void Strassen_class&lt;T&gt;::Strassen(int N, T **MatrixA, T **MatrixB, T **MatrixC)&#123; int HalfSize = N/2; int newSize = N/2; if ( N &lt;= 64 ) //分治门槛，小于这个值时不再进行递归计算，而是采用常规矩阵计算方法 &#123; MUL(MatrixA,MatrixB,MatrixC,N); &#125; else &#123; T** A11; T** A12; T** A21; T** A22; T** B11; T** B12; T** B21; T** B22; T** C11; T** C12; T** C21; T** C22; T** M1; T** M2; T** M3; T** M4; T** M5; T** M6; T** M7; T** AResult; T** BResult; //making a 1 diminsional pointer based array. A11 = new T *[newSize]; A12 = new T *[newSize]; A21 = new T *[newSize]; A22 = new T *[newSize]; B11 = new T *[newSize]; B12 = new T *[newSize]; B21 = new T *[newSize]; B22 = new T *[newSize]; C11 = new T *[newSize]; C12 = new T *[newSize]; C21 = new T *[newSize]; C22 = new T *[newSize]; M1 = new T *[newSize]; M2 = new T *[newSize]; M3 = new T *[newSize]; M4 = new T *[newSize]; M5 = new T *[newSize]; M6 = new T *[newSize]; M7 = new T *[newSize]; AResult = new T *[newSize]; BResult = new T *[newSize]; int newLength = newSize; //making that 1 diminsional pointer based array , a 2D pointer based array for ( int i = 0; i &lt; newSize; i++) &#123; A11[i] = new T[newLength]; A12[i] = new T[newLength]; A21[i] = new T[newLength]; A22[i] = new T[newLength]; B11[i] = new T[newLength]; B12[i] = new T[newLength]; B21[i] = new T[newLength]; B22[i] = new T[newLength]; C11[i] = new T[newLength]; C12[i] = new T[newLength]; C21[i] = new T[newLength]; C22[i] = new T[newLength]; M1[i] = new T[newLength]; M2[i] = new T[newLength]; M3[i] = new T[newLength]; M4[i] = new T[newLength]; M5[i] = new T[newLength]; M6[i] = new T[newLength]; M7[i] = new T[newLength]; AResult[i] = new T[newLength]; BResult[i] = new T[newLength]; &#125; //splitting input Matrixes, into 4 submatrices each. for (int i = 0; i &lt; N / 2; i++) &#123; for (int j = 0; j &lt; N / 2; j++) &#123; A11[i][j] = MatrixA[i][j]; A12[i][j] = MatrixA[i][j + N / 2]; A21[i][j] = MatrixA[i + N / 2][j]; A22[i][j] = MatrixA[i + N / 2][j + N / 2]; B11[i][j] = MatrixB[i][j]; B12[i][j] = MatrixB[i][j + N / 2]; B21[i][j] = MatrixB[i + N / 2][j]; B22[i][j] = MatrixB[i + N / 2][j + N / 2]; &#125; &#125; //here we calculate M1..M7 matrices . //M1[][] ADD( A11,A22,AResult, HalfSize); ADD( B11,B22,BResult, HalfSize); //p5=(a+d)*(e+h) Strassen( HalfSize, AResult, BResult, M1 ); //now that we need to multiply this , we use the strassen itself . //M2[][] ADD( A21,A22,AResult, HalfSize); //M2=(A21+A22)B11 p3=(c+d)*e Strassen(HalfSize, AResult, B11, M2); //Mul(AResult,B11,M2); //M3[][] SUB( B12,B22,BResult, HalfSize); //M3=A11(B12-B22) p1=a*(f-h) Strassen(HalfSize, A11, BResult, M3); //Mul(A11,BResult,M3); //M4[][] SUB( B21, B11, BResult, HalfSize); //M4=A22(B21-B11) p4=d*(g-e) Strassen(HalfSize, A22, BResult, M4); //Mul(A22,BResult,M4); //M5[][] ADD( A11, A12, AResult, HalfSize); //M5=(A11+A12)B22 p2=(a+b)*h Strassen(HalfSize, AResult, B22, M5); //Mul(AResult,B22,M5); //M6[][] SUB( A21, A11, AResult, HalfSize); ADD( B11, B12, BResult, HalfSize); //M6=(A21-A11)(B11+B12) p7=(c-a)(e+f) Strassen( HalfSize, AResult, BResult, M6); //Mul(AResult,BResult,M6); //M7[][] SUB(A12, A22, AResult, HalfSize); ADD(B21, B22, BResult, HalfSize); //M7=(A12-A22)(B21+B22) p6=(b-d)*(g+h) Strassen(HalfSize, AResult, BResult, M7); //Mul(AResult,BResult,M7); //C11 = M1 + M4 - M5 + M7; ADD( M1, M4, AResult, HalfSize); SUB( M7, M5, BResult, HalfSize); ADD( AResult, BResult, C11, HalfSize); //C12 = M3 + M5; ADD( M3, M5, C12, HalfSize); //C21 = M2 + M4; ADD( M2, M4, C21, HalfSize); //C22 = M1 + M3 - M2 + M6; ADD( M1, M3, AResult, HalfSize); SUB( M6, M2, BResult, HalfSize); ADD( AResult, BResult, C22, HalfSize); //at this point , we have calculated the c11..c22 matrices, and now we are going to //put them together and make a unit matrix which would describe our resulting Matrix. //组合小矩阵到一个大矩阵 for (int i = 0; i &lt; N/2 ; i++) &#123; for (int j = 0 ; j &lt; N/2 ; j++) &#123; MatrixC[i][j] = C11[i][j]; MatrixC[i][j + N / 2] = C12[i][j]; MatrixC[i + N / 2][j] = C21[i][j]; MatrixC[i + N / 2][j + N / 2] = C22[i][j]; &#125; &#125; // 释放矩阵内存空间 for (int i = 0; i &lt; newLength; i++) &#123; delete[] A11[i];delete[] A12[i];delete[] A21[i]; delete[] A22[i]; delete[] B11[i];delete[] B12[i];delete[] B21[i]; delete[] B22[i]; delete[] C11[i];delete[] C12[i];delete[] C21[i]; delete[] C22[i]; delete[] M1[i];delete[] M2[i];delete[] M3[i];delete[] M4[i]; delete[] M5[i];delete[] M6[i];delete[] M7[i]; delete[] AResult[i];delete[] BResult[i] ; &#125; delete[] A11;delete[] A12;delete[] A21;delete[] A22; delete[] B11;delete[] B12;delete[] B21;delete[] B22; delete[] C11;delete[] C12;delete[] C21;delete[] C22; delete[] M1;delete[] M2;delete[] M3;delete[] M4;delete[] M5; delete[] M6;delete[] M7; delete[] AResult; delete[] BResult ; &#125;//end of else&#125;template&lt;typename T&gt;void Strassen_class&lt;T&gt;::FillMatrix( T** MatrixA, T** MatrixB, int length)&#123; for(int row = 0; row&lt;length; row++) &#123; for(int column = 0; column&lt;length; column++) &#123; MatrixB[row][column] = (MatrixA[row][column] = rand() %5); //matrix2[row][column] = rand() % 2;//ba hazfe in khat 50% afzayeshe soorat khahim dasht &#125; &#125;&#125;template&lt;typename T&gt;void Strassen_class&lt;T&gt;::PrintMatrix(T **MatrixA,int MatrixSize)&#123; cout&lt;&lt;endl; for(int row = 0; row&lt;MatrixSize; row++) &#123; for(int column = 0; column&lt;MatrixSize; column++) &#123; cout&lt;&lt;MatrixA[row][column]&lt;&lt;&quot;\\t&quot;; if ((column+1)%((MatrixSize)) == 0) cout&lt;&lt;endl; &#125; &#125; cout&lt;&lt;endl;&#125;#endifStrassen.h 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 Strassen.cpp ：#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;Windows.h&gt;using namespace std;#include &quot;Strassen.h&quot;int main()&#123; Strassen_class&lt;int&gt; stra;//定义Strassen_class类对象 int MatrixSize = 0; int** MatrixA; //存放矩阵A int** MatrixB; //存放矩阵B int** MatrixC; //存放结果矩阵 clock_t startTime_For_Normal_Multipilication ; clock_t endTime_For_Normal_Multipilication ; clock_t startTime_For_Strassen ; clock_t endTime_For_Strassen ; srand(time(0)); cout&lt;&lt;&quot;\\n请输入矩阵大小(必须是2的幂指数值(例如:32,64,512,..): &quot;; cin&gt;&gt;MatrixSize; int N = MatrixSize;//for readiblity. //申请内存 MatrixA = new int *[MatrixSize]; MatrixB = new int *[MatrixSize]; MatrixC = new int *[MatrixSize]; for (int i = 0; i &lt; MatrixSize; i++) &#123; MatrixA[i] = new int [MatrixSize]; MatrixB[i] = new int [MatrixSize]; MatrixC[i] = new int [MatrixSize]; &#125; stra.FillMatrix(MatrixA,MatrixB,MatrixSize); //矩阵赋值 //*******************conventional multiplication test cout&lt;&lt;&quot;朴素矩阵算法开始时钟: &quot;&lt;&lt; (startTime_For_Normal_Multipilication = clock()); stra.MUL(MatrixA,MatrixB,MatrixC,MatrixSize);//朴素矩阵相乘算法 T(n) = O(n^3) cout&lt;&lt;&quot;\\n朴素矩阵算法结束时钟: &quot;&lt;&lt; (endTime_For_Normal_Multipilication = clock()); cout&lt;&lt;&quot;\\n矩阵运算结果... \\n&quot;; stra.PrintMatrix(MatrixC,MatrixSize); //*******************Strassen multiplication test cout&lt;&lt;&quot;\\nStrassen算法开始时钟: &quot;&lt;&lt; (startTime_For_Strassen = clock()); stra.Strassen( N, MatrixA, MatrixB, MatrixC ); //strassen矩阵相乘算法 cout&lt;&lt;&quot;\\nStrassen算法结束时钟: &quot;&lt;&lt;(endTime_For_Strassen = clock()); cout&lt;&lt;&quot;\\n矩阵运算结果... \\n&quot;; stra.PrintMatrix(MatrixC,MatrixSize); cout&lt;&lt;&quot;矩阵大小 &quot;&lt;&lt;MatrixSize; cout&lt;&lt;&quot;\\n朴素矩阵算法: &quot;&lt;&lt;(endTime_For_Normal_Multipilication - startTime_For_Normal_Multipilication)&lt;&lt;&quot; Clocks..&quot;&lt;&lt;(endTime_For_Normal_Multipilication - startTime_For_Normal_Multipilication)/CLOCKS_PER_SEC&lt;&lt;&quot; Sec&quot;; cout&lt;&lt;&quot;\\nStrassen算法:&quot;&lt;&lt;(endTime_For_Strassen - startTime_For_Strassen)&lt;&lt;&quot; Clocks..&quot;&lt;&lt;(endTime_For_Strassen - startTime_For_Strassen)/CLOCKS_PER_SEC&lt;&lt;&quot; Sec\\n&quot;; system(&quot;Pause&quot;); return 0;&#125; 可以发现：可以看到使用Strassen算法时，耗时不但没有减少，反而剧烈增多，在n&#x3D;512时计算时间就无法忍受，效果没有朴素矩阵算法好。网上查阅资料，现罗列如下： 1）采用Strassen算法作递归运算，需要创建大量的动态二维数组，其中分配堆内存空间将占用大量计算时间，从而掩盖了Strassen算法的优势 2）于是对Strassen算法做出改进，设定一个界限。当n&lt;界限时，使用普通法计算矩阵，而不继续分治递归。需要合理设置界限，不同环境（硬件配置）下界限不同 3）矩阵乘法一般意义上还是选择的是朴素的方法，只有当矩阵变稠密，而且矩阵的阶数很大时，才会考虑使用Strassen算法。 合并排序最坏时间复杂度：O(nlogn)平均时间复杂度：O(nlogn)辅助空间：O(n) 快速排序最坏时间复杂度：O(n2)平均时间复杂度：O(nlogn)辅助空间：O(n)或O(logn)","categories":[{"name":"算法分析与设计","slug":"算法分析与设计","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"递归与分治","slug":"递归与分治","permalink":"https://zouyunkai.github.io/myblog/tags/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/"}],"author":"aoyuehan"},{"title":"linux","slug":"linux","date":"2020-02-23T11:43:00.000Z","updated":"2022-02-26T03:51:21.513Z","comments":true,"path":"2020/02/23/linux/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/23/linux/","excerpt":"","text":"Linux 教程 一、liunx基础 a 、Linux 英文解释为 Linux is not Unix。 b 、Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。 Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 https://www.runoob.com/wp-content/uploads/2014/06/1511849829609658.jpg c 、安装：注意安装有无界面 GNOME桌面版，NetInstall 网络安装镜像，DVD 标准安装版； Linux 系统启动过程 a 、Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段： 内核的引导。 运行 init。 系统初始化。 建立终端 。 用户登录系统。 b 、内核引导 当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。 操作系统接管硬件以后，首先读入 &#x2F;boot 目录下的内核文件。 c 、运行init init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。 init 程序首先是需要读取配置文件 &#x2F;etc&#x2F;inittab。 d 、运行级别 许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。 init进程的一大任务，就是去运行这些开机启动的程序。 但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。 e 、Linux系统有7个运行级别(runlevel)： 运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动 运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆 运行级别2：多用户状态(没有NFS) 运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 运行级别4：系统未使用，保留 运行级别5：X11控制台，登陆后进入图形GUI模式 运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 f 、系统初始化 在init的配置文件中有这么一行： si::sysinit:&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit 它调用执行了&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。 它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。 这地方还有些要整理。 g、建立终端 rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。 init接下来会打开6个终端，以便用户登录系统。 h 、用户登录系统 一般来说，用户的登录方式有三种： （1）命令行登录 （2）ssh登录 （3）图形界面登录 j 、图形模式与文字模式的切换方式 Linux预设提供了六个命令窗口终端机让我们来登录。 默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。 当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。 如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1~F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1~F6 切换至命令窗口。 h 、Linux 关机：正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt sync 命令 将数据由内存同步到硬盘中。 halt 命令 通知硬件来停止所有的 CPU 功能，但是仍然保持通电。你可以用它使系统处于低层维护状态。等同于shutdown –h now 和 poweroff。 poweroff 会发送一个 ACPI 信号来通知系统关机。 关机的命令有 shutdown –h now halt poweroff 和 init 0 , 重启系统的命令有 shutdown –r now reboot init 6。（reboot 命令 reboot 通知系统重启。） 定时关机： shutdown –h 20:25 系统会在今天20:25关机 要取消即将进行的关机： shutdown –c l 、常用快捷键： [Tab] 有『命令补全』与『文件补齐』的功能 [Tab] ## 接在一串指令的第一个字的后面，则为『命令补全』 [Tab] ## 接在一串指令的第二个字以后时，则为『文件补齐』 若安装 bash-completion 软件，则在某些指令后面使用 [tab] 按键时，可以进行『选项&#x2F;参数的补齐』功能！ [Ctrl]+ C 如果在Linux 底下输入了错误的指令或参数，想让当前的程序『停掉』的话。 [Ctrl]-d 『键盘输入结束(End Of File, EOF 或 End Of Input)』的意思 另外，他也可以用来取代 exit 的输入。 [Shift]+[Page Up] ## 往前翻页 [Shift]+[Page Down] ## 往后翻页 Linux 系统目录结构 a 、ls &#x2F;命令，显示当前目录下的文件 以下是对这些目录的解释： &#x2F;bin：bin是Binary的缩写, 这个目录存放着最经常使用的命令。 &#x2F;boot：这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。 &#x2F;dev ：dev是Device(设备)的缩写,该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。 &#x2F;etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。 &#x2F;home：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 &#x2F;lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。 &#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 &#x2F;media：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 &#x2F;mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。 &#x2F;opt： 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 &#x2F;proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器： echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all &#x2F;root：该目录为系统管理员，也称作超级权限者的用户主目录。 &#x2F;sbin：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 &#x2F;selinux： 这个目录是Redhat&#x2F;CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 &#x2F;srv： 该目录存放一些服务启动之后需要提取的数据。 &#x2F;sys： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。 sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。 该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 &#x2F;tmp：这个目录是用来存放一些临时文件的。 &#x2F;usr： 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的programfiles目录。 &#x2F;usr&#x2F;bin：系统用户使用的应用程序。 &#x2F;usr&#x2F;sbin：超级用户使用的比较高级的管理程序和系统守护程序。 &#x2F;usr&#x2F;src：内核源代码默认的放置目录。 &#x2F;var：（ 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在&#x2F;var&#x2F;log 目录下，另外mail的预设放置也是在这里。）这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 &#x2F;run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有&#x2F;var&#x2F;run 目录，应该让它指向 run。 c 、 文件系统的最顶层是由根目录开始的，系统使用 &#x2F; 来表示根目录。 d 、 . ：代表当前的目录，也可以使用 .&#x2F; 来表示； .. ：代表上一层目录，也可以 ..&#x2F; 来代表。 如果一个目录或文件名以一个点 . 开始，表示这个目录或文件是一个隐藏目录或文件(如：.bashrc)。即以默认方式查找时，不显示该目录或文件。 e 、 Linux 忘记密码解决方法 a 、重启linux系统 b 、3 秒之内要按一下回车 4_21 然后输入e 4_24 在 第二行最后边输入 single，有一个空格。具体方法为按向下尖头移动到第二行，按”e”进入编辑模式 在后边加上single 回车 最后按”b”启动，启动后就进入了单用户模式了 此时已经进入到单用户模式了，你可以更改root密码了。更密码的命令为 passwd c 、使用系统安装光盘的救援模式 Linux 远程登录 a 、Linux系统中是通过ssh服务实现的远程登录功能，默认ssh服务端口号为 22。 Window系统上 Linux 远程登录客户端有SecureCRT, Putty, SSH Secure Shell等。 b 、 终端利用ssh登录远程服务器 安装ssh： yum install ssh 启动ssh： service sshd start 登录远程服务器： ssh -p 50022 my@127.0.0.1 输入密码：（不显示密码） my@127.0.0.1: -p 后面是端口 my 是服务器用户名 127.0.0.1 是服务器 ip c 、使用密钥认证机制远程登录linux Linux 文件基本属性 a 、Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 b 、在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如： [root@www &#x2F;]# ls -l total 64 dr-xr-xr-x 2 root root 4096 Dec 14 2012 bin dr-xr-xr-x 4 root root 4096 Apr 19 2012 boot 介绍：”d”在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档(link file)； 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。 接下来的字符中，以三个为一组（就是这个r-xr-xr-x），且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。**要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ ]而已。** 363003_1227493859FdXT c 、Linux文件属主和属组 drwxr-xr-x 3 mysql mysql 4096 Apr 21 2014 mysql 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限。 对于 root 用户来说，一般情况下，文件的权限对其不起作用。 d 、更改文件属性 （1）chgrp：更改文件属组 语法：chgrp [-R] 属组名 文件名 -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 （2）chown：更改文件属主，也可以同时更改文件属组 chown [–R] 属主名 文件名 chown [-R] 属主名：属组名 文件名 （3）chmod：更改文件9个属性 Linux文件属性有两种设置方法，一种是数字，一种是符号。 ##数字权限类型 权限对照表 r: 4 w: 2 x: 1 每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为： [- rwxrwx—] 分数则是： owner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7 group &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7 others&#x3D; — &#x3D; 0+0+0 &#x3D; 0 该文件的权限数字就是770 命令： chmod [-R] xyz 文件或目录 xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。 -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更 例如：[root@www ~]# chmod 777 .bashrc ##符号类型改变文件权限 u, g, o是user，group，others的简写，a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看： | chmod | u | +(加入) | r | 文件或目录 || | g | -(除去) | w | || | o | &#x3D;(设定) | x | | a 如果我们需要将文件权限设置为 -rwxr-xr– ，可以使用 chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;r文件名 来设定: 如果我们需要将文件权限设置为 -rwxr-xr– ，可以使用 chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;r 文件名 来设定 要将权限去掉而不改变其他已存在的权限 chmod a-x 文件名或目录 Linux 文件与目录管理 a 、Linux的目录结构为树状结构，最顶级的目录为根目录 &#x2F;。 其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。 b 、 绝对路径：路径的写法，由根目录 &#x2F; 写起，例如： &#x2F;usr&#x2F;share&#x2F;doc 这个目录。 相对路径：路径的写法，不是由 &#x2F; 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成： cd ..&#x2F;man 这就是相对路径的写法啦！ c 、处理目录的常用命令 ls: 列出目录 cd：切换目录 pwd：显示目前的目录 mkdir：创建一个新的目录 rmdir：删除一个空的目录 cp: 复制文件或目录 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称 （1）ls 列出目录 选项与参数： -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用) -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) （2）cd 切换目录 Change Directory的意思 语法： cd [相对路径或绝对路径] #使用 mkdir 命令创建 runoob 目录 [root@www ~]# mkdir runoob #使用绝对路径切换到 runoob 目录 [root@www ~]# cd &#x2F;root&#x2F;runoob&#x2F; #使用相对路径切换到 runoob 目录 [root@www ~]# cd .&#x2F;runoob&#x2F; # 表示回到自己的家目录，亦即是 &#x2F;root 这个目录 [root@www runoob]# cd ~ # 表示去到目前的上一级目录，亦即是 &#x2F;root 的上一级目录的意思； [root@www ~]# cd .. （3）pwd (显示目前所在的目录) Print Working Directory 语法： [root@www ~]# pwd [-P] -P ：显示出确实的路径，而非使用连结 (link) 路径。 （4）mkdir (创建新目录) make directory 语法： mkdir [-mp] 目录名称 -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录**(包含上一级目录)递归创建起来**！ 实例：加了这个 -p 的选项，可以自行帮你创建多层目录！ [root@www tmp]# mkdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4 实例：创建权限为 rwx–x–x 的目录。 [root@www tmp]# mkdir -m 711 test2 （5）rmdir (删除空的目录) 语法： rmdir [-p] 目录名称 -p ：连同上一级『空的』目录也一起删除 （6）cp (复制文件或目录) [root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination) [root@www ~]# cp [options] source1 source2 source3 …. directory 选项与参数： -a：相当于 -pdr 的意思，至于 pdr 请参考下列说明；(常用) -d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身； -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式连结(hard link)的连结档创建，而非复制文件本身； -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -r：递归持续复制，用於目录的复制行为；(常用) -s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件； -u：若 destination 比 source 旧才升级 destination ！ 实例：用 root 身份，将 root 目录下的 .bashrc 复制到 &#x2F;tmp 下，并命名为 bashrc [root@www ~]# cp ~&#x2F;.bashrc &#x2F;tmp&#x2F;bashrc [root@www ~]# cp -i ~&#x2F;.bashrc &#x2F;tmp&#x2F;bashrc cp: overwrite `&#x2F;tmp&#x2F;bashrc’? n &lt;&#x3D;&#x3D;n不覆盖，y为覆盖 （7）rm (移除文件或目录) 语法： rm [-fir] 文件或目录 选项与参数： -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！（rm –rf 全删） （8）mv (移动文件与目录，或修改名称) 语法： [root@www ~]# mv [-fiu] source destination [root@www ~]# mv [options] source1 source2 source3 …. directory 选项参数： -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) d 、Linux 文件内容查看 Linux系统中使用以下命令来查看文件的内容： cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 （1）cat [-AbEnTv] 选项与参数： -A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 （2）nl [-bnw] 文件 选项与参数： -b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 （3）more 在 more 这个程序的运行过程中，你有几个按键可以按的： 空白键 (space)：代表向下翻一页； Enter ：代表向下翻『一行』； &#x2F;字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字； :f ：立刻显示出档名以及目前显示的行数； q ：代表立刻离开 more ，不再显示该文件内容。 b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。 （4）less less运行时可以输入的命令有： 空白键 ：向下翻动一页； [pagedown]：向下翻动一页； [pageup] ：向上翻动一页； &#x2F;字串 ：向下搜寻『字串』的功能； ?字串 ：向上搜寻『字串』的功能； n ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！) N ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！) q ：离开 less 这个程序； e 、Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln 命令产生硬链接。 Linux 用户和用户组管理 a 、Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 b 、Linux系统用户账号的管理 添加新的用户账号使用useradd命令，其语法如下： useradd 选项 用户名 参数选项说明: -c comment 指定一段注释性描述。 -d 目录指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 -g 用户组 指定用户所属的用户组。 -G 用户组，用户组 指定用户所属的附加组。 -s Shell文件 指定用户的登录Shell。 -u 用户号指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 实例：# useradd –d &#x2F;usr&#x2F;sam -m sam # useradd -s &#x2F;bin&#x2F;sh -g group –G adm,root gem c 、删除帐号 删除一个已有的用户账号使用userdel命令，其格式如下： userdel 选项 用户名 常用的选项是 -r，它的作用是把用户的主目录一起删除。 例如： # userdel -r sam d 、修改帐号 修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。 语法格式：usermod 选项 用户名 常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。 e 、用户口令的管理 用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。 格式（如果默认用户名，则修改当前用户的口令）： passwd 选项 用户名 可使用的选项： -l 锁定口令，即禁用账号，使其不能登录。 -u 口令解锁。 -d 使账号无口令。 -f 强迫用户下次登录时修改口令。 例如：# passwd -d sam # passwd -l sam &#x2F;&#x2F;sam为用户名 f 、Linux系统用户组的管理 每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对&#x2F;etc&#x2F;group文件的更新。 （1）增加一个新的用户组使用groupadd命令。其格式如下： groupadd 选项 用户组 可以使用的选项有： -g GID 指定新用户组的组标识号（GID）。 -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。（新组的组标识号是在当前已有的最大组标识号的基础上加1） （2）如果要删除一个已有的用户组，使用groupdel命令，其格式如下： groupdel 用户组 例如： # groupdel group1 （3）修改用户组的属性使用groupmod命令。其语法如下： groupmod 选项 用户组 常用的选项有： -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。 -n新用户组 将用户组的名字改为新名字 实例： # groupmod –g 10000 -n group3 group2 此命令将组group2的标识号改为10000，组名修改为group3。 （4）如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。 用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如： $ newgrp root g 、与用户账号有关的系统文件 （1）&#x2F;etc&#x2F;passwd文件是用户管理工作涉及的最重要的一个文件。 这个文件对所有用户都是可读的 格式：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 实例： root:x:0:0:Superuser:&#x2F;: daemon:x:1:1:System daemons:&#x2F;etc: bin:x:2:2:Owner of system commands:&#x2F;bin: sys:x:3:3:Owner of system files:&#x2F;usr&#x2F;sys: （2）介绍：“主目录”，也就是用户的起始工作目录。 “用户标识号”是一个整数，系统内部用它来标识用户。 “口令”一些系统中，存放着加密后的用户口令字。 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。 Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX&#x2F;TOPS-20 type C Shell), bash(Bourne Again Shell)等。 （3）系统中有一类用户称为伪用户（pseudo users）。 这些用户在&#x2F;etc&#x2F;passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。 常见的伪用户如下所示： 伪 用 户 含 义 bin 拥有可执行的用户命令文件 sys 拥有系统文件 adm 拥有帐户文件 uucp UUCP使用 lp lp或lpd子系统使用 nobody NFS使用 （4）拥有帐户文件，他们各自都有自己的账户文件 （5）用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。 （6）添加批量用户 1、创建一个文件，内容格式和 &#x2F;etc&#x2F;passwd 一样，如 test.txt 内容如下： us001:X:1000:1000::&#x2F;home&#x2F;us001:sbin&#x2F;bash us002:X:1001:1001::&#x2F;home&#x2F;us002:sbin&#x2F;bash 2、在 tty (终端设备的统称) 输入： [root@localhost~]# newusers test.txt 3、创建一个口令文件，内容格式 用户名:口令，如 pass.txt 内容如下： us001:123456 us002:123456 4、在 tty 输入： [root@localhost~]# chpasswd &lt;pass.txt 9 、 Linux 磁盘管理 a 、Linux磁盘管理常用三个命令为df、du和fdisk。 df：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量 fdisk：用于磁盘分区 b 、语法： df [-ahikHTm] [目录或文件名] 选项与参数： 选项与参数： -a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统； -k ：以 KBytes 的容量显示各文件系统； -m ：以 MBytes 的容量显示各文件系统； -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示； -H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式； -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3)也列出； -i ：不用硬盘容量，而以 inode 的数量来显示 c 、语法： du [-ahskm] 文件或目录名称 选项与参数： -a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。 -h ：以人们较易读的容量格式 (G&#x2F;M) 显示； -s ：列出总量而已，而不列出每个各别的目录占用容量； -S ：不包括子目录下的总计，与 -s 有点差别。 -k ：以 KBytes 列出容量显示； -m ：以 MBytes 列出容量显示； d 、语法： fdisk [-l] 装置名称 选项与参数： -l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。 f 、磁盘格式化语法： mkfs [-t 文件系统格式] 装置文件名 选项与参数： -t ：可以接文件系统格式，例如 ext3, ext2, vfat 等(系统有支持才会生效) 实例：将分区 &#x2F;dev&#x2F;hdc6（可指定你自己的分区） 格式化为 ext3 文件系统： [root@www ~]# mkfs -t ext3 &#x2F;dev&#x2F;hdc6 g 、磁盘检验 若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。 语法： fsck [-t 文件系统] [-ACay] 装置名称 h 、磁盘挂载与卸除 磁盘挂载语法： mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点 实例：将刚刚创建的 &#x2F;dev&#x2F;hdc6 挂载到 &#x2F;mnt&#x2F;hdc6 上面 [root@www ~]# mount &#x2F;dev&#x2F;hdc6 &#x2F;mnt&#x2F;hdc6 磁盘卸载命令 umount 语法： umount [-fn] 装置文件名或挂载点 选项与参数： -f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下； -n ：不升级 &#x2F;etc&#x2F;mtab 情况下卸除。 实例：卸载&#x2F;dev&#x2F;hdc6 [root@www ~]# umount &#x2F;dev&#x2F;hdc6 10 、Linux vi&#x2F;vim a 、vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。 所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。 b 、 c 、vi&#x2F;vim 的使用 基本上 vi&#x2F;vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 （1）命令模式： 用户刚刚启动 vi&#x2F;vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。 （2）输入模式 在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME&#x2F;END，移动光标到行首&#x2F;行尾 Page Up&#x2F;Page Down，上&#x2F;下翻页 Insert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线 ESC，退出输入模式，切换到命令模式 （3）底线命令模式 在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 d 、vi&#x2F;vim 使用实例 （1）用 vi 来建立一个名为 test.txt 的文件 $ vim runoob.txt （2）直接输入 vi 文件名 就能够进入 vi 的一般模式了（还要加后缀） （3）在一般模式之中，只要按下 i（从目前光标所在处输入）, o（在目前光标所在的下一行处输入新的一行）, a(从目前光标所在的下一个字符处开始输入) 等字符就可以进入输入模式了！在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。 这个时候，键盘上除了 Esc 这个按键（回到一般模式）之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。 （4）第一部份：一般模式可用的光标移动、复制粘贴、搜索替换等 移动光标的方法 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) 删除、复制与贴上 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行(常用) ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P（大写字母） 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) 搜索替换 | :n1,n2s&#x2F;word1&#x2F;word2&#x2F;g | n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： | 『:100,200s&#x2F;vbird&#x2F;VBIRD&#x2F;g』。(常用) :1,$s&#x2F;word1&#x2F;word2&#x2F;g 或 :%s&#x2F;word1&#x2F;word2&#x2F;g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s&#x2F;word1&#x2F;word2&#x2F;gc 或 :%s&#x2F;word1&#x2F;word2&#x2F;gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) &#x2F;word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用) G 移动到这个档案的最后一行(常用) gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) n&lt;Enter&gt; n 为数字。光标向下移动 n 行(常用) （5）第二部份：一般模式切换到编辑模式的可用的按钮说明 进入输入或取代的编辑模式 i, I 进入输入模式(Insert mode)： i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用) a, A 进入输入模式(Insert mode)： a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用) o, O 进入输入模式(Insert mode)： 这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！(常用) r, R **进入取代模式(Replace mode)**： r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用) [Esc] 退出编辑模式，回到一般模式中(常用) （6）第三部份：一般模式切换到指令行模式的可用的按钮说明 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！ :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如『:! ls &#x2F;home』即可在 vi 当中察看 &#x2F;home 底下以 ls 输出的档案信息！ （6）vim 环境的变更 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ （7）vim 中批量添加注释 方法一： Ctrl + v 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 I 进入行首插入模式输入注释符号如 &#x2F;&#x2F; 或 #，输入完毕之后，按两下 ESC，Vim 会自动将你选中的所有行首都加上注释，保存退出完成注释。 取消注释： Ctrl + v 进入块选择模式，选中你要删除的行首的注释符号，注意 &#x2F;&#x2F; 要选中两个，选好之后按 d 即可删除注释，ESC 保存退出。 方法二: 替换命令 批量注释。 使用下面命令在指定的行首添加注释。 使用名命令格式： :起始行号,结束行号s&#x2F;^&#x2F;注释符&#x2F;g（注意冒号）。 取消注释： 使用名命令格式： :起始行号,结束行号s&#x2F;^注释符&#x2F;&#x2F;g（注意冒号）。 例子： 1、在 10 - 20 行添加 &#x2F;&#x2F; 注释 :10,20s#^#&#x2F;&#x2F;#g 2、在 10 - 20 行删除 &#x2F;&#x2F; 注释 :10,20s#^&#x2F;&#x2F;##g 3、在 10 - 20 行添加 # 注释 :10,20s&#x2F;^&#x2F;#&#x2F;g 4、在 10 - 20 行删除 # 注释 :10,20s&#x2F;#&#x2F;&#x2F;g 11、linux yum 命令 a 、yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。 基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。 yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。 b 、yum 语法 yum [options] [command] [package …] options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。 command：要进行的操作。 package操作的对象。 c 、yum常用命令 1.列出所有可更新的软件清单命令：yum check-update 2.更新所有软件命令：yum update 3.仅安装指定的软件命令：yum install &lt;package_name&gt; 4.仅更新指定的软件命令：yum update &lt;package_name&gt; 5.列出所有可安裝的软件清单命令：yum list 6.删除软件包命令：yum remove &lt;package_name&gt; 7.查找软件包 命令：yum search &lt;keyword&gt; 8.清除缓存命令: yum clean packages: 清除缓存目录下的软件包 yum clean headers: 清除缓存目录下的 headers yum clean oldheaders: 清除缓存目录下旧的 headers yum clean, yum clean all (&#x3D; yum clean packages; yum clean oldheaders):清除缓存目录下的软件包及旧的headers 二、 Shell教程 三、mysql安装，apache安装","categories":[{"name":"linux","slug":"linux","permalink":"https://zouyunkai.github.io/myblog/categories/linux/"}],"tags":[{"name":"linux教程","slug":"linux教程","permalink":"https://zouyunkai.github.io/myblog/tags/linux%E6%95%99%E7%A8%8B/"}],"author":"aoyuehan"},{"title":"单调栈和单调队列","slug":"单调栈和单调队列","date":"2020-02-23T05:16:00.000Z","updated":"2022-02-26T03:52:52.593Z","comments":true,"path":"2020/02/23/单调栈和单调队列/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/23/%E5%8D%95%E8%B0%83%E6%A0%88%E5%92%8C%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","excerpt":"","text":"单调队列首先看一个问题。给定一个数列，从左至右输出每个长度为k的数列段内的最小数和最大数（第一行输出每个区间最小值，第二行输出最大值）。数列长度：N≤106，k≤N解法①很直观的一种解法，那就是从数列的开头，找到这最开始的k个数的最大值，然后后移一个单元，继续找到k个数中的最大值。这种方法每求一个f(i),都要进行k-1次的比较，复杂度为O(Nk)。解法②核心思想：去除无用的状态，保存有用的状态。考虑这样一个问题：现在区间中有两个元素a[i], a[j]，且满足i&lt;j,a[j]≥a[i]（假设要求区间内最大值）就是说a[j]比a[i]还大而且还在后面，那么a[j]肯定比a[i]有用（因为区间是往后推，找到的最大值有可能是a[i]，但不可能是a[j]）。 因此a[i]对于求这段区间的最值是没用的了。现在我们维护一个单调递减队列，并从队尾入队、队头出队（队内元素序号递增）。每次入队a[j]时，从队尾往前找到第一个大于a[j]的元素，并把a[j]插入到它后面。也就是说小于a[j]的元素不要了，因为它们对求出区间内的最大值来说是无用的。随着区间后移，再把队头超出区间范围的元素弹出。 单调队列实现的大致过程：1、维护队首（对于上题就是如果队首已经是当前元素的m个之前，则队首就应该被删了（head++来实现删除队首元素））2、在队尾插入（每插入一个就要从队尾开始往前去除冗杂状态，保持单调性） 简单举例应用数列为：6 4 10 10 8 6 4 2 12 14N&#x3D;10,K&#x3D;3;那么我们构造一个长度为3的单调递减队列：首先，那6和它的位置0放入队列中，我们用(6,0)表示，每一步插入元素时队列中的元素如下插入6：(6,0);插入4：(6,0),(4,1);插入10：(10,2);插入第二个10，保留后面那个：(10,3);插入8：(10,3),(8,4);插入6：(10,3),(8,4),(6,5);插入4，之前的(10,3)已经超出范围所以排掉：(8,4),(6,5),(4,6);插入2，同理：(6,5),(4,6),(2,7);插入12：(12,8);插入14：(14,9);那么f(i)就是第i步时队列当中的首元素：6,6,10,10,10,10,8,6,12,14同理，最小值也可以用单调队列来做。 单调队列的时间复杂度是O（N），因为每个数只会进队和出队一次，所以这个算法的效率还是很高的。注意：建议直接用数组模拟单调队列，因为系统自带容器不方便而且不易调试，同时，每个数只会进去一次，所以，数组绝对不会爆，空间也是S（N），优于堆或线段树等数据结构。更重要的：单调是一种思想，当我们解决问题的时候发现有许多冗杂无用的状态时，我们可以采用单调思想，用单调队列或类似于单调队列的方法去除冗杂状态，保存我们想要的状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#define reg registerconst int MAX=7000001;int n,k,a[MAX];int Min[MAX],Max[MAX];struct node&#123; int x,id; //x:值 id:位置（原序列中的下标）&#125;v[MAX];void get_min()&#123;//维护单调递增队列 int head=1,tail=0; //默认起始位置为1 因为插入是v[++tail]故初始化为0 for(reg int i=0;i&lt;k-1;++i)&#123; //根据题目 前m-1个先直接进入队列 while(head&lt;=tail &amp;&amp; v[tail].x&gt;=a[i]) --tail;//当队列非空并且队尾元素大于当前要入队的元素，就--tial在队尾出队 v[++tail].x=a[i], v[tail].id=i; &#125; for(reg int i=k-1;i&lt;n;++i)&#123;//从第k个开始，依次入队 while(head&lt;=tail &amp;&amp; v[tail].x&gt;=a[i]) --tail;//维护单调性 v[++tail].x=a[i], v[tail].id=i; while(v[head].id&lt;i-k+1) ++head;//将不在我们[i,i+m-1]范围内的元素出栈，因为已经不能对最小值有贡献了 Min[i-k+1]=v[head].x;//将队首的最小值存下来 //道理同上，当然了，要把已经超出范围的从head开始排出 //然后每个队首则是目前k个数的最小值 &#125;&#125;void get_max()&#123; // 维护的是递减队列 int head=1,tail=0; for(reg int i=0;i&lt;k-1;++i)&#123; while(head&lt;=tail &amp;&amp; v[tail].x&lt;=a[i]) --tail; v[++tail].x=a[i], v[tail].id=i; &#125; for(reg int i=k-1;i&lt;n;++i)&#123; while(head&lt;=tail &amp;&amp; v[tail].x&lt;=a[i]) --tail; v[++tail].x=a[i], v[tail].id=i; while(v[head].id&lt;i-k+1) ++head; Max[i-k+1]=v[head].x; &#125;&#125;void output()&#123; printf(&quot;%d&quot;,Min[0]); for(reg int i=1;i&lt;n-k+1;++i) printf(&quot; %d&quot;,Min[i]); printf(&quot;\\n%d&quot;,Max[0]); for(reg int i=1;i&lt;n-k+1;++i) printf(&quot; %d&quot;,Max[i]); printf(&quot;\\n&quot;);&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(reg int i=0;i&lt;n;++i) scanf(&quot;%d&quot;,&amp;a[i]); get_min(); get_max(); output(); return 0;&#125; 单调栈问题描述地上从左到右竖立着 n 块木板，从 1 到 n 依次编号，如下图所示。我们知道每块木板的高度，在第 n 块木板右侧竖立着一块高度无限大的木板，现对每块木板依次做如下的操作：对于第 i 块木板，我们从其右侧开始倒水，直到水的高度等于第 i 块木板的高度，倒入的水会淹没 ai 块木板（如果木板左右两侧水的高度大于等于木板高度即视为木板被淹没），求 n 次操作后，所有 ai 的和是多少。如图上所示，在第 4 块木板右侧倒水，可以淹没第 5 块和第 6 块一共 2 块木板，a4 &#x3D; 2。 解法①暴力求解，复杂度是O(n2)例如现在存在5块木板每块木板从左至右高分别为10，5，8，12，6从第一块木板（高度为10）右侧开始倒水，当水到达第四块木板（高度为12） 时，可以淹没第一块木板即第一块木板至第四块木板之间的木板数量，即4-1-1 &#x3D; 2，a1 &#x3D; 2；也就是说：寻找在第 i 个木板右边第一个比它大的木板j，ai 就等于木板 i 和木板 j 之间的木板数同理得到a2&#x3D;0a3&#x3D;0a4&#x3D;1a5&#x3D;0sum &#x3D; a1 + a2 +a3 +a4 +a5 &#x3D; 3于是，问题就变成了寻找在第 i 个数右边第一个比它大的数。可以暴力求解，从 1 循环到 n，对每块木板再往右循环一遍，这样的时间复杂度是O(n2) 。 解法② 单调栈来求解的话，复杂度是O(n)结合单调栈的性质：使用单调栈可以找到元素向左遍历第一个比他小的元素，也可以找到元素向左遍历第一个比他大的元素。顾名思义，单调栈就是栈内元素单调递增或者单调递减的栈，这一点和单调队列很相似，但是单调栈只能在栈顶操作。 单调栈有以下两个性质：1、若是单调递增栈，则从栈顶到栈底的元素是严格递增的。若是单调递减栈，则从栈顶到栈底的元素是严格递减的。2、越靠近栈顶的元素越后进栈。单调栈与单调队列不同的地方在于栈只能在栈顶操作，因此一般在应用单调栈的地方不限定栈的大小，否则可能会造成元素无法进栈。元素进栈过程：对于单调递增栈，若当前进栈元素为e，从栈顶开始遍历元素，把小于e或者等于e的元素弹出栈，直接遇到一个大于e的元素或者栈为空为止，然后再把e压入栈中。对于单调递减栈，则每次弹出的是大于e或者等于e的元素。 数据模拟木板倒水单调栈的入栈计算过程思路：寻找比栈顶高的木板i，找到就出栈，不是就把木板i入栈，给出循环计数样例 10，5，8，12，6从左往右扫描栈为空，10入栈 栈：10 此时栈顶是10，也就是说要寻找比10大的木板5比10小，5入栈 栈：5，10 此时栈顶是5，也就是说要寻找比5大的木板8比5大，5出栈 栈：10这个时候，第二个高度为5的木板右边比它高的木板已经找到了，是第三个木板 8，所以5出栈，计算a2 &#x3D; 3-2-1 &#x3D; 08比10小，8入栈 栈：8，10 此时栈顶是8，也就是说要寻找比8大的木板12比8大，8出栈 栈：10第三个高度为8的木板右边比它高的木板已经找到了，是第四个木板12，8出栈，计算a3 &#x3D; 4-3-1 &#x3D; 012比10大，10出栈 栈：空第一个高度为10的木板右边比它高的木板已经找到了，是第四个木板12，所以10出栈，计算a1 &#x3D; 4-1-1 &#x3D; 2栈为空，12入栈 栈：12 此时栈顶是12，也就是说要寻找比12大的木板6比12小，6入栈 栈：6，12 此时栈顶是6，也就是说要寻找比6大的木板扫描完成结束 最后栈的结构是：6，12 栈顶为6由于最右端竖立着一块高度无限大的木板，即存在第六块木板高度为无穷，所以剩余两块木板的算法如下 a5 &#x3D; 6-5-1 &#x3D;0a4 &#x3D; 6-4-1 &#x3D; 1sum &#x3D; a1 + a2 +a3 +a4 +a5 &#x3D; 3因此本题可以在O(n)的时间内迎刃而解了。从左往右将木板节点压栈，遇到比栈顶木板高的木板就将当前栈顶木板出栈并计算淹没的木板数，如此循环直到栈顶木板高度比当前木板高或者栈为空，然后将此木板压栈。木板全都压栈完成后，栈内剩余的木板都是右侧没有比它们更高的木板的，所以一个个出栈并计算ai&#x3D;n+1-temp_id-1(用最右边无限高的木板减)。 12345678910111213141516171819202122232425//从左往右解木板倒水int main() &#123; int n,ans=0; cin&gt;&gt;n; Stack&lt;Node&gt; stack(n); Node temp;//node一定要有id和val两个属性，因为要记录val所在的位置 for(int i=1;i&lt;=n;i++)&#123;//维护单调递减栈 cin&gt;&gt;temp.height; temp.id=i; //遇到了右侧第一个比栈顶元素大的元素,计算并出栈 while(!stack.empty()&amp;&amp;stack.top().height&lt;=temp.height)&#123;//因为 新加进去的这个元素 左边可能有好几个比他小的，所以要用while ans=ans+i-stack.top().id-1;//计算贡献 stack.pop();//弹出来，接着计算贡献，或者把元素压进去 &#125; stack.push(temp); &#125; //现在栈中的木板右侧没有比它高的木板,用最右侧无限高的木板减 while(!stack.empty())&#123;//没有元素再入栈的，所以计算栈中元素的贡献 ans=ans+n+1-stack.top().id-1; stack.pop(); &#125; //也可设a[n+1]=INF，可以省去最后出队的while。 cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 单调栈接雨水 LeetCode-42给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 方法一：找出每根柱子左右的最高点，取两边最高柱子最小的高度，与中间柱子高度相减就是凹槽的高度 123456789101112131415161718192021class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int n = height.size(); vector&lt;int&gt; left(n),right(n); for(int i=1;i&lt;n;i++) // 左边最高的点 left[i] = max(left[i-1],height[i-1]); for(int j=n-2;j&gt;=0;j--) // 右边最高的点 &#123; right[j] = max(right[j+1],height[j+1]); &#125; int w = 0; for(int i=0;i&lt;n;i++) &#123; int level = min(left[i],right[i]); w+=max(0,level-height[i]); &#125; return w;//返回贡献 &#125;&#125;; 单调栈法维护一个单调递减栈，当当前元素小于栈顶元素时，进栈，当大于栈顶元素时，说明可以构成一个凹槽，栈顶元素出栈，并判断栈顶元素两边柱子的最小高度，取最小高度作为凹槽的高度。直到碰到栈顶元素大于当前元素时再次进栈。思路还是要找到栈顶柱子两边的最小柱子的高度，然后乘上柱子之间的宽度就是凹槽盛水的容积。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;stack&gt;using namespace std;int n;int nums[20005];stack&lt;int&gt; st;int ans;int main()&#123; // freopen(&quot;test.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d&quot;,&amp;n);//n个柱子 for(int i=0;i&lt;n;i++) &#123;//输入 scanf(&quot;%d&quot;,nums+i); &#125; for(int i=0;i&lt;n;i++) &#123; int width = 0; while(!st.empty()&amp;&amp;nums[st.top()]&lt;nums[i]) &#123;//栈非空 并且栈顶元素小于将要入栈的元素 int t = st.top();//栈顶元素的序号出栈 st.pop(); if(st.empty()) break;//若果此时栈为空，说明形不成凹槽了，直接退出 if(nums[t] == nums[st.top()]) continue;//如果两边柱子的较小值和中间柱子相等，说明没有形成凹槽 width = i-st.top()-1;//计算凹槽的宽度 int h = min(nums[i],nums[st.top()]);//计算两端柱子中较小的值 ans += width*(h - nums[t]);//h - nums[t] 为凹槽的高度 &#125; st.push(i);//将要入栈的元素的序号入栈 &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125; 解法三：双指针 我们首先建立left和right两个指针。我们首先判断height[left]&lt;height[right]，如果成立的话，我们left+&#x3D;1，否则的话，我们right-&#x3D;1。 我们挪动left和right的同时需要记录左右的最大值maxLeft和maxRight。如果height[left]&lt;height[right]并且height[left]&lt;maxLeft的话，那么说明此时的left处于较低位置，我们应该增加水量。但是增加多少呢？maxLeft-height[left]还是height[right]-height[left]呢？很明显是前者，通过反证法很好得到这个结论。如果height[left]&gt;&#x3D;height[right]并且height[right]&lt;maxRight的话，那么说明此时的right处于较低位置，我们应该增加maxRight-height[right]水量。 12345678910111213141516171819202122232425262728293031int trap(vector&lt;int&gt;&amp; height) &#123; if (height.size() &lt; 2) &#123; return 0; &#125; int l, r, lMax, rMax; l = lMax = rMax = 0; r = height.size() - 1; int totalRain = 0; while (l &lt; r) &#123; if (height[l] &lt; height[r]) &#123; if (height[l] &gt; lMax) &#123; lMax = height[l++]; &#125; else &#123; totalRain += lMax - height[l++]; &#125; &#125; else &#123; if (height[r] &gt; rMax) &#123; rMax = height[r--]; &#125; else &#123; totalRain += rMax - height[r--]; &#125; &#125; &#125; return totalRain;&#125;思路：1.所接的雨水的多少应该和较小一端有关系(木桶原理)，首先两个指针分别指向头尾，小的一方先走 2.同时记录左右两边最大值，如果此时的值比最大值还大，则更新最大值，否则可以接雨水。","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"单调队列","slug":"单调队列","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"}],"author":"aoyuehan"},{"title":"训练18 cf abc 2_22 and 2_24","slug":"训练18-cf-abc","date":"2020-02-22T12:13:00.000Z","updated":"2022-02-26T03:52:51.270Z","comments":true,"path":"2020/02/22/训练18-cf-abc/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/22/%E8%AE%AD%E7%BB%8318-cf-abc/","excerpt":"","text":"A 牌比较大小两张牌比大小的游戏。第一个字母是牌面点数，第二个是花色（Spade黑桃、Heart红桃、Diamond方片、Clover梅花）先给出的那个字母是王牌花色，如果两张牌一个是王牌另一个不是，那么王牌花色获胜，如果都是或者都不是比点数大小。 题意：第一行给出一个王牌的花色，第二行给出一对牌，包括一个数字牌，一张花色牌。 若果前者赢，则输出yes，否则为no。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstring&gt; #include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;char rank[9]=&#123;&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;T&#x27;,&#x27;J&#x27;,&#x27;Q&#x27;,&#x27;K&#x27;,&#x27;A&#x27;&#125;;//顺序牌，其顺序代表大小 int main()&#123; string wangpai;//第一张代表王牌的花色 cin&gt;&gt;wangpai; string a,b; cin&gt;&gt;a&gt;&gt;b; if(a[1]==wangpai[0] &amp;&amp; b[1]!=wangpai[0]) cout&lt;&lt;&quot;YES&quot;;//先比较王牌是否有王牌，有王牌的一方获胜 else if(a[1]!=wangpai[0] &amp;&amp; b[1]==wangpai[0]) cout&lt;&lt;&quot;NO&quot;; else &#123;//双方都没有王牌，那么就比较顺序牌 //int dist=find(rank,rank+9,a[0])-find(rank,rank+9,b[0]); if(dist&gt;0) cout&lt;&lt;&quot;YES&quot;; else cout&lt;&lt;&quot;NO&quot;; &#125; return 0;&#125; /*tips:find函数在数组中查找#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;//注意要包含该头文件using namespace std;int main()&#123; int nums[] = &#123; 3, 1, 4, 1, 5, 9 &#125;; int num_to_find = 5; int start = 0; int end = 5; int* result = find( nums + start, nums + end, num_to_find );//nums + start是数组起始地址 if( result == nums + end ) &#123; cout&lt;&lt; &quot;Did not find any number matching &quot; &lt;&lt; num_to_find &lt;&lt; endl; &#125; else &#123; cout&lt;&lt; &quot;Found a matching number: &quot; &lt;&lt; *result &lt;&lt; endl; &#125; return 0;&#125;*/ B 选配电脑题意：给出电脑的数量，接下来给出每台电脑的fans，ram，hdd，cost四个属性，然后如果有三个配置不如另一台电脑，那么这台电脑就可以不配考虑了。要求出符合要求价钱最低的那台电脑。 解题说明：此题采用暴力做法求解，需要比较任意两个电脑的配置，但是要注意一旦某个电脑三个方面的配置都不如另外一个电脑，这个电脑以后就不用考虑了，为了区别，可以把价格设一个很大的值。当全部比较完成以后，从价格中找出一个最小值，这就是需要选择的电脑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;struct node&#123; int fans,ram,rom,costs;&#125; s[10010];int main()&#123; int n,i,j; scanf(&quot;%d&quot;,&amp;n); for(i=0; i&lt;n; i++) &#123;//输入 scanf(&quot;%d %d %d %d&quot;,&amp;s[i].fans, &amp;s[i].ram, &amp;s[i].rom, &amp;s[i].costs); &#125; for(i=0; i&lt;n; i++) &#123; for(j=0; j&lt;n; j++) &#123; if(i!=j) &#123;//每两个电脑之间比较一次 if(s[i].fans&lt;s[j].fans &amp;&amp; s[i].ram&lt;s[j].ram &amp;&amp; s[i].rom&lt;s[j].rom) &#123;//若果他的三个配置都不如别人的好，那么这台电脑就不用考虑了 s[i].costs=1010;//把价钱设的很高，然后过会遍历一下求价钱最少的电脑 &#125; &#125; &#125; &#125; int k=-1; int min=1010; for(i=0; i&lt;n; i++) &#123; if(s[i].costs&lt;min) &#123; min=s[i].costs; k=i; &#125; &#125; printf(&quot;%d\\n&quot;,k+1); return 0;&#125; A 求并列第k名的人数题意：acm有n个队，然后如果题数和罚时相同的队伍两者的排名相同，然后求第k名的有多少个队。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;struct team&#123; int p;int t;&#125;;bool cmp(team a,team b)&#123; if(a.p==b.p)&#123; return a.t&lt;b.t; &#125; return a.p&gt;b.p;//那一会写成a.p&gt;a.p了，所以错了好几次 &#125;team ans[55];int main()&#123; int n,k,cnt=1; cin&gt;&gt;n&gt;&gt;k;//以为求的是第k名，所以数组总1开始存和从0开始存不一样 for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;ans[i].p; cin&gt;&gt;ans[i].t; &#125; sort(ans+1,ans+n+1,cmp);// for(int i=0;i&lt;=n;i++)&#123;// cout&lt;&lt;ans[i].p&lt;&lt;endl;// cout&lt;&lt;ans[i].t&lt;&lt;endl;// &#125; for(int i=k+1;i&lt;=n;i++)&#123;//从k+1向右边找 if( ans[k].p==ans[i].p&amp;&amp;ans[k].t==ans[i].t)cnt++; &#125; for(int i=1;i&lt;k;i++)&#123;//从1开始 向右边找 if( ans[k].p==ans[i].p&amp;&amp;ans[k].t==ans[i].t)cnt++; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125;版本二：#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct team&#123; int p;int t;&#125;;int cmp(team a,team b)&#123; if(a.p==b.p)&#123; return a.t&lt;b.t; &#125; return a.p&gt;b.p;//这地方原来为a.p&gt;a.p; &#125;struct team ans[100];int main()&#123; int n,k,cnt=0; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;ans[i].p; cin&gt;&gt;ans[i].t; &#125; sort(ans,ans+n,cmp); for(int i=0;i&lt;n;i++)&#123; if(ans[k-1].p==ans[i].p&amp;&amp;ans[k-1].t==ans[i].t)cnt++; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125; C 求中间值的特殊版本给出一个序列，然后通过公式mid&#x3D;n（n+1）&#x2F;2来找到中间值，给出n个数和中间值k，若k不为这n个数的中间值话，就往数列中加数，加随便的一个数，然后在判断k是否为中间值，然后问最少加多少次才能让k为这个数列的中间值。 12345678910111213141516171819202122232425262728293031方法转载：#include&lt;bits/stdc++.h&gt;using namespace std;int n;int k; //中位数int s[2000];int ans;int main()&#123; cin&gt;&gt;n&gt;&gt;k; int tmp=n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;s[i]; sort(s+1,s+1+n); if(s[(1+n)/2]==k)//先判中间位是不是k &#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; while(s[(1+tmp)/2]!=k)//如果不是k，那么一直向数列中加 k &#123; tmp++; s[tmp]=k; sort(s+1,s+1+tmp); ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 方法二：常规的讨论，发现规律首先，求中位数需要添加几位数。那么久需要看这个序列里面有没有x，这是两种情况。如果有的话，直接用这个数左边的个数和右边的个数相减的绝对值就可以了。 不过还需要注意一点。 如果右边的个数比左边的个数多， 那么你得到的绝对值还需要在减去一。 模拟一下就可得到。 123456789101112131415161718192021222324252627282930#include&quot;stdio.h&quot;#include&quot;string.h&quot;#include&quot;algorithm&quot;using namespace std;int main()&#123; int n,x; int a[510]; scanf(&quot;%d%d&quot;,&amp;n,&amp;x); for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+n+1); int pos = lower_bound(a+1,a+n+1,x) - a; int ans = upper_bound(a+1,a+n+1,x) - a; if(pos &gt; n) &#123; printf(&quot;%d\\n&quot;,n + 1); return 0;&#125;//这两种情况特判 if(ans == 1) &#123; printf(&quot;%d\\n&quot;,n); return 0;&#125; int minx = 99999; for(int i = pos; i &lt; ans; i ++) &#123; int cnt =( n - i ) &gt; (i - 1); minx = min((abs((n - i) - (i -1)) - cnt),minx); &#125; if(minx != 99999) &#123; printf(&quot;%d\\n&quot;,minx); return 0;&#125; int cnt = 1; pos = ans ; n ++; int id =(n - pos) &gt; (pos - 1); printf(&quot;%d\\n&quot;,abs((n - pos) - (pos - 1)) + cnt - id);&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"codeforce","slug":"codeforce","permalink":"https://zouyunkai.github.io/myblog/tags/codeforce/"}],"author":"aoyuehan"},{"title":"训练17 图论基础 bfs dfs 并查集 最小生成树 最短路径","slug":"训练17-图论基础","date":"2020-02-22T07:39:00.000Z","updated":"2022-02-26T03:52:52.056Z","comments":true,"path":"2020/02/22/训练17-图论基础/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/22/%E8%AE%AD%E7%BB%8317-%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80/","excerpt":"","text":"A象棋中马的走位 dfs搜索题意：国际象棋中，马只能走日（看图），给出初始位置和目标位置，求最少步数。解题思路：因为多组输入，直接BFS求最短路径，注意一下清空队列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define mem(a,b) memset(a,b,sizeof(a))using namespace std;const int maxn=300+5;int vis[maxn][maxn];int n;int dx[]=&#123;-2,-1,1,2,2,1,-1,-2&#125;;//方向 int dy[]=&#123;1,2,2,1,-1,-2,-2,-1&#125;;struct Node&#123; int x,y,step;&#125;;queue&lt;Node&gt; Q;bool check(int x,int y)//检查下一步是否合法 &#123; if(x&lt;0||x&gt;=n||y&lt;0||y&gt;=n) return false; if(vis[x][y]) return false; return true;&#125;int BFS(int x1,int y1,int x2,int y2)&#123; while(!Q.empty()) Q.pop();//因为多组输入，要清空队列 vis[x1][y1]=1;//起点先加入队列中，并标记已访问 Q.push((Node)&#123;x1,y1,0&#125;); while(!Q.empty()) &#123; Node u=Q.front(); //cout&lt;&lt;u.x&lt;&lt;&#x27; &#x27;&lt;&lt;u.y&lt;&lt;&#x27; &#x27;&lt;&lt;u.step&lt;&lt;endl; Q.pop(); if(u.x==x2&amp;&amp;u.y==y2) return u.step;//先判是否到大终点，然后朝八个方向走一下试试 for(int i=0;i&lt;8;i++) &#123; int x=u.x+dx[i]; int y=u.y+dy[i]; if(check(x,y)) &#123; vis[x][y]=1; Q.push(Node&#123;x,y,u.step+1&#125;); &#125; &#125; &#125; return 0;//如果走不到，说明结果为0 &#125;int main()&#123; int T; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; int x1,y1,x2,y2; scanf(&quot;%d%d%d%d%d&quot;,&amp;n,&amp;x1,&amp;y1,&amp;x2,&amp;y2); mem(vis,0);//清空vis数组 int ans=BFS(x1,y1,x2,y2); printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; B POJ3984《迷宫问题》 bfs搜索 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152方法一：#include&lt;iostream&gt;using namespace std;struct Node&#123; int x, y, pre; &#125;queue[50];//手写的模拟队列 int front = 0;int rear = 0;int a[5][5];//迷宫 int visit[5][5];//访问数组 int dir[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;//方向 void dfs(int beginX, int beginY, int endX, int endY)&#123; queue[0].x = beginX; queue[0].y = beginY; queue[0].pre = -1; rear+=1; visit[beginX][beginY]=1;//将迷宫起点加进来 while(front &lt; rear)//队列不为空 &#123; for(int i = 0; i &lt; 4; i++) &#123;//尝试四个方向 int nowX = queue[front].x + dir[i][0]; int nowY = queue[front].y + dir[i][1]; if(nowX &lt; 0 || nowX &gt; 5 || nowY &lt; 0 || nowY &gt; 5 || a[nowX][nowY] == 1 || visit[nowX][nowY] == 1) &#123; continue; &#125; queue[rear].x = nowX; queue[rear].y = nowY; queue[rear].pre = front; //这一个节点的前驱，用来最后找到路径 rear++;//尾指针++ ，为下一次进队做准备 visit[nowX][nowY] = 1; if(nowX == endX &amp;&amp; nowY == endY) return;//到达终点后返回 &#125; front++;//出队 &#125;&#125;void print(Node past)&#123;//打印路径函数 if(past.pre == -1) cout&lt;&lt;&quot;(&quot;&lt;&lt;past.x&lt;&lt;&quot;, &quot;&lt;&lt;past.y&lt;&lt;&quot;)&quot;&lt;&lt;endl; else &#123; print(queue[past.pre]); cout&lt;&lt;&quot;(&quot;&lt;&lt;past.x&lt;&lt;&quot;, &quot;&lt;&lt;past.y&lt;&lt;&quot;)&quot;&lt;&lt;endl; &#125;&#125;int main()&#123; for(int i = 0; i &lt; 5; i++) &#123; for(int j = 0; j &lt; 5; j++) &#123; cin&gt;&gt;a[i][j];//输入迷宫 &#125; &#125; dfs(0, 0, 4, 4); print(queue[rear-1]);//打印路径 return 0;&#125;方法二：自己整出了bug改了半天 发现如果那地方数据不对，就顺着思路一点一点的来推样例，这样才能更快的发现问题的所在#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int maze[5][5];//迷宫数组 int is[5][5];//是否被访问 int cnt=0;//用来记录c的存放位置 struct Node&#123;//一个节点 int x, y ; int pre; int cntt;//pre代表一条路径的前面那个节点，cntt代表这个节点在c数组中的存放位置 &#125;;struct Node c[30]; Node a,b;int isgo(int x,int y)&#123;//若果在上一个节点的基础上可以向那一方向走，就返回1 if(x&gt;=0&amp;&amp;x&lt;=4&amp;&amp;y&gt;=0&amp;&amp;y&lt;=4)&#123; return 1; &#125; return 0;&#125;queue&lt;Node&gt;q;void printa(Node a)&#123;//用来打印路径 ,传进来最后的那个节点（终点） if(a.pre==0)&#123; cout&lt;&lt;&#x27;(&#x27;&lt;&lt;a.x&lt;&lt;&quot;, &quot;&lt;&lt;a.y&lt;&lt;&#x27;)&#x27;&lt;&lt;endl;//这地方在，后面还有个空格 &#125;else &#123; printa(c[a.pre]); cout&lt;&lt;&#x27;(&#x27;&lt;&lt;a.x&lt;&lt;&quot;, &quot;&lt;&lt;a.y&lt;&lt;&#x27;)&#x27;&lt;&lt;endl; &#125;&#125;int dir[4][2]=&#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;int bfs(int si,int sj,int ei,int ej)&#123;//si，sj分别为起点的x，y坐标 ； ei，ej为终点的x y坐标 a.x=si; a.y=sj; c[cnt]=a; a.pre=0;a.cntt=0;cnt++;//第一个点进队 q.push( a);is[si][sj]=1; while(!q.empty())&#123; b=q.front();q.pop(); for(int i=0;i&lt;4;i++)&#123; a.x=b.x+dir[i][0]; a.y=b.y+dir[i][1]; if(isgo(a.x,a.y)&amp;&amp;!is[a.x][a.y]&amp;&amp;maze[a.x][a.y]!=1)&#123;//如果这个点可以走 a.cntt=cnt; a.pre=b.cntt;//先给a的前驱赋值，然后再把a存起来，顺序不能乱 c[cnt]=a; cnt++; if(a.x==ei&amp;&amp;a.y==ej)return 1; is[a.x][a.y]=1; q.push(a); &#125; &#125; &#125; return 0; &#125;int main()&#123; for(int i=0;i&lt;5;i++)&#123;//输入 for(int j=0;j&lt;5;j++)&#123; cin&gt;&gt;maze[i][j]; &#125; &#125; bfs(0,0,4,4); cout&lt;&lt;&quot;(0, 0)&quot;&lt;&lt;endl; printa(c[cnt-1]);// for(int i=0;i&lt;cnt;i++)&#123;// cout&lt;&lt;c[i].x&lt;&lt;&#x27; &#x27;&lt;&lt;c[i].y&lt;&lt;&#x27; &#x27;&lt;&lt;c[i].pre&lt;&lt;&#x27; &#x27;&lt;&lt;c[i].cntt&lt;&lt;endl;// &#125; return 0;&#125; /*debug:在可以进队的条件下，这地方因为写错了顺序，导致结果出错 a.cntt=cnt;//a的存储位置为下标为cnt的地方 c[cnt]=a; //这地方这么写不对，因为得先给a.pre赋值了之后，在把c存起来 cnt++; a.pre=b.cntt;//a的前驱指向b的位置 */ tips： **Presentation Error ** 指的是输出数据的格式问题，比如本题中的那个，后面的空格。 POJ2251:Dungeon Master(BFS)三维bfs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172转载：#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;char a[35][35][35];//地图 int b[35][35][35];//标记每个点是否被访问过 ，让每个点只经过队列一次 int L,R,C;int f[3][6]= &#123;&#123;1,-1,0, 0,0, 0&#125;,//三维的六个方向 &#123;0, 0,1,-1,0, 0&#125;, &#123;0, 0,0, 0,1,-1&#125;&#125;;int s2[35][35][35];int flag;//记录是否有出口 struct Knot &#123;//节点的性质 int x,y,z; int step;&#125;;Knot c,d;bool search1(int x,int y,int z) &#123;//判断这个点是否可以走 return (x&gt;=1&amp;&amp;x&lt;=L&amp;&amp;y&gt;=1&amp;&amp;y&lt;=R&amp;&amp;z&gt;=1&amp;&amp;z&lt;=C);&#125;int bfs(int si,int sj,int sk) &#123; queue&lt;Knot&gt;s; c.x=si; c.y=sj; c.z=sk; c.step=0; s.push(c);//把起点加到这个队列中 while (!s.empty()) &#123; d=s.front(); s.pop(); c.step=d.step+1; //在栈顶的步数的基础上走 for (int i=0; i&lt;6; i++) &#123; c.x=d.x+f[0][i];//在原来的基础上向哪个方向走 c.y=d.y+f[1][i]; c.z=d.z+f[2][i]; if (search1(c.x,c.y,c.z)&amp;&amp;!b[c.x][c.y][c.z]&amp;&amp;a[c.x][c.y][c.z]!=&#x27;#&#x27;) &#123;//若果满足条件 if (a[c.x][c.y][c.z]==&#x27;E&#x27;)//第一次遇到终点的话，那么可以直接返回 return c.step;//可以想到，先加入队列的节点要比后加入的节点的step值要小 b[c.x][c.y][c.z]=1; s.push(c); &#125; &#125; &#125; return -1;&#125;int main() &#123; int i,j,k; int si,sj,sk; while (cin&gt;&gt;L&gt;&gt;R&gt;&gt;C&amp;&amp;(L!=0||R!=0||C!=0)) &#123; memset(b,0,sizeof(b)); for (i=1; i&lt;=L; i++) for (j=1; j&lt;=R; j++) for (k=1; k&lt;=C; k++) &#123; cin&gt;&gt;a[i][j][k]; if (a[i][j][k]==&#x27;S&#x27;) &#123;//记录起始点的坐标 si=i; sj=j; sk=k; &#125; &#125; flag=bfs(si,sj,sk); if (flag==-1) cout &lt;&lt; &quot;Trapped!&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Escaped in &quot; &lt;&lt; flag &lt;&lt; &quot; minute(s).&quot; &lt;&lt; endl; &#125; return 0;&#125; D 克鲁斯卡尔算法 最小生成树题目大意：对于每组数据，首先读入一个n，然后接下来是n - 1行的数据，每行数据由： 出发点 该点出发边数m （边的另一端点 边的权值）× m 。求连接所有点的最短方案，输出所有点都连接起来的最短距离。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define Max_N 30#define Max_M 100int f[Max_N];struct edge &#123; int from; int to; int cost;//两条边之间的权值 bool operator &lt;(const edge r) const &#123;//边的cost从小到大排列 return cost &lt; r.cost; &#125;&#125;E[Max_M];int M;int N;int find(int x)&#123; return x == f[x] ? x : f[x] = find(f[x]);&#125; int Kruskal()&#123; sort(E, E + M); //对边排序 for (int i = 1; i &lt;= N; i++) f[i] = i;//刚开始，每个节点各成一个连通分量 int res = 0;//结果记为0 for (int i = 0; i &lt; M; i++) &#123; edge e = E[i]; // 每次选取最小的边，因为排过序了 int f1 = find(e.from);//判断最小边的起点和终点的连通分量 int f2 = find(e.to); if (f1 == f2 ) continue; // 利用并查集高效的判断 f[f1] = f2;//将起点和终点加在一个连通分量中 res += e.cost;//累加结果 &#125; return res;&#125; int main()&#123; int n, w; while (true) &#123; scanf(&quot;%d&quot;, &amp;N); if(N == 0) return 0; M = 0; for (int i = 0; i &lt; N - 1; i++) &#123; char a[3]; cin &gt;&gt; a &gt;&gt; n; for (int j = 0; j &lt; n; j++) &#123; char b[3]; cin &gt;&gt; b &gt;&gt; w; E[M].from = a[0] - &#x27;A&#x27; + 1; //输入的时候要进行处理 E[M].to = b[0] - &#x27;A&#x27; + 1; E[M].cost = w; M ++; &#125; &#125; printf(&quot;%d\\n&quot;, Kruskal()); &#125;return 0;&#125; E 最小生成树的代价为多少 prim算法题意：首先输入一个n，表示农场的个数，接下来输入一个N*N的矩阵，表示每个农场之间的距离。当然，对角线将会是0，因为不会有线路从自身农场到它本身。输出：把这n个农场连接起来的最小距离为多少。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;int m,n,sum,e[110][110],book[110],dis[110];int inf = 99999999;void Prim()&#123; int i,j,k,min; for(i = 1; i &lt;= n; i ++) &#123;//对dis和book初始化 dis[i] = e[1][i]; book[i] = 0; &#125; dis[1] = 0;//dis[j]为从起点1到其他点的最小距离 book[1] = 1;//标记该节点是否已经在最小生成树里 for(i = 1; i &lt; n; i ++) &#123;//从节点1遍历，找从起点到其余没有在树中的点的最小距离 min = inf; for(j = 1; j &lt;= n; j ++) if(book[j] == 0 &amp;&amp; dis[j] &lt; min) &#123;//找最小，k记录最小的那个节点 min = dis[j]; k = j; &#125; sum += min;//加上贡献 book[k] = 1;//标记本节点在最小生成树里 for(j = 1; j &lt;= n; j ++)//因为加入一个节点，对没有加入的点做一个更新 if(book[j] == 0 &amp;&amp; dis[j] &gt; e[k][j]) dis[j] = e[k][j]; &#125;&#125;int main()&#123; int i,j; while(scanf(&quot;%d&quot;,&amp;n) != EOF) &#123; sum = 0; for(i = 1; i &lt;= n; i ++) for(j = 1; j &lt;= n; j ++) scanf(&quot;%d&quot;,&amp;e[i][j]);//输入 Prim(); printf(&quot;%d\\n&quot;,sum); &#125; return 0;&#125; F 畅通工程 并查集 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798方法一：#include &lt;iostream&gt;using namespace std;int fa[1010];int ans;int find(int a)&#123;//路径压缩版本 int b=a; //把初始值赋给b while(a!=fa[a])&#123; a=fa[a]; //找到a的祖先节点 &#125; while(b!=a)&#123; //直到b==a为止 int temp=fa[b]; //设一个中间变量为b的父亲节点 fa[b]=a; //直接让b的父亲节点为a的祖先节点 b=temp; //b等于b的父亲节点 &#125; return a;/*总的来说就是把一个数传进这个函数，先找到这个数的祖先节点，然后把这个 数到这个数的祖先节点中的所有点都直接连向a的祖先节点*/&#125;void combine(int a,int b)&#123; int ffa=find(a); int ffb=find(b); if(ffa!=ffb)&#123; fa[ffa]=ffb; ans--; //若果两个点不在一个集合中，那么合并两者之后，总的集合数减一 &#125;&#125;int main()&#123; int i,n,m,x,y; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n!=0)&#123; scanf(&quot;%d&quot;,&amp;m); ans=n;//ans初始化为n个集合 ，一个集合就代表互相连接的一些城镇 for(i=0;i&lt;=n;i++)&#123; fa[i]=i; &#125; while(m--)&#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); combine(x,y); &#125; cout&lt;&lt;ans-1&lt;&lt;endl;//ans代表有多少个集合，要修的路最少就为集合数减1 &#125; return 0;&#125;方法二：#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;int parent[1002];void init(int n)//初始化&#123; for(int i=1;i&lt;=n;i++) parent[i]=i;&#125;int find(int x)//寻找根节点&#123; return parent[x]==x?x:find(parent[x]);&#125;void unite(int x,int y)//连接，分集合&#123; x=find(x); y=find(y); if(x==y) return ; else parent[x]=y;&#125;int main()&#123; int n,m; while(cin&gt;&gt;n&amp;&amp;n) &#123; cin&gt;&gt;m; init(n);//不能忘了这一句，初始化 int x,y; for(int i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); unite(x,y);//在输入的时候就分集合 &#125; int count=0; for(int i=1;i&lt;=n;i++) &#123; if(parent[i]==i)//当村庄的根节点编号等于该村庄编号时，代表一个集合 count++; &#125; cout&lt;&lt;count-1&lt;&lt;endl; &#125; return 0;&#125; G - 最短路径二：Floyd算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130解法一：迪杰斯特拉算法#include&lt;iostream&gt;using namespace std;const int maxnv=1e2+10;//点的数目 int maxint=1e4+20; struct AMGraph&#123; int vexnum; int arc[maxnv][maxnv];&#125;; int path[maxnv]; //用来存这个点的指前驱int d[maxnv];//到某个节点的最短路径的的长度 bool s[maxnv];//记录是否在已选中的集合里 int ans[maxnv][maxnv];void dj(AMGraph G,int v0)&#123;//求v0到其他点最短路径的长度 int n=G.vexnum; for(int v=0;v&lt;n;v++)&#123;//对图进行初始化 s[v]=false; d[v]=G.arc[v0][v];//从v0到v的最短路径初始化为两点之间最短的边 if(d[v]&lt;maxint)&#123; path[v]=v0;//初始化该点的前驱节点 &#125;else&#123; path[v]=-1; &#125; &#125; s[v0]=true;//将v0加入集合中 d[v0]=0;//到自己的路径为0 int tmp; for(int i=1;i&lt;n;i++)&#123; int min=maxint; for(int v=0;v&lt;n;v++)&#123; if(!s[v]&amp;&amp;d[v]&lt;min)&#123; tmp=v;//找到没有在集合中的，且到v0距离最小的点 min=d[v]; &#125; &#125; s[tmp]=true;//将找到的点加入到集合s中 for(int w=0;w&lt;n;w++)&#123; //因为加入一个点，重新跟新一下没有加入集合s中的那 //些点到v0的距离，在下一次for中用来找到tmp if(!s[w]&amp;&amp;(d[tmp]+G.arc[tmp][w]&lt;d[w]))&#123; d[w]=d[tmp]+G.arc[tmp][w]; path[w]=tmp; &#125; &#125; &#125; &#125; int main()&#123; int n,m ;int v1 ,v2,vlen; cin&gt;&gt;n&gt;&gt;m; AMGraph a;a.vexnum=n; for(int i=0;i&lt;n ;i++)&#123;//初始化邻接矩阵 for(int j=0;j&lt;n ;j++) &#123; if(i==j)a.arc[i][j]=0; else a.arc[i][j]=maxint;//a.arc[j][i]=maxint; &#125; &#125; for(int i=0;i&lt;m;i++)&#123;//因为两个点之间的路径有多条边，取最小的边存进去 cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;vlen; a.arc[v1-1][v2-1]=min(vlen,a.arc[v1-1][v2-1]); a.arc[v2-1][v1-1]=min(vlen,a.arc[v2-1][v1-1]); &#125; for(int i=0;i&lt;n;i++)&#123;//向ans结果矩阵中输入结果 dj(a,i); for(int j=0;j&lt;n;j++)&#123; ans[i][j]=d[j]; &#125; &#125; for(int i=0;i&lt;n;i++)&#123;//输出结果 for(int j=0;j&lt;n;j++) &#123; cout&lt;&lt;ans[i][j]&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl; &#125;&#125; 方法二：floyd#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define INF 0x3fffffffusing namespace std;int e[105][105];int main() &#123; int n,m; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; int u,v,cost; //memset(e,0,sizeof(e));//初始化领结 for(int i=1; i&lt;=n; i++) &#123; //初始化路径长度 for(int j=1; j&lt;=n; j++) &#123; if(i==j) &#123; e[i][j]=0; &#125; else &#123; e[i][j]=INF; &#125; &#125; &#125; for(int i=0; i&lt;m; i++) &#123;//输入边数 scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;cost); e[u][v]=e[v][u]=min(cost,e[u][v]); &#125; for(int k=1; k&lt;=n; k++) &#123;//找中介 缩短路径 for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; if(e[i][k]+e[k][j]&lt;e[i][j]) &#123; e[i][j]=e[i][k]+e[k][j]; &#125; &#125; &#125; &#125; for(int i=1; i&lt;=n; i++) &#123;//打印结果，floyd的算法可以求出任意两点之间的距离 for(int j=1; j&lt;=n; j++) &#123; if(j!=n) &#123; printf(&quot;%d &quot;,e[i][j]); &#125; else &#123; printf(&quot;%d\\n&quot;,e[i][j]); &#125; &#125; &#125; &#125; return 0;&#125; H - 最短路径·三： SPFA算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt; #include&lt;map&gt;#include&lt;queue&gt;using namespace std;#define mp(x, y) make_pair(x, y)typedef pair Pr;const int N = 100000 + 5;const int INF = 0x3f3f3f3f;int n, m, s, t, dist[N];//dist[i]为起点到点i的距离 bool in[N];//判断是否在队列中 vector v[N];//用来存邻接表 queue Q;int SPFA()&#123; for(int i = 1; i &lt;= n; i++) dist[i] = INF, in[i] = false;//初始化 dist[s] = 0;//将起点加入到队列中，并且到自己的距离为0 in[s] = true; Q.push(s); while(!Q.empty())&#123; int u = Q.front(); Q.pop();//从队列中取出一个点 in[u] = false; for(int i = v[u].size() - 1; i &gt;= 0; i--)&#123;//判断与这个点相邻的点 int j = v[u][i].first;//j为以i为起点的这一条边的终点 if(dist[j] &gt; dist[u] + v[u][i].second)&#123;//如果可以把dist[j]缩小，那么就缩小 dist[j] = dist[u] + v[u][i].second; if(!in[j])&#123;//若果这个点没在队列中，就加入队列；这与迪杰斯特拉 //算法不同（贪心），djs的算法判断的是不在集合s中的那些数 Q.push(j); in[j] = true; &#125; &#125; &#125; &#125; return dist[t];//返回到达终点的最短距离 &#125;int main()&#123; scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;s, &amp;t); int x, y, c; for(int i = 1; i &lt;= m; i++)&#123; scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;c); v[x].push_back(mp(y, c)); v[y].push_back(mp(x, c)); &#125; printf(&quot;%d\\n&quot;, SPFA());&#125; 无向图最小环——Floyd解法题目链接简单讲一下题意：给n(&lt;&#x3D;1e5)个数，数字范围(1e18)任意两个数字之间如果经过与运算以后不为0则可以判为两点相连，给出最小环大小，如果没有则输出-1；第一步将1e5变小，可以发现只要二进制的任意一位上面出现过3个乃至以上的1则只需输出3，大致算一下那么只有100个数字左右了可以跑Floyd了！！由Floyd算法可以知道，在它运行到以k做中间节点时，前面经过所有点都比k小的节点之间的最短路径其实已经确定了。因为在k做中间节点时他的最大节点必须大于等于k。因此每一次枚举一个中间节点我们都可以知道前面所产生的比k小的所有的最短路径。而一个环（p-&gt;i-&gt;j-&gt;p）的长度为dis[i][j]+a[p][i]+a[j][p];我们每一次枚举dis[i][j]的长度再加上原本图上的两条边找到最小值就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stdio.h&gt;using namespace std;const int N = 1e5 + 5;int n, cnt = 0,dis[200][200], p[200][200];long long ans = N,a[N], b[N];void floyd(void)&#123; for (int i = 1; i &lt;= cnt; i++)//一定经过i点 &#123; for (int j = 1; j &lt; i; j++)//枚举比i小的一个点 &#123; for (int k = j+1; k &lt; i; k++)// &#123; if(k!=j) ans = min((long long)dis[j][k] + p[k][i] + p[i][j], ans); //0x3f3f3f3f*3越int了 //cout &lt;&lt; ans&lt;&lt;endl; &#125; &#125; for (int j = 1; j &lt;= cnt; j++) &#123; for (int k = 1; k &lt;= cnt; k++) &#123; dis[j][k] = min(dis[j][k], dis[i][k] + dis[j][i]); &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); int v[63]; memset(v, 0, sizeof(v)); memset(dis, 0x3f3f3f3f, sizeof(dis)); memset(p, 0x3f3f3f3f, sizeof(p)); for (int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%lld&quot;, &amp;a[i]); for (int j = 62; j &gt; 0; j--) &#123; if ((a[i] &gt;&gt; j)&amp;1) v[j]++; &#125; &#125; for (int i = 1; i &lt;= 62; i++) &#123; if (v[i] &gt; 2) &#123; puts(&quot;3&quot;); return 0; &#125; &#125; for (int i = 1; i &lt;= n; i++) if (a[i]) b[++cnt] = a[i]; for (int i = 1; i &lt;= cnt; i++) &#123; for (int j = 1; j &lt;= cnt; j++) &#123; if (b[i] &amp; b[j]) dis[i][j] = 1, p[i][j] = 1; &#125; &#125; //cout &lt;&lt; ans &lt;&lt; endl; floyd(); //printf_s(&quot;%lld\\n&quot;, ans); if (ans == N) ans = -1; cout &lt;&lt; ans;&#125; 总结最小生成树问题是可以处理一个有环的图的最小生成树，而最短路径中，迪杰斯特拉算法就不能处理图中有环的情况（即只适用于非负权值、有向无环图中，单源最短路（有一个起点））floyd算法可以处理图中有环的情况，多源最短路。","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%9B%BE%E8%AE%BA/"}],"author":"aoyuehan"},{"title":"训练16 联盟周赛1","slug":"训练16-联盟周赛","date":"2020-02-22T07:21:00.000Z","updated":"2022-02-26T03:52:51.247Z","comments":true,"path":"2020/02/22/训练16-联盟周赛/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/22/%E8%AE%AD%E7%BB%8316-%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9B/","excerpt":"","text":"A 子集生成题意：抽象为：给出k个0 1组成的序列，然后问你出现0的次数有多少次。 方法一：解释一： 解释二： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667错误解法： 因为k=1000，pow函数一次运算可能会溢出#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;const int mod=1000000007;int a,b,c,k;long long ans=1;int main() &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;k&gt;&gt;c; int flag=0; if(a==c||b==c)flag=2; if(a==c&amp;&amp;b==c)flag=1; if(a!=c&amp;&amp;b!=c)flag=3; if(flag==2) &#123; for(int i=1;i&lt;=k;i++)&#123; ans=(ans+(int)pow(2,i-1)*pow(2,k-i))%mod; &#125;// for(int i=1; i&lt;=k-1; i++) &#123;// ans=(2*ans)%mod;// &#125;// ans=(k*ans)%mod;//其实for循环跑一遍结果为 k*(2^（k-1)） &#125; if(flag==1) &#123; ans=k; &#125; if(flag==3) &#123; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; //cout&lt;&lt;flag&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl;&#125;正确解法：快速幂加取模#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;typedef long long ll;const ll mod=1e9+7;ll a,b,c,k;long long ans=0;ll binaryPow(ll a, ll b, ll m)&#123; if(b == 0) return 1; else if(b % 2 == 1) return a * binaryPow(a, b - 1, m) % m; else&#123; ll num = binaryPow(a, b/2, m) % m; //优化 return num * num % m;// 不直接写成return binaryPow(a, b/2, m) * binaryPow(a, b/2, m) &#125;&#125;int main() &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;k&gt;&gt;c; if(a==c&amp;&amp;b==c) &#123; cout&lt;&lt;k&lt;&lt;endl; return 0; &#125; if(a==c||b==c) &#123; for(int i=1;i&lt;=k;i++)&#123; ans= (ans+(binaryPow(2,i-1,mod)*binaryPow(2,k-i,mod))%mod)%mod; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125; cout&lt;&lt;0&lt;&lt;endl;&#125; 方法二： 12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;typedef long long ll;const ll mod=1e9+7;2ll qpow(ll a,ll b,ll mod) &#123; //快速幂 ll ans=1%mod; while(b) &#123; if(b&amp;1) ans=(ans%mod*a%mod)%mod; a=(a%mod*a%mod)%mod; b&gt;&gt;=1; &#125; return ans;&#125;int main() &#123; ll f[1007]; f[0]=f[1]=1; for(int i=2; i&lt;=1000; i++)f[i]=(f[i-1]*i)%mod; //打表获得阶乘 ll a,b,k,c; ll tmp,ans=0; cin&gt;&gt;a&gt;&gt;b&gt;&gt;k&gt;&gt;c; if(a!=c&amp;&amp;b!=c)cout&lt;&lt;0&lt;&lt;endl; else if(a==b)cout&lt;&lt;k&lt;&lt;endl; else &#123; for(int i=1; i&lt;=k; i++) &#123; tmp=(i%mod*f[k]%mod*qpow(f[k-i],mod-2,mod)%mod*qpow(f[i],mod-2,mod)%mod)%mod;//i*组合数 ans=(ans%mod+tmp%mod)%mod; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; B 字符串|||统计价钱 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;ctype.h&gt;int main() &#123; int price=42,c=0,res=0;//默认价格为 42 char ch,flag=1;//flag=1 代表这一行是 raked line while(~scanf(&quot;%c&quot;,&amp;ch)) &#123; //逐个读取每个字符 if(ch==&#x27;\\n&#x27;) &#123; //换行时把这一行的总价累加起来 if(c==0 &amp;&amp; price!=42)//特判 priced line 中&#x27;|&#x27;个数为 0 的情况 res = price; //&#x27;|&#x27;个数为 0 则价格为 price else res+=price*c;//&#x27;|&#x27;个数不为 0,直接累加 c=0; //恢复默认价格 price=42; flag=1;//重置 raked line 标记 continue; &#125; if(price==42 &amp;&amp; ch==&#x27;|&#x27;)//如果是 raked line 则进行 raked line 计数 c++; else &#123; //不是 raked line ,进行 priced line 计数 if(flag==1)flag=0,price=0;//设置 flag 标记为 priced line 标记 if(isdigit(ch))//字符串转整数 price = price * 10 + ch - &#x27;0&#x27;; else if(ch==&#x27;|&#x27;)//计数 c++; &#125; &#125; if(res%10)res+=10-res%10; //向上取整到 10 的倍数 printf(&quot;%d,-\\n&quot;,res); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"联盟周赛","slug":"联盟周赛","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9B/"}],"author":"aoyuehan"},{"title":"新生训练15 cf测试1","slug":"新生训练15-cf测试1","date":"2020-02-21T03:38:00.000Z","updated":"2022-02-26T03:52:51.664Z","comments":true,"path":"2020/02/21/新生训练15-cf测试1/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/21/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%8315-cf%E6%B5%8B%E8%AF%951/","excerpt":"","text":"A 字符串比较 java大数解题说明：此题是依据输入数字的大小判断选用什么类型来存储，可以通过判断数字位数来实现，注意在达到某个类型最大位数的情况下不要超过该类型的最大值即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485解法一：#include&lt;bits/stdc++.h&gt;using namespace std;string s;//其实用char数组来做，就可以直接用strcmp了 int len;int main()&#123; cin&gt;&gt;s;int flag=0; string str1=&quot;127&quot;; string str2=&quot;32767&quot;; string str3=&quot;2147483647&quot;; string str4=&quot;9223372036854775807&quot;; len=s.length(); if(len&lt;3||(len==3&amp;&amp;s&lt;=str1)) //这样写是为了判断128 156这种三位数，数字的位数为3位，但是比127大的 cout&lt;&lt;&quot;byte&quot;&lt;&lt;endl; else if(len&lt;5||(len==5&amp;&amp;s&lt;=str2)) cout&lt;&lt;&quot;short&quot;&lt;&lt;endl; else if(len&lt;10||(len==10&amp;&amp;s&lt;=str3)) cout&lt;&lt;&quot;int&quot;&lt;&lt;endl; else if(len&lt;19||(len==19&amp;&amp;s&lt;=str4)) cout&lt;&lt;&quot;long&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;BigInteger&quot;&lt;&lt;endl;&#125;方法二：多此一举了 为了用strcmp函数#include&lt;bits/stdc++.h&gt;using namespace std;string s;//其实用char数组来做，就可以直接用strcmp了 int len;int main()&#123; cin&gt;&gt;s;int flag=0; string str1=&quot;127&quot;; string str2=&quot;32767&quot;; string str3=&quot;2147483647&quot;; string str4=&quot;9223372036854775807&quot;; len=s.length(); if(len&lt;3||(len==3&amp;&amp;strcmp(s.c_str(),str1.c_str())&lt;=0)) //将字符串转换为字符数组的形式，然后用strcmp函数比较大小 cout&lt;&lt;&quot;byte&quot;&lt;&lt;endl; else if(len&lt;5||(len==5&amp;&amp;strcmp(s.c_str(),str2.c_str())&lt;=0)) cout&lt;&lt;&quot;short&quot;&lt;&lt;endl; else if(len&lt;10||(len==10&amp;&amp;strcmp(s.c_str(),str3.c_str())&lt;=0)) cout&lt;&lt;&quot;int&quot;&lt;&lt;endl; else if(len&lt;19||(len==19&amp;&amp;strcmp(s.c_str(),str4.c_str())&lt;=0)) cout&lt;&lt;&quot;long&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;BigInteger&quot;&lt;&lt;endl;&#125;方法三：java大数运算import java.math.BigInteger;import java.util.Scanner;//这一题没说要判断负数，所以不用讨论负数的情况public class Main&#123; public static void main(String [] args)&#123; BigInteger a; BigInteger bigInteger1= new BigInteger(&quot;127&quot;); BigInteger bigInteger2= new BigInteger(&quot;32767&quot;); BigInteger bigInteger3= new BigInteger(&quot;2147483647&quot;); BigInteger bigInteger4= new BigInteger(&quot;9223372036854775807&quot;); Scanner sc=new Scanner(System.in); a=sc.nextBigInteger(); if(a.compareTo(bigInteger1)&lt;=0) &#123; System.out.println(&quot;byte&quot;); &#125;else if (a.compareTo(bigInteger2)&lt;=0) &#123; System.out.println(&quot;short&quot;); &#125;else if (a.compareTo(bigInteger3)&lt;=0) &#123; System.out.println(&quot;int&quot;); &#125;else if (a.compareTo(bigInteger4)&lt;=0) &#123; System.out.println(&quot;long&quot;); &#125;else &#123; System.out.println(&quot;BigInteger&quot;); &#125; sc.close(); &#125;&#125; 找凸子序列问题题意分析：输入一串整数，求它的连续子序列（此序列中存在最打大值，然后两边依次减小）的最大长度，就是求最长凸子序列的长度 。 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int a[1010];int ans ; int maxn=1;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;n;i++)&#123;//从这一个地方向两边扩展 //而且这个for循环要从0开始，我以为从1开始就可以的 //一想万一从0这个位置开始的是最长的呐，例如 4 3 2 1 //若果从1开始的话结果为3，而从0开始，结果为4 ans=1; for(int j=i-1;j&gt;=0;j--)&#123;//左边 if(a[j]&lt;=a[j+1])ans++; else break; &#125; for(int k=i+1;k&lt;n;k++)&#123;//右边 if(a[k]&lt;=a[k-1])ans++; else break; &#125; maxn=max(maxn,ans); //cout&lt;&lt;&quot;cishi i:&quot;&lt;&lt;i&lt;&lt;endl; &#125; printf(&quot;%d\\n&quot;,maxn);&#125; 判断文件个数和文件夹的数量给若干个文件路径，然后问子文件夹以及子文件数量最多分别为多少 方法一：就是直接模拟，从磁盘开始到该文件夹结束算作一个文件夹加入set中，这样可以避免冲突。最后直接算map中的最大的个数就好了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859方法一：#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string root, buff; map&lt;string, set&lt;string&gt;&gt; folder, files;//map前一个string代表磁盘，后一个set用来存路径 while(cin &gt;&gt; buff) &#123; int flr=0; for(int i=0; i&lt;(int)buff.size(); i++) &#123; if(buff[i]==&#x27;\\\\&#x27;)/*这里是转义字符，\\\\才代表一个\\ ;这地方不能用单行注释 */ &#123; flr++; if(flr==2) root = buff.substr(0,i); else if(flr&gt;2) folder[root].insert(buff.substr(0,i)); &#125; &#125; files[root].insert(buff); &#125; int ans0=0, ans1=0;//把文件存到文件的map中 for(auto &amp;pr:folder) ans0 = max(ans0, (int)pr.second.size()); for(auto &amp;pr:files) ans1 = max(ans1, (int)pr.second.size()); //auto &amp;pr:folder 这种写法（变量前加&amp;）的时候，若改变该变量的值，集合原来的值也会被改变 printf(&quot;%d %d\\n&quot;, ans0, ans1); return 0;&#125;方法二：转载#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;string s;map&lt;string,int&gt;fi,bag;map&lt;string,int&gt;::iterator it;int main()&#123;fi.clear();bag.clear(); while(cin&gt;&gt;s) &#123; int v=0; while(1) &#123; int pos=s.find_last_of(&#x27;\\\\&#x27;);//从后往前找\\的位置， if(pos==2)break; s.erase(s.begin()+pos,s.end());//删了 bool flag=fi[s]==0&amp;&amp;bag[s]==0;//flag的作用就是第一次进来的时候，让v变为1 bag[s]+=v;//以s为路径的文件夹的数量+1 if(flag)++v; ++fi[s];//以该s为路径的那个fi[]的值+1 &#125; &#125; int x=0,y=0; for(it=bag.begin();it!=bag.end();++it) x=max(x,it-&gt;second); for(it=fi.begin();it!=fi.end();++it) y=max(y,it-&gt;second); cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot;\\n&quot;;&#125; 方法二：建树来做","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"codeforce","slug":"codeforce","permalink":"https://zouyunkai.github.io/myblog/tags/codeforce/"}],"author":"aoyuehan"},{"title":"IIS配置","slug":"asp-net上机实验","date":"2020-02-18T13:26:00.000Z","updated":"2022-02-26T03:52:52.252Z","comments":true,"path":"2020/02/18/asp-net上机实验/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/18/asp-net%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"ISS的配置一、 ISS的安装和配置（1） 安装ISS找到控制面板的程序和功能的窗口，点击启用和关闭Windows功能，选中Internrt Information Services中的web管理用具，万维网服务等一些自己需要的功能。 （2） 打开控制面板，然后选择管理工具，选择ISS管理器，选中网站，右键添加网站，这里输入网站的名字，物理路径等。完成添加网站的任务。 这样，通过浏览器就能打开你配置的这个网页了。 二、 在VS中显示Web页面 （1） 在vs中新建一个asp.net的web工程，然后添加一个web窗体（如图1），在设计视图中拖拽生成一个图片框和按钮，日历框等。 三、 实验中遇到的问题（1） 首先在第一步的配置网站时，我输入了ip地址和端口，端口设置为80端口，后来显示不出来页面，错误代码为404，想了好久才知道，我以前安装过xammp，apache等软件，可能是他们的服务占用了80端口。 （2） 配置网站的时候还输入了域名，导致在打开网站的时候不显示任何东西，一直在加载；后来查阅相关资料才知道，是浏览器再打开的时候先去解析了这个域名，从而出现404的页面，而没有访问到我本地的这个页面。解决办法就是把域名这栏空出来（在实际的时候填写域名，会解析到你自己的域名上），默认为localhost的域名。 （3） 在第二步中，插入了一张图片，我把图片放到了App_Data文件夹下面，却遇到下面这样显示不出来的情况： 单击图片之后显示404.8；搜索之后发现这是因为你图片放到了指定的目录下，如App_Data，models，App_Browsers，App_code，App_GlobalResources，App_WebReferences，App_LocalResources，web.config，bin这些系统隐藏起来的文件或文件夹下面了，这些都是配置文件，对外隐藏，所以出现没有限权访问的错误。 （4） 还有一个错误就是我直接把老师给的源文件添加到目录中，打开后显示500.19的错误，显示重复定义节的提示，这是因为一下子开了好几个网站（就是一个工程里放了多个工程），这样就会有好几个web.config的文件，所以当然重复定义某个节了呀。 （5）IIS 安装后没有默认网站 新建网站绑定没有http 重装无效 如何解决 点下找到 listenerAdapters （6）权限不足（比如放在c盘，受保护的地方），无法访问修改那个安全中的用户属性，设置一个everyone。","categories":[{"name":"asp","slug":"asp","permalink":"https://zouyunkai.github.io/myblog/categories/asp/"}],"tags":[{"name":"iis配置","slug":"iis配置","permalink":"https://zouyunkai.github.io/myblog/tags/iis%E9%85%8D%E7%BD%AE/"}],"author":"aoyuehan"},{"title":"面试题目汇总","slug":"面试题目汇总","date":"2020-02-18T07:23:00.000Z","updated":"2022-02-26T03:52:51.621Z","comments":true,"path":"2020/02/18/面试题目汇总/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/","excerpt":"","text":"腾讯算法面试题 第一步:分八组，各跑一轮，依成绩组内排名并编号。第二步:每个组的第一名跑一轮，依成绩再编号。此时共跑九轮选出最快马。第三步:此时A马（即第一次参赛跑第一，第二次参赛跑第二的马）与最快马第一次参赛剩下的七匹（可能的次快马）。让它们八匹跑一轮。此时假如A马在该轮比赛中跑第三。则该轮的第一第二马分别为64匹中的亚军与季军。而A马为所有马中第四快的马。至此10轮选出前四。因题目问“最少”，故第十轮不考虑其他可能出现的结果，就算第十轮中A马跑得不是第三，比如第一，只需要让第十轮的第二和第三与第九轮中除去最快马和A马剩下的马（共八匹）比一次，就能决定最快的四匹马;也就11次就能选出来。 图解： 另一个人的证明方法 tips：足球比赛的规则 123456789101112131415161718192021222324小组赛阶段 32支参赛队通过抽签分为八个小组,每个小组分别有四支球队进行比赛，每支球队都必须和其他三支球队进行且只进行一场比赛,每组4个队循环比赛，共打6场(a1-a2;a1-a3;a1-a4;a2-a3;a2-a4;a3-a4),每场比赛90分钟，胜平负分别积3、1、0分。每个小组积分的前两名球队出线进入淘汰赛阶段的1/8决赛，共16支队，即“16强”。 淘汰赛阶段1/8决赛A组第一对阵B组第二=胜者1A组第二对阵B组第一=胜者2C组第一对阵D组第二=胜者3C组第二对阵D组第一=胜者4E组第一对阵F组第二=胜者5E组第二对阵F组第一=胜者6G组第一对阵H组第二=胜者7G组第二对阵H组第一=胜者8获胜的8个队进入1/4决赛，即所谓“8强”1/4决赛 胜者1对阵胜者3=胜者A //胜者1肯定比胜者2（若胜者2位A组的第二的话）要强，所以此处让胜者1对阵胜者3 是最公平的。胜者2对阵胜者4=胜者B胜者5对阵胜者7=胜者C胜者6对阵胜者8=胜者D1/4决赛的4个获胜队进入“4强”半决赛胜者A对阵胜者C胜者B对阵胜者D决赛半决赛获胜两队进入决赛，失利的两队争夺三名 ThreadLocal为什么要设计成private statichttps://blog.csdn.net/silyvin/article/details/79551635 薛勤同学讲座 找一个靠谱的能解决问题的人，来解决自己的问题，这样很省时间，精力。 首先老师讲的太浅了 ，就必须java这个语言，jvm虚拟机，ssh，sshm，集合，框架 ， jdk源码，集合类的底层原理，hash底层原理，spring，中间件，分布式git，多线程。 大三下学期准备实习，秋招重要 坚持 把要学的都学完，天天学，天天学。 静下心 计划 有计划的学和复习 项目实践，扎实的基本功。","categories":[{"name":"面试","slug":"面试","permalink":"https://zouyunkai.github.io/myblog/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zouyunkai.github.io/myblog/tags/%E9%9D%A2%E8%AF%95/"}],"author":"aoyuehan"},{"title":"新生训练14-牛客竞赛6","slug":"新生训练14-牛客竞赛6","date":"2020-02-16T04:25:00.000Z","updated":"2022-02-26T03:52:51.335Z","comments":true,"path":"2020/02/16/新生训练14-牛客竞赛6/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/16/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%8314-%E7%89%9B%E5%AE%A2%E7%AB%9E%E8%B5%9B6/","excerpt":"","text":"A-配对问题 大胆猜测哦 我们要使得第K大的和尽可能大，显然可以贪心：首先，组成这K对数字的显然是A中最大的K个数字和B中最大的K个数字。问题转化为怎样配对使得最小的和最大：我们发现，如果A1&lt;A2,B1&lt;B2，那么一定是由A1和B2配对较优。倒序配对使得A中最大的K个数字和B中最大的K个数字配对所形成的和更加平均。经过简单的归纳可以得到，倒序配对是最优的，这样就解决了问题。**比赛的时候也想到是这样，一想这样太简单了吧，就没试；大胆猜测，大胆的试 ** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std;const int N = 100050; int a[N], b[N], n, k, ans = 2e8;int main()&#123; int i, j; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for(i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); for(i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;b[i]); sort(a + 1, a + n + 1); sort(b + 1, b + n + 1); for(i = n; i &gt; n - k; i --) ans = min(ans, a[i] + b[n - k + n + 1 - i]); printf(&quot;%d\\n&quot;, ans); return 0;&#125;方法二：在c++11上超时 过%80数据但在c++15上就能过，而且我发现加上注释之后更容易超时#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1e5+5;int n,k,a[N],b[N];multiset&lt;int&gt;s;multiset&lt;int&gt;::iterator it;bool judge(int m)&#123; s.clear(); for(int i=1;i&lt;=n;i++) s.insert(b[i]);//先把b数组中的数加进来 int ans=0;//记录加进去一个a数组中的值，判断m是第ans大 for(int i=1;i&lt;=n;i++)//依次判断a数组中的值 &#123; if(ans+n-i+1&lt;k) return false;//剪枝，就算把for循环后面的全都加进来，也无法到达第k大，那么直接返回false it=s.lower_bound(m-a[i]); //因为假设m就为两数组相互配对之后的第k大 ，那么m-a[i]就是配对之后的那个b[i]的值 if(it!=s.end())//如果存在相配对的那个b[i]，那么ans++ &#123; ans++; s.erase(s.find(*it)); &#125; &#125; return ans&gt;=k;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); sort(a+1,a+1+n); sort(b+1,b+1+n); int l=0,r=200000000,ans; while(l&lt;=r)//二分来找第k大 &#123; int m=l+r&gt;&gt;1; if(judge(m)) ans=m,l=m+1; else r=m-1; &#125; printf(&quot;%d\\n&quot;,ans);&#125; B-图的简单路径包含的数量（基环树） 1 tips：基环树是一种图，它由一个环组成，环上每个点都是一棵树点树根，所以称为基环树。当然，一棵树上连一条边也会变成基环树。 有向的基环树基环内向树：每个点出度为1（因此每个环上点的子树，儿子指向父亲） 基环外向树：每个点入度为1（因此每个环上点的子树，父亲指向儿子）上图把所有边反一下，就是个基环外向树. D重排列 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std;typedef long long LL;const int N = 100050;const LL mod = 1000000007; int a[N], b[N], ans = 1, n; int main()&#123; int i, j, k; cin &gt;&gt; n; for(i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); for(i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;b[i]); sort(a + 1, a + n + 1); sort(b + 1, b + n + 1); for(i = 1, j = 0; i &lt;= n; i ++)&#123; while(j &lt; n &amp;&amp; a[j + 1] &lt;= b[i]) j ++;//找到a中小于b[i]的个数 ans = (LL)ans * max(0ll, j - i + 1ll) % mod; //0ll就是long long类型的0 &#125; printf(&quot;%d&quot;, ans % mod); return 0;&#125; F 十字阵列 它累加的是每一个格子的值*（i+j），原来是这个意思，比赛的时候看成是每个格子的值相累加，没看懂这（i+j）是什么意思，比赛的时候不要慌，要细心地想一想呀 设3个数组a[]，b[]和ab[][]，分别统计对行，列和每格造成的伤害进行操作(xi,yi,zi)时，a[xi]，b[yi]，ab[xi][yi]都加上zi每次询问一格的答案时，只要查询a[x]+b[y]-ab[x][y]就好了 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std;const int N = 2010;const int mod = 1000000007; int x[N], y[N], xy[N][N], n, m, H, ans; int main()&#123; int i, j, k, h; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;H); for(i = 1; i &lt;= H; i ++)&#123; scanf(&quot;%d%d%d&quot;, &amp;j, &amp;k, &amp;h); x[j] += h, y[k] += h, xy[j][k] += h; &#125; for(i = 1; i &lt;= n; i ++) for(j = 1; j &lt;= m; j ++) ans = (ans + (long long)(x[i] + y[j] - xy[i][j]) * (i + j) % mod) % mod; printf(&quot;%d&quot;, (ans + mod) % mod); return 0;&#125; G-括号序列 栈的模拟 12345678910111213141516171819202122232425262728293031方法一：用栈来模拟#include&lt;bits/stdc++.h&gt;#include&lt;string.h&gt;using namespace std;string s;int main() &#123; int t,len; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;len;//len为该括号序列的长度 if(len==0) &#123;//若果是空串 cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; &#125; else &#123; stack&lt;char&gt;st;//别忘记清空栈，重要 //getchar();下面若果使用getline的时候要加上这句，防止回车进入到s中 cin&gt;&gt;s; char tmp; for(int i=0; i&lt;len; i++) &#123; if(s[i]==&#x27;(&#x27;)tmp=&#x27; &#x27;; if(s[i]==&#x27;)&#x27;)tmp=&#x27;(&#x27;; if(st.empty())st.push( s[i] );//栈空的时候一定要压栈 else &#123; if(st.top()== tmp )st.pop();//若果栈顶为(,新加入的为),则弹出( else st.push( s[i] );//否则压入栈 &#125; // cout&lt;&lt;&quot;st top:&quot;&lt;&lt;st.top()&lt;&lt;&quot;st len:&quot;&lt;&lt;st.size()&lt;&lt;endl; &#125; cout&lt;&lt; st.size();&lt;&lt;endl;//最后留在栈中的括号就是要删除的 &#125; &#125;&#125; 方法二：括号序列合法的一个充要条件是：设’(‘为1，’)’为-1，则：①序列所有位置前缀和非负；②’(‘与’)’数量相等为了保证条件1，我们可以用栈模拟括号序列的匹配过程碰到一个’(‘就加入栈中，碰到一个’)’就消去栈顶的一个’(‘如果栈中没有没有’(‘则这个’)’必须要删去在这个过程结束之后，如果’(‘比’)’多，则从后向前删去多余的’(‘，直到序列合法即可可以证明这样一定能得到满足要求的括号序列：两个步骤中删除的括号都是必须删去的 123456789101112131415161718192021222324252627282930313233 #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std;const int N = 1000050; int T, n, l, r, sum, ans; char s[N];int main()&#123; int i, j, k; scanf(&quot;%d&quot;, &amp;T); while(T --)&#123; scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%s&quot;, s + 1); l = r = sum = ans = 0; for(i = 1; i &lt;= n; i ++)&#123; if(s[i] == &#x27;(&#x27;) l ++, sum ++;//左括号的数量l++，括号的总数量sum++ else if(sum &gt; 0) r ++, sum --;//若果压入的是),而且栈中有(,则r++，sum--，把栈中的(减掉 else ans ++;//若果要入的是),且栈空，那么这个一定要删去，ans++ &#125; printf(&quot;%d\\n&quot;, ans + l - r);//最后ans+左括号的数量-已经配对之后的）的数量就是答案 &#125; return 0;&#125; J-三角形三个顶点的圆两辆内切 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;double l0,l1,l2;bool issan(double l1,double l2,double l3) &#123;//判断是否为三角形 if(l1+l2&gt;l3&amp;&amp;l1+l3&gt;l2&amp;&amp;l2+l3&gt;l1&amp;&amp;l1&gt;0&amp;&amp;l2&gt;0&amp;&amp;l3&gt;0)return true; else return false;&#125;double a[3];int main() &#123; cin&gt;&gt;l0&gt;&gt;l1&gt;&gt;l2; if(issan(l0,l1,l2)) &#123; a[0]=(l0+l1-l2);//内切圆的半径=（两边之和减第三边）/2 a[1]=(l1+l2-l0);//从 r1+r2=l3;r1+r3=l2;r2+r3=l1 这三个关系推出来的 a[2]=(l0+l2-l1);//这地方写错了，没看出来 sort(a,a+3); if(a[0]&gt;0)&#123; cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;a[0]*1.0/2&lt;&lt;&#x27; &#x27;&lt;&lt;a[1]*1.0/2&lt;&lt;&#x27; &#x27;&lt;&lt;a[2]*1.0/2&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; &#125; else &#123; cout&lt;&lt;&quot;wtnl&quot;&lt;&lt;endl; &#125;&#125; 1234567891011121314151617181920212223242526方法二：可以证明“No”是不存在的，所以不论怎么写都能对。 #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt; using namespace std; double a[3], b[3];int main()&#123; cin &gt;&gt; a[0] &gt;&gt; a[1] &gt;&gt; a[2]; sort(a, a + 3); if(a[0] + a[1] &lt;= a[2])&#123; puts(&quot;wtnl&quot;); return 0; &#125; puts(&quot;Yes&quot;); b[1] = (a[2] - a[1] + a[0]) / 2; b[0] = a[0] - b[1], b[2] = a[2] - b[1]; printf(&quot;%.2lf %.2lf %.2lf&quot;, b[0], b[1], b[2]); return 0;&#125; tips：这样写可以一边遍历一遍修改容器mp中的值：for(auto &amp;i:mp)","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"牛客","slug":"牛客","permalink":"https://zouyunkai.github.io/myblog/tags/%E7%89%9B%E5%AE%A2/"}],"author":"aoyuehan"},{"title":"qlu_acm个人赛第四场","slug":"qlu-acm个人赛第四场","date":"2020-02-14T10:17:10.000Z","updated":"2022-02-26T03:52:51.863Z","comments":true,"path":"2020/02/14/qlu-acm个人赛第四场/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/14/qlu-acm%E4%B8%AA%E4%BA%BA%E8%B5%9B%E7%AC%AC%E5%9B%9B%E5%9C%BA/","excerpt":"","text":"A. Prefixes题意：题目意思大概就是给你一个由 ‘a’、’b’ 构成的字符串，问你最少改变几个字符使这个字符串的每个偶数前缀的 ‘a’、’b’ 字符数量相同，并输出改变后的字符串。思路：直接扫一遍，每次找两个字符，如果数量不同就改。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;using namespace std;#define ll long long int main()&#123; ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);//上面那句话就是来增加c++的cin和cout的输入输出速度的（关闭cin和cout的缓存） int n; cin&gt;&gt;n; string str; cin&gt;&gt;str; int cnt_a=0,cnt_b=0; int ans=0; for(int i=0;i&lt;n;i++) &#123; if(str[i]==&#x27;a&#x27;) cnt_a++; else if(str[i]==&#x27;b&#x27;) cnt_b++; if(i&amp;1)//下标是从0开始的 &#123;//这地方可以这么写，因为当i为奇数时（因为i从0开始），i&amp;1为真，就实现了没比较两个数就执行一次该if判断 if(cnt_a!=cnt_b) &#123; ans++; if(cnt_a==2) str[i]=&#x27;b&#x27;; else if(cnt_b==2) str[i]=&#x27;a&#x27;; &#125; cnt_a=0; //一定要记得让cnt_a和cnt_b都等于0，进行下一轮比较 cnt_b=0; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; cout&lt;&lt;str&lt;&lt;endl; return 0;&#125; B. Shooting题意： 射击一排瓶子，射倒第一个罐子需要 1 次，击倒之后的需要 a[i] * x + 1 次，顺序自选，x从1递增题解： 直接排序，从大到小，最大的a[i] * 最小的x 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1000+10;typedef long long ll;typedef struct&#123; int num; int id;&#125;st;st sum[maxn];bool cmp(st &amp;a,st &amp;b)&#123; return a.num&gt;b.num; //num从大到小来排列&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;sum[i].num; sum[i].id=i; &#125; sort(sum+1,sum+n+1,cmp); ll ans=0; for(int i=1;i&lt;=n;i++) ans+=(i-1)*sum[i].num+1; //第一位乘的是0，第二次乘的是1,....（i-1就相当于x） cout&lt;&lt;ans&lt;&lt;endl; for(int i=1;i&lt;=n;i++) cout&lt;&lt;sum[i].id&lt;&lt;&quot; &quot;; return 0;&#125;Input65 4 5 4 4 5Output696 1 3 5 2 4 这一组数中下标从1开始，那么下标为1就对应这第一个5 D. Swords题意： 剧院有n种剑，每种都有x把， y 个人来到剧院拿了相同的剑（每个人拿的剑的种类相同），只有1种剑没有被拿过，然后给出每种剑剩余的个数，求最少有多少个人，拿了多少把剑题解： 直接可以看出 x 等于剩余剑数最多的那种剑，每个人拿的剑相同，所以应该是差值的最大公约数 ； 用最大数减去所给的值，然后对前n-1个值求一个gcd，然后除掉gcd求和就是答案。这一题中说了最初的剑是一样的，所以最大的那个就是起初所有各种剑的数目。 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;using namespace std;#define ll long long const int maxn=2e5+10;ll int gcd(ll int a,ll int b)&#123; if(b==0) return a; else return gcd(b,a%b);&#125;int num[maxn];int main()&#123; ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); int n; cin&gt;&gt;n; int maxx=-1; for(int i=0;i&lt;n;i++) cin&gt;&gt;num[i]; sort(num,num+n); maxx=num[n-1];//每种剑的种类数x就是maxx int now; for(int i=0;i&lt;n-1;i++) &#123; if(i==0) now=maxx-num[i]; else//这个差值对前n-1个数求一个最大公约数 now=gcd(now,maxx-num[i]); &#125; ll int ans=0; for(int i=0;i&lt;n-1;i++) &#123;//每一种剑被拿走的数量/now就是这种剑有几个人拿走了 ans+=(maxx-num[i])/now; &#125; cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;now&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"训练","slug":"训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"qlu_acm个人赛第三场","slug":"qlu-acm个人赛第三场","date":"2020-02-14T07:17:49.000Z","updated":"2022-02-26T03:51:21.521Z","comments":true,"path":"2020/02/14/qlu-acm个人赛第三场/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/14/qlu-acm%E4%B8%AA%E4%BA%BA%E8%B5%9B%E7%AC%AC%E4%B8%89%E5%9C%BA/","excerpt":"","text":"A. Mike and Fax 判断一个字符串的x个子串是否也是回文串题意及题解：给个字符串 和 回文串数量， 长度为回文长度（字符串长度除以所给回文串数量可得）来分割这个字符串（等长分割）， 判断分割出来的回文串是不是都是回文串 且 回文长度 都要 相等。ps: 中间不存在多余 字符的存在， 判 字符串长度 不能整除 回文串数量 时，直接输出nomethod1: 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string str; int k,n; int id; cin&lt;&lt;str&lt;&lt;k; if(str.length()%k!=0)&#123;//若果串的长度不能被回文串的数量整除 cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0; &#125; n=str.length()/k;//每一个回文串的长度 bool ans=false; for(int i=0;i&lt;=k;i++)&#123; int bi=(i-1)*n;//bi ei为两个指针，指向这个串的头和尾 int ei=i*n; while(bi&lt;=ei)&#123; if(str[bi]!=str[ei])&#123; ans=true; break; &#125; ei--; bi++; &#125; if(ans)break;//若果这个子串不是回文串 &#125; if(ans)cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; return 0; &#125; method2: 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;char str[1005];int len;int main()&#123; int i,j,k; while(~scanf(&quot;%s%d&quot;,str,&amp;k)) &#123; len = strlen(str); if(len%k)//不能整除 &#123; printf(&quot;NO\\n&quot;); continue; &#125; int r = len/k,flag = 0; for(i = 0; i&lt;len; i+=r) &#123; for(j=i; j&lt;i+r; j++) &#123; if(str[j]!=str[(i+r)-1-j+i])//判断一个子串相对应的位置 &#123; flag = 1; break; &#125; &#125; if(flag) break; &#125; if(flag) printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n&quot;); &#125; return 0;&#125; B. Mike and Fun 矩阵改变+统计连续的次数题意：给出一个n*m的0，1矩阵然后有k次操作，每次操作给出一个坐标，代表对该坐标的数字取反每次操作之后，输出矩阵里每一行连续1的个数最大的那个值 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std;int a[510][510];int main()&#123; int n,m,q,x,y,ans; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;a[i][j];//初始化矩阵 &#125; &#125; for(int i=0;i&lt;q;i++)&#123; cin&gt;&gt;x&gt;&gt;y; a[x][y]=!a[x][y];//表情转换 int MAXN=-1; for(int s=1;s&lt;=n;s++)&#123;//统计每一行中连续1的个数 ans=0; for(int t=1;t&lt;=m;t++)&#123; if(a[s][t]==0)//遇到0，就变为不连续的了 ans=0;//不连续，结果记为0 else ans++;//连续的话ans++ MAXN=max(MAXN,ans);//记录最大值 &#125; &#125; cout&lt;&lt;MAXN&lt;&lt;endl; &#125; return 0;&#125; Mike and Feet CodeForces - 548D （单调栈）题意：给出n个数，这n个数在区间长度为i（1~n）的时候可以分割成一些区间，这每个区间都会有一个最小值，在同样长度的这些区间的最小值中，输出最大值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;#define MEM(a,x) memset(a,x,sizeof(a)) /*num栈顶的元素，width宽度，跟现在入栈的数之间相隔了多少个数，因为要求的是连续区间，所以这个也是必须记录的*/struct node&#123; int num,width; node() &#123;&#125;; node(int _num,int _width):num(_num),width(_width) &#123;&#125;&#125;; stack&lt;node&gt; S;int a[N],ans[N]; int main()&#123; int n,i,j; scanf(&quot;%d&quot;,&amp;n); for(i = 0; i&lt;n; i++) scanf(&quot;%d&quot;,&amp;a[i]); a[n++] = 0; MEM(ans,0); for(i = 0; i&lt;n; i++) &#123; int len = 0;//连续区间的长度 node k; while(!S.empty()) &#123; k = S.top(); if(k.num&lt;a[i])//栈是从小到大 排的 break; //新入栈的元素比栈顶元素要小，那么对于这个连续区间而言，这个比新入栈的元素就没有用了，可以出栈 int ls=k.width+len;//出栈的同时获得其长度 if(k.num&gt;ans[ls])//ans记录ls区间的时候的最大值 &#123; ans[ls]=k.num;//当压进去的数，比栈顶更小的时候才会走这地方，记录答案 &#125; len+=k.width; S.pop(); &#125; S.push(node(a[i],len+1)); &#125; for(i = n-1; i&gt;=1; i--)//因为上面只更新了一部分的点，所以现在要对那些没有更新的点也更新 ans[i]=max(ans[i],ans[i+1]); printf(&quot;%d&quot;,ans[1]); for(i = 2; i&lt;n; i++) printf(&quot; %d&quot;,ans[i]); printf(&quot;\\n&quot;); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"训练","slug":"训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"新生训练13-牛客竞赛5","slug":"新生训练13-牛客竞赛5","date":"2020-02-14T03:57:46.000Z","updated":"2022-02-26T03:52:51.939Z","comments":true,"path":"2020/02/14/新生训练13-牛客竞赛5/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/14/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%8313-%E7%89%9B%E5%AE%A2%E7%AB%9E%E8%B5%9B5/","excerpt":"","text":"A字符串之间的变化数量 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int cnt=0;int n,m;const int maxn=1e5+10;char s[maxn],s1[maxn];int main() &#123; cin&gt;&gt;n&gt;&gt;m; cin&gt;&gt;s; cin&gt;&gt;s1; if(n&lt;=m) &#123; //分 两种情况讨论 for(int i=0; i&lt;n; i++) &#123; //找到前一个串中要修改的数量 if(s[i]!=s1[i])cnt++; &#125;//xyzx xyz for(int i=n; i&lt;m; i++)cnt++; //要删去的数量 &#125; else &#123; for(int i=0; i&lt;m; i++) &#123; //先找较短的那一串中要改的数量 if(s[i]!=s1[i])cnt++; &#125;//xyz xyzx for(int i=m; i&lt;n; i++)cnt++; //找到末尾要补的数量 &#125; cout&lt;&lt;cnt&lt;&lt;endl;&#125; B 牛牛的比赛场地 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std; struct p&#123; int x,y;&#125;a[100005];int n;double check(double x)&#123; double max=0; for (int i=1;i&lt;=n;i++) &#123; double tmp=sqrt(a[i].y*a[i].y+(a[i].x-x)*(a[i].x-x)); if (tmp&gt;max) max=tmp; &#125; return max;&#125;double tsearch(double left,double right)&#123;//三分找答案 int i; double mid,midmid; for(i=0;i&lt;100;i++)&#123; mid=left+(right-left)/2; midmid=mid+(right-mid)/2; if(check(mid)&gt;check(midmid)) //极大值求法 left=mid; else right=midmid; &#125; return mid;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for (int i=1;i&lt;=n;i++) scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); double max=tsearch(-10000,10000); printf(&quot;%.4lf\\n&quot;,check(max)); return 0;&#125; C-c语言IDE 模拟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217 #include &lt;bits/stdc++.h&gt;using namespace std; string source;void replaceAll(string &amp;s, string oldstr, string newstr)&#123; for (string::size_type pos = 0; pos != string::npos; pos += newstr.length()) if ((pos = s.find(oldstr, pos)) != string::npos) s.replace(pos, oldstr.length(), newstr); else break;&#125;struct functions&#123; string inClass, name, outputType; vector&lt;string&gt; inputType; functions(string inClass = &quot;&quot;, string name = &quot;&quot;, string outputType = &quot;void&quot;, vector&lt;string&gt; inputType = vector&lt;string&gt;(0)) :inClass(inClass), name(name), outputType(outputType), inputType(inputType) &#123;&#125;&#125;;vector&lt;functions&gt; funs;void solve(string &amp;s)&#123; replaceAll(s, &quot;/*&quot;, &quot; /* &quot;); replaceAll(s, &quot;*/&quot;, &quot; */ &quot;); replaceAll(s, &quot;//&quot;, &quot; // &quot;); replaceAll(s, &quot;(&quot;, &quot; ( &quot;); replaceAll(s, &quot;)&quot;, &quot; ) &quot;); replaceAll(s, &quot;&#123;&quot;, &quot; &#123; &quot;); replaceAll(s, &quot;&#125;&quot;, &quot; &#125; &quot;); replaceAll(s, &quot;=&quot;, &quot; = &quot;); replaceAll(s, &quot;\\&quot;&quot;, &quot; \\&quot; &quot;); replaceAll(s, &quot;&#x27;&quot;, &quot; &#x27; &quot;); replaceAll(s, &quot;;&quot;, &quot; ; &quot;); replaceAll(s, &quot;,&quot;, &quot; , &quot;); replaceAll(s, &quot;+ = &quot;, &quot;+=&quot;); replaceAll(s, &quot;- = &quot;, &quot;-=&quot;); replaceAll(s, &quot;* = &quot;, &quot;*=&quot;); replaceAll(s, &quot;/ = &quot;, &quot;/=&quot;); replaceAll(s, &quot;^ = &quot;, &quot;^=&quot;); replaceAll(s, &quot;| = &quot;, &quot;|=&quot;); replaceAll(s, &quot;&amp; = &quot;, &quot;&amp;=&quot;); replaceAll(s, &quot;:&quot;, &quot; : &quot;); replaceAll(s, &quot; : : &quot;, &quot;::&quot;); //ע���滻������ע�� vector&lt;string&gt; tokens; string now = &quot;&quot;; for (int i = 0; s[i]; i++) &#123; if (s[i] == &#x27; &#x27; || s[i] == &#x27;\\t&#x27; || s[i] == &#x27;\\r&#x27; || s[i] == &#x27;\\n&#x27; || s[i] == &#x27;\\0&#x27;) &#123; if (now != &quot;&quot;) &#123; if (now == &quot;:&quot; &amp;&amp; tokens.back() == &quot;)&quot;) &#123; string tmpnow = &quot;&quot;; for (int j = i + 1; s[j]; j++) &#123; if (s[j] == &#x27; &#x27; || s[j] == &#x27;\\t&#x27; || s[j] == &#x27;\\r&#x27; || s[j] == &#x27;\\n&#x27; || s[j] == &#x27;\\0&#x27;) &#123; if (tmpnow == &quot;&#123;&quot;) &#123; now = &quot;&#123;&quot;; i = j - 1; break; &#125; tmpnow = &quot;&quot;; &#125; else tmpnow += s[j]; &#125; continue; &#125; if (now == &quot;const&quot;) &#123; now = &quot;&quot;; continue; &#125; if (now == &quot;//&quot;) &#123; for (int j = i; s[j]; j++) &#123; if (s[j] == &#x27;\\n&#x27;) &#123; i = j - 1; break; &#125; &#125; now = &quot;&quot;; continue; &#125; if (now == &quot;/*&quot;) &#123; int num = 1; string tmpnow = &quot;&quot;; for (int j = i + 1; s[j]; j++) &#123; if (s[j] == &#x27; &#x27; || s[j] == &#x27;\\t&#x27; || s[j] == &#x27;\\r&#x27; || s[j] == &#x27;\\n&#x27; || s[j] == &#x27;\\0&#x27;) &#123; if (tmpnow == &quot;/*&quot;) num++; if (tmpnow == &quot;*/&quot;) &#123; num--; if (num == 0) &#123; i = j - 1; break; &#125; &#125; tmpnow = &quot;&quot;; &#125; else tmpnow += s[j]; &#125; now = &quot;&quot;; continue; &#125; //cout &lt;&lt; now &lt;&lt; s[i]; tokens.push_back(now); now = &quot;&quot;; &#125; //else cout &lt;&lt; s[i]; &#125; else now += s[i]; &#125; int cnt = 0; string nowNamespace = &quot;&quot;; for (int i = 1; i &lt; (int)tokens.size(); i++) &#123; if ((tokens[i] == &quot;struct&quot; || tokens[i] == &quot;class&quot;) &amp;&amp; tokens[i + 2] == &quot;&#123;&quot;) &#123; cnt = 0; nowNamespace = tokens[i + 1]; i += 2; &#125; functions tmp(nowNamespace); if (tokens[i] == &quot;&#123;&quot; &amp;&amp; tokens[i - 1] == &quot;)&quot;) &#123; int num = 1; for (int j = i - 2; j &gt;= 0; j--) &#123; if (tokens[j] == &quot;)&quot;) num++; if (tokens[j] == &quot;(&quot;) &#123; num--; if (num == 0) &#123; tmp.name = tokens[j - 1]; tmp.outputType = &quot;&quot;; for (int k = j - 2; k &gt;= 0; k--) if (tokens[k] != &quot;&#125;&quot; &amp;&amp; tokens[k] != &quot;&#125;&quot; &amp;&amp; tokens[k] != &quot;;&quot; &amp;&amp; tokens[k].back() != &#x27;:&#x27; &amp;&amp; tokens[k] != &quot;inline&quot; &amp;&amp; tokens[k] != &quot;static&quot; &amp;&amp; tokens[k][0] != &#x27;#&#x27; &amp;&amp; tokens[k].back() != &#x27;\\&quot;&#x27; &amp;&amp; tokens[k].back() != &#x27;&gt;&#x27;) tmp.outputType = tmp.outputType == &quot;&quot; ? tokens[k] : tokens[k] + &quot; &quot; + tmp.outputType; else break; int last = i - 2; for (int k = i - 2; k &gt;= j; k--) &#123; if (tokens[k] == &quot;(&quot; || tokens[k] == &quot;,&quot;) &#123; string tt = &quot;&quot;; for (int t = k + 1; t &lt; last; t++) tt = tt == &quot;&quot; ? tokens[t] : tt + &quot; &quot; + tokens[t]; if (tt != &quot;&quot;) tmp.inputType.push_back(tt); last = k - 1; &#125; if (tokens[k] == &quot;=&quot; || tokens[k] == &quot;)&quot;) last = k - 1; &#125; reverse(tmp.inputType.begin(), tmp.inputType.end()); break; &#125; &#125; &#125; funs.push_back(tmp); num = 1; for (int j = i + 1; j &lt; (int)tokens.size(); j++) &#123; if (tokens[j] == &quot;&#123;&quot;) num++; if (tokens[j] == &quot;&#125;&quot;) &#123; num--; if (num == 0) &#123; i = j; //cout &lt;&lt; tmp.outputType &lt;&lt; &quot; &quot; &lt;&lt; tmp.name &lt;&lt; &quot; &quot;; //cout &lt;&lt; j &lt;&lt; endl; break; &#125; &#125; &#125; continue; &#125; if (nowNamespace != &quot;&quot;) &#123; //cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; nowNamespace &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; endl; if (tokens[i] == &quot;&#123;&quot;) cnt++; if (tokens[i] == &quot;&#125;&quot;) &#123; cnt--; if (!cnt) nowNamespace = &quot;&quot;; &#125; &#125; &#125;&#125;int main()&#123; char ch; while ((ch = getchar()) != EOF) source += ch; solve(source); for (auto &amp; i: funs) &#123; if (i.outputType != &quot;&quot;) cout &lt;&lt; i.outputType &lt;&lt; &quot; &quot;; if (i.inClass != &quot;&quot;) cout &lt;&lt; i.inClass &lt;&lt; &quot;::&quot;; cout &lt;&lt; i.name &lt;&lt; &quot;(&quot;; for (int j = 0; j &lt; (int)i.inputType.size(); j++) cout &lt;&lt; i.inputType[j] &lt;&lt; (j == (int)i.inputType.size() - 1 ? &quot;)&quot; : &quot;,&quot;); if ((int)i.inputType.size() == 0) cout &lt;&lt; &quot;)&quot;; cout &lt;&lt; endl; &#125; return 0;&#125; D-牛牛和牛妹的约会 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283正确解法：#include&lt;bits/stdc++.h&gt;#define ll long long#define lowbit(x) ((x)&amp;(-(x)))#define mid ((l+r)&gt;&gt;1)#define lson rt&lt;&lt;1, l, mid#define rson rt&lt;&lt;1|1, mid+1, rusing namespace std;const double eps = 1e-8;int main()&#123; int T; cin&gt;&gt;T; while(T--)&#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); double ans = 0; double ca = a, cb = b; double p = 1.0/3.0; while(1)&#123; double na;//只需要判断a是否大于0即可 if(ca &lt; 0) na = -pow(-ca,p); else na = pow(ca, p); if(abs(na-cb)+1.0 &lt; abs(ca-cb)) ans += 1.0, ca = na; else &#123; ans += abs(ca-cb); break; &#125; &#125; printf(&quot;%.9f\\n&quot;, ans); &#125;&#125;自己的超时解法：讨论了b和a的大小关系，其实没必要讨论关于b的，因为pow每次只有a参与运算，讨论b的大小没意义 #include&lt;bits/stdc++.h&gt;using namespace std; int t;double a,b; int main() &#123; cin&gt;&gt;t; while(t--)&#123; double ans=0; cin&gt;&gt;a&gt;&gt;b; if(b&lt;0)&#123; if(a&gt;b)&#123; if(a&lt;=0)&#123;//b a 0 ans=a-b; &#125;else &#123;//b 0 a while(a-pow(a,1.0/3.0)&gt;=1)&#123; ans+=1; a=pow(a,1.0/3.0); &#125; //cout&lt;&lt;&quot;ceshi 3 -1 ans:&quot;&lt;&lt;ans&lt;&lt;endl; ans=ans+a-b; &#125; &#125;else &#123;//a b 0 while(((-pow(-a,1.0/3.0))-a&gt;=1)&amp;&amp;(-pow(-a,1.0/3.0))&lt;=b)&#123; ans+=1; a=-pow(-a,1.0/3.0); &#125; ans=ans+b-a; &#125; &#125;else &#123; if(a&gt;b)&#123;//0 b a while(a-pow(a,1.0/3.0)&gt;=1&amp;&amp;pow(a,1.0/3.0)&gt;=b)&#123; ans+=1; a=pow(a,1.0/3.0); &#125; ans=ans+a-b; &#125;else &#123;//0 a b if(a&gt;=0)ans=b-a; else &#123;//a 0 b while((-pow(-a,1.0/3.0))-a&gt;=1)&#123; ans+=1; a=-pow(-a,1.0/3.0); &#125; ans=ans+b-a; &#125; &#125; &#125; printf(&quot;%.9lf\\n&quot;,ans); &#125; &#125; tips pow函数的注意点： 1234int a=-9;int b=9;int p=1.0/3.0;cout&lt;&lt;pow(a,p)&lt;&lt;&#x27; &#x27;&lt;&lt;pow(-a,p)&lt;&lt;&#x27; &#x27;&lt;&lt;pow(b,p)&lt;&lt;endl;结果为：1 1 1 ；所以用此种方法求根下运算的时候底数部分看为正数返回值：x不能为负数且y为小数，或者x为0且y小于等于0，返回幂指数的结果； E-nim游戏找规律可以发现，当张数是 2^n 的时候输出Alice，否则输出Bob 12345678910111213141516171819202122 #include &lt;bits/stdc++.h&gt;using namespace std; int main()&#123; long long n; scanf(&quot;%lld&quot;, &amp;n); long long tmp = 2; for (int i = 1; i &lt;= 60; i++) &#123; if (tmp == n) &#123; printf(&quot;Alice\\n&quot;); return 0; &#125; tmp = tmp * 2; &#125; printf(&quot;Bob\\n&quot;); return 0;&#125; H-hash 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt; using namespace std; const int LEN = 6;int mod; char str[15]; int main()&#123;#ifndef ONLINE_JUDGE freopen(&quot;hash.in&quot;, &quot;r&quot;, stdin); freopen(&quot;hash.out&quot;, &quot;w&quot;, stdout);#endif while (scanf(&quot;%s%d&quot;, str, &amp;mod) != EOF) &#123; long long res = 0; for (int i = 0; i &lt; LEN; i++) &#123; res = res * 26 + str[i] - &#x27;a&#x27;; &#125; res += mod; for (int i = LEN - 1; i &gt;= 0; i--) &#123; str[i] = res % 26 + &#x27;a&#x27;; res /= 26; &#125; if (res) &#123; puts(&quot;-1&quot;); &#125; else &#123; printf(&quot;%s\\n&quot;, str); &#125; &#125; return 0;&#125; I-排名次 判断是否为签到题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;bool is=false ;//is为是否是签到题int n,m;struct a&#123; int num;//num表示存储的下标 double grade;//grade代表做出来的人数&#125;b[20];bool cmp(a x,a x1)&#123;//重载算子，按grade从大到小排列 if(x.grade==x1.grade) return x.num&lt;x.num; return x.grade&gt;x1.grade;&#125;double tmpe;int cnt=0;double tmp=-1;//cnt记录排名的位置，tmp中间变量int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)&#123;//下标从0开始录入 cin&gt;&gt;b[i].grade; b[i].num=i; if(i==8)&#123;//如果i题的人数大于总人数的0.8，则记录is为yes if(b[i].grade &gt;=m*0.8)is=true; tmpe=b[i].grade; &#125; &#125; sort(b,b+n,cmp); if(tmpe==b[0].grade||tmpe==b[1].grade||tmpe==b[2].grade)is=true; if(is)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125;错误解法：#include&lt;bits/stdc++.h&gt;using namespace std;bool is=false ;//is为是否是签到题int n,m;struct a&#123; int num;//num表示存储的下标 double grade;//grade代表做出来的人数&#125;b[20];bool cmp(a x,a x1)&#123;//重载算子，按grade从大到小排列 if(x.grade==x1.grade) return x.num&lt;x.num; return x.grade&gt;x1.grade;&#125;double tmpe;int cnt=0;double tmp=-1;//cnt记录排名的位置，tmp中间变量int main() &#123; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)&#123;//下标从0开始录入 cin&gt;&gt;b[i].grade; b[i].num=i; if(i==8)&#123;//如果i题的人数大于总人数的0.8，则记录is为yes if(b[i].grade &gt;=m*0.8)is=true; tmpe=b[i].grade; &#125; &#125; sort(b,b+n,cmp); //for(int i=0;i&lt;n;i++)cout&lt;&lt;b[i].grade; for(int i=0;i&lt;3;i++)&#123;//排序之后找i题是否排在前三 if(i&gt;2)&#123; if(b[i].grade!=tmp)cnt++;//如果本题和前面的题做出来的人数不相等，则cnt++，代表第几cnt名 //tmp=b[i].grade;//tmp重新赋值 &#125;else&#123; cnt++;//这地方也是不对的，万一序号为8的人数排在第一名里面呐 tmp=b[i].grade; &#125; if(cnt&gt;3)break;//如果到了第四名还没找到i题，则跳出循环 if(b[i].num==8)is=true;//如果在前三中找到i题，则记录is &#125; if(is)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; tips：就是120 120 110 109.。。这样的话，110是排第三名的为了让56同学排出来56个人，所以他们同分的并列一个名次，但是后面从第三名开始计算 J圆的内接正多边形 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std; #define PI 3.1415926int n;double r;double dushu=360; int a,b;int main() &#123; cin&gt;&gt;n;cin&gt;&gt;r; double af=dushu/n; af/=2;//af为正多边形对的圆心角的一半 double bian;//求出正多边形的一边的长度 bian=r*sin(af*PI/180)*2; //sin函数要变为度数，而不是度数的值 cin&gt;&gt;a&gt;&gt;b; int num; num=min(abs(a-b),(n-max(a,b))+min(a,b));//找到两点之间的最小边数 printf(&quot;%.6lf&quot;,num*1.0*bian ) ; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"牛客","slug":"牛客","permalink":"https://zouyunkai.github.io/myblog/tags/%E7%89%9B%E5%AE%A2/"}],"author":"aoyuehan"},{"title":"新生训练12-牛客竞赛4","slug":"新生训练12-牛客竞赛4","date":"2020-02-12T12:04:12.000Z","updated":"2022-02-26T03:52:51.769Z","comments":true,"path":"2020/02/12/新生训练12-牛客竞赛4/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/12/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%8312-%E7%89%9B%E5%AE%A2%E7%AB%9E%E8%B5%9B4/","excerpt":"","text":"A-欧几里得算法 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;long long ans[90];//必须为long long类型才可以int main() &#123; long long tmp=2; long long tmp1=3; long long tmp2; ans[0]=1; ans[1]=3; int i=2; while(i&lt;=80) &#123; ans[i]=tmp+tmp1; tmp2=tmp1; tmp1=tmp1+tmp; tmp=tmp2; i++; &#125;//这地方的规律就是gcd的逆运算，余他最小的就是他俩相加然后余他 //例如：（1，1%1)余出来1，那么就应该（1+1,1） （3,2） （5,3）；其中 （5,3）的下一步就是 （3,5%3）=（3，2） int t; cin&gt;&gt;t; int n; while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); cout&lt;&lt;ans[n]&lt;&lt;endl; &#125; return 0;&#125; B-括号匹配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192用栈来模拟一下方法一：此种方法对于空串和)(是不行的#include&lt;bits/stdc++.h&gt;#include&lt;string.h&gt;using namespace std;//const int maxn=1e6+10;stack&lt;char&gt;st;string s; int main()&#123; cin&gt;&gt;s; char tmp; st.push( s[0] ); for(int i=1;i&lt;s.length();i++)&#123; if(s[i]==&#x27;[&#x27;)tmp=&#x27;]&#x27;; if(s[i]==&#x27;]&#x27;)tmp=&#x27;[&#x27;; if(s[i]==&#x27;(&#x27;)tmp=&#x27;)&#x27;; if(s[i]==&#x27;)&#x27;)tmp=&#x27;(&#x27;; if(s[i]==&#x27;&#123;&#x27;)tmp=&#x27;&#125;&#x27;; if(s[i]==&#x27;&#125;&#x27;)tmp=&#x27;&#123;&#x27;; if(st.empty())st.push( s[i] );//栈空时，一定是要push一个数 else &#123; if(st.top()== tmp &amp;&amp;!st.empty())st.pop(); else st.push( s[i] ); &#125; // cout&lt;&lt;&quot;st top:&quot;&lt;&lt;st.top()&lt;&lt;&quot;st len:&quot;&lt;&lt;st.size()&lt;&lt;endl; &#125; if(!st.empty())cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;&#125; 方法二：#include&lt;bits/stdc++.h&gt;#include&lt;string.h&gt;using namespace std;//const int maxn=1e6+10;stack&lt;char&gt;st;string s; int main()&#123; getline(cin,s); char tmp; int ok=1; for(int i=0;i&lt;s.length();i++)&#123; if(s[i]==&#x27;[&#x27;)tmp=&#x27; &#x27;; if(s[i]==&#x27;]&#x27;)tmp=&#x27;[&#x27;; if(s[i]==&#x27;(&#x27;)tmp=&#x27; &#x27;; if(s[i]==&#x27;)&#x27;)tmp=&#x27;(&#x27;; if(s[i]==&#x27;&#123;&#x27;)tmp=&#x27; &#x27;; if(s[i]==&#x27;&#125;&#x27;)tmp=&#x27;&#123;&#x27;; ok=0; if(st.empty())st.push( s[i] );//栈空时，一定是要push一个数 else &#123; if(st.top()== tmp )st.pop(); else st.push( s[i] ); &#125; // cout&lt;&lt;&quot;st top:&quot;&lt;&lt;st.top()&lt;&lt;&quot;st len:&quot;&lt;&lt;st.size()&lt;&lt;endl; &#125; if(!st.empty()&amp;&amp;ok==0)cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; &#125; 方法三：#include &lt;iostream&gt;#include &lt;cstring&gt; using namespace std; char str[1000020],stk[1000020];int n,st = 0;int main()&#123; cin&gt;&gt;str; n = strlen(str); int ok = 1; for(int i=0;i&lt;n;i++)&#123; if(str[i] == &#x27;(&#x27; || str[i] == &#x27;[&#x27; || str[i] == &#x27;&#123;&#x27;)&#123; stk[st] = str[i]; st++; &#125;else&#123; if(st == 0 || (str[i] == &#x27;)&#x27; &amp;&amp; stk[st-1]!=&#x27;(&#x27;) || (str[i] == &#x27;]&#x27; &amp;&amp; stk[st-1]!=&#x27;[&#x27;) || (str[i] == &#x27;&#125;&#x27; &amp;&amp; stk[st-1]!=&#x27;&#123;&#x27;))&#123; ok = 0; break; &#125; st--; &#125; &#125; if(st!=0)ok = 0; if(ok)&#123; cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125; C-子段乘积 方法一：用线段树来模拟，原来线段树不仅可以来维护区间和，还能维护区间乘积 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576方法一：管超龙的代码，长见识了#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;ctype.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;long long mod=998244353;struct data &#123; long long l,r,num;&#125;line[8000005];long long dis[2000005];long long n;void ff (long long x) //表示x跟他的孩子节点之间的关系。根据孩子节点来x节点的值&#123; line[x].num=(line[x*2].num*line[x*2+1].num)%mod;&#125;void bulid(long long l,long long r,long long x) //讲所给数据构建成一个完全二叉树的形式，&#123; line[x].l=l; line[x].r=r; if(l==r)&#123; //判断是否是叶子节点，如果是叶子节点，这对其进行赋值。 line[x].num=dis[r]%mod; return ; &#125; long long m=(l+r)/2;//因为m若等于l则m+1也必等于r bulid(l,m,x*2); //构建节点的左子树 bulid(m+1,r,x*2+1); //构建节点的右子树 且改变l值将各个数组的值分别加入树，是分段最关键的步骤 ff(x); //通过构建完成的左子树和右子树的值来对x节点的值进行更新&#125;int query (long long l,long long r,long long x) //用来执行查询的函数&#123; if(l&lt;=line[x].l&amp;&amp;line[x].r&lt;=r)&#123;//如果查询的区间包含了x节点的区间，这返回x区间的最大值。 return line[x].num%mod; &#125; int m=(line[x].r+line[x].l)/2; if(r&lt;=m)&#123; //判断查询的区间在x节点区间的位置，这个判断是判断当查询区间在x节点左子树的时候 return query(l,r,x*2)%mod; &#125;else if(l&gt;m)&#123; //判断当查询的区间在x节点的右子树的时候 return query(l,r,x*2+1)%mod; &#125;else &#123; return ((query(l,m,x*2)%mod)*(query(m+1,r,x*2+1)%mod))%mod; //这个情况是当查询的区间即在x节点的左子树又在x节点的右子树的时候 &#125;&#125;void updata (int a,int b,int x)//用来执行更新的函数&#123; if(line[x].r==line[x].l&amp;&amp;line[x].r==a)&#123; //如果这个点是一个叶子节点，且这个节点是需要更新的节点的时候，对这个节点标记内容进行更新 line[x].num+=b;//只有叶子节点储存数值。 return ; &#125; int m=(line[x].r+line[x].l)/2; if(a&lt;=m)&#123; //判断需要更新的节点在x节点的那一部分 updata(a,b,x*2); &#125;else &#123; updata(a,b,x*2+1); &#125; ff(x); //这里是对已经对相应节点更新完毕时对其父亲节点进行更新&#125;int main ()&#123; long long n,k; cin&gt;&gt;n&gt;&gt;k; for(long long i=1;i&lt;=n;i++)&#123; scanf(&quot;%ld&quot;,&amp;dis[i]); &#125; bulid(1,n,1); long long m=0,sum; for(long long i=1;i&lt;=n-k+1;i++)&#123; sum=query(i,i+k-1,1)%mod; if(i==1)m=sum; if(sum&gt;m)m=sum; &#125; cout&lt;&lt;m&lt;&lt;endl; return 0;&#125; 思路：尺取法，l代表左端点，r代表右端点。l先不动，r往前扫描，如果成功扫到，有k个非0元素的子段就累乘起来，最后把最左端的元素除了，左端点往前移动，l++（此时要在sum上除，用到逆元），再继续扫描。再未达到k个非零元素的子段前，如果遇到0，当前的区间就废了 ,左端点直接到0的下一个位置。继续扫描。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455方法二：逆元+尺取法#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 998244353;const ll N = 200005;ll a[N];ll Max = 0;//记录最终结果ll sum = 1;ll Qpow(ll x,ll k)//快速幂求逆元&#123; ll ans = 1; while(k) &#123; if(k%2!=0) ans = ans*x%mod; k=k&gt;&gt;1; x=x*x%mod; &#125; return ans;&#125;int main()&#123; ll n,k; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; ll l = 1; //尺取法 ll r = 1; while(r&lt;=n) &#123; if(a[r]) //不是0就累乘直到达到k段子段 &#123; sum=(sum*a[r])%mod;//sum是每一次扫描成功的值 if((r-l+1)%k==0) //达到k子段 &#123; if(sum&gt;Max) Max = sum;//题上要求取最大的 sum = sum*Qpow(a[l],mod-2)%mod;//逆元 ，原本是sum=sum/a[l] 。 //一次扫描成功后，就吧最左端的元素除掉，再继续扫描。当然不能直接除 ， l++; &#125; &#125; else //再未达到k个非零元素的子段前，如果遇到0，当前的区间就废了 &#123; l = r + 1;// 左端点直接到0的下一个位置 sum = 1;//sum归1 &#125; r++; &#125; cout&lt;&lt;Max&lt;&lt;endl; return 0;&#125; D 最大异或和—不大懂 异或有两个很重要的性质：1、 A^A &#x3D; 0;2、 A^0 &#x3D; A; 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;#define ll long longusing namespace std;const int maxn = 2e5 + 5;std::map&lt;ll, ll&gt; mp;ll a[maxn],b[maxn];int main()&#123; int n; cin &gt;&gt; n; ll ans = 0; for(int i = 1; i &lt;= n; i++)&#123; cin &gt;&gt; a[i]; b[i] = a[i] ^ b[i - 1]; if(b[i] == 0)ans++; ans += mp[b[i]]; mp[b[i]]++; cout &lt;&lt; ans &lt;&lt; endl; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; E 最小表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118方法一：#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; int cnt[20];int sum[500050]; char s[500050];int main() &#123; cin&gt;&gt;s; int ccnt = 1;//ccnt就是+的个数加一 int n = strlen(s); for(int i=0;i&lt;n;i++)&#123; if(isdigit(s[i]))&#123; cnt[s[i]-&#x27;0&#x27;]+=1;//统计不同数字的个数 &#125;else&#123; ccnt+=1;//统计+的个数 &#125; &#125; int p = 0,cp = 0; for(int i=10;i&gt;=1;i--)&#123;//就是把这些单个的数字分配成ccnt个数 while(cnt[i])&#123;//先分配个位，十分位，在分配百分位 sum[cp]+=i;//把十进制的数都加在一起 cnt[i]-=1;//这一种数的个数-- p = (p+1)%ccnt; if(p == 0)cp+=1;//分配下一个位制 &#125; &#125; for(int i=0;i&lt;500010;i++)&#123; sum[i+1]+=sum[i]/10; sum[i]%=10; //因为sum数组存放的是某一个进制下所有数的和，所以通过本位加上低一位 //的数/10，低一位数%10的方式来累加所有数的和 &#125; int opt = 0;//找到有数字的那个位置，然后从后往前输出 for(int i=500010;i&gt;=0;i--)&#123; if(opt || sum[i])&#123;//若果本位有数子的话就输出，一直到0 cout&lt;&lt;sum[i]; opt = 1; &#125; &#125; cout&lt;&lt;endl; return 0;&#125;方法二：把所有的数字从小到大排列，然后分配到每个v数组中，其中每个v数组就代表每个要相加的数，然后把这些结果相加起来就可以了，但是运算量太大，超时了#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=5*1e5+10;//用不完vector&lt;int&gt;v[maxn];typedef long long ll;vector&lt;int&gt;v1;char s[maxn];//vector的内容转成相应的数字，后来一想若数字太大了，会溢出 //ll ans=0;//ll vtoi(int i)&#123;// ll tmp=0;int base=pow(10,(v[i].size()-1)); // for(vector&lt;int&gt;::iterator it=v[i].begin();it!=v[i].end();it++)&#123;// tmp=tmp+(*it)*base;// base/=10;// &#125;// return tmp;//&#125;int dashu[maxn];int dashulen=0; int dashulen1=0;int dashulen2=0;void add(int k)&#123;//将v[k]的数（长度为dashulen1）和dashu数组中的数（长度为dashulen）相加，结果保存在dashu数组中 int carry=0;//carry是进位 dashulen2=0;//用来计算相加之后结果的位数 for(int i=0;i&lt;dashulen||i&lt;dashulen1;i++)&#123; int tmp=dashu[i]+v[k][dashulen1-i-1]+carry; dashu[dashulen2++]=tmp%10; carry=tmp/10; &#125; if(carry!=0)&#123; dashu[dashulen2++]=carry; &#125; dashulen=dashulen2;//将dashulen2的长度赋给dashulen &#125;int main() &#123; cin&gt;&gt;s; int jiahao=0;//统计+的个数 int tmp; for(int i=0; i&lt;strlen(s); i++) &#123; if(s[i]==&#x27;+&#x27;)jiahao++; else v1.push_back(s[i]-&#x27;0&#x27;); &#125; sort(v1.begin(),v1.end());//将所有数字从小到大排序 int num=strlen(s)-jiahao; int shu=jiahao+1;//shu的个数就是+数量加一 //cout&lt;&lt;&quot; jiahoa :&quot;&lt;&lt;jiahao&lt;&lt;endl&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl; for(vector&lt;int&gt;::iterator it=v1.begin();it!=v1.end();)&#123;//将v1中存放的所有数按顺序放到v这个数组中 for(int j=shu-1; j&gt;=0 &amp;&amp;it!=v1.end(); j--) &#123; tmp=*it; v[j].push_back(tmp); it++;//注意这地方不能填一个删一个，要走一遍就好 &#125; &#125; dashulen=v[0].size();//初始化dashu这个数就是v[0]中代表的数 int lenxiabiao=dashulen-1; for(vector&lt;int&gt;::iterator itt=v[0].begin();itt!=v[0].end();itt++)&#123; dashu[lenxiabiao]=*itt; lenxiabiao--; &#125; for(int i=1;i&lt;shu;i++)&#123; dashulen1=v[i].size(); add(i);//遍历v剩下 数组中的数，把他和dashu相加 &#125; for(int i=dashulen-1;i&gt;=0;i--)&#123;//输出dashu中的结果 cout&lt;&lt;dashu[i]; &#125; cout&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"牛客","slug":"牛客","permalink":"https://zouyunkai.github.io/myblog/tags/%E7%89%9B%E5%AE%A2/"}],"author":"aoyuehan"},{"title":"新生训练11-牛客竞赛3","slug":"新生训练11-牛客竞赛3","date":"2020-02-10T10:30:47.000Z","updated":"2022-02-26T03:52:51.265Z","comments":true,"path":"2020/02/10/新生训练11-牛客竞赛3/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/10/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%8311-%E7%89%9B%E5%AE%A2%E7%AB%9E%E8%B5%9B3/","excerpt":"","text":"A 牛牛的DRB迷宫I -记忆化搜索 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136方法一：递归式#include&lt;bits/stdc++.h&gt;using namespace std;int const maxn=55;int const mod=1e9+7;char a[maxn][maxn];long long vis[maxn][maxn];//用来存递归之后的值 int n,m; //自己写的就是不行，返回值不对，写check的时候条件不对，应该大于n，大于m的时候返回0 //void dfs(int x,int y)&#123;// if(x&gt;n||y&gt;m)&#123;// //vis[x][y]=1; // return 0;// &#125;// if(a[x][y]==&#x27;D&#x27;&amp;&amp;(x+1)&lt;=n&amp;&amp;vis[x+1][y]==0)&#123;// dfs(x+1,y);vis[x][y]+=vis[x+1][y];vis[x][y]%mod;// &#125;else if(a[x][y]==&#x27;D&#x27;&amp;&amp;(x+1)&lt;=n&amp;&amp;vis[x+1][y]!=0)&#123;// vis[x][y]+=vis[x+1][y];vis[x][y]%mod;// &#125;// if(a[x][y]==&#x27;R&#x27;&amp;&amp;(y+1)&lt;=m&amp;&amp;vis[x][y+1]==0)&#123;// dfs(x,y+1);vis[x][y]+=vis[x][y+1];vis[x][y]%mod;// &#125;else if(a[x][y]==&#x27;R&#x27;&amp;&amp;(y+1)&lt;=m&amp;&amp;vis[x][y+1]!=0)&#123;// vis[x][y]+=vis[x][y+1];vis[x][y]%mod;// &#125;// // if(a[x][y]==&#x27;B&#x27;)&#123;// if((x+1)&lt;=n&amp;&amp;vis[x+1][y]==0)&#123;// dfs(x+1,y);vis[x][y]+=vis[x+1][y];vis[x][y]%mod;// &#125;// else if((x+1)&lt;=n&amp;&amp;vis[x+1][y]!=0) &#123;// vis[x][y]+=vis[x+1][y];vis[x][y]%mod;// &#125;// if((y+1)&lt;=m&amp;&amp;vis[x][y+1]==0)&#123;// dfs(x,y+1);vis[x][y]+=vis[x][y+1];vis[x][y]%mod;// &#125;// else if((y+1)&lt;=m&amp;&amp;vis[x][y+1]!=0)&#123;// vis[x][y]+=vis[x][y+1];vis[x][y]%mod;// &#125;// &#125;//&#125;long long dfs(int x,int y)&#123;//记忆性递归都是有返回值的，超出范围返回0 if(x&gt;n||y&gt;m)&#123;// 不能写为x==n||y==m，这样的话是不对的 return 0; &#125; if(vis[x][y]!=-1)return vis[x][y];//递归之前先查，没有的话在进行递归 if(a[x][y]==&#x27;D&#x27; )&#123; return vis[x][y]= dfs(x+1,y); &#125; if(a[x][y]==&#x27;R&#x27; )&#123; return vis[x][y] =dfs(x,y+1);//右边dfs走的路径的种数就是本vis的值 &#125; if(a[x][y]==&#x27;B&#x27; )&#123; return vis[x][y]=(dfs(x+1,y)+dfs(x,y+1))%mod;//这地方要取模才可以，防止相加的时候溢出 &#125;&#125;int main()&#123; memset(vis,-1,sizeof(vis)); scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(&quot;%s&quot;,a[i]+1); vis[n][m]=1; printf(&quot;%lld\\n&quot;,dfs(1,1)); // for(int i=1;i&lt;=n;i++)&#123;// for(int j=1;j&lt;=m;j++)cout&lt;&lt;a[i][j]&lt;&lt;&#x27; &#x27;;cout&lt;&lt;endl;// &#125;&#125;方法二：递归式简便写法：#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=55;const long long mod=1e9+7;int n,m;char s[MAXN][MAXN];long long dp[MAXN][MAXN];long long dp_dfs(int x,int y)&#123; if(x&gt;n||y&gt;m)return 0;//x&gt;n,y&gt;m时返回0，因为没有在右下角返回的地方返回, if(dp[x][y]!=-1)return dp[x][y]; if(s[x][y]==&#x27;D&#x27;)return dp[x][y]=dp_dfs(x+1,y); if(s[x][y]==&#x27;R&#x27;)return dp[x][y]=dp_dfs(x,y+1); if(s[x][y]==&#x27;B&#x27;)return dp[x][y]=(dp_dfs(x+1,y)+dp_dfs(x,y+1))%mod;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); memset(dp,-1,sizeof(dp)); dp[n][m]=1; for(int i=1;i&lt;=n;++i) &#123; scanf(&quot;%s&quot;,s[i]+1); &#125; printf(&quot;%lld\\n&quot;,dp_dfs(1,1)); return 0;&#125;方法三：递推式的写法，棋盘dp#include &lt;bits/stdc++.h&gt;using namespace std;const long long mod=1e9+7;const int MAXN=55;long long dp[MAXN][MAXN];char mp[MAXN][MAXN];int n,m;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) &#123; scanf(&quot;%s&quot;,mp[i]+1); &#125; dp[1][1]=1; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=m;++j) &#123; if(mp[i][j]==&#x27;D&#x27;) &#123; dp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod; &#125; if(mp[i][j]==&#x27;R&#x27;) &#123; dp[i][j+1]=(dp[i][j+1]+dp[i][j])%mod; &#125; if(mp[i][j]==&#x27;B&#x27;) &#123; dp[i+1][j]=(dp[i+1][j]+dp[i][j])%mod; dp[i][j+1]=(dp[i][j+1]+dp[i][j])%mod; &#125; &#125; &#125; printf(&quot;%lld\\n&quot;,dp[n][m]); return 0;&#125; B1 C 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127标程：#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1000005;int maxsize,n,m,a[MAXN],T,x,y,val,p;int hash1(int x,int y)&#123; if(x*m+y&gt;=maxsize||x*m+y&lt;0)return -1; return x*m+y;&#125;bool flag1,flag2;int main()&#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; flag1=true;//定义两个flag分别记录Runtime error和Undefined Behaviour就可以避免我自 //己做的那种有可能现在已经是运行时错误了，后来改变成了UB flag2=true; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;p); maxsize=n*m; for(int i=0;i&lt;maxsize;++i)a[i]=0; while(p--) &#123; scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;val); if(x&gt;=n||y&gt;=m||x&lt;0||y&lt;0) &#123; flag2=false; &#125; int pos=hash1(x,y); if(~pos) //-1取反是0，而1的反码是-2 &#123; a[pos]=val; &#125; else &#123; flag1=false; &#125; &#125; if(flag1) &#123; for(int i=0;i&lt;n;++i) &#123; for(int j=0;j&lt;m;++j) &#123; printf(&quot;%d%c&quot;,a[hash1(i,j)],j==m-1?&#x27;\\n&#x27;:&#x27; &#x27;); &#125; &#125; if(flag2) &#123; printf(&quot;Accepted\\n&quot;); &#125; else &#123; printf(&quot;Undefined Behaviour\\n&quot;); &#125; &#125; else &#123; printf(&quot;Runtime error\\n&quot;); &#125; &#125; return 0;&#125;方法二：自己的模拟方法#include&lt;iostream&gt;using namespace std;const int maxn=1020;int a[maxn][maxn];int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; int n,m,p,sumnum,val,x,y,tmp,x1,y1; int flag=0;//一个flag来计算的时候要避免flag=3时变为了flag=2 cin&gt;&gt;n&gt;&gt;m&gt;&gt;p; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; a[i][j]=0; &#125; &#125; sumnum=n*m; for(int k=0;k&lt;p;k++)&#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;val; if((m*x+y)&lt;0||(m*x+y+1)&gt;sumnum)&#123; flag=3;continue; //而且这地方不能是break，因为还要输入完所有的数据之后才能进行下一组数据 &#125; if(x&lt;0||(x+1)&gt;n||y&lt;0||(y+1)&gt;m)&#123; if(flag=0)flag=2;//一定要注意这个地方 tmp=x*m+y; x1=(int)tmp/m; y1=tmp%m; a[x1][y1]=val; &#125;else &#123; a[x][y]=val; &#125; &#125; if(flag==3)&#123; cout&lt;&lt;&quot;Runtime error&quot;&lt;&lt;endl; &#125;else if(flag==0)&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(j==m-1)&#123; printf(&quot;%d&quot;,a[i][j]); &#125;else&#123; printf(&quot;%d &quot;,a[i][j]); &#125; &#125; printf(&quot;\\n&quot;); &#125; cout&lt;&lt;&quot;Accepted&quot;&lt;&lt;endl; &#125;else if(flag==2)&#123; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(j==m-1)&#123; printf(&quot;%d&quot;,a[i][j]); &#125;else&#123; printf(&quot;%d &quot;,a[i][j]); &#125; &#125; printf(&quot;\\n&quot;); &#125; cout&lt;&lt;&quot;Undefined Behaviour&quot;&lt;&lt;endl; &#125; &#125;&#125; tips：取反操作：我们都知道取反操作是将二进制0和1互换，但是计算时容易出错，这是由于计算机中数值是以二进制补码形式存储的。补码：正数的补码和原码相同；负数的补码为符号位不变，剩余位取反再加1.一定要时刻记住补码的表现形式。eg1：int a &#x3D; 77;cout&lt;&lt;a&lt;&lt;endl;答：77的原码为01001101，在计算机中存储形式（补码）为01001101，77运行以后得到二进制10110010，这是补码存储形式，其原码为1101110，所以输出为-78eg2：int a &#x3D; -2;cout&lt;&lt;a&lt;&lt;endl;答：**-2的原码为10000010，在计算机中存储形式为11111110，取反以后得到00000001，这是正数的补码，其原码为其本身，所以输出为1.（通过原码的补码得到取反后的补码，然后通过补码得到原码，这就是结果） **其他二进制逻辑操作（&amp;，|，^等）原理相同。 D 因为节点的顺序是从节点的值1 2 3 4 的顺序输出的，所以通过一个map来记录一个节点的值存放的在数组中位置 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#include &lt;map&gt;using namespace std;int a[100005];int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; map&lt;int,int&gt;m; int cnt=0; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); if(a[i]&gt;0) &#123; cnt++; m[a[i]]=i; &#125; &#125; printf(&quot;The size of the tree is %d\\n&quot;,cnt); printf(&quot;Node %d is the root node of the tree\\n&quot;,a[1]); for(int i=1;i&lt;=cnt;i++) &#123; printf(&quot;The father of node %d is %d,&quot;,i,m[i]/2==0?-1:a[m[i]/2]); printf(&quot; the left child is %d, and the right child is %d\\n&quot;,m[i]*2&gt;n?-1:a[m[i]*2],m[i]*2+1&gt;n?-1:a[m[i]*2+1]); &#125; &#125;&#125; E1 F 前缀和，差分方法一：直接算 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=100005;const long long mod=1e9+7;char s[MAXN];int n;long long sum,cnt,ans;int main()&#123; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1); for(int i=1;i&lt;=n;++i) &#123; sum=(sum+cnt)%mod; if(s[i]==&#x27;1&#x27;) &#123;//每遇到一个1的时候就把每个点的贡献加到ans里面 ans=(ans+sum)%mod; ++cnt; &#125; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; 方法二：静态维护区间加多项式的求和问题 静态维护区间加等差数列的求和问题 就我们发现每个“1”对于它本身位置产生的影 响贡献为0，而往后面依次产生了0,1,2,3,4,5…的贡献。然后你可以利用静态维护区间加等差数列的技巧对于每个位置的1”，假设它的位置为pos，那么直接对a[pos+1]加上1的贡献。全部做完以后，做两次前缀和操作，对于每个位置的“1”直接查询数组中的值加起来即可。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=100005;const long long mod=1e9+7;char s[MAXN];int n;long long ans,sum[MAXN];void pre_sum()&#123; for(int i=1;s[i];++i) &#123; sum[i]+=sum[i-1]; if(sum[i]&gt;=mod)sum[i]-=mod; &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s); for(int i=0;s[i];++i) &#123; if(s[i]==&#x27;1&#x27;) &#123; sum[i+1]++; //本来的数组是0 1 2 3...因为求两次差分之后的结果就是在串1的后面的那个值加上1 &#125; &#125; pre_sum();//求两次前缀和操作，得到每项加上相应的多项式的值 pre_sum(); for(int i=1;s[i];++i) &#123; if(s[i]==&#x27;1&#x27;) &#123; ans+=sum[i]; if(ans&gt;=mod)ans-=mod; &#125; &#125; printf(&quot;%lld\\n&quot;,ans); return 0;&#125; G F题的变形 方法一：树状数组维护前缀和的前缀和 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=100005;const long long mod=1e9+7;char s[MAXN];int n,m,x,q;long long ans;struct BIT&#123; long long bit[MAXN]; int lowbit(int x) &#123; return x&amp;-x; &#125; long long sum(int x) &#123; long long ret=0; while(x) &#123; ret=ret+bit[x]; if(ret&gt;=mod)ret-=mod; x-=lowbit(x); &#125; return ret; &#125; void add(int x,long long val) &#123; while(x&lt;=n) &#123; bit[x]+=val; if(bit[x]&gt;=mod)bit[x]-=mod; x+=lowbit(x); &#125; &#125;&#125;pre,jpre,suf,jsuf;int main()&#123; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1); for(int i=1;i&lt;=n;++i) &#123; if(s[i]==&#x27;1&#x27;) &#123; ans=((ans+(i+1)*pre.sum(i)%mod-jpre.sum(i))%mod+mod)%mod; if(i!=n) &#123; pre.add(i+1,1); jpre.add(i+1,i+1); &#125; if(i!=1) &#123; suf.add(n-i+2,1); jsuf.add(n-i+2,n-i+2); &#125; &#125; &#125; printf(&quot;%lld\\n&quot;,ans); scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;++i) &#123; scanf(&quot;%d %d&quot;,&amp;q,&amp;x); long long pres=(x+1)*pre.sum(x)%mod-jpre.sum(x); long long sufs=(n-x+2)*suf.sum(n-x+1)%mod-jsuf.sum(n-x+1); if(q==1) &#123; ans=((ans+pres+sufs)%mod+mod)%mod; if(x!=n) &#123; pre.add(x+1,1); jpre.add(x+1,x+1); &#125; if(x!=1) &#123; suf.add(n-x+2,1); jsuf.add(n-x+2,n-x+2); &#125; &#125; else &#123; ans=((ans-pres-sufs)%mod+mod)%mod; if(x!=n) &#123; pre.add(x+1,-1); jpre.add(x+1,-(x+1)); &#125; if(x!=1) &#123; suf.add(n-x+2,-1); jsuf.add(n-x+2,-(n-x+2)); &#125; &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125; 方法二：线段树维护前缀和的前缀和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=100005;const long long mod=1e9+7;char s[MAXN];int n,m,x,q;long long ans;struct tnode&#123; long long sum,lazy; int l,r;&#125;;struct Segment_Tree&#123; tnode t[4*MAXN]; void pushdown(int root) &#123; if(t[root].lazy!=0) &#123; t[root].sum+=t[root].lazy*(t[root].r-t[root].l+1); if(t[root].l!=t[root].r) &#123; int ch=root&lt;&lt;1; t[ch].lazy+=t[root].lazy; t[ch+1].lazy+=t[root].lazy; &#125; t[root].lazy=0; &#125; &#125; void update (int root) &#123; int ch=root&lt;&lt;1; pushdown(ch); pushdown(ch+1); t[root].sum=t[ch].sum+t[ch+1].sum; &#125; void build(int l,int r,int root=1) &#123; t[root].l=l; t[root].r=r; if(l!=r) &#123; int mid=(l+r)&gt;&gt;1; int ch=root&lt;&lt;1; build(l,mid,ch); build(mid+1,r,ch+1); update(root); &#125; else t[root].sum=0; &#125; void change(int l,int r,long long delta,int root=1) &#123; if(l==t[root].l&amp;&amp;r==t[root].r) &#123; t[root].lazy+=delta; pushdown(root); return; &#125; int mid=(t[root].l+t[root].r)&gt;&gt;1; int ch=root&lt;&lt;1; if(r&lt;=mid)change(l,r,delta,ch); else if(l&gt;mid)change(l,r,delta,ch+1); else &#123;change(l,mid,delta,ch);change(mid+1,r,delta,ch+1);&#125; update(root); &#125; long long sum(int l,int r,int root=1) &#123; pushdown(root); if(t[root].l==l&amp;&amp;t[root].r==r) &#123; return t[root].sum; &#125; int mid=(t[root].l+t[root].r)&gt;&gt;1; int ch=root&lt;&lt;1; if(r&lt;=mid)return sum(l,r,ch); else if(l&gt;mid)return sum(l,r,ch+1); else return sum(l,mid,ch)+sum(mid+1,r,ch+1); &#125;&#125;;Segment_Tree pre,suf;int main()&#123; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1); pre.build(1,n); suf.build(1,n); for(int i=1;i&lt;=n;++i) &#123; if(s[i]==&#x27;1&#x27;) &#123; ans=(ans+pre.sum(1,i))%mod; if(i!=n)pre.change(i+1,n,1); if(i!=1)suf.change(1,i-1,1); &#125; &#125; printf(&quot;%lld\\n&quot;,ans); scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;++i) &#123; scanf(&quot;%d %d&quot;,&amp;q,&amp;x); long long pres=pre.sum(1,x); long long sufs=suf.sum(x,n); if(q==1) &#123; ans=(ans+pres+sufs)%mod; if(x!=n)pre.change(x+1,n,1); if(x!=1)suf.change(1,x-1,1); &#125; else &#123; ans=((ans-pres-sufs)%mod+mod)%mod; if(x!=n)pre.change(x+1,n,-1); if(x!=1)suf.change(1,x-1,-1); &#125; printf(&quot;%lld\\n&quot;,ans); &#125; return 0;&#125; H k合因子数 埃式筛筛出质数，然后对于合数再筛一遍，然后统计每个数字被筛到的次数。桶排序一下即可。O(nlog2n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113方法一：#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN=100005;int f[MAXN],cnt[MAXN],n,m,x;bool prim[MAXN];void init(int n)&#123; for(int i=2;i&lt;=n;++i) &#123; prim[i]=true; &#125; for(int i=2;i&lt;=n;++i) &#123; if(prim[i]) &#123; for(int j=i+i;j&lt;=n;j+=i) &#123; prim[j]=false; &#125; &#125; else &#123; for(int j=i;j&lt;=n;j+=i) &#123; cnt[j]++;//因为此时j为合数，那么因子为合数的那个计数++ &#125; &#125; f[cnt[i]]++; //就是从n到2来倒着来筛选，从i=2 3 4，到4的时候可以把合数因子有4的那个次数++ //在每一次i遍历结束的时候，把出现cnt[i]的那个次数++ &#125;&#125;int main()&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); init(n); while(m--) &#123; scanf(&quot;%d&quot;,&amp;x); printf(&quot;%d\\n&quot;,f[x]); &#125;&#125;方法二：本来打算超出1~n所有数的质因子的个数，然后枚举k合因子数的个数，发现很难实现，因为有时候如2 2 3 5 5，这样找到他的那个所有的种类数很难。#include&lt;math.h&gt;#include&lt;iostream&gt;using namespace std;//typedef long long ll;int const maxn=1e5+10;int Punm=66;int k[maxn]=&#123;0&#125;;int prime[68]= &#123;2,3,5,7,11,13,17,19,23, 29,31,37,41,43,47,53,59,61,67,71,73,79, 83,89,97,101,103,107,109,113,127,131, 137,139,149,151,157,163,167,173,179,181, 191,193,197,199,211,223,227,229,233,239, 241,251,257,263,269,271,277,281,283,293,307,311,313,317 &#125;;//65个int C(int n,int m)&#123; int ans=1; for(int i=1;i&lt;=m;i++)&#123; ans=ans*(n-m+i)/i;//注意一定要先乘后除 &#125; return ans; &#125; void fenjie(int n) &#123; int num=0;//质因子分解 int cnt=0; for(int i=0; i&lt;Punm&amp;&amp;prime[i]&lt;=sqrt(n); i++) &#123; if(n%prime[i]==0) &#123; while(n%prime[i]==0) &#123; //计算该因子的个数 cnt++; n/=prime[i]; &#125; num++;//不同的质因子的个数 &#125; if(n==1)break; &#125; if(n!=1) &#123; //如果无法被根号n以内的质因子除尽 //那么一定有一个大于根号n的质因子 cnt++; num++; &#125; if(num==1)&#123; k[cnt-1]++;//这样不对呀，在2 2 3 5 5这样，你就找不出他有多少个排列了 &#125;else &#123; k[C(cnt,num)]++; &#125; //return ;&#125;int main() &#123; int n,m,tmp; scanf(&quot;%d%d&quot;,&amp;n,&amp;m);int zhishu=0; while(n&gt;=prime[zhishu])&#123;zhishu++; &#125; for(int i=2;i&lt;=n;i++)&#123; fenjie(i); &#125; k[0]-=zhishu; for(int i=0;i&lt;m;i++)&#123; scanf(&quot;%d&quot;,&amp;tmp); printf(&quot;%d\\n&quot;,k[tmp]); &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"牛客","slug":"牛客","permalink":"https://zouyunkai.github.io/myblog/tags/%E7%89%9B%E5%AE%A2/"}],"author":"aoyuehan"},{"title":"新生训练10-牛客竞赛2","slug":"新生训练10-牛客竞赛2","date":"2020-02-06T10:38:27.000Z","updated":"2022-02-26T03:52:52.327Z","comments":true,"path":"2020/02/06/新生训练10-牛客竞赛2/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/06/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%8310-%E7%89%9B%E5%AE%A2%E7%AB%9E%E8%B5%9B2/","excerpt":"","text":"就是用最普普通通的逻辑来做题，比如说那个G题取余的问题，对要运算之前的数取余在进行运算，然后再相比，这就是按照最低等的规则去做的呀，为什么你想不到呀 A剪刀石头布 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; long long ans=0,a,b,c,x,y,z; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;x&gt;&gt;y&gt;&gt;z; ans+=min(a,y);//石头战胜剪刀，所以出石头能胜利的次数是两者中较小的 ans+=min(b,z); ans+=min(c,x); cout&lt;&lt;ans&lt;&lt;endl;&#125; B 排数字 616 1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123; int n,ans=0,num1=0,num6=0; string s; cin&gt;&gt;n; cin&gt;&gt;s; for(int i=0;i&lt;n;i++)&#123; if(s[i]-&#x27;0&#x27;==1)num1++; if(s[i]-&#x27;0&#x27;==6)num6++; &#125; if((num6-1)&gt;=num1)ans=num1; else ans=num6-1; //因为子串中第一个字符的位置不相同就为不相同的子串 cout&lt;&lt;ans&lt;&lt;endl;//61616111 &#125; C 算概率本来这题想到了其实给出模mod之后的值可以当做概率来算，可是一想知道了某道题的概率，然后通过排列组合求不出来，通过dfs也很难遍历出每一种选择。 最后标程用的是递推式的做法，dp的那种思想，所以不是那种求最终有多少组的，或者满足某一条件之后增加结果的，就用递推式来求这种题，对一个，对两个，对三个等等。 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2005, mod = 1e9 + 7;long long n, p[N], f[N][N];int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; p[i];//输入每题对的概率 for (int i = f[0][0] = 1; i &lt;= n; ++i) &#123; f[i][0] = f[i - 1][0] * (mod + 1 - p[i]) % mod;//前i题中作对j题的概率 for (int j = 1; j &lt;= i; ++j) f[i][j] = (f[i - 1][j] * (mod + 1 - p[i]) + f[i - 1][j - 1] * p[i]) % mod; &#125; for (int i = 0; i &lt;= n; ++i) cout &lt;&lt; f[n][i] &lt;&lt; &#x27; &#x27;; return 0;&#125; D 找钝角三角形 1234567891011121314151617181920212223方法一：向量的做法#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 505;int n, x[N], y[N], ans;bool chk(int i, int j, int k) &#123; return ((x[j] - x[i]) * (x[k] - x[i]) + (y[j] - y[i]) * (y[k] - y[i]) &lt; 0) &amp;&amp; ((x[j] - x[i]) * (y[k] - y[i]) - (x[k] - x[i]) * (y[j] - y[i]) != 0);&#125;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d&quot;, &amp;x[i], &amp;y[i]); for (int i = 1; i &lt;= n; ++i) for (int j = i + 1; j &lt;= n; ++j) for (int k = j + 1; k &lt;= n; ++k) if (chk(i, j, k) || chk(k, i, j) || chk(j, i, k)) ++ans; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 1方法二：三边关系，eps？？？？？ E 1234567891011121314#include &lt;cstdio&gt;using namespace std;int n, ans;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i * i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) if (i * i % j == 0)//找到这样的一个因式之后+2 ans += 2; ans -= 1;//因为上面当i和j相等的时候加重了一次，所以减去那一次 &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; F 拿物品 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std; const int N = 2e5 + 7;int n; vector&lt;int&gt;sa, sb;struct atom &#123; int a, b, id; bool operator &lt; (const atom &amp;rhs) const &#123; return a + b &gt; rhs.a + rhs.b; &#125;&#125; a[N];int main() &#123; scanf(&quot;%d&quot;, &amp;n); assert(n &gt;= 1 &amp;&amp; n &lt;= 200000); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i].a); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i].b), a[i].id = i; sort(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; ++i) ((i &amp; 1) ? sa : sb).push_back(a[i].id); for (auto x : sa) printf(&quot;%d &quot;, x); puts(&quot;&quot;); for (auto x : sb) printf(&quot;%d &quot;, x); return 0;&#125; G 判正误 本来我也想着，直接算会不会溢出啥的，可是没想到要多选几个mod，而且必须要让每次运算之前数据的范围都在m这个范围内，否则会出错 12345678910111213141516171819202122232425262728293031323334353637方法一：#include &lt;bits/stdc++.h&gt;using namespace std;const int mod[] = &#123;2, 3, 5, 7, 11, 31, 71, 97, 233, 397, 433, 449, 607, 857, 10007, 21179, 36251, 44579, 62003, 72883, 97843, 139991, 232013, 369353, 681521, 692711, 777241, 822821, 1956761, 2145137, 2915837, 6229117, 7788787, 13743493, 17331841, 19260817, 19269293, 19959809, 21006959, 23937083, 24410849, 28452757, 28478603, 29229359, 35570827, 35604011, 35875487, 37370863, 38303347, 38475517, 38819149, 40455791, 44021539, 45641993, 46531301, 48866749, 50529641, 52634191, 52790587, 55180799, 56971613, 58259351, 60954737, 62207269, 63367453, 65072599, 66017821, 67952779, 69475349, 74689217, 77059907, 77907121, 79391659, 84768797, 85584601, 85724879, 85756609, 86850899, 91783511, 92331541, 94519499, 96375241, 99033413, 99486311, 100569829, 106873549, 109329881, 109913681, 111186487, 111894067, 112136617, 112417363, 114011921, 119143363, 122994493, 123747781, 124001021, 126515639, 128191039, 128767909, 132222763, 133587661, 139644719, 145641527, 153388423, 155187077, 156883333, 157989581, 159538063, 161488643, 164039129, 166070447, 169181543, 169554227, 173564801, 175742867, 185469637, 187203899, 191263223, 198691817, 204144887, 211631201, 217903877, 218028203, 220073423, 228143453, 228667423, 232064653, 240519263, 245647159, 247586411, 247936121, 250949197, 253413211, 253464329, 260572729, 260590409, 262887773, 265711423, 266763641, 273585149, 276472817, 276500531, 280543667, 280649591, 281385491, 291366337, 293273159, 296973107, 302890501, 306568693, 315614297, 316729409, 317617121, 320337781, 320613497, 321322823, 324691051, 325963067, 327184157, 329900633, 330670159, 332058781, 332213669, 332300869, 334382221, 341895677, 347938237, 349011827, 349347503, 349906439, 353796941, 364557253, 364755931, 367946441, 372413831, 374358983, 379589897, 381149689, 389431873, 404683493, 405216109, 405495029, 408142403, 408989747, 410841979, 410935093, 412405351, 412592459, 412722139, 412990573, 418171483, 421270357, 424233613, 427938449, 428492083, 429962881, 430883569, 434988383, 435941201, 438816151, 440052953, 440143589, 444693631, 453646433, 455847109, 456640189, 457911511, 458185237, 463116761, 463861417, 469275953, 471298573, 471712513, 478267417, 483824813, 494828483, 497397293, 499657393, 507957479, 512906621, 519346459, 519879973, 520094713, 523213693, 525673273, 529575763, 529883803, 533887031, 534260809, 535328309, 541992667, 542253071, 544780177, 545567609, 552922529, 555129893, 555820037, 558473471, 563484017, 571310471, 578121241, 582251063, 583825639, 584121323, 592038487, 599098811, 601467677, 610073969, 615059213, 619220713, 622457177, 627412609, 630547919, 632342989, 637357363, 638865419, 648268013, 650007487, 651564761, 654115433, 661281713, 662664461, 667914281, 682988213, 691099121, 691445809, 692038043, 692411953, 698620943, 699007259, 701164631, 706806461, 707096251, 707697451, 709566589, 719095829, 725756807, 736880491, 739603867, 743026709, 744236861, 744396049, 747393791, 749395103, 760341121, 762934307, 773124059, 773195911, 776162609, 781629113, 781884613, 786120631, 788314343, 788898377, 788939293, 790209983, 791933183, 796328783, 798643889, 802280047, 803293991, 803847559, 809752739, 818520473, 820434047, 826810489, 829359959, 829707427, 836587463, 841011167, 843763253, 849410557, 851226437, 853058471, 853168793, 853778327, 859086391, 860720017, 863193077, 873061181, 888803059, 893035529, 900902953, 904636883, 917949577, 921817139, 922328707, 931449133, 933074827, 933156233, 935241721, 935632799, 939948881, 957119773, 961329913, 965269573, 965337949, 967551691, 971080093, 973578143, 976825877, 985100197, 985413691, 986124823, 990650057, 998244353, 999058883, 1000000007&#125;;int ff(int a, int m) &#123; return (a % m + m) % m;&#125;int Pow(int a, int b, int c) &#123; int ret = 1; while (b) &#123; if (b &amp; 1) ret = ret * 1ll * a % c; a = a * 1ll * a % c; b &gt;&gt;= 1; &#125; return ret;&#125;int a, b, c, d, e, f, g; bool check(int m) &#123; return ((Pow(ff(a, m), d, m) + Pow(ff(b, m), e, m)) % m + Pow(ff(c, m), f, m)) % m == ff(g, m); //必须先让a对m取模，然后在d的多少次幂之后再对m取模，相加之后在接着取模，然后在加上一项，再取模；必须要让每次+之前的时候都在m这个范围内，否则会出错&#125; int main() &#123; int T; cin &gt;&gt; T; while (T--) &#123; // cerr &lt;&lt; T &lt;&lt; endl; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g; assert((a || d) &amp;&amp; (b || e) &amp;&amp; (c || f)); assert(min(a, min(b, min(c, g))) &gt;= -1e9 &amp;&amp; max(a, max(b, max(c, g))) &lt;= 1e9 &amp;&amp; min(d, min(e, f)) &gt;= 0 &amp;&amp; max(d, max(e, f)) &lt;= 1e9); bool flag = 1; for (int i = 0; i &lt; 349; ++i) if (!check(mod[i])) &#123;flag = 0; break;&#125; puts(flag ? &quot;Yes&quot; : &quot;No&quot;); &#125; return 0;&#125; 方法二：可以直接用某个mod模一下就能过，1E9+1 +3 +5 +9 +11、1E9-1 -3 -5等等……均能AC；本题就是卡了一下固定的模数。 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int MOD = 1E9+9; ll qpow_m(ll a, ll b) &#123; if(a == 0) return 0; if(b == 0) return 1; ll ans = 1; ll base = a % MOD; while(b) &#123; if(b &amp; 1) ans = (ans * base) % MOD; base = (base * base) % MOD; b &gt;&gt;= 1; &#125; return ans;&#125; int main() &#123; int t; while(~scanf(&quot;%d&quot;, &amp;t)) &#123; ll a, b, c, d, e, f, g; while(t--) &#123; scanf(&quot;%lld %lld %lld %lld %lld %lld %lld&quot;, &amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f, &amp;g); printf(((qpow_m(a, d) + qpow_m(b, e) + qpow_m(c, f)) % MOD == g % MOD)?&quot;Yes\\n&quot;:&quot;No\\n&quot;); &#125; &#125; return 0;&#125; H 施魔法 一维dp 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5 + 7;int dp[N], pre, a[N], n, k;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i); sort(a + 1, a + 1 + n); pre = -a[1]; for (int i = 1; i &lt; k; ++i) dp[i] = 2e9; for (int i = k; i &lt;= n; ++i) &#123; dp[i] = pre + a[i]; pre = min(pre, dp[i - k + 1] - a[i - k + 2]); &#125;//pre就是那个min&#123;f（j-1）-a j&#125; cout &lt;&lt; dp[n]; return 0;&#125; I 建通道 二进制lowbit（） ；数据离散化 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2e5 + 5;int n, k;int v[N], va, vo;long long ans;int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;v[i]); sort(v + 1, v + n + 1); va = 0x7fffffff; for (int i = 1; i &lt;= n; i++) &#123; va &amp;= v[i]; vo |= v[i]; &#125; for (int i = n; i; i--) k += (v[i] != v[i + 1]); va ^= vo; for (int i = 0; i &lt;= 30; i++) &#123; int cur = 1 &lt;&lt; i; if (va &amp; cur) &#123; ans = 1ll * cur * (k - 1); break; &#125; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; J 线段数 求函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 7, mod = 1e9 + 7;typedef long long ll;typedef pair&lt;int, int&gt; pii;int n, m, t[N &lt;&lt; 2], t1[N &lt;&lt; 2], k[N];void modify(int o, int l, int r, int k, ll v, ll v1) &#123; if (l == r) return t[o] = v, t1[o] = v1, void(); int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid) modify(o &lt;&lt; 1, l, mid, k, v, v1); else modify(o &lt;&lt; 1 | 1, mid + 1, r, k, v, v1); t[o] = (t[o &lt;&lt; 1] * 1ll * t[o &lt;&lt; 1 | 1]) % mod; t1[o] = (t1[o &lt;&lt; 1] * 1ll * t[o &lt;&lt; 1 | 1] + t1[o &lt;&lt; 1 | 1]) % mod;&#125; pii merge(pii a, pii b) &#123; return &#123;a.first * 1ll * b.first % mod, (a.second * 1ll * b.first + b.second) % mod&#125;;&#125; pii query(int o, int l, int r, int ql, int qr) &#123; if (ql &lt;= l &amp;&amp; r &lt;= qr) return &#123;t[o], t1[o]&#125;; int mid = (l + r) &gt;&gt; 1; if (qr &lt;= mid) return query(o &lt;&lt; 1, l, mid, ql, qr); if (ql &gt; mid) return query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr); return merge(query(o &lt;&lt; 1, l, mid, ql, qr), query(o &lt;&lt; 1 | 1, mid + 1, r, ql, qr));&#125; int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); int op, x, y, z; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, k + i); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%d&quot;, &amp;x); modify(1, 1, n, i, k[i], x); &#125; while (m--) &#123; scanf(&quot;%d%d%d&quot;, &amp;op, &amp;x, &amp;y); if (op == 2) &#123; pii ans = query(1, 1, n, x, y); printf(&quot;%d\\n&quot;, (ans.first + ans.second) % mod); &#125; else scanf(&quot;%d&quot;, &amp;z), modify(1, 1, n, x, y, z); &#125; return 0;&#125; 补充 字符串哈希例题首先两种做法都用到了一个操作，就是用一个整数来表示一个字符串。这个操作很简单，设一个指数，如我设了131，那么我们就把字符串当成一个131进制数，然后换算成十进制的数，就是它哈希时候的代表值。 然后我们发现代表值不能太大，所以我们要取膜域。我们为了避免冲突，通常还会用乘法哈希，就是把这个值乘上一个大质数，然后取膜，然后还要判断冲突，如果当前位置已有冲突，就取下一个位置。但实际上字符串哈希出现冲突的概率是很小的，除非出题人刻意出了鬼畜的数据来卡字符串哈希 ，否则基本不会出事。比如例题我就没有处理冲突直接ac了。 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;unsigned long long base=131;int N,arr[10005];char st[1600]; int hash(char ch[])&#123; unsigned long long ans=0; int len=strlen(ch); for(int i=0;i&lt;len;i++) ans=ans*base+ch[i]; return ans;&#125; int main()&#123; int ans=0; scanf(&quot;%d&quot;,&amp;N); for(int i=1;i&lt;=N;i++) &#123; scanf(&quot;%s&quot;,st); arr[i]=hash(st); &#125; sort(arr+1,arr+1+N); for(int i=2;i&lt;=N;i++) if(arr[i]!=arr[i-1]) ans++; cout&lt;&lt;ans+1;&#125; 123456789101112131415161718192021222324252627282930313233找一个大质数，直接取模#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define modl 19260817*19890604-19491001using namespace std;long long base=131;int N,arr[10005];char st[1600]; int hash(char ch[])&#123; long long ans=0; int len=strlen(ch); for(int i=0;i&lt;len;i++) ans=ans*base+ch[i],ans%=modl; return ans;&#125; int main()&#123; int ans=0; scanf(&quot;%d&quot;,&amp;N); for(int i=1;i&lt;=N;i++) &#123; scanf(&quot;%s&quot;,st); arr[i]=hash(st); &#125; sort(arr+1,arr+1+N); for(int i=2;i&lt;=N;i++) if(arr[i]!=arr[i-1]) ans++; cout&lt;&lt;ans+1;&#125; 但是上述取模和base的方法仍然会出现哈希冲突现象，那么就应该用sort和unique的方法即双哈希 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define ull unsigned long long#define ll long longconst int base=2333;const int Mod1=998244353;const int Mod2=1000000007;int n,tot;char ch[2000];int CalcHash(char *s,int len,int Mod)&#123; int hash=0; for(int i=0;i&lt;len;++i) hash=(1ll*hash*base+s[i])%Mod; return hash;&#125;pair&lt;int,int&gt; ele[10010];int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1,l;i&lt;=n;++i) &#123; scanf(&quot;%s&quot;,ch);l=strlen(ch); ele[i]=make_pair(CalcHash(ch,l,Mod1),CalcHash(ch,l,Mod2)); &#125; sort(&amp;ele[1],&amp;ele[n+1]);tot=unique(&amp;ele[1],&amp;ele[n+1])-ele-1; printf(&quot;%d\\n&quot;,tot); return 0;&#125; tips：unique函数属于STL中比较常用函数，它的功能是元素去重。即”删除”序列中所有相邻的重复元素(只保留一个)。此处的删除，并不是真的删除，而是指重复元素被移到数组的末尾了。由于它”删除”的是相邻的重复元素，所以在使用unique函数之前，一般都会将目标序列进行排序。（也可以通过前一个和后一个数相比较的方式，实现unqiue方法）","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"牛客","slug":"牛客","permalink":"https://zouyunkai.github.io/myblog/tags/%E7%89%9B%E5%AE%A2/"}],"author":"aoyuehan"},{"title":"新生训练09-牛客竞赛1","slug":"新生训练09-牛客竞赛1","date":"2020-02-04T07:05:00.000Z","updated":"2022-02-26T03:52:52.117Z","comments":true,"path":"2020/02/04/新生训练09-牛客竞赛1/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/04/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%8309-%E7%89%9B%E5%AE%A2%E7%AB%9E%E8%B5%9B1/","excerpt":"","text":"A-好三角形的个数“好三角形”分为两类分开统计：两条边和两个坐标轴平行；只有一条边和某个坐标轴平行。对于第一种情况，一定是 1∗2 或者 2∗1 的形式，一个 1∗2 的矩形中含有4个不同的三角形。总数是 4∗((n−2)∗(m−1)+(m−2)∗(n−1))对于第二种情况，可以分别统计底边为 222 、高为 111 和底边为 111 、高为 222 的情况。 123456789101112131415161718//分情况讨论#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int mod = 1e9+7;int main()&#123; ll n,m; cin&gt;&gt;n&gt;&gt;m; ll s=(n-2)*(m-1)*4%mod+(n-1)*(m-2)*4%mod; // 两条边分别和x轴和y轴平行的部分 s=(s+2*(n-1)*(m-2)%mod*(m-2)%mod+2*(m-1)*(n-2)%mod*(n-2)%mod)%mod;//一条边平行于x轴，高为1，底为2或者高为2，底为1 s=(s+2*(n-2)*(m-1)%mod*(m-2)%mod+2*(m-2)*(n-1)%mod*(n-2)%mod)%mod;//一条边平行于y轴，高为1，底为2或者高为2，底为1 cout&lt;&lt;s; &#125; B-概率论求数学期望 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b,n,x;long long temp1=0,temp2=0;double ans; cin&gt;&gt;n&gt;&gt;x&gt;&gt;a&gt;&gt;b; temp1=n*a; temp2=n*b; ans=temp1*x*1.0/100+temp2*(100-x)*1.0/100;//按比例求相应的占比 //cout&lt;&lt;temp1&lt;&lt;&#x27; &#x27;&lt;&lt;temp2&lt;&lt;endl; //cout&lt;&lt;temp1*x*1.0/100&lt;&lt;&#x27; &#x27;&lt;&lt;temp2*(100-x)*1.0/100&lt;&lt;endl; printf(&quot;%.2lf\\n&quot;,ans);&#125; C-计算几何 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long vector&lt;double&gt;v1,v2; //v1、v2分别存umi和靶子连接的线段与两个坐标轴的交点（如果存在的话）int main()&#123; double x0,y0; int n,k,i; cin&gt;&gt;x0&gt;&gt;y0&gt;&gt;n&gt;&gt;k; k=n-k; for(i=0;i&lt;n;i++)&#123; double x,y; cin&gt;&gt;x&gt;&gt;y; if(x*x0&lt;0)&#123; v2.push_back(y0-x0*(y-y0)/(x-x0)); &#125; if(y*y0&lt;0)&#123; v1.push_back(x0-y0*(x-x0)/(y-y0)); &#125; &#125; double mi=1e18; sort(v1.begin(),v1.end()); sort(v2.begin(),v2.end()); if(v1.size()&gt;=k)&#123; double head=0,tail=k-1; //双指针，用mi维护最小值 while(tail&lt;v1.size())&#123; mi=min(mi,v1[tail]-v1[head]); //用一个挡板能遮住n-k个（因为处理过k=n-k）点时的最小挡板的长度 tail++,head++; &#125; &#125; if(v2.size()&gt;=k)&#123; double head=0,tail=k-1; while(tail&lt;v2.size())&#123; mi=min(mi,v2[tail]-v2[head]); tail++,head++; &#125; &#125; if(mi==1e18)cout&lt;&lt;-1; else printf(&quot;%.7lf&quot;,mi);&#125; D-1到n的和 1234567891011121314#include&lt;iostream&gt;using namespace std;const int maxn=1e5+10;int main()&#123; int n,tmp=0,ans=0,sum=0; cin&gt;&gt;n; for(int i=1;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;tmp); ans+=tmp; &#125; sum=n*(n+1)/2; tmp=sum-ans;//1到n的总和减去给出的碗里的米数的和就是答案 printf(&quot;%d\\n&quot;,tmp);&#125; E-数论之因子的个数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;typedef long long ll;struct factor&#123; int x,cnt;//x为质因子，cnt为个数 &#125;fac[20]; //int范围内开10个质因子就可int Punm=80;//素数的个数，其实80个就可以分解1e12范围内的数了int prime[168]=&#123;//1000以内的质数2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727, 733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997 &#125;;ll fenjie(ll n)&#123; int num=0;//质因子分解for(int i=0;i&lt;Punm&amp;&amp;prime[i]&lt;=sqrt(n);i++)&#123; if(n%prime[i]==0)&#123; fac[num].x=prime[i];//记录该因子 fac[num].cnt=0; while(n%prime[i]==0)&#123;//计算该因子的个数 fac[num].cnt++; n/=prime[i]; &#125; num++;//不同的质因子的个数 &#125; if(n==1)break; &#125; if(n!=1)&#123;//如果无法被根号n以内的质因子除尽 fac[num].x=n;//那么一定有一个大于根号n的质因子 fac[num].cnt=1;&#125;ll tmp=1;for(int i=0;i&lt;num;i++)&#123; tmp*=(1+fac[i].cnt);&#125;if(n!=1)tmp*=(1+fac[num].cnt);//特判是否那个大于根n的质因子是否存在return tmp;&#125;int main()&#123; ll curcnt=1; ll n; cin&gt;&gt;n; //cout&lt;&lt;fenjie(4)&lt;&lt;fenjie(12)&lt;&lt;fenjie(3); while(1)&#123; n=fenjie(n); if(n==2)break; //cout&lt;&lt;&#x27; &#x27;&lt;&lt;n&lt;&lt;&#x27; &#x27;&lt;&lt;curcnt&lt;&lt;endl; curcnt++; &#125; cout&lt;&lt;curcnt&lt;&lt;endl;&#125; 暴力解法： 12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll f(ll x)&#123; //求x的因子个数 ll i,res=0; for(i=1;i*i&lt;x;i++)&#123; if(x%i==0)res+=2; &#125; return res+(i*i==x);&#125;int main()&#123; ll i=0,n; cin&gt;&gt;n; while(n!=2)n=f(n),i++; cout&lt;&lt;i;&#125; F-树的简单路径、连同块开始先预处理下所有点，将相连的白点都加一个权值，表示有几个白点相连，那么当我们计算路径的时候就好算的的多了，然后假如遇见一个黑点，相连n个白块，计算到哪个白点了就等于这块白点乘上之前的白点数再加上自己就可以了。因为一个黑点能和一个连通块中的一个白点相连，所以计算到哪个白点了就等于这块白点乘上之前的白点（就是两头为白点，中间为黑点的情况）数再加上自己（就是两头的点一个为黑点、一个为白点的情况）就可以了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define fast ios::sync_with_stdio(0)vector&lt;int&gt;ve[100100];vector&lt;int&gt;v;char c[100100]; ll sum=0;ll dis[100100]; int bfs(int X)&#123;//求一个白点的连通块中的个数 v.clear(); queue&lt;int&gt;q; q.push(X); dis[X]=1; int ans=0; while(!q.empty()) &#123; int x=q.front();q.pop(); ans++;//计算这一块白点一共有几个 v.push_back(x);//记录这些点，方便以后给其赋权值 for(int i:ve[x]) &#123; if(c[i]==&#x27;W&#x27;&amp;&amp;dis[i]==0)//如果是白点且没放进去过队列就放进去 &#123; dis[i]=1; q.push(i); &#125; &#125; &#125; return ans;&#125; int main()&#123; int n;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;c[i]; for(int x,y,i=1;i&lt;n;i++) &#123; cin&gt;&gt;x&gt;&gt;y; ve[x].push_back(y);//ve这个集合表示这个顶点相连的其他顶点 ve[y].push_back(x); &#125; for(int i=1;i&lt;=n;i++)//预处理这个树 &#123; if(c[i]==&#x27;W&#x27;&amp;&amp;!dis[i])//如果这个点是白点还没跑过就跑 &#123; int y=bfs(i); for(int j:v)//将这一大块白点都赋一样的权值方便以后的操作 &#123; dis[j]=y;//dis中是这个点的权值 &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; ll ans=0;//记录一个黑点相连的白点有几个 if(c[i]==&#x27;B&#x27;) &#123; for(int j:ve[i]) &#123; if(c[j]==&#x27;W&#x27;)//如果这个点是白点 &#123; sum+=ans*dis[j]+dis[j];//路径树量等于通过这个点走向前面的其他点 //再加上自己到这个黑点的路径树量 ans+=dis[j];//更新现有的白点树量 &#125; &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;&quot;\\n&quot;; return 0;&#125; G-找最短不间断且包含k个相同字母的长度简单的队列模拟 首先把每一个字母加入队列，我们用head，tail表示队列的头和尾head是头的后一位，tail是尾那么目前所查找的区间长度为tail-head+1， tail&#x3D;head+1时队列为空我们先不断地加入字母(按顺序)直到其中出现重复的k个字母，这时候就要把头缩回来(++head)，直到头是这个字母为止，那么我们认为以这个字母为头和尾的字串是目前查找的最短的字串那么在头缩进去的时候，会失去一些其他的字母，但很明显，目前来看的队列长度是len，而这些字母为首能组成的k个字母重复的字串明显是&gt;len的，而以当前字母为尾的k个重复的字串还在缩头过程中，必定&lt;len重复做这些操作，比较最大值即可 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define maxn 200010#define INF 9999999using namespace std; int n,k,ans=INF;int que[maxn],head=1,tail=0;int num[30];string str; int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); cin&gt;&gt;str; for(int i=0;i&lt;n;++i)&#123; int j=int(str[i])-&#x27;a&#x27;+1; que[++tail]=j; num[j]++; if(num[j]==k)&#123; while(head&lt;tail+1)&#123;//队列不为空的时候 if(que[head]==j)&#123; ans=min(ans,tail-head+1); --num[j]; ++head; break;//找到以j字母的那段长度后跳出去 &#125; else --num[que[head]],++head; //此时把num[que[head]的这段字母减去就行 &#125; &#125; &#125; if(ans==INF) printf(&quot;-1&quot;); else printf(&quot;%d&quot;,ans); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536标程：#include&lt;bits/stdc++.h&gt;using namespace std;int dp[200010][26]=&#123;0&#125;; //26个前缀和数组int main()&#123; int n,k,i,j; cin&gt;&gt;n&gt;&gt;k; string s; cin&gt;&gt;s; dp[0][s[0]-&#x27;a&#x27;]=1; for(i=1;i&lt;n;i++)&#123; for(j=0;j&lt;26;j++)&#123; dp[i][j]=dp[i-1][j]; &#125; dp[i][s[i]-&#x27;a&#x27;]++; &#125; int mi=1e9; for(i=0;i&lt;26;i++)&#123; int temp=0,t2=0; if(dp[n-1][i]&lt;k)continue; while(temp&lt;n&amp;&amp;dp[temp][i]==0)temp++; while(t2&lt;n&amp;&amp;dp[t2][i]&lt;k)t2++; mi=min(mi,t2-temp+1); for(temp++;temp&lt;n;temp++)&#123; //从temp开始从前往后依次找k个这个字母的子串 if(s[temp-1]-&#x27;a&#x27;==i)&#123; t2++; while(t2&lt;n&amp;&amp;s[t2]-&#x27;a&#x27;!=i)t2++; if(t2==n)break; &#125; mi=min(mi,t2-temp+1); &#125; &#125; if(mi==1e9)cout&lt;&lt;-1; else cout&lt;&lt;mi;&#125; I-动态规划 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll dp[322222]=&#123;0&#125;;string a;int main()&#123; ll i,n,x,y,z; cin&gt;&gt;n&gt;&gt;x&gt;&gt;y&gt;&gt;z; cin&gt;&gt;a; for(i=0;i&lt;n;i++)&#123; if(i&gt;0)dp[i]=dp[i-1]; if(i&gt;=3&amp;&amp;a[i-3]==&#x27;n&#x27;&amp;&amp;a[i-2]==&#x27;i&#x27;&amp;&amp;a[i-1]==&#x27;c&#x27;&amp;&amp;a[i]==&#x27;o&#x27;) dp[i]=max(dp[i],dp[i-3]+x); if(i&gt;=5&amp;&amp;a[i-5]==&#x27;n&#x27;&amp;&amp;a[i-4]==&#x27;i&#x27;&amp;&amp;a[i-3]==&#x27;c&#x27;&amp;&amp;a[i-2]==&#x27;o&#x27;&amp;&amp;a[i-1]==&#x27;n&#x27;&amp;&amp;a[i]==&#x27;i&#x27;) dp[i]=max(dp[i],dp[i-5]+y); if(i&gt;=9&amp;&amp;a[i-9]==&#x27;n&#x27;&amp;&amp;a[i-8]==&#x27;i&#x27;&amp;&amp;a[i-7]==&#x27;c&#x27;&amp;&amp;a[i-6]==&#x27;o&#x27;&amp;&amp;a[i-5]==&#x27;n&#x27;&amp;&amp;a[i-4]==&#x27;i&#x27;&amp;&amp;a[i-3]==&#x27;c&#x27;&amp;&amp;a[i-2]==&#x27;o&#x27;&amp;&amp;a[i-1]==&#x27;n&#x27;&amp;&amp;a[i]==&#x27;i&#x27;) dp[i]=max(dp[i],dp[i-9]+z); &#125; //这里偷懒了，对于字符a[i]=&#x27;n&#x27;的情况，显然dp[i]=dp[i-1]。这样就不用处理dp[-1]的值。 cout&lt;&lt;dp[n-1];&#125; J-矩阵快速幂和推导方法一： 方法二： 对结果模mod，但是对指数来说就要模mod-1（费马小定理），矩阵的结果最终是要做指数的，所以模mod-1。 方法一的变种矩阵求斐波那锲数https://www.cnblogs.com/frog112111/archive/2013/05/19/3087648.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091方法一：#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longstruct mt&#123; ll a[3][3];&#125;;mt t(mt a,mt b,ll mod)&#123; mt res; int i,j,k; for(i=0;i&lt;3;i++)&#123; for(j=0;j&lt;3;j++)&#123; res.a[i][j]=0; for(k=0;k&lt;3;k++)&#123; res.a[i][j]+=a.a[i][k]*b.a[k][j]%mod; res.a[i][j]%=mod; &#125; &#125; &#125; return res;&#125;mt power(mt a,ll b,ll mod)&#123; mt res; int i,j; for(i=0;i&lt;3;i++)&#123; for(j=0;j&lt;3;j++)&#123; res.a[i][j]=0; &#125; &#125; res.a[0][0]=res.a[1][1]=res.a[2][2]=1; while(b)&#123; if(b&amp;1)res=t(res,a,mod); b&gt;&gt;=1; a=t(a,a,mod); &#125; return res;&#125;ll feb(ll n,ll mod)&#123; mt temp; int i,j; for(i=0;i&lt;3;i++)&#123; for(j=0;j&lt;3;j++)&#123; temp.a[i][j]=0; &#125; &#125; temp.a[0][1]=temp.a[1][1]=temp.a[1][0]=temp.a[1][2]=1; mt res=power(temp,n-1,mod); return (res.a[0][0]+res.a[0][1])%mod; //这是求f(n)=f（n-1）+f(n-2)&#125;ll feb2(ll n,ll mod)&#123; mt temp; int i,j; for(i=0;i&lt;3;i++)&#123; for(j=0;j&lt;3;j++)&#123; temp.a[i][j]=0; &#125; &#125; temp.a[0][1]=temp.a[1][1]=temp.a[1][0]=temp.a[1][2]=temp.a[2][2]=1; mt res=power(temp,n-1,mod); return (res.a[0][0]+2*res.a[0][1]+res.a[0][2])%mod; //这是什么意思，求f(n-1)+f(n-2)+1,为什么要*2呀&#125;ll power(ll a,ll b,ll mod)&#123; ll res=1; while(b)&#123; if(b&amp;1)res=res*a%mod; b&gt;&gt;=1; a=a*a%mod; &#125; return res;&#125;int main()&#123; int m=1e9+7; int i,j; ll n,x,y,a,b; cin&gt;&gt;n&gt;&gt;x&gt;&gt;y&gt;&gt;a&gt;&gt;b; if(n==1)&#123;cout&lt;&lt;x%m;return 0;&#125; if(n==2)&#123;cout&lt;&lt;y%m;return 0;&#125; x%=m; y%=m; a=power(a%m,b,m); //先计算a的b次方可以避免b模mod-1为0的情况 cout&lt;&lt;power(x,feb(n-2,m-1),m)*power(y,feb(n-1,m-1),m)%m*power(a%m,feb2(n-2,m-1)%(m-1),m)%m&lt;&lt;endl; &#125; H - 01串中全0或全1的子串的长度 分两种情况讨论，0改1或者1改0，尺取这两种长度（尺取的下标是这个字符在原来01串中的位置，相差k就是中间能改k个0或者1） 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;string s;vector&lt;int&gt;v0,v1; //v0存字符&#x27;0&#x27;的坐标位置，v1存字符&#x27;1&#x27;的坐标位置int main()&#123; int n,k,i,j; cin&gt;&gt;n&gt;&gt;k; cin&gt;&gt;s; v0.push_back(-1);//在数组0的地方填进去一个，占位 v1.push_back(-1); for(i=0;i&lt;n;i++)&#123; if(s[i]==&#x27;0&#x27;)v0.push_back(i); else v1.push_back(i); &#125; v0.push_back(n); v1.push_back(n); int ma=0; if(v0.size()-2&lt;=k)ma=n;//size这地方没有填数，若果0的数量减 //去头上的-1和尾部的size之后小于k，则这个串能变成全1的串 else&#123; for(i=1,j=k;j&lt;v0.size()-1;i++,j++)&#123; ma=max(ma,v0[j+1]-v0[i-1]-1);//尺取k个0的变为1，统计1串的最长长度 &#125; &#125; if(v1.size()-2&lt;=k)ma=n;//可以全变为0串 else&#123; for(i=1,j=k;j&lt;v1.size()-1;i++,j++)&#123;//尺取k个1变为0 ma=max(ma,v1[j+1]-v1[i-1]-1); &#125; &#125; cout&lt;&lt;ma;&#125; 知识点总结快速幂vs矩阵快速幂1、pow函数，最简单的实现就是一直累乘；算法的时间复杂度是O(n)。2、快速幂O(lgn)的复杂度快速幂取模：首先，快速幂的目的就是做到快速求幂，假设我们要求a^b,假设我们要求a^b，那么其实b是可以拆成二进制的，该二进制数第i位的权为2^(i-1)，例如当b&#x3D;&#x3D;11时 a11&#x3D;a(2^0+2^1+2^3) 11的二进制是1011，11 &#x3D; 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 a2^0a2^1a2^3，也就是a1a2a8，看出来快的多了吧原来算11次，现在算三次。例如计算 1234567891011ll binaryPow(ll a, ll b, ll m)&#123; ll ans = 1;//因为是关于乘法的运算，此时的幺元为1 while(b &gt; 0)&#123; if(b &amp; 1)&#123; ans = ans * a % m; &#125; a = a * a % m;//此时a就相当于base，该位的权的大小 b &gt;&gt;= 1; &#125; return ans;&#125; 3、矩阵快速幂 123456789101112131415161718192021222324252627typedef long long ll;const int mod = 1e9 + 7;const int MAXN = 10005;//矩阵的大小struct Mat &#123; ll m[MAXN][MAXN];&#125;ans, a;//ans为结果矩阵，a为输入矩阵Mat Mul(Mat a, Mat b, int n) &#123;//计算矩阵a乘矩阵b，n为矩阵的大小 Mat c;//临时矩阵c memset(c.m, 0, sizeof(c.m)); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) for (int k = 1; k &lt;= n; k++) c.m[i][j] = (c.m[i][j] + (a.m[i][k] * b.m[k][j]) % mod) % mod; return c;&#125;Mat _power(Mat a, int b, int n) &#123;//计算a^b，n为矩阵的大小 for (int i = 1; i &lt;= n; i++)//构造单位矩阵，这就是幺元 ans[i][i] = 1; while (b) &#123; if (b &amp; 1) ans = Mul(ans, a, n); a = Mul(a, a, n);//相应的此时a就是这一个矩阵运算时的权 b &gt;&gt;= 1; &#125; return ans;&#125; 矩阵快速幂求斐波那锲 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int MOD=10000;struct mat&#123; ll a[2][2];&#125;;mat mat_mul(mat x,mat y)&#123;//矩阵相乘 mat res; memset(res.a,0,sizeof(res.a)); for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) res.a[i][j]=(res.a[i][j]+x.a[i][k]*y.a[k][j])%MOD; return res;&#125;void mat_pow(int n)&#123;//矩阵快速幂 mat c,res; c.a[0][0]=c.a[0][1]=c.a[1][0]=1; c.a[1][1]=0;//c为特征矩阵 memset(res.a,0,sizeof(res.a)); for(int i=0;i&lt;2;i++) res.a[i][i]=1;//res为单位矩阵 while(n) &#123; if(n&amp;1) res=mat_mul(res,c); c=mat_mul(c,c);//c为这一位矩阵的权 n=n&gt;&gt;1; &#125; printf(&quot;%I64d\\n&quot;,res.a[0][1]);&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n!=-1) &#123; mat_pow(n); &#125; return 0;&#125; 并查集并查集主要有两部分1.并 (find函数)2.查 (combine函数)用来判断一个图中是否有环，主要思想是把各自的节点的父节点初始化为自己，然后每加入一条边，就把一个点的父节点变成另外一个节点，当加入一条边的两个点的父节点都是同一个父节点的时候，此时，两个点就在一个环上。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;int fa[100010];int find(int a)&#123;//路径压缩版本 int b=a; //把初始值赋给b while(a!=fa[a])&#123; a=fa[a]; //找到a的祖先节点 &#125; while(b!=a)&#123; //直到b==a为止 int temp=fa[b]; //设一个中间变量为b的父亲节点 fa[b]=a; //直接让b的父亲节点为a的祖先节点 b=temp; //b等于b的父亲节点 &#125; return a;/*总的来说就是把一个数传进这个函数，先找到这个数的祖先节点，然后把这个 数到这个数的祖先节点中的所有点都直接连向a的祖先节点*/&#125;void combine(int a,int b)&#123; int ffa=find(a); int ffb=find(b); if(ffa!=ffb)&#123; fa[ffa]=ffb; &#125;&#125;int main()&#123; int i,j,n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(i=0;i&lt;=n;i++)&#123; fa[i]=i; &#125; while(m--)&#123; int z,x,y; scanf(&quot;%d%d%d&quot;,&amp;z,&amp;x,&amp;y); //z=1合并 ，z=2判断是否为同一集合 if(z==1)&#123; combine(x,y); &#125;else&#123; if(find(x)==find(y)) printf(&quot;Y\\n&quot;); else printf(&quot;N\\n&quot;); &#125; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"牛客","slug":"牛客","permalink":"https://zouyunkai.github.io/myblog/tags/%E7%89%9B%E5%AE%A2/"}],"author":"aoyuehan"},{"title":"新生训练08-山师联赛4","slug":"新生训练08-山师联赛4","date":"2020-02-02T07:05:00.000Z","updated":"2022-02-26T03:51:21.569Z","comments":true,"path":"2020/02/02/新生训练08-山师联赛4/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/02/02/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%8308-%E5%B1%B1%E5%B8%88%E8%81%94%E8%B5%9B4/","excerpt":"","text":"H - Triangle HDU - 5914 题意：给你1n的这n个数，问你要拿去多少个数之后，剩下的数才组不成三角形解法： 其实这是斐波那锲的变形，我做的时候没看出来，看到才20组，画了画，模拟过了，其实拿去多少个数之后，剩下的都是在1n（包括n）之间的斐波那锲数，例如：n&#x3D;8；可以取走3个数，剩下为1，2，3,5，8； 123456789101112131415161718192021222324252627282930313233343536373839404142434445方法一：#include&lt;iostream&gt;using namespace std;int ans[21]=&#123;0,0,0,0,1,1,2,3,3,4,5,6,7,7,8,9,10,11,12,13,14&#125;;int main()&#123; int T,n,t; cin&gt;&gt;T; t=T; while(T--)&#123; cin&gt;&gt;n; cout&lt;&lt;&quot;Case #&quot;&lt;&lt;t-T&lt;&lt;&quot;: &quot;&lt;&lt;ans[n]&lt;&lt;endl; &#125;&#125; 方法二：#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;string&gt;using namespace std; int main()&#123; int t,i,n,m,ans; scanf(&quot;%d&quot;,&amp;t); ans=0; while(t--)&#123; ans++; scanf(&quot;%d&quot;,&amp;n); if(n&lt;=3)&#123; m=n; &#125; else&#123; m=0; for(i=1;i&lt;=n;i++)&#123; if(i==1||i==2||i==3||i==5||i==8||i==13)&#123; m++; &#125; &#125; &#125; printf(&quot;Case #%d: %d\\n&quot;,ans,n-m); &#125; return 0;&#125; tips：提交后出现了Presentation Error。死活过不了，那段代码的输出我少了一个空格符（仔细回味，确实应该加换行或者空格的，否则会跟结果不完全匹配）。oj对这种格式的要求非常严格。出现这种问题多半是数据吻合，但是输出是格式有点问题 I - Birthday Paradox-lightoj 1104(期望)生日悖论，指如果一个房间里有23个或23个以上的人，那么至少有两个人的生日相同的概率要大于50%。这就意味着在一个典型的标准小学班级(30人)中，存在两人生日相同的可能性更高。对于60或者更多的人，这种概率要大于99%。从引起逻辑矛盾的角度来说生日悖论并不是一种悖论，从这个数学事实与一般直觉相抵触的意义上，它才称得上是一个悖论。大多数人会认为，23人中有2人生日相同的概率应该远远小于50%。计算与此相关的概率被称为生日问题，在这个问题之后的数学理论已被用于设计著名的密码攻击方法：生日攻击。 本题给出一年多少天，求当人数大于多少的时候这个概率大于等于0.5； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950方法一：#include&lt;iostream&gt;using namespace std;int main()&#123; int T,t; double tmp=1; double ans=0,n; cin&gt;&gt;T;t=T; while(T--)&#123; cin&gt;&gt;n; while(1)&#123; tmp=tmp*(n-ans)*1.0/(n*1.0); if(1-tmp&gt;=0.5)break; //若果上一步的那个ans就满足要求的，就直接退出，ans不++，否则的话ans会比结果大一 ++ans;//这一句话一定要放到上面一句的后面 //cout&lt;&lt;1-tmp&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl; &#125; cout&lt;&lt;&quot;Case #&quot;&lt;&lt;t-T&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; ans=0; tmp=1; &#125;&#125;方法二：#include&lt;iostream&gt;using namespace std;int main()&#123; int T,t; double tmp=1; double ans=1,n,n1; cin&gt;&gt;T;t=T; while(T--)&#123; cin&gt;&gt;n; n1=n; n1--; while(1)&#123; tmp=tmp*(n1*1.0)/(n*1.0); if(1-tmp&gt;=0.5)break;//注意顺序，不能乱 ，否则逻辑就不对了 //cout&lt;&lt;1-tmp&lt;&lt;&#x27; &#x27;&lt;&lt;n1&lt;&lt;&#x27; &#x27;&lt;&lt;ans&lt;&lt;endl; --n1; ++ans; &#125; cout&lt;&lt;&quot;Case &quot;&lt;&lt;t-T&lt;&lt;&quot;: &quot;&lt;&lt;ans&lt;&lt;endl; ans=1; tmp=1; &#125;&#125; 本题因为刚开始看结果的时候看成23,和31；找了半天错误没发现原因，最后一看题面，发现结果是22和30，哎，好好看题； K - Reverse a Substring题意：有一个串s，若把这个串的一部分翻转过来，翻转的串的总体字典序变小，则输出翻转的位置；本来看到这题以为求最小的那个字典序，可后来看到答案不唯一，其实本题让你求一个串就行，不一定求最小。 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=3*1e5+10;int n;string s1,s2;int main()&#123; int flag=0,left=0,right=0; cin&gt;&gt;n; cin&gt;&gt;s1; for(int i=1;i&lt;n;i++)&#123; if(s1[i-1]&gt;s1[i])&#123; flag=1; left=i; right=i+1; break; &#125; &#125; if(flag==1)&#123; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl&lt;&lt;left&lt;&lt;&#x27; &#x27;&lt;&lt;right&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125;&#125; L-Game with Telephone Numbers 题意：定义电话号第一个数字为8，且为11位数。给出一个数字串（数字串的长度为奇数且大于等于13），a先开始取走一个，b在开始，然后轮流取，一直到数字串的长度为11结束，最后结束的时候如果数字串为8开头的电话号，那么a赢；给出数字串，判断a是否赢； 12345678910111213141516#include&lt;iostream&gt;using namespace std;const int maxn=1e5+10;char d[maxn];int main()&#123; int n,tmp=0,isba=0; cin&gt;&gt;n; tmp=(n-11)/2;//tmp代表a能玩几回合 cin&gt;&gt;d; for(int i=0;i&lt;=2*tmp;i++)&#123;//若前1+tmp*2中有tmp+1个8的话，不管怎么取，都是a赢 if(d[i]-&#x27;0&#x27;==8)isba++; &#125; if(isba&gt;=tmp+1)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; M - Alarm Clocks Everywhere（cf1155c）题意： 有n个事件，m个间隔；给你n个事件的起始事件，一是事件可以为任意时刻，问从哪一时刻起，能有一个间隔到达所有事件的时刻。题解：gcd来找每个时刻之间的间隔的最小公约数，然后遍历一下m个间隔，若相余的0则输出相应的位置，否则输出no。 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int inf = 1&lt;&lt;30;const LL maxn = 3*1e5+10;int n, m;LL x[maxn], p[maxn], a[maxn];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; x[i]; for(int i = 1; i &lt;= m; i++) cin &gt;&gt; p[i]; for(int i = 1; i &lt; n; i++) a[i] = x[i+1]-x[i]; LL tag = a[1];//记录各个间隔的最小的那个公约数 for(int i = 2; i &lt; n; i++) tag = __gcd(tag, a[i]); for(int i = 1; i &lt;= m; i++) if(tag%p[i]==0)&#123;//如果间隔是那个最小的公约数的因数 ，那么就可以完成 cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl&lt;&lt; x[1] &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl; return 0; &#125; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return 0;&#125; B - So Easy! hdu-4565(矩阵快速幂+推导)其中是我们设出来的，因为这个的幂只包含这两个因子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define ll long longusing namespace std; ll a,b,n,mod;struct matrix&#123; ll f[3][3]; matrix operator * (const matrix &amp;a) const &#123; matrix res; for (int i=1;i&lt;=2;i++) &#123; for (int j=1;j&lt;=2;j++) &#123; res.f[i][j]=0; for (int k=1;k&lt;=2;k++) res.f[i][j]=(res.f[i][j]+(*this).f[i][k]*a.f[k][j])%mod; &#125; &#125; return res; &#125;&#125;A,B; matrix fast_pow(matrix base,int k)&#123; matrix ans=base; while (k) &#123; if (k&amp;1) ans=ans*base; base=base*base; k&gt;&gt;=1; &#125; return ans;&#125; void init()&#123; B.f[1][1]=a,B.f[1][2]=b; B.f[2][1]=1,B.f[2][2]=a; A.f[1][1]=a,A.f[2][1]=1;//矩阵A就是矩阵【x1，y1】&#125; int main()&#123; while (scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;n,&amp;mod)!=EOF) &#123; if (n==1) &#123; printf(&quot;%lld\\n&quot;,(a+(ll) sqrt(b)+1)%mod);continue;&#125; n-=2; init(); struct matrix cur,ans; cur=B; cur=fast_pow(cur,n); ans=cur*A;//见图中的解释 printf(&quot;%lld\\n&quot;,(2*ans.f[1][1])%mod); &#125; return 0;&#125; 123456789101112131415161718related to 关于fractions n.[数]分数；小部分，片段（fraction的复数）denominator n.[数]分母；命名者；共同特征或共同性质；平均水平或标准irreducible adj.[数]不可约的；不能削减的；不能复归的numerator n.分子；计算者；计算器coprime 互质convert 转换decimal adj.小数的；十进位的 n.小数notation n.符号；乐谱；注释；记号法alternatively adv.要不，或者；非此即彼；二者择一地；作为一种选择arranged adj.安排的v.安排；计划；准备crops n.农作物（crop的复数）v.种植（crop的三单形式）；收割；修剪；产庄稼Metropolis n.大都市；首府；重要中心departure n.离开；出发；违背schedule n.计划（表）；时间表；一览表；课程表intact adj.完整的；原封不动的；未受损伤的optimal adj.最佳的；最理想的preserving n.保留，保存","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"新生训练","slug":"新生训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"新生训练赛06_山师联赛1","slug":"新生训练赛06-山师联赛1","date":"2020-01-31T08:15:00.000Z","updated":"2022-02-26T03:52:52.402Z","comments":true,"path":"2020/01/31/新生训练赛06-山师联赛1/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/31/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83%E8%B5%9B06-%E5%B1%B1%E5%B8%88%E8%81%94%E8%B5%9B1/","excerpt":"","text":"A -互质问题a&#x2F;b 有gcd(a,b)&#x3D;&#x3D;1 a&lt;b 现在已知a+b&#x3D;n，我们求最大的a,b 123456789101112131415161718#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n; int i,len=0; cin&gt;&gt;n; if(n&amp;2==1)len=(n+1)/2;//注意这地方是一半，而不是根下多少 else len=n/2; for(i=len;i&gt;=1;i--)&#123; if(__gcd(i,n-i)==1&amp;&amp;i!=(n-i))break; &#125; if(i&lt;n-i) cout&lt;&lt;i&lt;&lt;&#x27; &#x27;&lt;&lt;n-i&lt;&lt;endl; else cout&lt;&lt;n-i&lt;&lt;&#x27; &#x27;&lt;&lt;i&lt;&lt;endl;&#125; B-找规律一排n个房子，其中有的房子是被居住的，问可能找到一个没有居住的且至少有一个已经居住的邻居的个数为m个，求m的最大值和最小值。*比赛的时候没看清是求的个数，我以为是可能性的大小，细心；（the maximum possible） number of apartments，number of就是数量的意思；这种题一看肯定是有公式可寻的，所以多写几组数据，进行推导，或者猜n-m，2m等等** 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int main()&#123; long long n,k,m; cin&gt;&gt;n&gt;&gt;k; if(n&lt;=3*k) m=n-k; else m=2*k; if(n==k||k==0) cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;1&lt;&lt;&quot; &quot;&lt;&lt;m&lt;&lt;endl; return 0;&#125;或者为：除去0的情况，即n == m , m == 0 , 的情况；剩下的由规律得min(n-m, m&lt;&lt;1)#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123; int n, m; while(cin &gt;&gt; n &gt;&gt; m) &#123; if(m == 0 || n == m) &#123; cout &lt;&lt; &quot;0 0&quot; &lt;&lt; endl; continue; &#125; cout &lt;&lt; &quot;1 &quot; &lt;&lt; min(n-m, m&lt;&lt;1) &lt;&lt; endl; &#125; return 0;&#125; C-贪心，优先队列题意：表示有n架飞机本需要在[1,n]时间内起飞,一分钟只能飞一架.但是现在[1,k]时间内并不能起飞,只能在[k+1,k+n]内起飞.ci序号为i的飞机起飞延误一分钟的cost.一个飞机不能比原定时间早起飞,请安排一个起飞顺序,求最小的cost和。贪心证明设序号为i的飞机起飞时间为di,则cost&#x3D;∑(di-i)ci&#x3D;∑dici-∑i*ci.显然后一项为常数,而{di-k}为[1,n]的一个排列, di就是1+k到n+k的一个排列，所以只要使ci越大的i尽可能早起飞即可使得cost最小.求解对于每个[k+1,k+n]的时刻t,都会有一架飞机起飞,而可起飞的飞机只有原定起飞时刻在[1,t]内已经准备好的飞机.从这些飞机中选取ci最大的即可.维护一个优先队列.一次循环就可以得出结果. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define N 300010using namespace std;struct NODE&#123; int i,w; bool operator &lt;(const NODE&amp;a)const &#123;//重载小于号，使得权重大的在队列的顶部 return w&lt;a.w; &#125;&#125;p[N];int main()&#123; int n,k; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;p[i].w); p[i].i=i; &#125; priority_queue&lt;NODE&gt;q; for(int i=1;i&lt;=k;i++) &#123;//序号1~k的那些飞机先进队列中 q.push(p[i]); &#125; long long sum=0; for(int i=k+1;i&lt;=n+k;i++) &#123; if(i&lt;=n) &#123;//让在k+1到n之间的飞机进到队列里，然后大于n的时候，就不能进队了 q.push(p[i]); &#125; NODE now=q.top(); q.pop(); sum+=(long long) (i-now.i)*now.w;//计算改架飞机起飞的消耗 p[now.i].i=i;//重新标记起飞的序号 &#125; printf(&quot;%lld\\n&quot;,sum); for(int i=1;i&lt;=n;i++) &#123; printf(&quot;%d &quot;,p[i].i);//依次打印起飞飞机的序列 &#125; return 0;&#125; E-博弈 拆数游戏给你n次，每次给一个数x，两个对手进行拆数，其中每次可以将2以上的数拆成两个数，1不能继续拆了，谁不能继续拆的就算输。如例子 1 2 3；当到达2的位置时，先手把2拆成1 和1，因为第一个1不能继续拆了，所以先手赢，输出1； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859自己的错误解法：#include&lt;iostream&gt;using namespace std;const int maxn=100010;int a[maxn];int main()&#123; int n,tmp=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i]!=1)&#123; if(a[i]%2==1)&#123; //奇数 tmp+=2;//因为发现这一项为奇数的话，贡献的是偶数次 &#125;else &#123; tmp+=1;//偶数的话，贡献的是奇数次 &#125; if(tmp%2==0)&#123; cout&lt;&lt;&#x27;2&#x27;&lt;&lt;endl; &#125;else &#123; cout&lt;&lt;&#x27;1&#x27;&lt;&lt;endl; &#125; &#125;else&#123;//这样的话不对，因为前面有可能给你贡献的次数，这样的话 //你就不能当这一项为1的时候直接输出2 ，就是说a[0]没有算到下面的计算中 cout&lt;&lt;&#x27;2&#x27;&lt;&lt;endl; &#125; &#125; &#125;自己的正确解法：#include&lt;iostream&gt;using namespace std;const int maxn=100010;int a[maxn];int main()&#123; int n,tmp=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i]==1)&#123; &#125;else if(a[i]%2==1)&#123; //奇数 tmp+=2; &#125;else &#123; tmp+=1; &#125; if(tmp%2==0)&#123; cout&lt;&lt;&#x27;2&#x27;&lt;&lt;endl; &#125;else &#123; cout&lt;&lt;&#x27;1&#x27;&lt;&lt;endl; &#125; &#125;&#125; 因为一个数n最终能被拆n-1次，所以每次的贡献就为n-1（即可以取n-1次），所以判断这一项之前的贡献之和是偶数还是奇数就好了，奇数的话后手2赢，偶数的话就是先手1赢。 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;const int maxn=100010;int a[maxn];int main()&#123; int num,flag=0; cin&gt;&gt;num; for(int i=0;i&lt;num;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;num;i++)&#123; flag=flag+(a[i]-1)%2;//累计贡献 if(flag%2==0) cout&lt;&lt;2&lt;&lt;endl; else cout&lt;&lt;1&lt;&lt;endl; &#125;&#125; F- 模拟题意： 手机app产生未读消息，有n款app，对应三种事件，事件一，x号app产生一条新的未读消息。事件二，作者读了x号app的所有未读信息。事件三，作者读了最开始的t条消息，（这些就是按顺序产生的app消息，不管读没读，也有可能会读重）。每次事件后，都要输出当前的未读消息数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051方法一：比较繁琐#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define LL long long#define sz 300010using namespace std;struct info &#123; int id; bool vis;&#125; store[sz];//存放所有的消息 int amount[sz];//存放某种消息的总数 int pos[sz];//某种app未读消息的开始 vector &lt;int&gt; v[sz];//对应每个app产生的消息记录在store中的下标int main() &#123; int sum=0,n,q,a,b,p=0,cnt=0;//sum为未读消息的总数 scanf(&quot;%d%d&quot;,&amp;n,&amp;q); for(int i=0; i&lt;q; i++) &#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(a==1) &#123;//事件1 v[b].push_back(cnt); amount[b]++;//b这种app的消息总数++ sum++; store[cnt].vis=0; store[cnt].id=b; cnt++; &#125; if(a==2) &#123; sum-=amount[b];//b这种app的消息总数标记为全读 amount[b]=0; for(int j=pos[b]; j&lt;v[b].size(); j++) &#123; store[v[b][j]].vis=1;//因为v为一个int类型数组的数组 &#125; pos[b]=v[b].size();//将b这种app的未读的地方标记到末尾 &#125; if(a==3) &#123; for(int j=p; j&lt;b; j++) &#123;//把消息序列的前b条消息标记为已读 if(!store[j].vis) &#123; store[j].vis=1; sum--; amount[store[j].id]--; &#125; &#125; p=max(p,b);//不加这一句就会超时，因为每一次都要重新执行for循环 //p为指向的最大未读的地方 &#125; printf(&quot;%d\\n&quot;,sum); &#125; return 0;&#125; 方法二：设置一个sum队列，里面存放所有的消息序号；vis数组存放每个app相应的消息序号；used存放已经阅读过的消息的序号当读到事件2的时候，那么ans++；最终的结果就是cnt-ans； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;using namespace std;const int maxn = 3e5+5;queue&lt;int&gt; sum,vis[maxn];int used[maxn];int main()&#123; int n,q; cin&gt;&gt;n&gt;&gt;q; int ans = 0; int cnt = 0; int x,y; for(int i=1;i&lt;=q;i++) &#123; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); if(x==1) &#123; cnt++; vis[y].push(cnt); sum.push(cnt); &#125; else if(x==2) &#123; while(!vis[y].empty()) &#123; if(!used[vis[y].front()]) &#123; used[vis[y].front()] = 1; ans++; &#125; vis[y].pop(); &#125; &#125; else &#123; while(!sum.empty()&amp;&amp;sum.front()&lt;=y) &#123; if(!used[sum.front()]) &#123; used[sum.front()] = 1; ans++; &#125; sum.pop(); &#125; &#125; printf(&quot;%d\\n&quot;,cnt-ans); &#125; return 0;&#125; J-二维差分题意： 给你n和m，表示有一个nm的矩阵(nm&lt;&#x3D;1e7)都很大，不能直接开数组来做，用个vector来做才不会超内存，初始全0，接下来一个数p(p&lt;&#x3D;1e6)，接下来p个矩阵的左下角和右上角的坐标。把这位于这些矩阵内的格子置为1，再接下来一个数q(1&lt;&#x3D;1e6)，接下来q个矩阵的左下角和右上角的坐标，对于每个矩阵，如果它包含的每个格子都是1，则输出YES，否则输出NO。 思路：经典的二维前缀和。。。用前缀和的方法计算出每个格子是否被覆盖（p个矩阵都进行二维前缀和的加1更新操作，然后统计一遍前缀和即可得出每个格子是否被覆盖，大于等于1即为被覆盖）然后把被覆盖的格子都置为1，重新统计一遍前缀和（这时候前缀和就表示矩形(1,1,x,y)包含的被覆盖的格子数了）。方便我们接下来的判断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;//const int maxn=1e4;//int record[maxn][maxn],glass[maxn][maxn];//这么打就会内存超限的，所以用vector动态来存 int main()&#123; int n, m; while (~scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) &#123; int monitor, thieves; scanf(&quot;%d&quot;,&amp;monitor); int ldx, ldy, rux, ruy; vector&lt;vector&lt;int&gt; &gt; record(n + 2, vector&lt;int&gt;(m + 2)), glass(n + 2, vector&lt;int&gt;(m + 2)); //memset(record,0,sizeof(record)); //memset(glass,0,sizeof(glass)); while (monitor--) &#123;//因为record数组里这会全是0，所以可以当二维差分数组来用 //左上角x,y 右下角x,y scanf(&quot;%d%d%d%d&quot;,&amp;ldx,&amp;ldy,&amp;rux,&amp;ruy); ++record[ldx][ldy]; ++record[rux + 1][ruy + 1]; --record[ldx][ruy + 1]; --record[rux + 1][ldy]; &#125; for (int row = 1; row &lt;= n; ++row) &#123;//将有监控的地方标记出来，其中record[row][col]代表这个地方被几个监控监视到了 for (int col = 1; col &lt;= m; ++col) record[row][col] += record[row - 1][col] + record[row][col - 1] - record[row - 1][col - 1]; &#125; for (int row = 1; row &lt;= n; ++row) &#123;//这个就是最后的二维前缀和 for (int col = 1; col &lt;= m; ++col) glass[row][col] += glass[row - 1][col] + glass[row][col - 1] - glass[row - 1][col - 1] + (record[row][col] &gt; 0 ? 1 : 0); &#125; scanf(&quot;%d&quot;,&amp;thieves); while (thieves--) &#123; scanf(&quot;%d%d%d%d&quot;,&amp;ldx,&amp;ldy,&amp;rux,&amp;ruy); int area = glass[rux][ruy] - glass[rux][ldy - 1] - glass[ldx - 1][ruy] + glass[ldx - 1][ldy - 1]; //此时的area就是这一个区域中能被监控 监视到的地方 的数量的大小 if (area == (rux - ldx + 1) * (ruy - ldy + 1))//若两者相等，说明小偷偷的区域都能被监控监视到 printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); &#125; &#125;&#125; tips:二维差分DP[i][j]&#x3D;DP[i-1][j]+DP[i][j-1]-DP[i-1][j-1]+map[i][j] https://blog.csdn.net/ema1997/article/details/52151842 https://blog.csdn.net/LSD20164388/article/details/89412548 https://www.cnblogs.com/lmnx/archive/2012/05/03/2481217.html https://blog.csdn.net/zhaoxinfan/article/details/78001649 https://blog.csdn.net/qq_41703679/article/details/82192077https://blog.csdn.net/qq_32193741/article/details/81741951 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768raised enough money 筹集足够的钱biology n.（一个地区全部的）生物；生物学company n.公司；陪伴，同伴；连队vi.交往vt.陪伴ship n.船，舰；宇宙飞船；飞机 v.（用船、飞机、卡车）运送；遣送（某人）；colony n.殖民地；移民队；种群；动物栖息地closed loop 闭环，闭合环路adjacent adj.邻近的，毗连的rectangular adj.矩形的；成直角的array n.数组，阵列；排列 一系列；衣服 vt.排列，部署；打扮a rectangular array of black and white pixels（像素的复数）overlap v.与……重叠，与……互搭；n.重叠的部分，交接时期particularly adv.异乎寻常地；特别是；明确地consequently adv.因此；结果；所以For instance 例如encryption n.加密；加密术decryption n.[通信]解密；[计][通信]译码（解释编码的数据）rotation n.旋转；循环，轮流corresponding adj.相当的，相应的；一致的；通信的v.类似（correspond的ing形式）；相配indicate v.表明，要求；暗示；指示；标示；写明；简要陈述；显示（量度）； in charge of 负责；主管throughout adv.自始至终；遍及 prep.自始至终；遍及set up v.建立；装配；开业；竖立redundancy n.[计][数]冗余（等于redundance）；裁员；人浮于事spies n.间谍；密探（spy的复数形式）v.侦探，找出（spy的三单形式） blow up 爆发，爆炸；放大；使充气strike v.撞击；打；踢（球等）；突击；罢工；使打动；侵袭；undoubtedly adv.确实地，毋庸置疑地exact junction 准确的结点specifically adv.特别地；明确地removal n.免职；移动；排除；搬迁destroyed adj.被毁的，遭破坏的 v.破坏，摧毁； as small as possible 尽可能小consecutively adv.连续地corporate sponsors 公司的赞助者们consecutive adj.连贯的；连续不断的afterwards adv.后来；然后fractions n.[数]分数；小部分，片段（fraction的复数）Furthermore adv.此外；而且refrain vi.节制，克制；避免；制止 n.叠句，副歌；重复consumption n.消费；消耗；肺痨prospect n.前途；预期；景色 vi.勘探，找矿 1234567891011121314151617 题目考察的知识点：A：水题。B：水题、C：贪心D：二分E：博弈、F：模拟G：线型DPH：树的哈希I：线段树J：二维前缀和/差分、K：状压DPL：差分约束M：矩阵","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"新生训练","slug":"新生训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"博弈论汇总","slug":"博弈论汇总","date":"2020-01-30T10:08:00.000Z","updated":"2022-02-26T03:51:21.548Z","comments":true,"path":"2020/01/30/博弈论汇总/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/30/%E5%8D%9A%E5%BC%88%E8%AE%BA%E6%B1%87%E6%80%BB/","excerpt":"","text":"拆数游戏博弈 拆数游戏给你n次，每次给一个数x，两个对手进行拆数，其中每次可以将2以上的数拆成两个数，1不能继续拆了，谁不能继续拆的就算输。如例子 1 2 3；当到达2的位置时，先手把2拆成1 和1，因为第一个1不能继续拆了，所以先手赢，输出1； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859自己的错误解法：#include&lt;iostream&gt;using namespace std;const int maxn=100010;int a[maxn];int main()&#123; int n,tmp=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i]!=1)&#123; if(a[i]%2==1)&#123; //奇数 tmp+=2;//因为发现这一项为奇数的话，贡献的是偶数次 &#125;else &#123; tmp+=1;//偶数的话，贡献的是奇数次 &#125; if(tmp%2==0)&#123; cout&lt;&lt;&#x27;2&#x27;&lt;&lt;endl; &#125;else &#123; cout&lt;&lt;&#x27;1&#x27;&lt;&lt;endl; &#125; &#125;else&#123;//这样的话不对，因为前面有可能给你贡献的次数，这样的话 //你就不能当这一项为1的时候直接输出2 cout&lt;&lt;&#x27;2&#x27;&lt;&lt;endl; &#125; &#125; &#125;自己的正确解法：#include&lt;iostream&gt;using namespace std;const int maxn=100010;int a[maxn];int main()&#123; int n,tmp=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i]==1)&#123; &#125;else if(a[i]%2==1)&#123; //奇数 tmp+=2; &#125;else &#123; tmp+=1; &#125; if(tmp%2==0)&#123; cout&lt;&lt;&#x27;2&#x27;&lt;&lt;endl; &#125;else &#123; cout&lt;&lt;&#x27;1&#x27;&lt;&lt;endl; &#125; &#125;&#125; 因为一个数n最终能被拆n-1次，所以每次的贡献就为n-1（即可以取n-1次），所以判断这一项之前的贡献之和是偶数还是奇数就好了，奇数的话后手2赢，偶数的话就是先手1赢。 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;const int maxn=100010;int a[maxn];int main()&#123; int num,flag=0; cin&gt;&gt;num; for(int i=0;i&lt;num;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;num;i++)&#123; flag=flag+(a[i]-1)%2; if(flag%2==0) cout&lt;&lt;2&lt;&lt;endl; else cout&lt;&lt;1&lt;&lt;endl; &#125;&#125; nim游戏 平衡状态的概念： 引入一个概念，平衡状态，又称作奇异局势。当面对这个局势时则会失败。任意非平衡态经过一次操作可以变为平衡态。每个玩家都会努力使自己抓完石子之后的局势为平衡，将这个平衡局势留给对方。因此，玩家A能够在初始为非平衡的游戏中取胜，玩家B能够在初始为平衡的游戏中取胜。 玩法一（1堆n个石子每次最多取m个）： 显然，如果n&#x3D;m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果n&#x3D;（m+1）r+s，（r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走k（≤m)个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。 即，若n&#x3D;k(m+1)，则后取着胜，反之，存在先取者获胜的取法。n%(m+1)&#x3D;&#x3D;0. 先取者必败。* 这个游戏还可以有一种变相的玩法：两个人轮流报数，每次至少报一个，最多报十个，谁能报到100者胜。（&lt;&#x3D;&gt;从一堆100个石子中取石子，最后取完的胜） 最后一个奇异局势是n&#x3D;(0)。一种奇异局势是n&#x3D;(m+1)，那么无论我取走多少个，对 方都能够一次取走剩余所有的物品取胜。 奇异局势的判定： 一般的奇异局势是n&#x3D;(m+1)*i，其中i为自然数，即n%(m+1)&#x3D;0，面对这种情况无论我怎么取，对方总可以将其恢复为n%(m+1)&#x3D;0，一直到n&#x3D;(m+1)局势。 玩家的策略： 就是把当前面对的非奇异局势变为奇异局势留给对方。如果当前的石子个数为(m+1)*i+s，那么就将s个石子取走，使其达到奇异局势。 https://blog.csdn.net/acm_baihuzi/article/details/41622825","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}],"author":"aoyuehan"},{"title":"新生训练赛07_山师联赛2","slug":"新生训练赛07-山师联赛2","date":"2020-01-30T08:15:00.000Z","updated":"2022-02-26T03:52:52.023Z","comments":true,"path":"2020/01/30/新生训练赛07-山师联赛2/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/30/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83%E8%B5%9B07-%E5%B1%B1%E5%B8%88%E8%81%94%E8%B5%9B2/","excerpt":"","text":"A 矩阵的最大子矩阵的和 （二维前缀和||dp）123456789101112131415161718192021222324252627282930方法一：（二维前缀和）#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;int a[1001][1001];int main()&#123; int tt;scanf(&quot;%d&quot;,&amp;tt);//测试数量 int n,m,x,y;//在n行m列的矩阵中找一个x*y的子矩阵，使得子矩阵的和最大 while(tt--) &#123; scanf(&quot;%d%d%d%d&quot;,&amp;m,&amp;n,&amp;x,&amp;y); //memset(a,0,sizeof(a));在main函数外自动赋值为0 //memset函数的初始化只能对一维数组，对于每一行，是连续分配的； 然而对于各行之间，却不是连续非配的，容易出错 for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++)&#123; int t; scanf(&quot;%d&quot;,&amp;t); a[i][j]=a[i-1][j]+a[i][j-1]+t-a[i-1][j-1];// a[i][j]为二维前缀和 &#125; int ans=0; for(int i=x;i&lt;=m;i++) for(int j=y;j&lt;=n;j++) ans=max(ans,a[i][j]-a[i-x][j]-a[i][j-y]+a[i-x][j-y]);//遍历每一个x*y的矩阵，取最大值 printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; dp思想： 动态规划状态dp[i][j]代表长i宽j的矩阵的元素和。（dp[i][j]+&#x3D;dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]）假设要求找出x长y宽的最大子矩阵在i&gt;&#x3D;x且j&gt;&#x3D;y的矩阵中找的话，dp[i][j]就是包含a[i][j]元素的子矩阵的元素和，则dp[i][j]-dp[i][j-y]-dp[i-x][j]+dp[i-x][j-y]（上面这个式子用到了容斥原理，加上删了两次的那一部分，即dp[i-x][j-y]）就是dp[i][j]中x长y宽的子矩阵的元素和（右下角元素为a[i][j]） 123456789101112131415161718192021222324252627282930313233方法二（动态规划的方法）：#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;int dp[1010][1010];int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; memset(dp,0,sizeof(dp)); int n,m,x,y; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;x,&amp;y); int ans=0; for(int i=1;i&lt;=n;i++) //不从零开始，为下面存dp提供方便 &#123;//要注意此时变量从1开始比较简便 for(int j=1;j&lt;=m;j++) &#123; scanf(&quot;%d&quot;,&amp;dp[i][j]); dp[i][j]+=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];//将map[i][j]的左上角所有元素和存起来 if(i&gt;=x&amp;&amp;j&gt;=y)//注意这里 ans=max(ans,dp[i][j]-dp[i-x][j]-dp[i][j-y]+dp[i-x][j-y]);//以i、j为角标，左上角x*y的矩形之和 &#125; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; B 最短路径+费用最少（典型） 给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。Input 输入n,m，点的编号是1~n,然后是m行，每行4个数 a,b,d,p，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 s,t;起点s，终点。n和m为0时输入结束。 (1&lt;n&lt;&#x3D;1000, 0&lt;m&lt;100000, s !&#x3D; t)Output 输出 一行有两个数， 最短距离及其花费。 思路：其实题目要求的只是最短路径，而那个费用是再这条路径上的最少费用。这里要注意的是：两个点中可以有重边，特别是最短的路径的重边，应为我们求的时候只求第一个最小的的路径（以后在遇到相同的最小路径的时候就不会换值），而这条路径不能保证费用最小。所以当路径最小时，还要判断费用是不是最小，从而换值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;using namespace std;const int M=1100;//最多点数const int INF=1&lt;&lt;30;struct djs&#123; int l,p;&#125;d[M],g[M][M];bool used[M];//标记i是否被用过void init(int n)&#123; int i, j; for (i = 1; i &lt;= n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; g[i][j].l = INF;//初始化图没有边，默认为INF,为了一定更新 g[i][j].p = INF; &#125; &#125; for (i = 1; i &lt;= n; i++) &#123; d[i].l = INF; d[i].p = INF; &#125; memset(used, 0, sizeof(used));&#125;int dijkstra(int star, int end, int n)//起点，终点，总点数(编号为1,2...n)&#123; int min_num;//最小值的位置 int i; d[star].l= 0; d[star].p= 0;//起点到起点的最短距离为0，很重要的一步 for (int cnt = 0; cnt &lt; n; cnt++)//注意别用while(n--),这样会改变n的值。n次贪心 &#123; int min = INF; for (i = 1; i &lt;= n; i++) &#123; if (!used[i] &amp;&amp; d[i].l &lt; min) &#123; min = d[i].l; min_num = i; &#125; &#125; used[min_num] = 1; //把d[min_num]作为中间点，对相邻的点做松弛 for (i = 1; i &lt;= n; i++) &#123; if (!used[i] &amp;&amp; d[i].l &gt; d[min_num].l + g[min_num][i].l) &#123; d[i].l = d[min_num].l + g[min_num][i].l; d[i].p = d[min_num].p + g[min_num][i].p; &#125; if (!used[i] &amp;&amp; d[i].l == d[min_num].l + g[min_num][i].l &amp;&amp; d[i].p &gt; d[min_num].p + g[min_num][i].p) //这里的判断是关键 &#123; d[i].p = d[min_num].p + g[min_num][i].p; &#125; &#125; &#125; return d[end].l;&#125;int main()&#123; int n, m; int i, j; while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n + m) &#123; init(n); for (i = 0; i &lt; m; i++) &#123; int a, b, c, c1; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;c1); if (g[a][b].l &gt; c) &#123; g[b][a].l = g[a][b].l = c; g[b][a].p= g[a][b].p = c1; &#125;//此题为无向图 if (g[a][b].l == c &amp;&amp; g[b][a].p &gt; c1)//这里的判断是关键 &#123; g[b][a].p= g[a][b].p = c1; &#125; &#125; int star, end,ans; scanf(&quot;%d%d&quot;, &amp;star, &amp;end); ans = dijkstra(star, end, n); printf(&quot;%d %d\\n&quot;, ans, d[end].p); &#125; return 0;&#125; C 通过语言选电影（离散化和排序）题意：给出不同专家会的语言的序列，然后给出每部电影的主语言和副语言，然后求电影（看懂的专家数量最多的电影）是哪个tips：因为不离散化的话，数据太大，表示不了用map的原因是数组开不到1e9，会报错 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;map&lt;int,int&gt;s; struct p&#123;//结构体代表一个人 int b;//主语言的序号 int c;//副语言的序号 int t1; int t2;//副语言看懂的专家数量 int num;//对应电影的序号&#125;P[200009]; bool cmp(p X,p Y)&#123; if(X.t1==Y.t1) return X.t2&gt;Y.t2; else return X.t1&gt;Y.t1;&#125;int main()&#123; //memset(s,0,sizeof(s)); int n,t,m; scanf(&quot;%d&quot;,&amp;n);//专家的人数 for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;t);//t是某一种语言的序号 s[t]++; //s数组对应着每种语言 专家懂的人数 &#125; scanf(&quot;%d&quot;,&amp;m);//电影的数量 for(int i=1;i&lt;=m;i++) &#123;//主语言 scanf(&quot;%d&quot;,&amp;P[i].b); P[i].num=i; &#125; for(int i=1;i&lt;=m;i++) &#123;//副语言 scanf(&quot;%d&quot;,&amp;P[i].c); &#125; for(int i=1;i&lt;=m;i++) &#123; P[i].t1=s[P[i].b];//此时t1为第i钟语言支持的人数 P[i].t2=s[P[i].c]; &#125; sort(P+1,P+m+1,cmp); cout&lt;&lt;P[1].num&lt;&lt;endl; return 0;&#125; tips：（离散化）离散化处理离散化是对一堆元素进行操作，通过改变他们的大小，但不改变他们的大小关系，这种做法往往可以节省空间，减低时空复杂度；对于一些数量较少，但数值较大或者可能出现负数这种难以处理的数据，自身无法作为数组的下标保存对应的属性，如果这时只是需要这些数据的相对属性， 那么可以对其进行重新赋值，即进行离散化处理。本题中那个语言的序号很大，可以用map来存一下，但我只对应到某一个P结构体中，不用考虑全部的语言种类 离散化的方式：一般离散化分为两种：1.一种是对付有重复元素的离散化。2.另一种是对付无重复元素的离散化（复杂度低于第一种）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970第一种：#include &lt;bits/stdc++.h&gt;using namespace std;bool cmp(int a,int b)&#123; return a&lt;b;&#125;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int a[n+4],t[n+4]; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); t[i]=a[i]; &#125; sort(t+1,t+1+n,cmp); int m=unique(t+1,t+1+n)-(t+1);//unique(t+1,t+1+n)是去重后数组的末地址，（t+1）是初始地址。 for(int i=1;i&lt;=m;i++)//注意m是最后一个不相同值的位置 &#123; printf(&quot;%d &quot;,t[i]);//t数组就是去重之后相应的数据 &#125; return 0; /*例子： 81 3 2 1 3 5 3 21 2 3 5 */ &#125;第二种： const int N=1e5+7; struct Node&#123; int v,id; bool operator &lt; (const Node a)const&#123; return v&lt;a.v;&#125;//排序用 &#125;a[N]; int n,rank[N]; int main() &#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i].v;//存值 a[i].id=i;//结构体的id用来存放原来的位置 &#125; sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) rank[a[i].id]=i; &#125; 这种方法直接用结构体存储原本的数列的元素的位置，然后排序以后将他们再重新赋值。那么rank[]就是结构体a[]离散化后的结果。举例：v: 3 6 5 10 8id:1 2 3 4 5排序以后：v: 3 5 6 8 10id:1 3 2 5 4所以离散化以后：v: 3 5 6 8 10id:1 3 2 5 4rk:1 2 3 4 5在按原来的顺序排列：v: 3 6 5 10 8rk:1 3 2 5 4 D 拓扑排序题目大意：给出n组数据，前面的的序号表示这个任务先于后面序号的任务，例如：i j，这样就会有一条i –&gt;j的路径，要求将任务先后排序（不一定有一种，单输出一种就可以）解题思路：拓扑排序，先将数据存成有向图，遍历，输出入读为0的点，并且将该点所有出入抹掉。再遍历，知道所有点都已经输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 方法一：设计一个in数组来存放入度大小，从而容易找到入度为0 的点#include&lt;iostream&gt;#include&lt;cstring&gt;#define ms(a) memset(a,0,sizeof(a))using namespace std;const int maxn=1e3+10;int n,m;int a[maxn][maxn];int in[maxn];//存放入度的大小void toposort()&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; if(in[j]==0)&#123; in[j]--; if(i!=n)&#123; cout&lt;&lt;j&lt;&lt;&#x27; &#x27;; &#125; else&#123; cout&lt;&lt;j&lt;&lt;endl; &#125; for(int k=1;k&lt;=n;k++)&#123; if(a[j][k]) in[k]--;//让以j为起点的边的终点的入度--，就是把这条边给删去 &#125; break; &#125; &#125; &#125;&#125;int main()&#123; std::ios::sync_with_stdio(false); int x,y; while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n||m) &#123; ms(a); ms(in); for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;x&gt;&gt;y; // if(!a[x][y])&#123; a[x][y]=1; in[y]++; // &#125; &#125; toposort(); &#125;&#125;方法二：设计一个judge函数，来找到有向图中入度为0的点，输出该点之后把以该点为起点的有向路径置为0 ，然后依次输出入度为0的点 。#include&lt;iostream&gt;#include&lt;string.h&gt;#define N 105using namespace std;int m, n, cnt;int map[N][N], bo[N];int judge(int k)&#123;//判断k这个点是不是入度为0的点 for (int i = 1; i &lt;= n; i++) if (map[i][k]) return 0; return 1;&#125;int main()&#123; while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n || m)&#123; // Init. memset(map, 0, sizeof(map)); memset(bo, 0, sizeof(bo)); cnt = 0; // Read. for (int i = 0; i &lt; m; i++)&#123; int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); map[a][b] = 1; &#125; // Handle. while (cnt &lt; n)&#123; for (int i = 1; i &lt;= n; i++)&#123;//n是点数，m是边数 if (bo[i]) continue;//如果i这个点已经删去了 if (judge(i))&#123; if (cnt) printf(&quot; &quot;); printf(&quot;%d&quot;, i); bo[i] = 1;//标记这个点已经删去了 cnt++;//记录打印出来的数的个数 for(int j=1;j&lt;=n;j++)&#123; if(map[i][j])map[i][j]=0; &#125; break; &#125; &#125; &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 有一道例题，讲离散化，排序如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;const int Kmax=500000+10;//数组开小了int num[Kmax];int temp[Kmax];int sum[Kmax];int n;map&lt;int,int&gt; mp;inline int lowbit(int x)&#123; return x&amp;-x;&#125;int getsum(int x)&#123; int res=0; for(;x;x-=lowbit(x))&#123; res+=sum[x]; &#125; return res;&#125;void insert(int x)&#123; for(;x&lt;=n;x+=lowbit(x))&#123; sum[x]++; &#125;&#125; int main()&#123; long long ans=0; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;num[i]); &#125; copy(num,num+n,temp); sort(temp,temp+n); int m=unique(temp,temp+n)-temp;//去重 for(int i=0;i&lt;m;i++)//数据离散化 &#123; mp[temp[i]]=i+1;//i+1就是离散化之后该数对应的值 &#125; insert(mp[num[n-1]]);//从后往前插入数据 for(int i=n-2;i&gt;=0;i--) &#123; ans+=getsum(mp[num[i]]);//统计当前数比后面几个数大 insert(mp[num[i]]); &#125; printf(&quot;%lld\\n&quot;,ans); //爆int return 0;&#125; E 线段树的加乘变求和一个序列，进行四中操作1、某一段加上c2、某一段乘c3、某一段变为c4、求某一段的和 1 F方法一：分类讨论先求出所有正数的和，这个和一定是最大的，偶数减奇数还是奇数，他要是奇数就输出啊，因为已经最大了所以就是找奇数了，如果找负数的话，当然是最大的那个奇数了，这个数你没有加过，要加的。如果找偶数，当然是最小的奇数了，这个数你加过了，要减去因为存在全是正或全是负的数列，所以max一下找到最大值即可方法二：DP思想 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455方法一：#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int s=0; int mi=1&lt;&lt;30; int ma=-1&lt;&lt;30; for(int i=0;i&lt;n;i++) &#123; int t; scanf(&quot;%d&quot;,&amp;t); if(t&gt;0) s+=t; if(t&lt;0&amp;&amp;t%2&amp;&amp;t&gt;ma) ma=t; if(t&gt;0&amp;&amp;t%2&amp;&amp;t&lt;mi) mi=t; &#125; if(s%2==0) cout&lt;&lt;max(s-mi,s+ma)&lt;&lt;endl; else cout&lt;&lt;s&lt;&lt;endl;&#125;方法二：没看懂？？？？？？#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define pii pair&lt;int,int&gt;#define pll pair&lt;ll,ll&gt;#define PB push_back#define MP make_pair#define N 100001int dp[N][2];int main()&#123; int n; for(int x = 0; x &lt; 2; x++) dp[0][x] = INT_MIN / 2; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++)&#123; int a; scanf(&quot;%d&quot;, &amp;a); int x = (a % 2 != 0); for(int y = 0; y &lt; 2; y++)&#123; int k = (x + y) % 2; dp[i][k] = max(dp[i - 1][k], dp[i - 1][y] + a); &#125; dp[i][x] = max(dp[i][x], a); &#125; printf(&quot;%d\\n&quot;, dp[n][1]); return 0;&#125; G 两个串相互变化题意：给你两个串s和t，其中串的前后字符可以相互覆盖（s，t两个串都可以变化），如aabc对于第三位字母b可变为abbc或aabb，问通过多次的变化后，s和t是否可以相同解题：s和t都能变, 直接判断是否有相同的即可. 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;string.h&gt; using namespace std;int const maxn=110;char s[maxn],t[maxn];int main()&#123; int q=0; bool flag=false; cin&gt;&gt;q;getchar(); while(q--)&#123; gets(s); gets(t); int len=strlen(s); for(int i=0;i&lt;len;i++)&#123; for(int j=0;j&lt;len;j++)&#123; if(s[i]==t[j])&#123; flag=true; break; &#125; &#125; if(flag==true)&#123; break; &#125; &#125; if(flag)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; flag=false; &#125; &#125; HI-补图，最短路径这一题给出点的个数n，m条权为a的边，剩下的边为权值b。求起点1到终点n的最短路径（无向图）。这一题因为点的集合太大了，超过1e4，用迪杰斯特拉和spfa都会超时，或者内存超限；把权值为a的看做为原图，剩下的权值为b的边就相当于补图补 其中借鉴这种做法，分情况讨论1~n之间的路径如果 1 和 n 之间连边为 a ，那么答案一定为 a 与一条最短的全由b组成的路径的较小者，如果 1 和 n 之间连边为b，那么答案一定 为b和一条最短的全由a组成的路径的较小者。对于第1种情况直接bfs就可以，第二种情况由于边数较多，不能直接bfs 从1开始搜索与其相连的边权为b的边，用set维护一下，由于每个点只入队1次，复杂度算是 nlogn 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266方法一：分类讨论的思想# include &lt;iostream&gt;# include &lt;queue&gt;# include &lt;set&gt;# include &lt;algorithm&gt;using namespace std;inline int scan() &#123; int x=0,f=1; char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;) f=-1; ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;; ch=getchar();&#125; return x*f;&#125;inline void Out(int a) &#123; if(a&lt;0) &#123;putchar(&#x27;-&#x27;); a=-a;&#125; if(a&gt;=10) Out(a/10); putchar(a%10+&#x27;0&#x27;);&#125;# define MX 100005/**************************/struct Edge&#123; int v,nex;&#125;edge[MX&lt;&lt;1];//这样边就会够 int n,m,a,b,ip;int hlist[MX];LL dis[MX];bool vis[MX];void addedge(int u,int v)&#123; edge[ip]= (Edge)&#123;v,hlist[u]&#125;; hlist[u]=ip++; edge[ip]= (Edge)&#123;u,hlist[v]&#125;; hlist[v]=ip++;&#125;void bfsB() // 1-n 连b边&#123; dis[n]=INF; memset(vis,0,sizeof(vis)); queue&lt;int&gt; Q; Q.push(1); dis[1]=0; vis[1]=1;//先访问1，将其入队 while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int i=hlist[u];i!=-1;i=edge[i].nex)//连向星表示，遍历每一条边 &#123; int v = edge[i].v; if (!vis[v]) &#123; dis[v]=dis[u]+1;//为了 找到1~n有多少个a连同的边 Q.push(v); vis[v]=1; &#125; &#125; if (dis[n]!=INF) break; &#125; printf(&quot;%lld\\n&quot;,min(dis[n]*a,(LL)b));&#125;void bfsA() //1-n 连 a 边&#123; dis[n]=INF; set&lt;int&gt; st,ts; for (int i=2;i&lt;=n;i++) st.insert(i);//st中存了所有的点 set&lt;int&gt;::iterator it; queue&lt;int&gt; Q; Q.push(1); dis[1]=0; while (!Q.empty()) &#123; int u = Q.front(); Q.pop(); for (int i=hlist[u];i!=-1;i=edge[i].nex) &#123; int v=edge[i].v; if (st.count(v)==0) continue; st.erase(v); ts.insert(v);//因为最初加的是权值为a的边，现在遍历一遍，把这些权值为a的边的终点删去 &#125; for (it=st.begin();it!=st.end();it++)//遍历去除权值为a的边的终点后，剩下的边权值就为b &#123; dis[*it] = dis[u]+1;//然后找从起点到终点权值为b的边的条数 Q.push(*it); &#125; if (dis[n]!=INF) break; st.swap(ts);//把权值为a的边重新赋值到st中，然后重复上述操作对队列中的下一个点进行操作 ts.clear(); &#125; printf(&quot;%lld\\n&quot;,min(dis[n]*b,(LL)a));&#125;int main()&#123; while(scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;a,&amp;b)!=EOF) &#123; memset(hlist,-1,sizeof(hlist)); ip=0; bool flag=0; for (int i=0;i&lt;m;i++) &#123; int u = scan(); int v = scan(); addedge(u,v);//只把权值为a的边加进了边的集合 if (u&gt;v) swap(u,v); if (u==1&amp;&amp;v==n) flag=1; &#125; if (flag) &#123; if (a&lt;b) printf(&quot;%d\\n&quot;,a); else bfsA(); &#125; else &#123; if (b&lt;a) printf(&quot;%d\\n&quot;,b); else bfsB(); &#125; &#125; return 0;&#125;方法二：迪杰斯特拉算法 内存超限#include&lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3f#define maxn 10000#define sf scanf#define pf printfusing namespace std;int n,m,x,y,z; //n个城市和m条道路int mp[maxn][maxn],lowcost[maxn],vis[maxn],pre[maxn];void dijkstra(int sta,int edd) &#123; memset(vis,0,sizeof(vis)); memset(pre,0,sizeof(pre)); memset(lowcost,0,sizeof(lowcost)); for(int i=0; i&lt;n; i++) lowcost[i]=mp[sta][i]; vis[sta]=1; lowcost[sta]=0; //寻找距离原点最小的点加进集合 （除原点） for(int i=1; i&lt;n; i++) &#123; int Min=inf; int v=-1; for(int j=0; j&lt;n; j++) &#123; if(!vis[j]&amp;&amp;lowcost[j]&lt;Min) &#123; Min=lowcost[j]; v=j; &#125; &#125; //如果又一次更新失败退出此次循环 if(Min==inf) &#123; break; &#125; vis[v]=1; //用新加进来的点松弛 for(int k=0; k&lt;n; k++) &#123; if(!vis[k]&amp;&amp;lowcost[v]+mp[v][k]&lt;lowcost[k]) &#123; lowcost[k]=lowcost[v]+mp[v][k]; pre[k]=v; &#125; &#125; &#125;&#125;int main() &#123; int a1,b1; while(sf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;a1,&amp;b1)) &#123; for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) &#123; mp[i][j]=b1; &#125; mp[i][i]=0; &#125; for(int i=0; i&lt;m; i++) &#123; sf(&quot;%d%d&quot;,&amp;x,&amp;y); mp[x-1][y-1]=mp[y-1][x-1]=a1;//下标在序号的基础上-1了 &#125; dijkstra(0,n-1); pf(&quot;%d\\n&quot;,lowcost[n-1]); &#125;&#125;方法三：spfa算法 时间超限#include &lt;iostream&gt;#include&lt;queue&gt;#include&lt;string.h&gt;#define inf 0x3f3f3f3fusing namespace std;const int M=10005;//点的个数 struct A&#123; int end,value,next;&#125;a[M&lt;&lt;1];//因为是无向图，所以可以把边的集合扩大到边的两倍，即n(n-1)/2 int head[M],cnt=0;//链式前向星数组int vis[M],inqueue[M];void add(int x,int end,int k)//链式前向星，加入节点&#123; a[cnt].end=end, a[cnt].value=k, a[cnt].next=head[x]; head[x]=cnt++;//注意：先赋值后cnt++ &#125;bool SPFA(int s,int n)&#123; queue &lt;int&gt; q; memset(vis,inf,sizeof(vis)); memset(inqueue,0,sizeof(inqueue)); vis[s]=0;//初始化距离 inqueue[s]=1;//标记s节点（起点）在队列，队列次数+1 q.push(s); while(!q.empty()) &#123; int x=q.front(); q.pop();//出队 inqueue[x]=0;//标记不在队列 for(int i=head[x]; ~i; i=a[i].next)//遍历与x节点连通的点 &#123; int end=a[i].end; if(vis[end]&gt;vis[x]+a[i].value)//更新 &#123; vis[end]=vis[x]+a[i].value; if(!inqueue[end]) &#123; q.push(end); inqueue[end]=1; &#125; &#125; &#125; &#125; return true;&#125;int main()&#123; int n,m; int a1,b1; while(scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;a1,&amp;b1))&#123; cnt=0; memset(head,-1,sizeof(head)); struct b&#123; int s,end; &#125;b[m]; for(int i=1;i&lt;=m;i++) &#123; scanf(&quot;%d%d&quot;,&amp;b[i].s,&amp;b[i].end) ; &#125; int flag=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; for(int k=0;k&lt;m;k++)&#123; if((b[i].s==i&amp;&amp;b[i].end==j)||(b[i].end==i&amp;&amp;b[i].s==j))&#123; flag=1;break; &#125; &#125; if(flag)&#123; add(i,j,a1); &#125;else&#123; add(i,j,b1); &#125; flag=0; &#125; &#125; SPFA(1,n); printf(&quot;%d\\n&quot;,vis[n]); &#125;&#125; J - 【差分】题意：N个气球排成一排，从左到右依次编号为1,2,3….N.每次给定2个整数a b(a &lt;&#x3D; b),lele便为骑上他的“小飞鸽”牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？Input 每个测试实例第一行为一个整数N,(N &lt;&#x3D; 100000).接下来的N行，每行包括2个整数a b(1 &lt;&#x3D; a &lt;&#x3D; b &lt;&#x3D; N)。 当N &#x3D; 0，输入结束。Output 每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。 区间和，前缀和都可以用树状数组来解决 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include&lt;string.h&gt;typedef long long ll;using namespace std;int n,m;int c[100005]=&#123;0&#125;; //对应差分数组和树状数组//本题是差分（因为原来都是0，所以差分数组也全为0）和树状数组的结合 /*树状数组（可以拓展为二维矩阵的区间求和）本身是用来求前多少项的和，此时支持，单点修改，区间查询树状数组结合差分思想：用来区间修改，单点查询*/ int lowbit(int x)&#123; return x&amp;(-x);&#125;void updata(int i,int k)&#123; //在i位置加上k while(i &lt;= n)&#123; c[i] += k; i += lowbit(i); &#125;&#125;int getsum(int i)&#123; //求D[1 - i]的和，即A[i]值 int res = 0; while(i)&#123; res += c[i]; i -= lowbit(i); &#125; return res;&#125;int main()&#123; while(scanf(&quot;%d&quot;,&amp;n)&amp;&amp;n!=0)&#123; m=n; memset(c,0,sizeof(c));//区间修改的话，认为该树状数组就是差分之后的值 while(m--)&#123; int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); updata(a,1);//若a==b 则为单点修改，否则为区间修改 updata(b+1,-1); &#125; for(int i=1;i&lt;=n;i++)&#123;//一定要注意树状数组的下标从1开始 if(i==n)printf(&quot;%d\\n&quot;,getsum(i));//单点查询，区间查询就相当于两个单点查询 else printf(&quot;%d &quot;,getsum(i)); &#125; &#125;&#125; K-二分查找答案方法一：（二分搜答案）题目描述：给定一个正整数数列，数列的个数为n，求一个平均数最大的、长度不小于F的子段。解法：二分答案，判定是否存在一个长度不小于F的子段，平均数不小于二分的值。如果把数列中的每个数都减去二分的值，就转换为判定“是否存在一个长度不小于F的子段，子段和非负”。求一个子段，它的和最大，子段的长度不小于F。子段和可以转换为前缀和相减的形式，即设sumj表示Ai~Aj的和。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline int read()&#123; int x=0,f=1;char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125; return x*f;&#125;const int N=100000+10;const double eps=1e-5;int n,f,cows[N];double sum[N];//sum数组存放的是每个区域的奶牛-二分后平均的前缀和 bool check(double avg)&#123; for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+cows[i]-avg; double minv=0; for(int i=0,j=f;j&lt;=n;i++,j++)&#123; minv=min(minv,sum[i]); if(sum[j]&gt;=minv)return true;//其实就是判断sum[j]-minv是否大于0 //如果这地方有一个长度为j（j是大于F的）那么 //就可以继续在右边二分，知道找到那个不能继续二分的边界 &#125; return false;&#125;int main()&#123; n=read();f=read(); for(int i=1;i&lt;=n;i++)cows[i]=read(); double l=0,r=2000; while(r-l&gt;eps)&#123;//二分平均值来的到结果 double mid=(l+r)/2; if(check(mid))l=mid;//如果mid中存在长度大于F的段，那么应该增大二分的平均值 else r=mid;//mid太大了，不存在符合要求的F，那么在左边界中找 &#125; printf(&quot;%d\\n&quot;,int(r*1000)); return 0;&#125; 方法二：（递推求结果）问题等同于给一个数组，求数组中连续K（K&gt;&#x3D;F）个元素最大的平均值。设b[i]为以第i个元素结束的子段（长度&gt;&#x3D;F）的最大平均值，c[i]表示这个子段的元素个数。n[i]为以i结束的长度为F的子段的平均值。该问题的解就是b[i]中的最大值。得到一个递推式：b[i]&#x3D;Max( b[i-1]*c[i-1]+a[i]&#x2F;(c[i-1]+1),n[i]&#x2F;F); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;using namespace std;int a[100001];//a[i]double b[100001];//b[i]表示以第i个元素结尾的子段的最大平均值int n[100001];//n[i]表示以第i个元素结尾的长度为F的子段和int c[100001];//c[i]表示以第i个元素结尾的最大平均值子段的元素个数int Max(int a,int b)&#123; return a&gt;b?a:b;&#125;int main()&#123; int N,F; cin&gt;&gt;N&gt;&gt;F; int i; for(i=1;i&lt;=N;++i) cin&gt;&gt;a[i]; n[F]=0; for(i=1;i&lt;=F;++i) n[F]+=a[i]; for(i=F+1;i&lt;=N;++i) &#123; n[i]=(n[i-1]-a[i-F]+a[i]); &#125; b[F]=(double)n[F]/F; c[F]=F; for(i=F+1;i&lt;=N;++i) &#123; double temp; temp=(b[i-1]*c[i-1]+a[i])/(c[i-1]+1); double temp2=(double)n[i]/F; if(temp&gt;temp2) &#123; b[i]=temp; c[i]=c[i-1]+1; &#125; else &#123; b[i]=temp2; c[i]=F; &#125; &#125; int iMax=0; double dMax=0; for(i=F;i&lt;=N;++i) &#123; if(dMax&lt;b[i]) dMax=b[i]; &#125; iMax=dMax*1000; cout&lt;&lt;iMax&lt;&lt;endl; return 0;&#125; LM补【CF1016B】Segment Occurrences（一维前缀和、substr函数）题意：给出一个长度为n的字符串，和长度为m子串，进行q次查询，每次查询给出一个区间，求出每个区间里共有几个子串。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970方法一：（前缀和思想 ；否则查询一次，找一次会超时的）#include&lt;iostream&gt;#include&lt;string&gt;#define N 100001using namespace std;int pos[N];int sum[N];int main()&#123; int s,t,q; string str1,str2; cin&gt;&gt;s&gt;&gt;t&gt;&gt;q; cin&gt;&gt;str1&gt;&gt;str2; for(int i=0;i&lt;s;i++) &#123; for(int j=0;j&lt;t;j++) &#123; if(str1[i+j]!=str2[j])//如果不是子串则退出 break; else if(j==t-1)//记录串二首字母在串一中的位置 pos[i]=1; &#125; &#125; sum[0]=pos[0]; for(int i=1;i&lt;s;i++) //串1的前i个字符中串2出现的次数 sum[i]=sum[i-1]+pos[i]; while(q--) &#123; int l,r; cin&gt;&gt;l&gt;&gt;r;//从1开始，但是pos从0开始的 if(t&gt;s) cout&lt;&lt;0&lt;&lt;endl; else if(r-l+1&lt;t)//r-l+1即为这个区间的长度 cout&lt;&lt;0&lt;&lt;endl; else cout&lt;&lt;sum[r-t]-sum[l-2]&lt;&lt;endl; //此时不应该为sum[r]-sum[l],因为sum从0开始存，而且sum右边界应该为sum[r-t] &#125; return 0;&#125;方法二：（substr函数，可优化为前缀和）#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;int s[1005];int main()&#123; int l1,l2,n,m,i,a,b,num; string s1,s2; memset(s,0,sizeof(s)); cin&gt;&gt;l1&gt;&gt;l2&gt;&gt;n; cin&gt;&gt;s1&gt;&gt;s2; for(i=0;i&lt;=l1-l2;i++) //提前查找出所有子串的位置，以防查询次数过多导致超时 if(s1.substr(i,l2)==s2) s[i]=1; while(n--) &#123; num=0; cin&gt;&gt;a&gt;&gt;b; for(i=a-1;i&lt;=b-l2;i++) if(s[i]) num++; cout&lt;&lt;num&lt;&lt;endl; &#125; return 0;&#125; poj1201就是一个差分约束问题，也是一个贪心？？？？spfa算法 tips: 123456789101112131415161718conference n.会议；讨论；协商；联盟； vi.举行或参加（系列）会议attended v.参加；注意；照料（attend的过去分词）；伴随enumerate vt.列举；枚举；计算distinct adj.明显的；独特的；清楚的；有区别的subtitles 副标题odd 奇数的derived from 源于block n.块；街区；大厦；障碍物 vt.阻止；阻塞bidirectional adj.双向的；双向作用的assign vt.分配；指派；[计][数]赋值vi.将财产过户 123456789101112131415161718192021222324252627A：前缀和B：最短路C：离散化D：拓扑排序 E：线段树F：水题G：水题H：水题I：补图J：K：二分L：水题M：贪心https://blog.csdn.net/The___Flash/article/details/103939848","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"新生训练","slug":"新生训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"链式前向星和SPFA算法","slug":"链式前向星和SPFA算法","date":"2020-01-29T10:01:00.000Z","updated":"2022-02-26T03:52:51.339Z","comments":true,"path":"2020/01/29/链式前向星和SPFA算法/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/29/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E5%92%8CSPFA%E7%AE%97%E6%B3%95/","excerpt":"","text":"链式前向星 123456789101112131415161718192021222324252627282930313233用链式前向星表示该有向图（无向图同理）：输入边的顺序如下：1 22 33 41 34 11 54 5对于邻接表来说是这样的：1 -&gt; 2 -&gt; 3 -&gt; 52 -&gt; 33 -&gt; 44 -&gt; 1 -&gt; 55 -&gt;^对于链式前向星来说是这样的：edge[0].to = 2; edge[0].next = -1; head[1] = 0;edge[1].to = 3; edge[1].next = -1; head[2] = 1;edge[2].to = 4; edge[2],next = -1; head[3] = 2;edge[3].to = 3; edge[3].next = 0; head[1] = 3;edge[4].to = 1; edge[4].next = -1; head[4] = 4;edge[5].to = 5; edge[5].next = 3; head[1] = 5;edge[6].to = 5; edge[6].next = 4; head[4] = 6;（以起点为1举例）:head[1] = 5 （以1为起点的第一条边的位置） -&gt; edge[5].to = 5 （终点） -&gt; edge[5].next = 3（同一起点下一条边的位置） -&gt;edge[3].to = 3（第二条边的终点） -&gt; edge[3].next = 0 -&gt; edge[0].to = 2(第三条边的终点） -&gt;edge[0].next = -1 （没下一条边）简化来说就是：1 -&gt; 5 -&gt; 3 -&gt; 2可以看到链式前向星和邻接表除了顺序不一样，其他的可以说是一样的。 123456789101112131415161718192021222324252627const int maxn = 10005; //点的最大个数int head[maxn], cnt=0;//head用来表示以i为起点的第一条边存储的位置，cnt读入边的计数器struct Edge&#123; int next; //同一起点的上一条边的储存位置 int to; //第i条边的终点 int w; //第i条边权重&#125;;Edge edge[maxn];void add(int u,int v,int w) //读入边&#123; edge[cnt].w = w; edge[cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt++;&#125;void read() //遍历所有边&#123; for(int i=0; i&lt;=n; i++) for(int j=head[i]; j！=-1; j=edge[j].next)&#123; 要访问的节点=edge[j].to; &#125;&#125; SPFA求最短路径算法优点： 1.时间复杂度比普通的Dijkstra和Ford低。 2.能够计算负权图问题。 3.能够判断是否有负环 (即：每跑一圈，路径会减小，所以会一直循环跑下去)。 算法思想： 我们用数组记录每个结点的最短路径估计值，用邻接表来存储图G。 我们采取的方法是动态逼近法： 1.设立一个先进先出的队列用来保存待优化的结点。 2.优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。 3.这样不断从队列中取出结点来进行松弛操作，直至队列空为止期望的时间复杂度O(ke)， 其中k为所有顶点进队的平均次数，可以证明k一般小于等于2。 实现方法： 1.存入图。可以使用链式前向星或者vocter。 2.开一个队列，先将开始的节点放入。 3.每次从队列中取出一个节点X，遍历与X相通的Y节点，查询比对 Y的长度 和 X的长度+ X与Y的长度，如果X的长度+ X与Y的长度 &gt; Y的长度,说明需要更新操作。 1）.存入最短路。 2）.由于改变了原有的长度，所以需要往后更新，与这个节点相连的最短路。(即：判断下是否在队列，在就不用重复，不在就加入队列，等待更新)。 3）.在这期间可以记录这个节点的进队次数，判断是否存在负环。 4.直到队空。 判断有无负环：如果某个点进入队列的次数超过N次则存在负环 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//多起点多终点的spfa算法模板#include &lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3fusing namespace std;const int M=10005;//点的个数 struct A&#123; int end,value,next;&#125;a[M&lt;&lt;1];//因为是无向图，所以可以把边的集合缩小到边的一半 int head[M],cnt=0;//链式前向星数组int vis[M],inqueue[M],nums[M];//SPFS数组，vis记录最短路，inqueue记录是否在队列，nums记录入队次数void add(int x,int end,int k)//链式前向星，加入节点&#123; a[cnt].end=end, a[cnt].value=k, a[cnt].next=head[x]; //这一条边的指向的节点为end，权值为k，和这一条边同起点的边为以x为起点的边 head[x]=cnt++;//注意：先赋值后cnt++ //以x为起点的边为cnt的下一条边 &#125;bool SPFA(int s,int n)&#123; queue &lt;int&gt; q; memset(vis,inf,sizeof(vis)); memset(inqueue,0,sizeof(inqueue)); memset(nums,0,sizeof(nums)); vis[s]=0;//初始化距离 inqueue[s]=1,nums[s]++;//标记s节点（起点）在队列，队列次数+1 q.push(s); while(!q.empty()) &#123; int x=q.front(); q.pop();//出队 inqueue[x]=0;//标记不在队列 for(int i=head[x]; ~i; i=a[i].next)//遍历与x节点连通的点 &#123; int end=a[i].end; if(vis[end]&gt;vis[x]+a[i].value)//更新 &#123; vis[end]=vis[x]+a[i].value; if(!inqueue[end]) //由于更新了节点，所以后续以这个为基础的最短路，也要更新下 //所以如果在队列就不用加入，不在的话加入更新后续节点 &#123; q.push(end); inqueue[end]=1;//标记这个节点在队列中 nums[end]++;//记录加入次数 if(nums[end]&gt;n)//如果这个点加入超过n次，说明存在负圈，直接返回 return false; &#125; &#125; &#125; &#125; return true;&#125;int main()&#123; int n,m,t; int b[M],c[M]; while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;t) &#123; cnt=0; memset(head,-1,sizeof(head)); for(int i=0;i&lt;n;i++) &#123; int x,end,k;//k为权值 cin&gt;&gt;x&gt;&gt;end&gt;&gt;k; add(x,end,k);//因为是无向边，有向边的话加一次就好了 add(end,x,k); &#125; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;b[i];//b[]是起点的集合 &#125; for(int i=0;i&lt;t;i++) &#123; cin&gt;&gt;c[i];//c[]是终点的集合 &#125; int minn=inf; for(int i=0;i&lt;m;i++)//遍历每一个起点找寻最短路径 &#123; SPFA(b[i],n); for(int j=0;j&lt;t;j++)//对于每个起点跑一遍终点 minn=min(minn,vis[c[j]]); &#125; cout&lt;&lt;minn&lt;&lt;endl; &#125; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"最短路径","slug":"最短路径","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}],"author":"aoyuehan"},{"title":"acm中的英文单词","slug":"acm-1","date":"2020-01-20T10:34:00.000Z","updated":"2022-02-26T04:29:56.814Z","comments":true,"path":"2020/01/20/acm-1/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/20/acm-1/","excerpt":"","text":"转载管sir 链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298重点语句D is rounded to 2 decimal places D是精确到小数点后2位horizontal or vertical direction 水平和垂直方向uppercase（Capital） 大写字母（Lowercase letters小写字母）add, subtract, multiply and divide加减乘除cube立方square平方statistical 统计的square root平方根Cube root立方根integer 整数positive number正数negative number负数even 偶数odd 奇数divisor 因数fraction 分数prime number 质数parallel 平行的substring 子串intervals 间隔时间; 间隔( interval的名词复数 ); 区间invalid 无效的sequence 序列，数列vertex 顶点palindrome 回文optimally 最佳prefix 前缀horizontally 水平的diagonally 对角线的vertically 竖直的There are no special punctuation symbols or spacingrules 没有特殊标点符号或间距的规则two adjacent sequence elements 两个相邻的元素串two-dimensional array 二维数组unique identifier 唯一的标识符process a sequence of n distinct integers 处理一串n 个不同的整数gcd （greatest common divisor） 最大公约数lcm (Least Common Multiple) 最小公倍数arithmetic progression 等差数列geometric progression 等比数列in the shape of a cross 十字形clockwise order顺时针方向顺序average temperature顺时针counterclockwise 逆时针contraclockwise逆时针anticlockwise 逆时针Aaverage temperature顺时针anticlockwise 逆时针ascending order升序（descending order降序）alphabetical order 字典序arithmetic progression 等差数列（geometric progression 等比数列）approximate String Matching 模糊匹配arbitrary Precision Arithmetic 高精度计算alternate 交替的assess 评定，评估assemble 组合alternately rise and fall 交替上升和下降assume 假设，认为axis axes 轴abbreviation 省略Bbinary 二进制bidirectional 双向的boundary界限Bandwidth Reduction 带宽压缩Bin Packing 装箱问题Cclockwise order顺时针方向顺序（anticlockwise 逆时针）counterclockwise 逆时针contraclockwise逆时针consecutive 连续的computation geometry 计算几何coefficient 系数chariot 战车（中国象棋）checkmate (国际象棋） 将死; 输棋，将死; 败局; 败北，挫败;collinear 共线的carpet 地毯calculate 计算comma 逗号consistof由…组成contain包含coordinates 坐标corrupt 腐烂，破坏cubes 立方calendrical Calculations 日期clique 最大团combinatorial Problems 组合问题computational Geometry 计算几何connected Components 连通分支constrained and Unconstrained Optimization 最值问题convex Hull 凸包cryptography 密码Ddecimal 十进制dialing 拨号音 打电话，拨电话号码( dial的现在分词 )duplicates 完全一样的东西，复制品directory 人名地址录，（电话）号码簿; （计算机文件或程序的） 目录;指导的，指挥的; 咨询的; 管理的denote 代表; 指代; 预示; 意思是;D is rounded to 2 decimal places D是精确到小数点后2位diagonal对角（diagonally 斜对角线的）dial 钟面，拨打digit 位数 数字；手指；足趾distinctvalues 独一无二的值disjoint 不相交的data Structures 基本数据结构determinants and Permanents 行列式dictionaries 字典discrete Fourier Transform 离散Fourier变换drawing Graphs Nicely 图的描绘drawing Trees 树的描绘Eestimate 预测excluding 排除enable 启用equation方程式 等式even 偶数equivalent 相等的，等效的edge and Vertex Connectivity 割边/割点edge Coloring 边染色eulerian Cycle / Chinese Postman Euler回路/中国邮路Ffraction 分数frog 青蛙followby 跟随，其后Factoring and Primality Testing 因子分解/质数判定Feedback Edge/Vertex Set 最大无环子图Finite State Machine Minimization 有穷自动机简化Ggcd （greatest common divisor） 最大公约数geometric progression 等比数列Generating Graphs 图的生成Generating Partitions 划分生成Generating Permutations 排列生成Generating Subsets 子集生成Graph Data Structures 图Graph Isomorphism 同构Graph Partition 图的划分Graph Problems — hard 图论-NP问题Graph Problems — polynomial 图论-多项式算法Hhorizontal or vertical direction 水平和垂直方向horizontally 水平的Hamiltonian Cycle Hamilton回路Iinfinite 无限的in the range of 在…范围内integer 整数intersect 相交intersection 横断，横切; 交叉，相交in the shape of a cross 十字形intervals 间隔时间; 间隔( interval的名词复数 ); 区间Independent Set 独立集Intersection Detection 碰撞测试JJob Scheduling 工程安排KKing 国王Knight 骑士（马）Kd-Trees 线段树Knapsack Problem 背包问题Lloop 环lcm (Least Common Multiple) 最小公倍数linear algebra 线性代数Linear Programming 线性规划Longest Common Substring 最长公共子串Mmemorable 值得纪念的multiplication 乘法meadow 草坪matrix 矩阵minimalvolume 最小体积Maintaining Line Arrangements 平面分割Matching 匹配Matrix Multiplication 矩阵乘法Medial-Axis Transformation 中轴变换Median and Selection 中位数Minimum Spanning Tree 最小生成树Minkowski Sum Minkowski和Motion Planning 运动规划Nnotation 标记non-intersecting 非相交的; 不相交的;negative ，positive 负 ，正Nearest Neighbor Search 最近点对查询Network Flow 网络流Numerical Problems 数值问题Oox牛odd and even 奇和偶optimally 最佳Ppalindrome 回文Pawn 禁卫军（兵）Priority Queues 优先队列profile 轮廓prefix 前缀parallel 平行的proportional 成比例的parity property 奇偶性positive and negative integers 正整数和负整数present Error 呈现错误proceed 运行process a sequence of n distinct integers 处理一串n 个截然不同的整数Planarity Detection and Embedding 平面性检测和嵌入Point Location 位置查询Polygon Partitioning 多边形分割QQueen 皇后Rrat老鼠rectangular 矩形的，成直角的rooster鸡Rows and columns 行与列Random Number Generation 随机数生成Range Search 范围查询rate of convergence 收敛速度robustness 鲁棒性Ssheep羊statistical 统计的simultaneously 同时的segment 环节; 部分;分段; 分割，划分;square 平方，正方形，广场，方格sequence 一连串，有关联的一组事物series 连续的同类事物，系列serial 连续的; 连载的; 顺序排列的;sufficient 充足的；足够的；specify 指定stem 词根suffix 后缀Satisfiability 可满足性Searching 查找Set and String Problems 集合与串的问题Set Cover 集合覆盖Set Data Structures 集合Set Packing 集合配置Shape Similarity 相似多边形Shortest Common Superstring 最短公共父串Shortest Path 最短路径Simplifying Polygons 多边形化简Solving Linear Equations 线性方程组Sorting 排序Steiner Tree Steiner树String Matching 模式匹配Tthe course material 课程内容There are no special punctuation symbols or spacingrules 没有特殊标点符号或间距的规则two adjacent sequence elements 两个相邻的元素串two-dimensional array 二维数组unique identifier 唯一的标识符toss 扔（硬币）tail (尾部)Text Compression 压缩Topological Sorting 拓扑排序Transitive Closure and Reduction 传递闭包Traveling Salesman Problem 旅行商问题Triangulation 三角剖分Uuppercase（Capital） 大写字母（Lowercase letters小写字母）unique identifier 唯一的标识符Vvertex 顶点Vertex Coloring 点染色Vertex Cover 点覆盖Voronoi Diagrams Voronoi图Wwooden planks 木板XYZzero零","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"英文单词","slug":"英文单词","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D/"}],"author":"aoyuehan"},{"title":"新生训练05","slug":"新生训练05","date":"2020-01-19T06:25:00.000Z","updated":"2022-02-26T03:52:52.001Z","comments":true,"path":"2020/01/19/新生训练05/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/19/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%8305/","excerpt":"","text":"A - DRM Messageshttps://blog.csdn.net/tomjobs/article/details/103941379字典树https://www.cnblogs.com/dillydally/p/9567701.htmlhttps://www.cnblogs.com/Limbo-To-Heaven/p/11352589.html 题意：好像就是凯撒密码的一个变形，把26个字母看成一个圈，通过加密前的字母移动的一定的位数得到加密后的字母的方式进行加密。 注意：%取余运算，-5%3&#x3D;-2；0%3&#x3D;0；3%0会溢出。本题中字母从0开始排列到25，那么一个数%26就是最后移动之后的位置（%后面的26是字母的个数，而不是下标的那个25），记不住的话试一试就知道应该%多少了。 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;const int maxn=15010;int s1[maxn],s2[maxn];char s[maxn],ans[maxn];int main()&#123; cin&gt;&gt;s; int len=strlen(s); int len2=len/2; int num1=0,num2=0; for(int i=0;i&lt;len2;i++)&#123; num1+=s[i]-&#x27;A&#x27;; num2+=s[i+len2]-&#x27;A&#x27;; &#125; for(int i=0;i&lt;len2;i++)&#123; s1[i]=(s[i]-&#x27;A&#x27;+num1)%26; s2[i]=(s[i+len2]-&#x27;A&#x27;+num2)%26; &#125; for(int i=0;i&lt;len2;i++)&#123; ans[i]=(s1[i]+s2[i])%26+&#x27;A&#x27;; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; B - Game of Throwns题意：n个小朋友从0到n-1的序号围城一个圈，然后给出命令，若为正数就x，就顺时针把鸡蛋扔给相隔x的小朋友，若为负数，就逆时针扔，为undo x就复原上面x步。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152include&lt;iostream&gt;#include&lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;#include &lt;sstream&gt;//stringstream头文件 #include &lt;iostream&gt;#include&lt;stack&gt;using namespace std;struct per&#123; bool is;//用来判断是否要复原前面的步骤 int c;//储存要复原的数或要扔的数量 &#125;c[110];int n,k,ans;string s,tmp1;stack&lt;int&gt;st;//栈中存放要扔的数量 int main()&#123; cin&gt;&gt;n&gt;&gt;k; getchar();//cin不吸收回车，如果不加的话，就会被getline吸收 getline(cin,s); stringstream str;//把s以空格为分界线吐出来 str&lt;&lt;s; for(int i=0;i&lt;k;i++)&#123; str&gt;&gt;tmp1;//用来预处理数据 if(tmp1==&quot;undo&quot;)&#123; str&gt;&gt;c[i].c; c[i].is=1;//结构体的is为1的话，就要复原c步 &#125;else&#123;//atoi的参数为char*，可以通过str.c_str转换为char* c[i].c=atoi(tmp1.c_str()); c[i].is=0; &#125; &#125; for(int i=0;i&lt;k;i++)&#123; if(c[i].is==0)&#123; st.push(c[i].c); &#125;else&#123; for(int j=0;j&lt;c[i].c;j++)&#123; if(!st.empty())st.pop(); &#125; &#125; &#125; while( !st.empty() ) &#123; ans+=st.top(); st.pop(); &#125; if(ans%n&lt;0)&#123;//本来这地方没有分类，错了好几次 cout&lt;&lt;n+ans%n&lt;&lt;endl;//最终的小朋友下标不应该为负数 &#125;else cout&lt;&lt;ans%n&lt;&lt;endl;&#125; C - Sheba’s Amoebas 这题给你一个矩阵，让你找出这个矩阵代表的图形中有几个圈，当时读题的时候没读明白，后来一读，题意说No two closed loops in the image touch or overlap. 所以就不会有一个圈不闭合的情况了。 解法：dfs扫一遍，把已经走过的格子就变为’.’,vis数组标记一下（不用回溯），记录一下圈的个数。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;char map[105][105];int dx[8]=&#123;0,0,1,1,-1,-1,1,-1&#125;;int dy[8]=&#123;1,-1,1,-1,1,-1,0,0&#125;;//代表向上，下，斜右上，斜右下，斜左上，斜左下，左，右int n,m;int vis[105][105];void dfs(int x,int y)&#123; int nowx;//当前点的x，y坐标 int nowy; for(int i=0;i&lt;8;i++)&#123;//朝8个方向都跑一遍 nowx=x+dx[i]; nowy=y+dy[i]; if(nowx&gt;=0&amp;&amp;nowx&lt;n&amp;&amp;nowy&gt;=0&amp;&amp;nowy&lt;m&amp;&amp;vis[nowx][nowy]==0&amp;&amp;map[nowx][nowy]==&#x27;#&#x27;)&#123; vis[nowx][nowy]=1;//注意进入if语句的条件是什么 map[nowx][nowy]=&#x27;.&#x27;;//就是找到这一个#属于的圆，就把他给去掉 dfs(nowx,nowy); //从这一个点继续扫 &#125; &#125;&#125; int main()&#123; memset(vis,0,sizeof(vis)); cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;map[i];//初始化地图 &#125; int ans=0; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(map[i][j]==&#x27;#&#x27;&amp;&amp;vis[i][j]==0)&#123; vis[i][j]==1; ans++; dfs(i,j); //从地图中的一个点进入，然后扫描这个点的邻接点 &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; D - Keeping On Track题意 有编号从0到n的n+1个城市和n条路径，每两个城市之间有且只有一条路径。当两个城市间存在一天可达路径时，称两个城市是联通的。将关键城市定义为，当去掉这个城市后不连通的城市对最多。求去掉关键城市后不连通的城市对有多少，当新添加一条路径后，仍不连通城市对的最小数目。 E - A Question of Ingestion 题意： 起始饭量 &#x3D; m， 你可以吃n次饭， 当你连续吃时，饭量是上次的2&#x2F;3; 当你休息一次时, 饭量和上次相同; 当你连续休息两次时，饭量恢复到起始值m. dp[i][j]表示准备吃第i个，已经吃了j个的最大卡路里和 也就是在第i天，吃饭的饭量等级是j的状态 状态转移分为：从昨天转移过来，从前天转移过来，从大前天转移过来。 初始值：饭量等级为1，能吃多少吃多少。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define ms(x) memset(x,0,sizeof(x))typedef long long LL;using namespace std;int n,m;int ans;int a[321],val[321];int dp[123][323];int main()&#123; ms(val); ms(dp); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i = 1; i &lt;= n ; i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; int o = 1; val[o++] = m; while(val[o-1] &gt; 0) &#123; val[o] = (int) (2*val[o-1])/3; o++; &#125; for(int i=1;i&lt;=n;i++)&#123; dp[i][1] = min(a[i], val[1]); &#125; int ans = 0; for(int i=1;i&lt;=n;i++)&#123; // 真准备吃第i个， 已经吃了j个 for(int j=1;j&lt;=i;j++)&#123; if(i&gt;=1) dp[i][j] = max(dp[i][j], dp[i-1][j-1] + min(val[j], a[i])); if(i&gt;=2)&#123; // 可以休息一次的情况。 dp[i][j] = max(dp[i][j], dp[i-2][j] + min(val[j], a[i])); &#125; if(i&gt;=3)&#123; // 可以休息两次的情况 dp[i][1] = max(dp[i][1], dp[i-3][j] + min(val[1], a[i])); &#125; ans = max(ans, dp[i][j]); &#125; ans = max(ans, dp[i][1]);// &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125; 英文单词 1","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"新生训练","slug":"新生训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"字典树，最长前缀，ac自动收割机","slug":"字符串做题总结","date":"2020-01-17T10:54:00.000Z","updated":"2022-02-26T04:29:56.863Z","comments":true,"path":"2020/01/17/字符串做题总结/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/17/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"","text":"最大异或对123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117在给定的N个整数A1，A2……AN中选出两个进行xor（异或）运算，得到的结果最大是多少？输入格式第一行输入一个整数N。第二行输入N个整数A1～AN。输出格式输出一个整数表示答案。数据范围1≤N≤10^5,0≤Ai&lt;2^31输入样例：31 2 3输出样例：3#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int maxn = 100010;int t[maxn * 32][3],tot = 1;int a[maxn],n;void insert(int val)&#123; int p = 1; for(int i = 30;i &gt;= 0;i --) &#123; int ch = (val &gt;&gt; i) &amp; 1; if(t[p][ch] == 0) &#123; t[p][ch] = ++tot; &#125; p = t[p][ch]; &#125;&#125;int search(int val)&#123; int p = 1,ans = 0; for(int i = 30;i &gt;= 0;i--) &#123; int ch = (val &gt;&gt; i) &amp; 1;//取出第k位 if(t[p][ch ^ 1])//异或走路 &#123; p = t[p][ch ^ 1]; ans |= 1 &lt;&lt; i; &#125; else &#123; p = t[p][ch]; &#125; &#125; return ans;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n);int ans = 0; for(int i = 1;i &lt;= n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); insert(a[i]); ans = max(ans,search(a[i]));//没建完所有的树就能找到最大值吗？？ &#125; printf(&quot;%d\\n&quot;,ans); return 0;&#125;解法二：#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int a[N], trie[N * 32][5], idx;void insert(int x) //建树&#123; int p = 1; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp; 1; if(!trie[p][u])trie[p][u] = idx++; p = trie[p][u]; &#125;&#125;int search(int x)//找最大的&#123; int p = 1, ans = 0; for(int i = 30; i &gt;= 0; i--)&#123; int u = x &gt;&gt; i &amp;1; if(trie[p][u^1])&#123; p = trie[p][u^1]; ans +=(1 &lt;&lt; i); &#125; else p = trie[p][u]; &#125; return ans;&#125;int main()&#123; int n; cin &gt;&gt; n; idx =2; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a[i]; insert(a[i]); &#125; int res = 0; for(int i = 0; i &lt; n; i++)res = max(res, search(a[i])); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; D - Dr. Evil Underscores题意：给n个数a1，a2，a3…..an，找到一个数X，使得X 异或所有的ai ，得到的max（X xor ai）最小，输出这个值。 思路：a的范围是0~230，我们可以以01二进制的形式建一棵深度为30的字典树，每个数ai 的二进制序列插入到字典树中去，例如5 &#x3D; 101，那么101按位插入到字典树中去。然后从根开始遍历，在字典树上dp，因为该字典树建完后是一棵二叉树，所以分支情况就两种，下一位是0或1，那么如果只遇到1就往1这个分支走，这一位便没有贡献，如果只遇到0就往0这个分支走，这一位也没有贡献，如果遇到的是0和1两个分支，那么必定要加上这一位的贡献，然后递归01两个分支，两者再去min，一直递归到最后一位。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647没看懂，草#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;typedef long long ll;int trie[6000005][2],cnt ;//bool exist[31*31];// 该结点结尾的字符串是否存在void insert(int a)&#123;//建trie树 int p = 0; for(int i = 29;i&gt;=0;i--)&#123; int c = (a&gt;&gt;i)&amp;1; if(!trie[p][c]) trie[p][c] = ++cnt; // 如果没有，就添加结点 p = trie[p][c]; &#125;// exist[p] = 1;&#125; ll solve(ll cur,int k)&#123; if(k == -1) return 0; if(trie[cur][0] == 0)&#123; return solve(trie[cur][1],k-1); &#125; else if(trie[cur][1] == 0)&#123; return solve(trie[cur][0],k-1); &#125; else&#123; return (1&lt;&lt;k)+min(solve(trie[cur][0],k-1),solve(trie[cur][1],k-1)); &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i = 0;i&lt;n;i++)&#123; ll a;cin&gt;&gt;a; insert(a); &#125; ll ans = solve(0,29); cout&lt;&lt;ans; return 0;&#125; https://blog.csdn.net/tomjobs/article/details/103941379 https://www.cnblogs.com/dillydally/p/9567701.html https://www.cnblogs.com/Limbo-To-Heaven/p/11352589.html","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"aoyuehan"},{"title":"新生训练04","slug":"新生训练04","date":"2020-01-15T12:51:00.000Z","updated":"2022-02-26T04:29:57.054Z","comments":true,"path":"2020/01/15/新生训练04/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/15/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%8304/","excerpt":"","text":"A - Mezo Playing Zoma题意：Zoma在x轴的原点处，给出一个由LR组成的字符串，但是有时候会接收不到，问最后的结果有多少种。统计l和r的数量，再加上原点的位置。结果为t+1（t为字符串的长度） 123456789101112131415#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; string s; int t,l=0,r=0; cin&gt;&gt;t; cin&gt;&gt;s; for(int i=0;i&lt;t;i++)&#123; if(s[i]==&#x27;L&#x27;)l++; else r++; &#125; cout&lt;&lt;l+r+1&lt;&lt;endl;//其实就是t+1 &#125; B - Just Eat It!（最大连续子序列和——动态规划）题意：总共有n个糖果，有两个人，一个取全部，一个取片段（不能全取），问最后取片段的最大会不会小于全部的。tips：**首先假设我们已经找到了最大连续和子串在数组中的起始位置（i）和结束位置（j），其中i &lt;&#x3D; j，即最大和maxSum &#x3D; a[i] + a[i + 1] + … + a[j]，我们来看看这个子串有什么性质：1、a[i] &gt; 0，否则我们完全可以去掉a[i]这个元素 而得到一个更大的和；2、i &gt; 0且a[i - 1] &lt; 0 或 i &#x3D;&#x3D; 0，下面假设i &gt; 0，这一条性质也是因为如果a[i - 1] &gt; 0的话我们求和时可以加上a[i - 1]这个元素得到一个更大的和；3、元素a[i - 1]与它之前的任一元素之间的子串之和sum &lt; 0 ，即对于任何一个m(0 &lt;&#x3D; m &lt; i - 1)，则有a[m] + a[m + 1] + … + a[i - 1] &lt; 0；a[i - 1]是一个分界点，最大和的子串要么就在a[i - 1]元素之后，要么就在a[i - 1]之前，最大和的子串不可能跨过a[i - 1]这个点。 下面举2个例子来看看：第一个例子：假设数组为 1，－2， 3， 4，5，很容易发现－2这个元素满足前述的3个性质：1.-2 本身是负数2.-2 + 1 &#x3D; -1 &lt; 0所以-2是这样一个分界点，最大和的字串要么在－2之后要么在之前，－2之前的和是1，之后的和sum &#x3D; 3 + 4 + 5 &#x3D; 12，所以这个字串的最大和为12。我们稍微改变一下数组的元素就可以看到最大和字串在分解点之前的情况： 第二个例子：假设数组为 100，－101， 3， 4，5，很容易发现－101这个元素满足前述的3个性质：-101 本身是负数-101 + 100 &#x3D; -1 &lt; 0所以-101是这样一个分界点，最大和的字串要么在－101之后要么在之前，－101之前的和是100，之后的和sum &#x3D; 3 + 4 + 5 &#x3D; 12，所以这个字串的最大和为100。** 根据分析我们可以得出结论：只要找到分解点 a[i - 1]，最大和的子串要么就在a[i - 1]元素之后，要么就在a[i - 1]之前，最大和的子串不可能跨过a[i - 1]这个点；一个数组中可能有多个这种分界点，但每个分界点都可以把前后完全分开，可以单独算分界点之间的最大和，然后在这些最大和之间取最大值。 假设对于数组a，我们找到了两个分界点a[i]和a[j],那么整个数组的最大字串和就是max(sum(a[0]…a[i-1]), sum(a[i+1]…a[j-1]), sum(a[j+1]…a[len-1]))。 基于上述分析，因为本题片段不能包含所有的取值，所以分两步来计算，即1n-1和2n这两段，对于每段来说找到分界点a[i-1],然后计算片段和。最后与sum进行比较。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273暴力解法一：#include&lt;iostream&gt;using namespace std;long long ans1,ans2;const int maxn=1e5+10;int t,n,a[maxn];bool is=false;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; ans1=0;ans2=0; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); ans1+=a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=i;j&lt;n;j++)&#123; for(int k=i;k&lt;=j;k++)&#123; if(i==0&amp;&amp;k==n-1)&#123; &#125;else&#123; ans2+=a[k]; &#125; &#125; if(ans2&gt;=ans1)&#123; is=true; break; &#125; ans2=0; &#125; if(is)break; &#125; if(is)printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n&quot;); is=false; &#125;&#125;动态规划解法：#include&lt;iostream&gt;using namespace std;typedef long long ll;const int maxn=1e5+10;ll t,n,a[maxn];int main()&#123; ll maxh,maxsum1,maxsum2,sum; //maxh为走到第i个时的总和 cin&gt;&gt;t; while(t--)&#123; sum=0; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i];sum+=a[i]; &#125; //从1~n-1(因为不能全包含) maxh=a[1];maxsum1=a[1]; for(int i=2;i&lt;=n-1;i++)&#123; if(maxh&lt;=0)maxh=a[i]; else maxh+=a[i]; maxsum1=max(maxsum1,maxh);//没加一次都比较一次大小 &#125; //从2~n maxh=a[2];maxsum2=a[2]; for(int i=3;i&lt;=n;i++)&#123;//注意下标 if(maxh&lt;=0)maxh=a[i]; else maxh+=a[i]; maxsum2=max(maxsum2,maxh); &#125; if(max(maxsum1,maxsum2)&gt;=sum)cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; &#125;&#125; C - Fadi and LCM题意： 给你一个数字x，让你求出两个数a，b并且使max(a,b)最小且lcm(a,b)为x。 首先要最小公倍数为x，那么就有a * b &#x2F; gcd(a,b)出现，要使a,b最小，那么gcd(a,b)最小为是1（互质的一组是最简（小）形式因此可以推出其为最小的因子，而且互质的时候a和b的最小公倍数才是x），也就是a * b&#x2F;1&#x3D;x ，即a * b&#x3D;x且gcd(a,b) &#x3D; 1。 *ab&#x2F;(两者最大公约数)&#x3D;最小公倍数 ** 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; //while(1)&#123; long long x,a=0,b=0; scanf(&quot;%lld&quot;,&amp;x); for(long long i=1;i&lt;=sqrt(x);i++)&#123; if(__gcd(i,x/i)==1&amp;&amp;x%i==0)&#123; a=i;b=x/i; //就是两个数都越靠近根下x的时候，两个数的最大值才相对其他答案越小 &#125; &#125; if(x==1)printf(&quot;1 1\\n&quot;); else printf(&quot;%lld %lld\\n&quot;,a,b); // &#125;&#125;tips:最大公约数的实现方法注意：0%a=0a%0-----溢出递归：int gcd(int a,int b)&#123; return b == 0? a : gcd(b,a%b);&#125;非递归：int gcd(int a,int b) &#123; if(b==0) return a; int r; while((r=a%b)!=0) &#123; a=b; b=r; &#125; return b; &#125;解法二：梁sir#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ll n; cin&gt;&gt;n; ll m = sqrt(n); ll minn = n; for(ll i=2;i&lt;=m;i++) &#123;//不能从1开始，因为1是i的最小值，但是i最小时，n/i最大，不满足条件 if(n%i) continue; if(__gcd(i,n/i)==1) minn = min(minn,n/i); &#125; cout&lt;&lt;n/minn&lt;&lt;&quot; &quot;&lt;&lt;minn&lt;&lt;&quot;\\n&quot;; //其实只要求出n/i的最小值就好了，然后n/(n/i)就是i&#125; D - Dr. Evil UnderscoresE - Deadline给一个期限的天数n，和这时候你完成工作的时间d，d可以按照一个方法进行优化，问优化后的天数是否可以小于期限n。优化方法为： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int t,n,d; bool is=false; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;d); if(d&lt;=n)&#123; printf(&quot;YES\\n&quot;); &#125;else&#123; for(int i=1;i&lt;=n;i++)&#123; if((i+ceil(d*1.0/(i+1)*1.0))&lt;=n)&#123; //ceil为向上取整函数，floor向下取整，round四舍五入（但是round（2.5）=3 ） is=true; break; &#125; &#125; if(is)printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); &#125; is=false; &#125;&#125; F - Yet Another Meme Problem题意：找满足a⋅b+a+b&#x3D;conc(a,b)的个数。其中conc(a,b) is the concatenation of a and b (for example, conc(12,23)&#x3D;1223, conc(100,11)&#x3D;10011). 推理：a⋅b+a+b&#x3D;conc(a,b)&#x3D;&#x3D;&gt;a·b+a&#x3D;a*10w（上式两侧同减b，w为b的位数）&#x3D;&#x3D;&gt;b+1&#x3D;10w（上式两侧同除a）由上式可以看出，b为10w-1，例如9，99，999，9999……a无限制条件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061方法一：#include&lt;iostream&gt;using namespace std;typedef long long ll;const int maxn=20;int c[maxn];int main()&#123; int a,b; int t,d=1,i,cnt; for(int i=1;i&lt;=9;i++)&#123; d=d*10; c[i]=d-1; //cout&lt;&lt;c[i]&lt;&lt;endl; &#125; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); for(i=1;i&lt;=9;i++)&#123; if(c[i]&gt;b)break; &#125;//就算最后没有通过if语句跳出来， //如9个9，在i=10的时候出来，那么i-1是9，真好满足要求 printf(&quot;%lld\\n&quot;,(long long )a*(i-1)); &#125;&#125;方法二：#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; //freopen(&quot;text&quot;,&quot;r&quot;,stdin); int T; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; long long a,b; cin&gt;&gt;a&gt;&gt;b; if(b&lt;9) printf(&quot;0\\n&quot;); else&#123; if(b&lt;99) cout&lt;&lt;a&lt;&lt;endl; else if(b&lt;999) cout&lt;&lt;a*2&lt;&lt;endl; else if(b&lt;9999) cout&lt;&lt;a*3&lt;&lt;endl; else if(b&lt;99999) cout&lt;&lt;a*4&lt;&lt;endl; else if(b&lt;999999) cout&lt;&lt;a*5&lt;&lt;endl; else if(b&lt;9999999) cout&lt;&lt;a*6&lt;&lt;endl; else if(b&lt;99999999) cout&lt;&lt;a*7&lt;&lt;endl; else if(b&lt;999999999) cout&lt;&lt;a*8&lt;&lt;endl; else cout&lt;&lt;a*9&lt;&lt;endl; &#125; &#125; return 0;&#125; G - HQ9+就是扫一个串中的HQ9的个数，其中+不算。 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; string s; bool is=false; cin&gt;&gt;s; for(int i=0;i&lt;s.length();i++)&#123; if(s[i]==&#x27;H&#x27;||s[i]==&#x27;Q&#x27;||s[i]==&#x27;9&#x27;)&#123; is=true; break; &#125; &#125; if(is)printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); &#125; 总结：1、在第g题的时候，看了半天题意没搞懂，最后算了一下hq9+的数量，一看不对；是不是+不算呐，把+去了，对了。所以没看懂题意要猜，合理的猜对2、在哪个lcm的哪道题中，要把已知的简单规律写下来，进行推导公式，lcm和gcd一般都牵扯到互质。3、F题一看，没有规律性，这种定义规则的题目，可以把这个式子用数学语言写下来，进行推导，其实结果很明显，而且样例中给出了那个9的例子，可以大胆的猜测只有9,99,999，…可以。4、**懂得了动态规划那题的解法思路，找到那个分界点a[i-1],然后分段找最大的连续和就好了。 ** 12345678910111213141516171819202122232425262728293031initially 最初的controller n.控制器；管理员；主计长malfunctions 失灵proceed n.收入，收益；实收款项outcomes n.产出，结局；效果（outcome的复数）beforehand adv.事先；预先 adj.提前的；预先准备好的cupcakes n.纸杯蛋糕；美人；懦弱的男子（cupcake的复数）infinitely adv.无限地；极其nasty adj.极差的；恶心的；恶意的；有害的；严重的（伤、疾病）；粗鲁的，下流的；可恶的；难对付的n.令人不快的人（或物）；可恶；恐怖录像或影片n.(Nasty)（俄、美、印）耐史迪（人名）tasty adj.美味的；高雅的；有趣的 n.可口的东西；引人入胜的东西respectively adv.分别地；各自地，独自地LCM 最小公倍数（LowestCommonMultiple）GCD 最大公约数Fortunately adv.幸运地optimize vt.使最优化，使完善 vi.优化；持乐观态度simultaneously adv.同时地case insensitive 大小写敏感equation n.方程式，等式；相等；[化学]反应式Instructions n.指令；说明（instruction的复数形式）accumulator n.蓄电池；[计]累加器；积聚者","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"新生训练","slug":"新生训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"蓝桥杯校赛2020","slug":"蓝桥杯校赛2020","date":"2020-01-15T04:39:00.000Z","updated":"2022-02-26T03:52:51.568Z","comments":true,"path":"2020/01/15/蓝桥杯校赛2020/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/15/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B2020/","excerpt":"","text":"另一个xioasia 11234567891011问题描述 一个数被称为质数（或素数）是指除开1和它本身两个约数外，没有其他的约数。 不超过10000的数中，最大的质数是多少?答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 ans=9973 那么不超过19000的正整数中，与19000互质的数的个数是多少？ 212345问题描述 两个二进制数11110011101和1111101001的和是多少？请用二进制表示，注意在提交的时候不要提交前导0。答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个二进制数，在提交答案时只填写这个二进制数，填写多余的内容将无法得分。 ans=101110000110 3123456问题描述 在2019个有区别的球中选3个球放在一个盘子里，请问有多少种选法？答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 ans=1369657969 4123456问题描述 一棵包含有2019个结点的树，最多包含多少个叶结点？答案提交 这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。 ans=2018 只有一个根节点的时候，叶节点最多。 5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748问题描述 给定正整数 n，请问在整数 1 至 n 中，数字中没有数位相同的数有多少个？ 例如，当 n=30 时，除开 11 和 22 以外，其他的数都没有数位相同，因此答案为 28。输入格式 输入的第一行包含一个整数 n。输出格式 输出一行包含一个整数，表示答案。样例输入30样例输出28评测用例规模与约定 对于 40% 的评测用例，1 &lt;= n &lt;= 1000。 对于 80% 的评测用例，1 &lt;= n &lt;= 100000。 对于所有评测用例，1 &lt;= n &lt;= 1000000。 #include&lt;iostream&gt;using namespace std; int main()&#123; int n,tmp1,tmp2,ans=0,tmp3; bool is=true; cin&gt;&gt;n; if(n&lt;=9)&#123; cout&lt;&lt;n&lt;&lt;endl; return 0; &#125;else&#123; for(int i=10;i&lt;=n;i++)&#123; tmp3=i; tmp1=tmp3%10; while(tmp3)&#123;//用来找每个位都相同的数 tmp2=tmp3%10; tmp3=tmp3/10; if(tmp1!=tmp2)&#123; is=false; break; &#125; &#125; if(!is)ans++; is=true; &#125; cout&lt;&lt;ans+9&lt;&lt;endl; return 0; &#125;&#125; 612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849问题描述 输入一个单词，请输出这个单词中第一个出现的元音字母。 元音字母包括 a, e, i, o, u，共五个。输入格式 输入一行，包含一个单词，单词中只包含小写英文字母。输出格式 输出一行包含一个字母，为单词中第一个出现的元素字母。若单词中不存在元音字母，输出字母n。样例输入hello样例输出e样例输入fly样例输出n评测用例规模与约定 对于所有评测用例，单词中的字母个数不超过100。 #include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;char s[130];int main()&#123; gets(s); for(int i=0;i&lt;strlen(s);i++)&#123; if(s[i]==&#x27;a&#x27;)&#123; cout&lt;&lt;&quot;a&quot;&lt;&lt;endl; return 0; &#125; if(s[i]==&#x27;e&#x27;)&#123; cout&lt;&lt;&quot;e&quot;&lt;&lt;endl; return 0; &#125; if(s[i]==&#x27;i&#x27;)&#123; cout&lt;&lt;&quot;i&quot;&lt;&lt;endl; return 0; &#125; if(s[i]==&#x27;o&#x27;)&#123; cout&lt;&lt;&quot;o&quot;&lt;&lt;endl; return 0; &#125; if(s[i]==&#x27;u&#x27;)&#123; cout&lt;&lt;&quot;u&quot;&lt;&lt;endl; return 0; &#125; &#125; cout&lt;&lt;&quot;n&quot;&lt;&lt;endl; return 0;&#125; 7123456789101112131415161718192021222324252627282930313233343536373839问题描述 给定整数 m，在数列 a_1, a_2, ..., a_n中，如果两个数的和为 m 的倍数，则称为一个倍数对。 给定一个数列，请问数列中总共有多少个倍数对。输入格式 输入的第一行包含两个整数 n, m，分别表示数列中的元素个数和给定的整数 m。 第二行包含 n 个整数 a_1, a_2, ..., a_n，相邻的整数间用空格分隔，表示给定的数列。输出格式 输出一行包含一个整数，表示答案。样例输入6 36 1 2 5 6 2样例输出4样例说明 倍数对包括：a_1 和 a_5, a_2 和 a_3, a_2 和 a_4, a_2 和 a_6。评测用例规模与约定 对于 50% 的评测用例，1 &lt;= n &lt;= 100，1 &lt;= m &lt;= 1000，0 &lt;= 数列中的数 &lt;= 1000。 对于所有评测用例，1 &lt;= n &lt;= 1000，1 &lt;= m &lt;= 1000，0 &lt;= 数列中的数 &lt;= 10000。 #include&lt;iostream&gt;using namespace std;int main()&#123; int m,n,ans=0; int a[10010]; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i]; for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; if((a[i]+a[j])%m==0)&#123; ans++; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125; 81234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586问题描述 小明有一块空地，他将这块空地划分为 n 行 m 列的小块，每行和每列的长度都为 1。 小明选了其中的一些小块空地，种上了草，其他小块仍然保持是空地。 这些草长得很快，每个月，草都会向外长出一些，如果一个小块种了草，则它将向自己的上、下、左、右四小块空地扩展，这四小块空地都将变为有草的小块。 请告诉小明，k 个月后空地上哪些地方有草。输入格式 输入的第一行包含两个整数 n, m。 接下来 n 行，每行包含 m 个字母，表示初始的空地状态，字母之间没有空格。如果为小数点，表示为空地，如果字母为 g，表示种了草。 接下来包含一个整数 k。输出格式 输出 n 行，每行包含 m 个字母，表示 k 个月后空地的状态。如果为小数点，表示为空地，如果字母为 g，表示长了草。样例输入4 5.g..........g.......2样例输出gggg.gggg.ggggg.ggg.评测用例规模与约定 对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。 对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。 对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= k &lt;= 1000。这一题不能直接扫到一个g就把他的上下左右都变为g，否则的话程序会崩；因为长草是最后这一个月的那天才会长出来。#include&lt;iostream&gt;using namespace std;const int maxn=1010;char a[maxn][maxn];int main()&#123; int n,m,k; char s; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; cin&gt;&gt;s; if(s==&#x27;g&#x27;)&#123; a[i][j]=&#x27;g&#x27;; &#125;else&#123; a[i][j]=&#x27;.&#x27;; &#125; &#125; &#125; cin&gt;&gt;k; while(k--)&#123; for(int i=0;i&lt;n;i++)&#123;//hang for(int j=0;j&lt;m;j++)&#123; if(a[i][j]==&#x27;g&#x27;)&#123; if((i+1)&lt;n&amp;&amp;j&lt;m)&#123; if(a[i+1][j]!=&#x27;g&#x27;)a[i+1][j]=&#x27;i&#x27;; &#125; if((i-1)&lt;n&amp;&amp;(i-1)&gt;=0&amp;&amp;j&lt;m)&#123; if(a[i-1][j]!=&#x27;g&#x27;)a[i-1][j]=&#x27;i&#x27;; &#125; if(i&lt;n&amp;&amp;(j-1)&gt;=0&amp;&amp;(j-1)&lt;m)&#123; if(a[i][j-1]!=&#x27;g&#x27;)a[i][j-1]=&#x27;i&#x27;; &#125; if(i&lt;n&amp;&amp;(j+1)&lt;m)&#123; if(a[i][j+1]!=&#x27;g&#x27;)a[i][j+1]=&#x27;i&#x27;; &#125; &#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(a[i][j]==&#x27;i&#x27;)a[i][j]=&#x27;g&#x27;; &#125; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; cout&lt;&lt;a[i][j]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 912345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758问题描述 对于一个 n 行 m 列的表格，我们可以使用螺旋的方式给表格依次填上正整数，我们称填好的表格为一个螺旋矩阵。 例如，一个 4 行 5 列的螺旋矩阵如下： 1 2 3 4 5 14 15 16 17 6 13 20 19 18 7 12 11 10 9 8输入格式 输入的第一行包含两个整数 n, m，分别表示螺旋矩阵的行数和列数。 第二行包含两个整数 r, c，表示要求的行号和列号。输出格式 输出一个整数，表示螺旋矩阵中第 r 行第 c 列的元素的值。样例输入4 52 2样例输出15评测用例规模与约定 对于 30% 的评测用例，2 &lt;= n, m &lt;= 20。 对于 70% 的评测用例，2 &lt;= n, m &lt;= 100。 对于所有评测用例，2 &lt;= n, m &lt;= 1000，1 &lt;= r &lt;= n，1 &lt;= c &lt;= m。管sir的代码（自己模拟了半天没模拟出来，**最后想到其实没走一圈，行数和列数都-2了，有了这个规律就做出来了**）： #include&lt;iostream&gt;using namespace std;int d[1100][1100];int main()&#123; long long n,m; cin&gt;&gt;n&gt;&gt;m; long long a,b; a=1; b=1; int x,y; cin&gt;&gt;x&gt;&gt;y; long long sum=0; long long count=1; while(1)&#123; for(b=1+sum;b&lt;=m-sum;b++)&#123; if(d[a][b]==0)d[a][b]=count++; &#125; b=m-sum; for(a+=1;a&lt;=n-sum-1;a++)&#123; if(d[a][b]==0)d[a][b]=count++; &#125; for(b;b&gt;=sum+1;b--)&#123; if(d[a][b]==0)d[a][b]=count++; &#125; b=sum+1; for(a;a&gt;sum+1;a--)&#123; if(d[a][b]==0)d[a][b]=count++; &#125; a++;//就是a--之后才能跳出来，所以要变回去 if(count&gt;=n*m)break; sum++; &#125; cout&lt;&lt;d[x][y]; return 0;&#125; 101234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859问题描述 小明要组织一台晚会，总共准备了 n 个节目。然后晚会的时间有限，他只能最终选择其中的 m 个节目。 这 n 个节目是按照小明设想的顺序给定的，顺序不能改变。 小明发现，观众对于晚上的喜欢程度与前几个节目的好看程度有非常大的关系，他希望选出的第一个节目尽可能好看，在此前提下希望第二个节目尽可能好看，依次类推。 小明给每个节目定义了一个好看值，请你帮助小明选择出 m 个节目，满足他的要求。输入格式 输入的第一行包含两个整数 n, m ，表示节目的数量和要选择的数量。 第二行包含 n 个整数，依次为每个节目的好看值。输出格式 输出一行包含 m 个整数，为选出的节目的好看值。样例输入5 33 1 2 5 4样例输出3 5 4样例说明 选择了第1, 4, 5个节目。评测用例规模与约定 对于 30% 的评测用例，1 &lt;= n &lt;= 20； 对于 60% 的评测用例，1 &lt;= n &lt;= 100； 对于所有评测用例，1 &lt;= n &lt;= 100000，0 &lt;= 节目的好看值 &lt;= 100000。思路：就是先从大到小排一下序，然后取较大的前m个，然后把这前m个按以前的num顺序输出出来。#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int n,m,cnt;struct s&#123; int h; int num;&#125;;int cmp(s a1,s a2)&#123; return a1.h&gt;a2.h;&#125;struct s a[100010];int tmp[100010];int main()&#123; memset(tmp,0,sizeof(tmp));//mem在string.h中 cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i].h; a[i].num=i+1; &#125; sort(a,a+n,cmp); for(int i=0;i&lt;m;i++)&#123; tmp[a[i].num]=a[i].h; //cout&lt;&lt;a[i].h&lt;&lt;&#x27; &#x27;&lt;&lt;a[i].num&lt;&lt;endl; &#125; for(int i=0;i&lt;n+1;i++)&#123; if(tmp[i]!=0)cout&lt;&lt;tmp[i]&lt;&lt;&quot; &quot;; if(cnt==m&amp;&amp;tmp[i]!=0)cout&lt;&lt;endl; cnt++; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"author":"aoyuehan"},{"title":"新生训练01","slug":"新生训练01","date":"2020-01-14T05:36:00.000Z","updated":"2022-02-26T03:52:51.086Z","comments":true,"path":"2020/01/14/新生训练01/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/14/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%8301/","excerpt":"","text":"题解连接 C - Choosing Symbol Pairs题意：求一个字符串中有多少第i个和第j个字母或数字相同的对数，其中（i，j）与（j，i）不相同。解法： 求这一个字母出现的次数，然后从串的头扫到尾，每个字符出现的次数相加就是ans； 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;int main()&#123; map&lt;char,int&gt; cishu; long long ans=0; char c[100010]; cin&gt;&gt;c; int n=strlen(c); for(int i=0;i&lt;n;i++) cishu[c[i]]++; for(int i=0;i&lt;n;i++)&#123; ans+=cishu[c[i]]; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; D - Sum题意 给你两个数字，从第一个比数字里每一位中最大的数大的进制开始，到16进制，在当前的进制下进行加法，求出结果以后求长度的最大值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283解法一：#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#define maxn 200using namespace std;int getmaxnum(int x)//找一个数字中最大数位&#123; int max=0; while(x) &#123; int s=x%10; if(s&gt;max) max=s; x/=10; &#125; return max;&#125;int change(int x,int base)//10进制转base进制&#123; int s=0,p=1; while(x) &#123; s+=x%10*p; x/=10; p*=base; &#125; return s;&#125;int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; int base=max(getmaxnum(a),getmaxnum(b))+1;//求基数 int sum=change(a,base)+change(b,base);//在base进制下两数相加，求十进制结果 int j=0; while(sum)//求其位数 &#123; int s=sum%base; sum/=base; j++; &#125; cout&lt;&lt;j&lt;&lt;endl; return 0;&#125;方法二：梁sir的解法：import java.io.BufferedInputStream;import java.math.BigInteger;import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner cin = new Scanner(new BufferedInputStream(System.in)); int a = cin.nextInt(); int b = cin.nextInt(); int n = a, m = b; int maxx = 0; while(a!=0) &#123; maxx = Math.max(maxx,a%10); a/=10; &#125; while(b!=0) &#123; maxx = Math.max(maxx,b%10); b/=10; &#125;// System.out.println(maxx); int ans = 0; for(int i=maxx+1;i&lt;=16;i++) &#123; String nn = Integer.toString(n); String mm = Integer.toString(m); BigInteger s1 = new BigInteger(nn,i); BigInteger s2 = new BigInteger(mm,i);// System.out.println(s1 + &quot; &quot; + s2 + &quot; &quot;+s1.add(s2).toString(i)); ans = Math.max(ans, s1.add(s2).toString(i).length()); &#125; System.out.println(ans); &#125;&#125; G - You’re Given a String…暴力破解，直接遍历所有的子串进行比较就可以了，这种方法要记住。 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std; int main()&#123; string s; while(cin &gt;&gt; s)&#123; int ls = s.length() ; int max1 = 0; //一定要初始化为0 for(int i = 0 ; i &lt; ls ; i++)&#123; for( int j = i + 1 ; j &lt; ls ; j++)&#123; int m = 0; while(s[i + m] == s[j + m] )&#123; m++; &#125; max1 = max(m,max1); &#125; &#125; cout &lt;&lt; max1 &lt;&lt; endl; &#125; return 0;&#125; H-Party题意：现在party上有n个人参加，然后依次按照规律离开，第一次是有0个朋友的人离开，第二次是有1个朋友的人离开，第三次是有2个朋友的人离开，依次是3,4,5,6，。。n-1个朋友的一次离开，求最后party会剩下多少人 思路：找规律，当一个人或2个人的时候，将会剩下0个人，3个人以上，即n个人时，将会剩下（n-2)个人 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; int t; int a; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;a; if(a==2||a==1)cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; else cout&lt;&lt;a-2&lt;&lt;endl; &#125;&#125; J - Second Order Statistics 对一个整数序列（可以有负数）进行排序，找第二小的数。而且 In other words it is the smallest element strictly greater than the minimum. 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;int a[110];int main()&#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i]; set&lt;int&gt;v(a,a+n); //sort(v.begin(),v.end(),less&lt;int&gt;()); 这样不对，set不能进行排序，会自动从小到大排序了 set&lt;int&gt;::iterator it=v.begin(); v.erase(it); it=v.begin();// for(set&lt;int&gt;::iterator it=v.begin();it!=v.end();it++)// cout&lt;&lt;*it&lt;&lt;&quot; &quot;; if(v.size()==0)cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; else &#123; printf(&quot;%d&quot;,*it); &#125; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"新生训练","slug":"新生训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"新生训练03","slug":"新生训练03","date":"2020-01-10T08:01:00.000Z","updated":"2022-02-26T03:52:51.006Z","comments":true,"path":"2020/01/10/新生训练03/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/10/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%8303/","excerpt":"","text":"A - 最小的二进制数题意：给你一个01组成的字符串，求这个字符串通过变换之后可以表示的最小二进制数。有两种变换方式： 123You can perform two different operations on this string: swap any pair of adjacent characters (for example, &quot;101&quot; &quot;110&quot;); replace &quot;11&quot; with &quot;1&quot; (for example, &quot;110&quot; &quot;10&quot;). 思路：不管1的个数是偶数个还是奇数个，最后都可以变为一个1，统计0个数输出多少个0；当没有1的时候不能输出1，所以要特判。 123456789101112131415161718#include&lt;iostream&gt;#include&lt;string.h&gt; using namespace std;char s[120];int main()&#123; int n=0,one=0,zero=0; cin&gt;&gt;n; getchar();//注意这地方要消去回车，因为上面是cin，下面为c语言的gets gets(s); for(int i=0;i&lt;n;i++)&#123; if(s[i]==&#x27;0&#x27;)zero++; else one++; &#125; if(one&gt;=1)cout&lt;&lt;&quot;1&quot;;//注意当测试数据为0的时候,不能输出1 for(int i=0;i&lt;zero;i++)cout&lt;&lt;&quot;0&quot;; cout&lt;&lt;endl; &#125; B - 线段的包含关系求给出的段的包含关系，输出一组解（多解）即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586方法1（暴力）：//超时#include&lt;iostream&gt;using namespace std;const int maxn=3*1e5+10;typedef struct &#123; int l; int r;&#125;seg;seg a[maxn];int main()&#123;//超时 int n; bool is=false; int temp1,temp2; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d %d&quot;,&amp;a[i].l,&amp;a[i].r); &#125; for(int i=1;i&lt;n;i++)&#123; for(int j=i+1;j&lt;=n;j++)&#123; if(a[i].l&lt;=a[j].l&amp;&amp;a[i].r&gt;=a[j].r)&#123; temp1=j;temp2=i; is=true; break; &#125; if(a[i].l&gt;=a[j].l&amp;&amp;a[i].r&lt;=a[j].r)&#123; temp1=i;temp2=j; is=true; break; &#125; &#125; if(is)break; &#125; if(is)printf(&quot;%d %d\\n&quot;,temp1,temp2); else printf(&quot;-1 -1\\n&quot;);&#125;方法2（贪心）：/* 设置一个结构体 按左端点排序 从1开始枚举 当枚举到的点的右端点&lt;=已经枚举到的最大值时输出答案即可 **就是两个变量，确定一个变量，比较另一个变量来达到比较的方法***/#include &lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=3*1e5+10;struct node&#123; int l, r, num;&#125;s[N];bool cmp(node a, node b)&#123;//这种方法巧妙 ，但是相等的时候不判断就会出错 return a.l&lt;b.l||a.l==b.l&amp;&amp;a.r&gt;b.r;&#125;/*或者cmp这样写：bool cmp(sem a,sem b)&#123; if(a.l==b.l) return a.r&gt;b.r; return a.l&lt;b.l;&#125; */int main()&#123; int n, ans, Maxnum; cin&gt;&gt;n; for (int i = 1; i &lt;= n; i++) &#123; s[i].num = i; cin&gt;&gt;s[i].l&gt;&gt;s[i].r; &#125; sort(s + 1, s + n + 1, cmp); for (int i = 1; i &lt;= n; i++)&#123; if (ans &gt;= s[i].r) &#123; cout&lt;&lt;s[i].num&lt;&lt;&#x27; &#x27;&lt;&lt;Maxnum&lt;&lt;endl; return 0; &#125; else ans = s[i].r, Maxnum = s[i].num; &#125; cout&lt;&lt;-1&lt;&lt;&#x27; &#x27;&lt;&lt;-1&lt;&lt;endl; return 0;&#125; C - 地下城还有劳拉题意:从(1,1)开始，按照图示方式走位，给出步数，求最终停在哪个点。 解题方法： 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main()&#123; long long n,m,k; long long col,row; //while(true)&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; if(k&lt;n)&#123; if(k==0)cout&lt;&lt;&quot;1 1&quot;&lt;&lt;endl; else cout&lt;&lt;++k&lt;&lt;&quot; &quot;&lt;&lt;&quot;1&quot;&lt;&lt;endl; &#125; else&#123; row=(k-n)/(m-1); col=(k-n)%(m-1); if(row&amp;1)cout&lt;&lt;n-row&lt;&lt;&quot; &quot;&lt;&lt;m-col&lt;&lt;endl; else cout&lt;&lt;n-row&lt;&lt;&quot; &quot;&lt;&lt;col+2&lt;&lt;endl; &#125; //&#125;&#125; D - 心火牧日常计算题意：给你一堆动物（或者怪兽），每个动物有生命值和战斗力，你作为指挥官有两个能力，第一个是任意指定一个士兵把他的生命值×2，另一个是把他的生命值变成他的攻击力。现在给你a次使用第一种能力，b次使用第二种能力的机会，问你这些动物总的战斗力，而不是杀死这些动物所需要的血量是多少最大是多少？ 这一题是一个有两种属性，这两个属性有相关性的典型的贪心问题，要学会这种方法。 思路：首先把所有原有士兵的战斗值都都加起来，记为ans。对所有士兵进行排序（预处理），排序按照士兵的生命值减去战斗的大小，从大到小排序。将排序后的士兵，从头开始，把生命值赋给战斗力，这里注意，替换的次数要小于b，同时记录替换了多少个，记为ind，而且要替换生命值大于战斗力的。如果题目中给定的b为0，那么直接输出ans（因为不能用二技能交换，所以只需要输出所有动物的伤害值之和就好了）。接下来要找这么一个士兵，将他的生命值翻成2^a的倍数，然后赋给他的生命值。此处可以得知如果要在这n个士兵的生命进行翻倍，然后赋给战斗力，那么一定是找其中一个最生命最大的，让他翻2^a倍，而不是用某种策略将翻倍的次数均摊给某些士兵。（贪心策略） 如果ind值小于b次，那么表示还能继续使用赋值的技能。分交换过和没交换过两种情况：判断将该士兵生命值翻倍并赋给战斗力后，与原来的ans比较，如果比ans大，则更新。 如果ind值等于b次（因为在上一步中ind的值最大不超过b的值），不能继续使用二技能了，那么就要挑一个生命值减去战斗力值最小的，而且在上一步中已经被替换过生命和战斗力的动物，把他的生命和战斗力替换回去。分交换过和没交换过两种情况：接着判断将某一个动物的生命值提高2^a倍赋值给战斗力之后ans值的大小，如果比ans大，则更新。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll; const int maxn = 200010;struct node&#123; int hp,dam; int ex;&#125;;int cmp(const node &amp;n1,const node &amp;n2)&#123; if(n1.hp-n1.dam!=n2.hp-n2.dam) return n1.hp-n1.dam&gt;n2.hp-n2.dam; return n1.hp&gt;n2.hp;&#125;struct node c[maxn];int main()&#123; int n,a,b,ind=0; ll tmp;//第一次的时候把tmp定义为int类型了，然后wa了一次 ll ans=0; ll res=0; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; res=pow(2,a); for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;c[i].hp&gt;&gt;c[i].dam; c[i].ex=0; ans+=c[i].dam; &#125; sort(c+1,c+n+1,cmp); for(int i=1,j=1;i&lt;=n&amp;&amp;j&lt;=b;i++,j++)&#123; if(c[i].hp&gt;c[i].dam)&#123; ind++; c[i].ex=1; ans-=c[i].dam; ans+=c[i].hp; &#125; &#125; //特判 if(b==0)&#123; cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125; if(ind&lt;b)&#123;//还有能交换的没交换 tmp=ans; for(int i=1;i&lt;=n;i++)&#123; if(c[i].ex)&#123;//被交换过 if(ans-c[i].hp+c[i].hp*res&gt;tmp)&#123; tmp=ans-c[i].hp+c[i].hp*res; &#125; &#125;else&#123; if(ans-c[i].dam+c[i].hp*res&gt;tmp)&#123; tmp=ans-c[i].dam+c[i].hp*res; &#125; &#125; &#125; cout&lt;&lt;tmp&lt;&lt;endl; &#125;else&#123;//ind==b的时候， tmp=ans; for(int i=1;i&lt;=n;i++)&#123; if(c[i].ex)&#123;//被交换过 ,试着用一下a技能，看是否大于原来的 if(ans-c[i].hp+c[i].hp*res&gt;tmp)&#123; tmp=ans-c[i].hp+c[i].hp*res; &#125; &#125;else&#123;//选一个交换过的hp-dam最小的不交换，然后从没交换的里面交换一个 ，试着用一下a技能，看是否大于原来的 if(ans-c[ind].hp+c[ind].dam-c[i].dam+c[i].hp*res&gt;tmp)&#123; tmp=ans-c[ind].hp+c[ind].dam-c[i].dam+c[i].hp*res; &#125; &#125; &#125; cout&lt;&lt;tmp&lt;&lt;endl; &#125; &#125; tmp：这题的那个tmp如果用int ，会溢出，因为ans必须的是longlong类型的（因为有1 ≤ n ≤ 2·1e5；1 ≤ hp, dmg ≤ 1e9，所以n个dam相加会超出int类型的存储范围），所以tmp也必须的是longlong类型。 E - 法法在分配工作题意： 给一个数n，领导者的个数为i个，剩下的人可以被这n个领导者领导，且每个领导者手下的人数相等，求有多少种分发。思路：循环变量i为领导者的个数，n-i为除去领导者的人数，如果(n-i)%i等于0，即满足要求，ans++；的结果。 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; int n; long long ans=0; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n/2;i++)&#123; if((n-i)%i==0)ans++; &#125; printf(&quot;%lld\\n&quot;,ans);&#125; F - 法法要穿过大门题目：法法从(0,0)开始，当从y&#x3D;x的一边夸到另一边的时候，要交一个银币(只是从一边接触线，但是没有穿越，不用交银币)，问经过一个序列的运动之后，第一次走之后所在的那一边为他初始的那一边，法法要交多少钱。（R向右走，U向上走）思路：用d和u来代表法法在y&#x3D;x的上边还是下边，然后（x，y）代表法法的位置，然后进行模拟。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;using namespace std;const int maxn=1e5+10;char s[maxn];int main()&#123; //while(1)&#123; int n,x=0,y=0; int ans=0; bool is=false; int d=0,u=0; cin&gt;&gt;n; getchar(); gets(s); if(s[0]==&#x27;U&#x27;)&#123; y++; u=1; &#125;else&#123; x++; d=1; &#125; for(int i=1;i&lt;n;i++)&#123; if(s[i]==&#x27;U&#x27;)&#123; y++; if(x&gt;y&amp;&amp;u)&#123; ans++; &#125; if(x&lt;y&amp;&amp;d)&#123; ans++; &#125; if(x&gt;y)&#123; d=1;u=0; &#125; if(x&lt;y)&#123; u=1;d=0; &#125; &#125;else&#123; x++; if(x&gt;y&amp;&amp;u)&#123; ans++; &#125; if(x&lt;y&amp;&amp;d)&#123; ans++; &#125; if(x&gt;y)&#123; d=1;u=0; &#125; if(x&lt;y)&#123; u=1;d=0; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;// &#125;&#125; G - 法法非法是朋友题目大意： 给出一个圆形房间的圆B的圆心坐标（x1,y1）和半径 R，圆B就是房间的范围。给出另一个点A坐标（x2,y2）;求出一个不超出房间且不包含点A的最大的圆C，输出圆C的x,y坐标和半径（特别地，当A位于圆C上时，被认为不在圆C 内）。 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;double dis(double x1,double y1,double x2,double y2)&#123; return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));&#125;int main()&#123; cout.precision(20); double R,x1,x2,y1,y2,r; double ab,ad,ae,af,df,be; double x3,y3; cin&gt;&gt;R&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; if(dis(x1,y1,x2,y2)&gt;=R)&#123; cout&lt;&lt;x1&lt;&lt;&#x27; &#x27;&lt;&lt;y1&lt;&lt;&#x27; &#x27;&lt;&lt;R&lt;&lt;endl; &#125;else if((x1==x2)&amp;&amp;(y1==y2))&#123; cout&lt;&lt;x1+R*1.0/2&lt;&lt;&#x27; &#x27;&lt;&lt;y1&lt;&lt;&#x27; &#x27;&lt;&lt;R*1.0/2&lt;&lt;endl; &#125;else&#123; ab=dis(x1,y1,x2,y2); ad=ab+R; ae=x1-x2;//这地方不能加abs，这样求出来的数可以确定圆c的象限 be=y1-y2; af=ae*ad*1.0/ab; df=be*ad*1.0/ab; x3=x2+af; y3=y2+df; cout&lt;&lt;(x2+x3)*1.0/2&lt;&lt;&#x27; &#x27;&lt;&lt;(y2+y3)*1.0/2&lt;&lt;&#x27; &#x27;&lt;&lt;ad*1.0/2&lt;&lt;endl; &#125;&#125; 但是有一个bug，当认为ae和be都看为线段时，都是正数，那么应该怎么修改呐？？？？？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344//错误代码如下，求问怎么修改？？#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;double dis(double x1,double y1,double x2,double y2)&#123; return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));&#125;int main()&#123; cout.precision(20); double R,x1,x2,y1,y2,r; double ab,ad,ae,af,df,be; double x3,y3; cin&gt;&gt;R&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; if(dis(x1,y1,x2,y2)&gt;=R)&#123; cout&lt;&lt;x1&lt;&lt;&#x27; &#x27;&lt;&lt;y1&lt;&lt;&#x27; &#x27;&lt;&lt;R&lt;&lt;endl; &#125;else if((x1==x2)&amp;&amp;(y1==y2))&#123; cout&lt;&lt;x1+R*1.0/2&lt;&lt;&#x27; &#x27;&lt;&lt;y1&lt;&lt;&#x27; &#x27;&lt;&lt;R*1.0/2&lt;&lt;endl; &#125;else&#123; ab=dis(x1,y1,x2,y2); ad=ab+R; ae=abs(x1-x2);//把ae当做边来看，非负 be=abs(y1-y2); //cout&lt;&lt;ae &lt;&lt;&#x27; &#x27;&lt;&lt;be&lt;&lt;&#x27; &#x27;&lt;&lt;ab&lt;&lt;&#x27; &#x27;&lt;&lt;ad&lt;&lt;endl; af=ae*ad*1.0/ab; df=be*ad*1.0/ab; //cout&lt;&lt;af&lt;&lt;&#x27; &#x27;&lt;&lt;df&lt;&lt;endl; if(y1&lt;=0&amp;&amp;x1&lt;=0)&#123;//点c在第3象限的时候 y3=y2-df; x3=x2-af; &#125;else if(y1&lt;=0&amp;&amp;x1&gt;0)&#123;//第四象限 y3=y2-df; x3=x2+af; &#125; if(y1&gt;0&amp;&amp;x1&lt;=0)&#123;//2 y3=y2+df; x3=x2-af; &#125;else &#123;//1 y3=y2+df; x3=x2+af; &#125; cout&lt;&lt;(x2+x3)*1.0/2&lt;&lt;&#x27; &#x27;&lt;&lt;(y2+y3)*1.0/2&lt;&lt;&#x27; &#x27;&lt;&lt;ad*1.0/2&lt;&lt;endl; &#125;&#125; H - 法法和古代字母I - 法法和古代数学总结：1、如果数据范围是1e9的话，那么在多个这样的数相加的时候数据范围就有可能超出1e9了 ，这一点要注意!!!!2、对于字符数组类型，有strlen,strcopy,都是以\\0为结束符的，可以用gets（char）的方式输入。要注意这种形式 cin&gt;&gt;n; getchar(); gets(s);3、*cmp比较的特殊用法：bool cmp(node a, node b){&#x2F;&#x2F;这种方法巧妙 ，但是有时候为什么不对呐 return a.l&lt;b.l||a.l&#x3D;&#x3D;b.l&amp;&amp;a.r&gt;b.r;}&#x2F;*或者cmp这样写：bool cmp(sem a,sem b){ if(a.l&#x3D;&#x3D;b.l) return a.r&gt;b.r; return a.l&lt;b.l;}*&#x2F;但是： 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 200001;struct node&#123; int hp,dam; int ex;/*这种方法当hp-dam相等时 不行 bool operator&lt;(const node &amp;a1)&#123; return(a1.hp-a1.dam)&lt; (hp-dam)||(a1.hp-a1.dam==hp-dam)&amp;&amp;(a1.hp&gt;hp); &#125;//这样写不对 ,为什么 ？？？？？*/&#125;;int cmp(const node &amp;n1,const node &amp;n2)&#123; return (n1.hp-n1.dam)&gt;(n2.hp-n2.dam)||(n1.hp-n1.dam==n2.hp-n2.dam)&amp;&amp;(n1.hp&gt;n2.hp);/* 或者这样也可以 if(n1.hp-n1.dam!=n2.hp-n2.dam) return n1.hp-n1.dam&gt;n2.hp-n2.dam; return n1.hp&gt;n2.hp;*/&#125;struct node c[maxn];int main()&#123; for(int i=0;i&lt;5;i++)&#123; cin&gt;&gt;c[i].hp&gt;&gt;c[i].dam; &#125; sort(c,c+5,cmp); for(int i=0;i&lt;5;i++)&#123; cout&lt;&lt;c[i].hp&lt;&lt;c[i].dam&lt;&lt;endl; &#125;&#125; 4、这一次的心火牧的计算，是贪心题，本来写好了暴力，超时了之后就不知道怎么改了。看到这种题要想一下怎么贪，找好贪的方法，就本题来说，显然a技能都用在一个动物的身上时要比分摊的用在几个动物身上（这种情况也很难计算，所以要有想到第一种方法（即把a技能都用在一个动物身上）的想法）要贪的多一下。5、 那个给出步数k求位置的题目，要想到找规律来做，因为dfs啥的都不能按给定的方向走。 所以画图找规律，按公式计算位置。 6、不会的英文单词 1234567891011121314151617redundant adj.多余的，过剩的；被解雇的，失业的；冗长的，累赘的redundant leading zeroes 字符串的前缀0adjacent adj.邻近的，毗连的segments n.片段；段数（segment的复数）； v.把…分割成段；细胞分裂（segment的三单形式）segment tree 线段树spells v.拼写（spell的第三人称单数）n.符咒；魅力（spell的复数）；一段时间arbitrary adj.[数]任意的；武断的；专制的arbitrary order任意的顺序gameplay 游戏设置maximum n.[数]极大，最大限度；最大量 adj.最高的；最多的；最大极限的 silver coin 银币quadrant n.象限；[海洋][天]象限仪；四分之一圆the first quadrant 第一象限initially adv.最初，首先；开头access n.通道；进入；机会；使用权；探望权；（对计算机存储器的）访问；（情感）爆发v.接近，使用；访问，存取（电脑文档）adj.（电视节目或时间等）对外公开的represented v.代表；表现；描写（represent的过去分词）","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"新生训练","slug":"新生训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"新生训练_02","slug":"新生训练-02","date":"2020-01-07T06:38:00.000Z","updated":"2022-02-26T03:52:51.808Z","comments":true,"path":"2020/01/07/新生训练-02/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/07/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83-02/","excerpt":"","text":"A - 构造最长递增子串题意： 给定n个元素，你最多可以修改一个元素(可以为任意值)。问你严格递增的最大连续段。 解法一（别人的，我感觉比较牛）：因为要找的序列元素是连续的，所以可以正序dp求出以ai 结尾的最长递增子串，倒序dp求出以ai 开头的最长递增子串。然后只需要从头到尾扫一遍，更改当前ai的值判断能不能使ai两边的串连起来（不能则舍掉一边），更新最大长度即可。原来可以通过l[i]&#x3D;l[i-1]+1;的这种方式求出以ai 开头或结尾的最长递增子串，然后max一下ans和前后两个子串长度和+1 解法二 1234567891011121314151617181920212223242526解法一：#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;using namespace std;const int N=100007;int n,l[N],r[N],a[N],ans;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n))&#123; l[0]=r[0]=l[n+1]=r[n+1]=a[0]=a[n+1]=ans=0; for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) if(a[i]&gt;a[i-1])l[i]=l[i-1]+1; else l[i]=1; for(int i=n;i;i--) if(a[i]&lt;a[i+1])r[i]=r[i+1]+1; else r[i]=1; for(int i=1;i&lt;=n;i++) if(a[i+1]-a[i-1]&gt;1) ans=max(ans,r[i+1]+l[i-1]+1); else ans=max(ans,max(l[i-1]+1,r[i+1]+1)); printf(&quot;%d\\n&quot;,ans); &#125;&#125; B - Is it beautiful？题目大意： 给一个排列，定义 m 为存在一段连续的 1m 的排列(m为这段排列包含连续数的个数)，如 {4，5，1，3，2，6} ，就存在l&#x3D;3，r&#x3D;5的一个区间{ 1，3，2 }，为 m&#x3D;3 的排列，但是就不存在 m&#x3D;2 的排列（m&#x3D;2就是有两个相连续的数）。问对于每一个 m 判断是否存在 1m的一个排列。 思路：只要将每一个数字的位置记录下来为 pos数组（pos数组的下标为这个数，数组的值为该排列的数的大小），例如 {4，5，1，3，2，6} 的 pos 数组就是 {3,5,4,1,2,6} 那么我们只要从前往后记录最大值 maxpos 和最小值 minpos ，然后 maxpos−minpos+1&#x3D;&#x3D;i 就是存在 1~m 的排列。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int pos[200001];int main()&#123; int t,n; cin&gt;&gt;t; int m; while(t--) &#123; cin&gt;&gt;n; for (int i = 1; i &lt;= n; i++)&#123; cin&gt;&gt;m; pos[m] = i; &#125; int maxpos = 1;//为了第一次获得有效范围内的最大最小值要这么写 int minpos = n; for (int i = 1; i &lt;= n; i++)&#123; //这是一个维护一个序列的最大最小值的有效方法 //这要比写一个set或者重新排序或者 //扫描一遍区间来维护区间的最大最小值要好很多 minpos = min(minpos, pos[i]); maxpos = max(maxpos, pos[i]); cout&lt;&lt;(maxpos-minpos+1==i?1:0);//代码的简洁性，可以把好几步和到一起 &#125; cout&lt;&lt;endl; &#125;&#125; C - Juicer不会ing、、、题解blog：https://www.cnblogs.com/dongsheng/archive/2013/04/25/3043512.htmlhttps://blog.csdn.net/weixin_30786617/article/details/97649147https://blog.csdn.net/smile_benson/article/details/51458175https://blog.csdn.net/qq_45530271/article/details/103809647 D - Eat Candies题意给你三堆糖果，每天可以同时吃两个不同颜色的，问最后最多吃多少天 解法一思路：先把r,g,b排序，从小到大为a,b,c如果a+b&lt;&#x3D;c,结果肯定输出a+b否则输出(a+b+c)&#x2F;2原因：为了使天数最多，每次取最多和次多的两堆糖果，当次多的糖果吃到与最少的糖果相等时，把最多的糖果平分到最少和次多那一堆，（如果最多的为奇数，那么总共还剩一个，如果为偶数，所有糖果用完），所以说最优解剩下的糖果不超过两个(a+b&gt;c时). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748解法一：#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int t=0;int a[5];int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;a[1]&gt;&gt;a[2]&gt;&gt;a[3]; sort(a+1,a+4); //从小到大排 if(a[3]&gt;a[1]+a[2]) cout&lt;&lt;a[1]+a[2]&lt;&lt;endl; else cout&lt;&lt;(a[1]+a[2]+a[3])/2&lt;&lt;endl; &#125; return 0;&#125;解法二（别人的思路）：//题意分析:q组数据，每组给定三个正数，每次从中选两个数减一，问最多经过几次使得这三个数中第一次出现0#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int q; scanf(&quot;%d&quot;, &amp;q); while (q --) &#123; int r, g, b; scanf(&quot;%d%d%d&quot;, &amp;r, &amp;g, &amp;b); // 最小值，最大值，中间值 // 思路就是将中间值分配到最小值和最大值上，使得这两个值的大小尽可能接近 int mi = min(r, min(g, b)), ma = max(r, max(g, b)), mid = r + g + b - mi - ma; if (mi + mid &lt;= ma) mi += mid; else &#123; int tmp = mi + mid - ma; mi += mid; mi -= tmp / 2 + tmp % 2; ma += tmp / 2; &#125; printf(&quot;%d\\n&quot;, mi); &#125; return 0;&#125; 解法三：二分枚举 O(lgn) 为什么想到用二分呢？因为天数区间为[1, 1.5×10^8]. 一天吃两个糖果，最多可以有 3e8 个糖果. 因此最多可以吃 1.5e8 天。另外，我们假设糖果总数 n &#x3D; 4. 如果是{4,0,0}，最多能吃0天；{3,1,0}，最多能吃1天；{2,1,1}，最多能吃2天。也就是说，n &#x3D; 4 对应的天数区间为[0,2]. 我们需要求最多天数，即求该区间的有边界。因此，我们可以二分枚举天数，利用天数计算出当前天r,g,b能组成的最大糖果总数(tot)，再与该天吃的糖果总数(mid×2)比较。 那么tot &#x3D; min(mid,r) + min(mid,g) + min(mid,b). 因为在mid天每种糖果最多只能吃不超过mid个，并且糖果吃完后不能再吃。因此是min(mid,*). 如果 tot &lt; mid2 意味着当前吃了mid天后糖果数不够，天数可能取多了，缩小右边界；如果 tot &gt;&#x3D; mid2 意味着mid天数合法，即可以吃到mid天，于是向右逼近，取最大的mid. 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; int r, g, b; scanf(&quot;%d%d%d&quot;,&amp;r, &amp;g, &amp;b); int L = 0, R = 3e8+5; int ans = 0; while(L &lt; R) &#123; int mid = L+R&gt;&gt;1; int tot = min(mid,r) + min(mid,g) + min(mid,b); if(mid*2 &gt; tot) &#123; R = mid; &#125; else if(mid*2 &lt;= tot) &#123; L = mid+1; ans = max(ans,mid); &#125; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; E - 由你来决定怎么颁奖题意：有n个选手，解题数量为pi道（已经从大到小有序），让你从中选出金牌选手，银牌选手，铜牌选手的数量。要求金牌选手的数量小于银牌和铜牌的数量，对于银牌和铜牌的数量不做要求。并且g+s+b的数量不超过n的一半，且尽可能的最大。给你t组测试，输出金牌 银牌 铜牌的数量，若不符合要求输出0 0 0 首先这一题让我知道了n个数据存到数组中，从下标1开始存有时候不见得比从0开始存要好，这一题就是这样，从1开始存就很麻烦，要注意下标和循环变量之间的差异，而从0开始存，就可以减少很多麻烦；而且本题是一个多解题目，只要找到一个符合要求的解就好了（求这个解的方法要能求出其他的解才可以），所以按金牌数量最少的逻辑找到答案就是符合要求的解 tips：向上取整: int a&#x3D;ceil（2.2） &#x2F;&#x2F;a&#x3D;3 int j &#x3D; ceil(-2.2) &#x2F;&#x2F;a&#x3D;2向下取整: int i &#x3D; floor(2.2); &#x2F;&#x2F;a&#x3D;2四舍五入： double i &#x3D; round(2.2);&#x2F;&#x2F;i&#x3D;2 本题的解法就是选出最少的金牌数，然后选出符合要求的最少银牌数这就是合适的划分点，剩下的都给铜牌，最后判断一下各类的数量是否都符合要求即可。本来的想法是在1 2 2的基础上没加1就是加3个，然后求得金牌的最大数量，然后遍历金牌的数量，找到合适的答案，可是这样比较麻烦，做了半天没整出来（解法三）所以写代码要全想好了（实在不会了可以猜答案）再去实现，不然遇到一点问题实现不了就得半途而废了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117解法1#include&lt;iostream&gt;using namespace std;const int maxn=1e6;int p[maxn];int main()&#123; int t,n; int g=0,s=0,b=0; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;p[i]; &#125; for(g=0;g&lt;n&amp;&amp;p[g]==p[0];g++)&#123;&#125; for(s=g;(s&lt;n&amp;&amp;p[s]==p[s-1])||s-g&lt;=g;s++) &#123;&#125; for(b=s;(b&lt;n&amp;&amp;p[b]==p[b-1])||b-s&lt;=g;b++)&#123;&#125; while(b&lt;n/2)&#123; int temp_b=b; while(temp_b&lt;n&amp;&amp;p[b]==p[temp_b])&#123; temp_b++; &#125; if(temp_b&lt;=n/2)b=temp_b;//除号向下取整 else break; &#125; if(g&gt;=s-g||g&gt;=b-s||b&gt;n/2)cout&lt;&lt;&quot;0 0 0&quot;&lt;&lt;endl; else cout&lt;&lt;g&lt;&lt;&quot; &quot;&lt;&lt;s-g&lt;&lt;&quot; &quot;&lt;&lt;b-s&lt;&lt;endl; &#125;&#125;解法二：#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1e6;int p[maxn];int main()&#123; int t,n; int g=0,s=0,b=0; int k=2,j=0; bool is=true; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;p[i]; &#125; for(g=0;g&lt;=n&amp;&amp;p[g+1]==p[1];g++)&#123;&#125; for(s=g+1;(s&lt;=n&amp;&amp;p[s+1]==p[s])||s-g&lt;=g;s++) &#123;&#125; for(b=s+1;(b&lt;=n&amp;&amp;p[b+1]==p[b])||b-s&lt;=g;b++)&#123;&#125; b++; while(b&lt;=(n/2+1))&#123; int temp_b=b; while(temp_b&lt;=n&amp;&amp;p[b]==p[temp_b])&#123; temp_b++; &#125; if(temp_b&lt;=(n/2+1))b=temp_b; else break; &#125; b--; if(g&gt;=s-g||g&gt;=b-s||b&gt;n/2)cout&lt;&lt;&quot;0 0 0&quot;&lt;&lt;endl; else cout&lt;&lt;g&lt;&lt;&quot; &quot;&lt;&lt;s-g&lt;&lt;&quot; &quot;&lt;&lt;b-s&lt;&lt;endl; &#125;&#125;解法三（未实现）：#include&lt;iostream&gt;using namespace std;const int maxn=1e6;int p[maxn];int main()&#123; int t,n; int g=0,s=0,b=0; int k=0,j=0; bool is=true; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;p[i]; &#125; sort(p+1,p+n,greater&lt;int&gt;()); if(n/2&lt;5)&#123; cout&lt;&lt;&quot;0 0 0&quot;&lt;&lt;endl; continue; &#125; int halfn=n/2; int maxg=(halfn-5)%3; //先判断n==10和11的情况，因为1 2 2全都+1 就是2 3 3，所以用来%3 if(n==10||n==11)&#123; for(j=1;j&lt;n;j++)&#123; if(p[j]&gt;p[j+1])break;//找到前后不相等的就跳出来 &#125; g=j; for(j=g+g+1;j&lt;n;j++)&#123; if(p[j]&gt;p[j+1])break; &#125; s=j-g; for(j=j+g+1;j&lt;n;j++)&#123; if(j&gt;n/2)is=false; if(p[j]&gt;p[j+1])break; &#125; b=j-g-s; if(g&lt;s&amp;&amp;g&lt;s&amp;&amp;is)&#123; cout&lt;&lt;g&lt;&lt;&quot; &quot;&lt;&lt;s&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;&quot;0 0 0&quot;&lt;&lt;endl; &#125; continue; &#125; for(int i=1;i&lt;=halfn;i++)&#123; //从1开始往上增加金牌的数量，然后更新原来的 //然后找到符合要求的最后一个，输出 &#125; &#125;&#125; F - XorXor题意： 设f(i,j)&#x3D;ai^ a(i+1)^ a(i+2)^ …^aj 。 求[f(1,1) ^ f(1,2) … f(1,n) ] ^ [f(2,2) ^ f(2,3) … f(2,n)] ^ [f(n,n)] tips：任何数异或它本身&#x3D;0，任何数异或0是它本身，所以一个数自身异或奇数次是它本身，自身异或偶数次是0。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556解法一（数组下标从0开始）：#include&lt;iostream&gt;using namespace std;const int maxn=1e5+10;int a[maxn];int ans;int temp;int t,n;int main()&#123; //因为超时，写了sync都不行，只好换了scanf，然后过了 scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; ans=temp=0; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); //因为第一次提交超时，所以把输入和求k1放在一个循环里 if((n-i)%2==1)temp^=a[i]; //如果a[i]出现奇数次就异或上 &#125; ans=temp;//此时ans为k1 for(int j=0;j&lt;=n-2;j++)&#123; if((n-j)%2==1)temp^=a[j];//执行完后temp为k2，然后依次执行求k3，k4、、、kn ans^=temp;//依次求k1^k2^k3...^kn &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125;解法二（数组下标从1开始，别人思路）：/*所以假设k1=[f(1,1) ^ f(1,2) … f(1,n) ]，其中a[1]是被异或了(n-1+1)次那么k2=[f(2,2) ^ f(2,3) … f(2,n)] ，只需要把k1异或的(n-1+1)次a[1]异或掉就是k2。同理k3=k2异或(n-2+1)次a[2]，k4=k3异或(n-3+1)次a[3] …最终答案就是k1到kn的异或和。*/#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int N=100007;int a[N],ans,now,n,t;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n; now=ans=0; for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); if((n-i+1)%2)now^=a[i]; &#125; for(int i=1;i&lt;=n;i++)&#123; ans^=now; if((n-i+1)%2)now^=a[i]; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125; G - 0011看到梁sir说的括号匹配，好像是呀，0就是(，1就是)；还可以把本题抽象成两个相对的元素a，b之类的，满足条件的可以用该种方法来解题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172错误解法1（双指针扫描）：#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; /* 这种方法在判断01001101 类型（即数列中间为001101的情况，两个指针同时指向0）时就无法正确判断了，所以双指针扫一遍很难判断出来01的插入结果 后来改进为找到离末尾最近的相配对的1的位置，不能实现 */ bool ans; int ptr1,ptr2; string s; int num; cin&gt;&gt;num; while(num--)&#123; ans=true; cin&gt;&gt;s; ptr1=0; ptr2=s.length()-1; if(s[ptr1]!=&#x27;0&#x27;||s[ptr2]!=&#x27;1&#x27;||(s.length()%2!=0))&#123; //当时在这个地方写为ptr2%2==0，是不对的，因为ptr2=length-1了 cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; continue; &#125; while(true)&#123; ptr1++; ptr2--; if(ptr1&gt;ptr2)break; if(s[ptr1]==&#x27;1&#x27;)&#123; ptr2++; ptr1++; &#125; if(!(s[ptr1]==&#x27;0&#x27;&amp;&amp;s[ptr2]==&#x27;1&#x27;)) &#123; ans=false; break; &#125; &#125; if(ans)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; &#125; 正确解法2：/*统计0和1的个数，这个数列的性质是当前位置前的1的个数小于等于0的个数，yes的情况只有当最后扫描一遍之后且0和1的数量相同*/#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;string&gt;using namespace std;int main()&#123; int n; int num0=0,num1=0; string s; int i; cin&gt;&gt;n; while(n--)&#123; cin&gt;&gt;s; for(i=0;i&lt;s.length();i++)&#123; if(s[i]==&#x27;0&#x27;)num0++; else num1++; if(num1&gt;num0)&#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; break; &#125; &#125; //注意yes的条件，要想好，从多方面切入 if(i==s.length()&amp;&amp;num0==num1)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; num0=0;num1=0; &#125;&#125; H - Perfect String题意：给出一个由abc和?构成的字符串，问号可替换为a,b,c（至少有一个问号），如果替换后的字符串相邻的两个字符都不相同，则称为完美字符串（符合要求），就输出该字符串，若无法形成完美字符串，则输出-1 要想到比较和替换问号左右的字符使之不相同就可以了，直接扫一遍就好了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768解法一:#include&lt;iostream&gt;using namespace std;int main()&#123; int t,n,i; string s; cin&gt;&gt;t; while(t--)&#123; int flag=0; cin&gt;&gt;s; for(i=0;i&lt;s.length();i++)&#123; if(s[i]==&#x27;?&#x27;)&#123; if(i!=0) s[i]=(s[i-1]-&#x27;a&#x27;+1)%3+&#x27;a&#x27;;//如a的后面补b else s[i]=&#x27;a&#x27;; if(s[i+1]!=&#x27;?&#x27;) if(s[i]==s[i+1])//若补b后面的问号也为b，则补c就可以了 s[i]=(s[i+1]-&#x27;a&#x27;+1)%3+&#x27;a&#x27;; &#125; &#125; for(i=0;i&lt;s.length();i++)&#123;//char数组要用strlen（a）才可以 if(s[i]==s[i+1])&#123; flag=1; break; &#125; &#125; if(flag) cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl; else cout&lt;&lt;s&lt;&lt;endl; &#125; return 0;&#125;解法二（梁sir）：#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;cstdio&gt;using namespace std;int t,f;string s;int main()&#123; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;s; f=1; for(int i=0;i&lt;s.length();i++)&#123; if(s[i]==&#x27;?&#x27;)&#123; if(i==0)&#123; if(s[i]!=&#x27;a&#x27;&amp;&amp;s[1]!=&#x27;a&#x27;)s[i]=&#x27;a&#x27;;else if(s[i]!=&#x27;b&#x27;&amp;&amp;s[1]!=&#x27;b&#x27;)s[i]=&#x27;b&#x27;;else if(s[i]!=&#x27;c&#x27;&amp;&amp;s[1]!=&#x27;c&#x27;)s[i]=&#x27;c&#x27;; &#125;else &#123; if(s[i+1]!=&#x27;a&#x27;&amp;&amp;s[i-1]!=&#x27;a&#x27;)s[i]=&#x27;a&#x27;;else if(s[i+1]!=&#x27;b&#x27;&amp;&amp;s[i-1]!=&#x27;b&#x27;)s[i]=&#x27;b&#x27;;else if(s[i+1]!=&#x27;c&#x27;&amp;&amp;s[i-1]!=&#x27;c&#x27;)s[i]=&#x27;c&#x27;; &#125; &#125;else if(s[i]==s[i+1])&#123; //其实可以直接在这里判断是否符合要求 //若果第i位的非？字符和后面的字符相等，就不合要求 f=0; break; &#125; &#125; if(f)cout&lt;&lt;s&lt;&lt;&quot;\\n&quot;;else printf(&quot;-1\\n&quot;); &#125;&#125; I - 十进制中的二进制注意：（一定要注意题意）本题在提交的时候要输入多组数据，并没有说先输入case的数量t，所以直接while（cin&gt;&gt;n）或者！&#x3D;eof即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293解法一：#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;//cnt用来遍历这个十位数的长度，因为到10^9，所以大于10的话就可以return了//tmp代表这一次用来判断的数，ans记录符合要求的个数int ans=0;int n;void dfs(int tmp,int cnt)&#123; if(tmp&gt;n)return; if(cnt&gt;10)return ; if(tmp&lt;=n)ans++; dfs(tmp*10,cnt+1); dfs(tmp*10+1,cnt+1);&#125;int main()&#123; while(cin&gt;&gt;n)&#123; dfs(1,1 );//从十位数的1开始，从十位数的个数1开始dfs cout&lt;&lt;ans&lt;&lt;endl; ans=0; &#125;&#125;解法二（别人的）：#include&lt;iostream&gt;using namespace std;typedef long long ll;ll dfs(ll x)&#123; if(x==0)return 0; if(x==1)return 1; return dfs(x&gt;&gt;1)*10+(x&amp;1); &#125;int main()&#123; int n; while(cin&gt;&gt;n)&#123; ll ans=1,cnt=0; while(ans&lt;=n)&#123; cnt++; ans=dfs(cnt); //验证小于n的所有数的二进制表示 &#125; cout&lt;&lt;cnt-1&lt;&lt;endl; &#125;&#125;解法三（别人的）：#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n,ans;void dfs(int v,int d)&#123; if(!d)&#123; if(v&lt;=n&amp;&amp;v)ans++; return; &#125; dfs(v*10,d-1); dfs(v*10+1,d-1);&#125;int main()&#123; while(~scanf(&quot;%d&quot;,&amp;n))&#123; ans=0; dfs(0,10);//dfs，用0和1填10位数，造出来的数小于n结果就++ printf(&quot;%d\\n&quot;,ans); &#125;&#125;解法四（于sir）：#include&lt;iostream&gt;using namespace std;long long n;long long sum;int a[2]=&#123;0,1&#125;;void zhao(long long x)&#123; if(x&gt;n)&#123; return; &#125; else&#123; sum++; for(int i=0;i&lt;2;i++)&#123; zhao(x*10+a[i]); &#125; &#125;&#125;int main()&#123; while(cin&gt;&gt;n)&#123; sum=0; zhao(1); cout&lt;&lt;sum&lt;&lt;endl; &#125; &#125; [J-新年快乐]（https://vjudge.net/problem/279484/origin） 1234567891011121314151617181920212223242526272829303132333435363738//分情况讨论即可#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;using namespace std;int main() &#123; int x,y,z,t; double ans=0.0; while(cin&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;t)&#123; if((y==0&amp;&amp;z==0)||(z-x)==0)&#123; printf(&quot;0.0\\n&quot;); &#125;else&#123; if(y==0)&#123; ans=1.0/2*abs(z-x)*t; printf(&quot;%.1lf\\n&quot;,ans); &#125;else if(z==0)&#123; ans=1.0/2*abs(z-x)*t; printf(&quot;%.1lf\\n&quot;,ans);//注意printf中回车是反斜杠n //continue;因为if-else语句就只执行一个语句块，所以可以不用加continue &#125;else&#123; ans=1.0/2*abs(z-x)*(y+t); printf(&quot;%.1lf\\n&quot;,ans); &#125; &#125; &#125;&#125;解法二（梁sir）：//卧槽，原来这题这么简单；要找那几种情况的共性（本质就是求梯形面积）#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; double x,y,z,t; while(~scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x,&amp;y,&amp;z,&amp;t)) printf(&quot;%.1lf\\n&quot;,(fabs(y)+fabs(t))*fabs(x-z)/2); //高为z-x，上底看做y（当y或t为0的时候就为三角形，但是为0了加上就不影响最终结果了），下底看做t。&#125; tips：abs函数（在math.h中）：函数原型为int abs(int n)；fabs函数（在math.h中）：函数原型为double fabs(double x)；祥见连接C 标准库 - &lt;math.h&gt;另外pow用来处理double类型的数 double pow(double x, double y)long类型 scanf(“%ld”,&amp;n)!&#x3D;EOFlong long类型 scanf(“%lld”,&amp;n)!&#x3D;EOF 一、总结：1、首先这一次知道了代码简洁这东西，感觉自己写的太繁琐了（那个j题，求梯形面积，我却给分了好多情况才写好），比如求同样是实现一个步骤，别人可以一步完成，而自己却要绕好几步，想了想代码简洁还是建立在看过很多代码，思路明确的基础上的，所以要多刷题2、知道了一个求最长递增子串的方法，先正着来一遍，在倒着来一遍，然后ans&#x3D;max(ans,max(l[i-1]+1,r[i+1]+1)); 这种方法太奇妙了，想了想，其实也很符合常规思路，要找最长的，找隔一个的前后两个最长的连在一起就好了。3、做不出来的题，不要自己一直闷着想，给自己一个期限，如1.30小时，做不出来看看别人思路；对哦，要写完了自己的题解之后多看看别人的题解，然后找到他们的长处（如简洁，思路巧妙，效率高）然后想想他们的思维，改变自己的思维方式。取他人之长补己之短。4、另一个要好好读题，比如i题那个多组输入，其实是放在while（cin&gt;&gt;n）这种形式，而不是输入组数的那种方式。而且英文的题意有时候很难弄懂，要坚持读，理解5、D题告诉 我不会的（还有0101这题，a???cb这题），要从多组数据中找到规律，然后有依据的假设，并进行验证。这题答案为(a[1]+a[2]+a[3])&#x2F;2，可以从多组数据中进行找规律，猜测。6、写代码要一下子想好所有的解决方案，比如维护最大值，最小值（通过set维护，或者sort，或者），不要因为一时没想好，开始写后又被卡住了。 代办 最长递增子序列 lis lcs什么东西的 a题和c题有时间在重新理解一下 二、做题遇到的英文： 1234567891011121314151617181920consecutive 连续不断的is legal 是否是符合要求的characters n.特性；人物角色（character复数）v.描述（character的三单形式）；表示…的特性restriction n.限制；约束；束缚respectively adv.分别地；各自地，独自地contest 竞争 比赛Regional adj.(regional)地区的，区域的；局部的；整个大地区的standings n.战绩（standing的复数）；名次表participant n.参与者，参加者 adj.参与的jury 裁判 判断positive number n.[数]正数Xor 异或;异或门;按位异或;逻辑异或;运算符permutation n.[数]排列；[数]置换indices n.指数；目录（index的复数）such that the numbers [pl,pl+1,…,pr]determine v.（使）下决心，（使）做出决定vt.决定，确定；判定，判决；限定 vi.确定；决定；判决，终止；[主用于法律]了结，终止，结束It is guaranteed 约定exceed 超出某个范围subsegment of the sequence a 意为a的一个子串at most 至多 三、0x3f3f3f3f的介绍： 0x3f3f3f3f的十进制是1061109567，是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。 另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”，而0x7fffffff不能满足“无穷大加一个有穷的数依然是无穷大”这个条件，它会变成了一个很小的负数。），事实上0x3f3f3f3f+0x3f3f3f3f&#x3D;2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。 0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))，方便又高效，但是当我们想将某个数组全部赋值为无穷大时，就不能使用memset函数而得自己写循环了，因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0（一般我们只有赋值为-1和0的时候才使用它）。现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"新生训练_02","slug":"新生训练-02","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83-02/"}],"author":"aoyuehan"},{"title":"新生训练calss4-数据结构基础","slug":"新生训练calss4-数据结构基础","date":"2020-01-06T10:38:27.000Z","updated":"2022-04-03T13:18:44.656Z","comments":true,"path":"2020/01/06/新生训练calss4-数据结构基础/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/06/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83calss4-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/","excerpt":"","text":"线段树： 这个就是因为在+k的时候，只是给了某个区间加上了k，并没有给这个区间的每个值加上k，但是在单点查询的时候才给每个区间加上k https://www.cnblogs.com/jason2003/p/9676729.html 洛谷p3374模板题 （树状数组实现 单点修改，区间查询） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int n,m,bit[2000001],s;inline int lowbit(int x)&#123; return x&amp;(-x);&#125;inline void add(int x,int k)&#123; while(x&lt;=n) &#123; bit[x]+=k; x+=lowbit(x); &#125;&#125;inline int sum(int x)&#123; int ans(0); //初始化ans为0 while(x!=0) &#123; ans+=bit[x]; x-=lowbit(x); &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); register int i,j; cin&gt;&gt;n&gt;&gt;m; for(i=1;i&lt;=n;i++) &#123; int x; cin&gt;&gt;x; add(i,x); &#125; for(i=1;i&lt;=m;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(a==1) &#123; add(b,c); &#125; else &#123; cout&lt;&lt;sum(c)-sum(b-1)&lt;&lt;endl;//这一段的和就是两点的sum之差，之所以减b-1就是要包括欧b这地方的值 &#125; &#125; return 0;&#125;tips1:关于lowbit函数：如:x =1： 1 &amp;－１（设位数为８）0000 0001 &amp; 1111 1111 = 1 x = 6:6 &amp; -6 0000 0110 &amp;1111 1010 = 2 （因为正数的补码是是他本身，负数的补码是在源码的的基础上（除符号位外），将所有位 取反，然后在+1）总结一下，其实就是：求出2^p(其中p: x 的二进制表示数中， 右向左数第一个1的位置)，如6的二进制表示为110，向左数第零个为0，第一个为1，则p=1，故Lowbit(6) = 2^1 = 2。 tips2：register int中的register 表示使用cpu内部寄存器（寄存器是中央处理器内的组成部分。 寄存器是有限存贮容量的高速存贮部件）的变量，而平时的int是把变量放在内存中，存到寄存器中可以加快变量的读写速度 这是一个循环1e8的代码在使用int的用时 用时0.53而加上register后，用时仅需0.15； 所以register可以用在多层for循环中加快执行的素的。解法二（线段树）：#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=500010;int sum[maxn*8];int in[maxn];void build(int now,int l,int r)&#123; if(l==r) &#123;//如果l==r，那么该节点就是叶子结点 sum[now]=in[l]; return ; &#125; int mid=(l+r)/2; build(now*2,l,mid); build(now*2+1,mid+1,r); sum[now]=sum[now*2]+sum[now*2+1]; //这个2*now和now*2+1这个分别是数组存的树的左右子树的下标，那么sum就是 //这个节点的权值，就是这个节点表示的线段和&#125;void add(int now,int l,int r,int x,int k)&#123; if(l==r) &#123; sum[now]+=k; return ; &#125; int mid=(l+r)/2; if(x&lt;=mid) add(now*2,l,mid,x,k); else add(now*2+1,mid+1,r,x,k); sum[now]=sum[now*2]+sum[now*2+1];&#125;ll query(int now,int l,int r,int x,int y)&#123;//在l到r的范围内查找区间x到y的区间和，now是用来求这个节点表示的这一线段的和 if(x&lt;=l&amp;&amp;y&gt;=r) &#123;//就是找到有一段线段l到r包含在x到y的范围中 //（在递归的过程中l和r的值会发生改变），那么ans应该加上这一段线段的和 return sum[now]; &#125; ll ans=0; int mid=(l+r)/2; if(x&lt;=mid) ans+=query(now*2,l,mid,x,y); if(mid+1&lt;=y) ans+=query(now*2+1,mid+1,r,x,y); return ans; &#125;int main()&#123; int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;in[i]); &#125; build(1,1,n); for(int i=1;i&lt;=m;i++) &#123; int tmp,x,k,y; cin&gt;&gt;tmp; if(tmp==1) &#123; cin&gt;&gt;x&gt;&gt;k; add(1,1,n,x,k); &#125; if(tmp==2) &#123; cin&gt;&gt;x&gt;&gt;y; printf(&quot;%lld\\n&quot;,query(1,1,n,x,y)); &#125; &#125; return 0;&#125; 洛谷p3368 （树状数组，区间修改 单点查询；利用差分法，但不能实现区间查询） PS: 本题可以用线段树和树状数组来做，这个题只求x的值，所以可以用差分+树状数组来做，简单的解释一下，例如有数组a[]&#x3D;{1, 5 , 6 , 7 ,4 , 5};差分数组就是c[]&#x3D;{1, 4, 1, 1, -3, 1};可以看出a[x]&#x3D;c[1]+…+c[x];现在【2,4】+3；a数组变成a[]&#x3D;{1, 7 , 8, 9 ,4 , 5};，c数组变成c[]&#x3D;{1, 6, 1, 1, -5, 1}；数组只有a[1]和a[5]变了，a[1]+2,a[5]-2;，所以我们每次只改变两个数就可以了，可以看代码理解下，思想很巧妙。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include&lt;string&gt;#define lowbit(x) x&amp;(-x)typedef long long ll;using namespace std;ll num[maxn];int n,m;ll getsum(int x)&#123; ll sum=0; while(x) &#123; sum+=num[x]; x-=lowbit(x); &#125; return sum;&#125;void pushdata(int x,int k)&#123; while(x&lt;=n) &#123; num[x]+=k; x+=lowbit(x); &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; int t=0,t1; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;t1); pushdata(i,t1-t); t=t1; &#125; while(m--) &#123; int a,x,y,k; scanf(&quot;%d&quot;,&amp;a); if(a==1) &#123; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;k); pushdata(x,k);//区间修改 pushdata(y+1,-k); &#125; else &#123; scanf(&quot;%d&quot;,&amp;x); printf(&quot;%lld\\n&quot;,getsum(x));//单点查询 &#125; &#125; return 0;&#125;方法二（线段树）：#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#define ll long longusing namespace std;const int maxn=500010;int mark[maxn*8],in[maxn];int n,m;void pushdown(int now,int l,int r)&#123; if(l==r) return; mark[now*2]+=mark[now]; mark[now*2+1]+=mark[now]; mark[now]=0;&#125;void plusmark(int now,int l,int r,int x,int y,ll k)&#123; //cout&lt;&lt;now&lt;&lt;&#x27; &#x27;&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;&#x27; &#x27;&lt;&lt;mark[now]&lt;&lt;endl;; pushdown(now,l,r); if(x&lt;=l&amp;&amp;y&gt;=r) &#123; mark[now]+=k; return ; &#125; int mid=(l+r)/2; if(x&lt;=mid) plusmark(now*2,l,mid,x,y,k); if(mid+1&lt;=y) plusmark(now*2+1,mid+1,r,x,y,k); &#125;ll getsum(int now,int l,int r,int x)&#123; pushdown(now,l,r); if(l==r) &#123; return mark[now]; &#125; int mid=(l+r)/2; ll ans=0; if(x&lt;=mid) ans=getsum(now*2,l,mid,x); else ans=getsum(now*2+1,mid+1,r,x); return ans;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;in[i]); &#125; for(int i=1;i&lt;=m;i++) &#123; int tmp,x,y,k; cin&gt;&gt;tmp; if(tmp==1) &#123; scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;k); plusmark(1,1,n,x,y,k); &#125; if(tmp==2) &#123; scanf(&quot;%d&quot;,&amp;x); printf(&quot;%lld\\n&quot;,getsum(1,1,n,x)+in[x]); &#125; &#125; return 0;&#125; 树状数组实现区间查询，区间修改，单点查询，单点修改 https://blog.nowcoder.net/n/bb352f0f59ea4509b0a7fc15b11fa5a8 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;int sum1[1000];int sum2[1000];int a[1000];int n,m;int lowbit(int x)&#123; return x&amp;(-x);&#125;void update(int x,int w)&#123;//更新效果：把x位置后面所有的数的值+w for (int i=x;i&lt;=n;i+=lowbit(i))&#123; sum1[i]+=w;//维护前缀和c[i]；在这一个点处修改了，那么后面的值应该做相应的变化 sum2[i]+=w*(x-1);//维护前缀和c[i]*(n-1)；；这个x是传过来的那个x，这样的话就可以只改变哪一项，后面的值就加上这一项改变的那个值就好了 &#125;&#125;void range_update(int l,int r,int val)//更新效果：把l位置到r位置所有的数的值+w&#123; update(l,val); update(r+1,-val);&#125;int getsum(int x)&#123;//得到某点的值 int sum=0; while(x) &#123; sum+=sum1[x]; x-=lowbit(x); &#125; return sum;&#125;int sum(int x)&#123;//求1-x的和,这就是求前缀和的前缀和，sum1数组为差分数组的前缀和，函数返回的是差分数组1~n的前缀和的前缀和 int ans=0; for (int i=x;i&gt;0;i-=lowbit(i))&#123; ans+=x*sum1[i]-sum2[i]; //n*∑1 n c[i]-∑1 n c[i]*(i-1) ;注意，n只乘前面那一项一次，后面的 //那个（i-1）需要每次都往里面乘 &#125; return ans;&#125;int range_ask(int l,int r)&#123;//求l-r的和 return sum(r)-sum(l-1);&#125;int main()&#123; while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&#123; for (int i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); update(i,a[i]-a[i-1]);//维护差分数组 &#125; &#125; return 0;&#125; P3372 【模板】线段树如题，已知一个数列，你需要进行下面两种操作： 1.将某区间每一个数加上x2.求出某区间每一个数的和 1https://www.luogu.org/problemnew/solution/P3372 https://www.cnblogs.com/xenny/p/9739600.htmlhttps://www.luogu.org/blog/TJor/xian-duan-shu-yu-shu-zhuang-shuo- https://blog.csdn.net/qq_45530271/article/details/103092245 线段树 敌兵布阵 HDU1166Input 第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;&#x3D;50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;&#x3D;ai&lt;&#x3D;50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;&#x3D;j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令 Output 对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;#define Max 50005 int num[Max];//题目要求士兵的最大数量int tree[Max&lt;&lt;2];//建树的空间开成需处理空间的4倍void build(int p,int l,int r)//p为根节点，l为左端点，r为右端点&#123; if(l==r) &#123;tree[p] = num[l];return;&#125;//当左右端点相等时代表该点是叶子节点，赋初值并递归出口 int mid=(l+r)&gt;&gt;1;//相当于（l+r）/2 build(p&lt;&lt;1,l,mid);//p&lt;&lt;1相当于p*2，是左二子 build(p&lt;&lt;1|1,mid+1,r);//p&lt;&lt;1|1相当于p*2+1,是右儿子 tree[p]=tree[p&lt;&lt;1]+tree[p&lt;&lt;1|1];//父亲的值等于左右儿子的和&#125;void change(int p,int l,int r,int x,int num)//此处num代表需要更新的数据，加用正数，减用负数&#123; if(l==r) &#123;tree[p]+=num;return;&#125;//如果是叶子节点，就是对应p位置更新操作 int mid=(l+r)/2; if(x&lt;=mid) change(p*2,l,mid,x,num);//如果是左孩子，就在左孩子里找 else change(p&lt;&lt;1|1,mid+1,r,x,num); tree[p]=tree[p&lt;&lt;1]+tree[p&lt;&lt;1|1];&#125;int Find(int p,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;r&lt;=y) return tree[p]; //如果[l,r]要查询的区间包含root节点，表示直接返回root节点的sum值 int mid=(l+r)&gt;&gt;1; if(y&lt;=mid) return Find(p&lt;&lt;1,l,mid,x,y);//如果y小于等于mid小的，则说明区间在左子树 if(x&gt;mid) return Find(p&lt;&lt;1|1,mid+1,r,x,y);//如果x比mid大，则说明区间在有子树 return (Find(p&lt;&lt;1,l,mid,x,mid)+Find(p&lt;&lt;1|1,mid+1,r,mid+1,y)); //否则说明横跨两个区间，需要在两个区间同时查找&#125;int main()&#123; int T,N,a,b; scanf(&quot;%d&quot;,&amp;T); string str; int ans=1; while(T--) &#123; scanf(&quot;%d&quot;,&amp;N); for(int i=1;i&lt;=N;i++) scanf(&quot;%d&quot;,&amp;num[i]); build(1,1,N); printf(&quot;Case %d:\\n&quot;,ans++); //cout&lt;&lt;&quot;Case &quot;&lt;&lt;ans++&lt;&lt;&quot;:&quot;&lt;&lt;endl; while(cin&gt;&gt;str) &#123; if(str==&quot;End&quot;) break; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); if(str==&quot;Query&quot;) &#123; if(a&gt;b) swap(a,b); printf(&quot;%d\\n&quot;,Find(1,1,N,a,b));//起始位置是p，然后在1~N的范围内查找a b区间 &#125; if(str==&quot;Add&quot;) &#123;//起始位置是p，在1到N的范围内查找，在下标为a的位置的值加b change(1,1,N,a,b); &#125; if(str==&quot;Sub&quot;) &#123; //起始位置是p，在1到N的范围内查找，在下标为a的位置的值减b change(1,1,N,a,-b); &#125; &#125; &#125; return 0;&#125; 学生成绩查询最高分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;#define MAX 200005int num[MAX];int tree[MAX*4]; void build(int p,int l,int r)&#123; if(l==r) &#123;tree[p]=num[l]; return;&#125; int mid=(l+r)&gt;&gt;1; build(p&lt;&lt;1,l,mid); build(p&lt;&lt;1|1,mid+1,r); tree[p]=max(tree[p&lt;&lt;1],tree[p&lt;&lt;1|1]); //本题与第一道题的区别就是建树时，父亲的值等于左右儿子中的最大值&#125;void change(int p,int l,int r,int x,int num)&#123; if(l==r) &#123;tree[p]=num; return;&#125; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) change(p&lt;&lt;1,l,mid,x,num); else change(p&lt;&lt;1|1,mid+1,r,x,num); tree[p]=max(tree[p&lt;&lt;1],tree[p&lt;&lt;1|1]);&#125;int Find(int p,int l,int r,int x,int y)&#123; if(x&lt;=l&amp;&amp;y&gt;=r) &#123;return tree[p];&#125; int mid=(l+r)&gt;&gt;1; if(y&lt;=mid) return Find(p&lt;&lt;1,l,mid,x,y); if(x&gt;mid) return Find(p&lt;&lt;1|1,mid+1,r,x,y); return (max(Find(p&lt;&lt;1,l,mid,x,mid),Find(p&lt;&lt;1|1,mid+1,r,mid+1,y))); //这地方为max两者，即线段树的这一个节点存的是子节点中成绩最高的那个值 &#125; int main()&#123; int N,M,a,b; char s[2]; while(scanf(&quot;%d%d&quot;,&amp;N,&amp;M)!=EOF) &#123; for(int i=1;i&lt;=N;i++) scanf(&quot;%d&quot;,&amp;num[i]); build(1,1,N); while(M--) &#123; scanf(&quot;%s%d%d&quot;,s,&amp;a,&amp;b); if(s[0]==&#x27;Q&#x27;) &#123; printf(&quot;%d\\n&quot;,Find(1,1,N,a,b)); &#125; else change(1,1,N,a,b); &#125; &#125; return 0;&#125; 模板 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169//单点修改，单点查询（区间修改变形），区间修改，区间查询#include&lt;iostream&gt;using namespace std;typedef long long ll;const int maxn = 50000+10;int T,p,v,n,mid,kase=0,sum[maxn&lt;&lt;2],lazy[maxn&lt;&lt;2];//sum数组的下标用now来找到，代表该节点的序号；sum数组的值当做该节点的值的大小void push_up(int now) &#123; sum[now] = sum[now&lt;&lt;1] + sum[now&lt;&lt;1|1];&#125;void push_down(int k,int l,int r) &#123; //下放lazy标记//由于区间赋值要用绝对标记，因此当子节点已经有标记时，//要先下传子节点的标记，再下传该节点的标记。//但是区间赋值会覆盖掉子节点的值，因此在这个问题中，直接修改标记就可以了 if(lazy[k]==0)return; int m=(l+r)&gt;&gt;1; sum[k&lt;&lt;1]=(m-l+1)*lazy[k]; sum[k&lt;&lt;1|1]=(r-m)*lazy[k]; lazy[k&lt;&lt;1]+=lazy[k]; lazy[k&lt;&lt;1|1]+=lazy[k]; lazy[k]=0;&#125;void build(int l, int r, int now) &#123; //从now开始，在l，r的范围内创建树 if(l == r) &#123; scanf(&quot;%d&quot;,&amp;sum[now]); return ; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, now&lt;&lt;1);//now*2 build(mid+1, r, now&lt;&lt;1|1);//now*2+1 push_up(now);//往上走的时候跟新这个节点的sum值&#125;void update(int p, int add, int l, int r, int now) &#123; //单点修改，在区间l到r的范围中（l和r在每一次递归的时候都会变的 //，在p的位置加上add，now代表在每次递归数组中p所在位置的下标 if(l == r) &#123; sum[now] += add;//位置为now的sum加上add return ; &#125; int mid = (l + r) &gt;&gt; 1; if(p &lt;= mid) update(p, add, l, mid, now&lt;&lt;1); else update(p, add, mid+1, r, now&lt;&lt;1|1); push_up(now);//修改完了，往上走的时候顺便更新&#125;int query(int L, int R, int l, int r, int now) &#123; //ans记录答案，在l到r的范围中，查找L到R区间的和，now用来存每次sum应该加上的位置的下标 if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[now];//返回的是位置为now的和 &#125; int mid = (l + r) &gt;&gt; 1, ans = 0; push_down(now,l,r);//一定要先下传lazy标记，在向下递归 if(mid &gt;= L) ans += query(L, R, l, mid, now&lt;&lt;1); if(mid+1 &lt;= R) ans += query(L, R, mid+1, r, now&lt;&lt;1|1); return ans;&#125;void modify(int L,int R,int l,int r,int now,int val) &#123; //区间修改 //在L到R的区间上加上val，l和r为每次循环时候的下标 if(L&lt;=l&amp;&amp;R&gt;=r) &#123; lazy[now]=val;//注意这地方是now的位置为val sum[now]=(r-l+1)*val; return; &#125; int mid=(l+r)&gt;&gt;1; push_down(now,l,r);//一定要先push_down之后再modify if(L&lt;=mid)modify(L,R,l,mid,now&lt;&lt;1,val);//这地方写L&lt;=mid,后面写mid，而下一行写R&gt;mid，然后写mid+1到r if(R&gt;mid)modify(L,R,mid+1,r,now&lt;&lt;1|1,val); push_up(now); //因为修改了某部分的值，所以，往上走的时候跟新下&#125;int main() &#123; int val=0; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d&quot;,&amp;n); build(1,n,1); char s[10]; printf(&quot;Case %d:\\n&quot;,++kase); while(~scanf(&quot;%s&quot;,s)) &#123; if(s[0] == &#x27;m&#x27;) &#123; //输入m p v val修改区间p v的每个节点的值全为val cin&gt;&gt;p&gt;&gt;v&gt;&gt;val; //scanf(&quot;%d%d%d&quot;,&amp;p,&amp;v,&amp;val); modify(p,v,1,n,1,val); //修改p v区间加上value，在1~n的区间内查找，起始位置为now=1， &#125; else &#123; if(s[0] == &#x27;E&#x27;) break; scanf(&quot;%d%d&quot;,&amp;p,&amp;v); if(s[0] == &#x27;A&#x27;) update(p,v,1,n,1); //修改p的位置加上v，在1~n的范围内进行查找，其实now为1 if(s[0] == &#x27;a&#x27;) modify(1,n,1,n,1,1); //让区间1~n都变为1，其实位置now为1 else if(s[0] == &#x27;S&#x27;) update(p,-v,1,n,1); //修改p的位置减去v，在1~n的范围内进行查找，其实now为1 else printf(&quot;%d\\n&quot;,query(p,v,1,n,1)); //单点查询，就相当于区间查询时把区间换位同一个点呀 &#125; &#125; &#125; return 0;&#125;//单点修改，区间查询//单点修改，区间查询 #include&lt;iostream&gt;using namespace std;typedef long long ll;const int maxn = 50000+10;int T,p,v,n,mid,kase=0,sum[maxn&lt;&lt;2];void push_up(int now) &#123; sum[now] = sum[now&lt;&lt;1] + sum[now&lt;&lt;1|1];&#125;void build(int l, int r, int now) &#123; //从now开始，在l，r的范围内创建树 if(l == r) &#123; scanf(&quot;%d&quot;,&amp;sum[now]); return ; &#125; int mid = (l + r) &gt;&gt; 1; build(l, mid, now&lt;&lt;1);//now*2 build(mid+1, r, now&lt;&lt;1|1);//now*2+1 push_up(now);//跟新这个节点的sum值 &#125;void update(int p, int add, int l, int r, int now) &#123; //单点修改，在区间l到r的范围中（l和r在每一次递归的时候都会变的 //，在p的位置加上add，now代表在每次递归数组中p所在位置的下标 int mid = (l + r) &gt;&gt; 1; if(l == r) &#123; sum[now] += add; return ; &#125; if(p &lt;= mid) update(p, add, l, mid, now&lt;&lt;1); else update(p, add, mid+1, r, now&lt;&lt;1|1); push_up(now);&#125;int query(int L, int R, int l, int r, int now) &#123; //ans记录答案，在l到r的范围中，查找L到R区间的和，now用来存每次sum应该加上的位置的下标 int mid = (l + r) &gt;&gt; 1, ans = 0; if(L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[now]; &#125; if(mid &gt;= L) ans += query(L, R, l, mid, now&lt;&lt;1); if(mid+1 &lt;= R) ans += query(L, R, mid+1, r, now&lt;&lt;1|1); return ans;&#125;int main() &#123; scanf(&quot;%d&quot;,&amp;T); while(T--) &#123; scanf(&quot;%d&quot;,&amp;n); build(1,n,1); char s[10]; printf(&quot;Case %d:\\n&quot;,++kase); while(~scanf(&quot;%s&quot;,s)) &#123; if(s[0] == &#x27;E&#x27;) break; scanf(&quot;%d%d&quot;,&amp;p,&amp;v); if(s[0] == &#x27;A&#x27;) update(p,v,1,n,1); else if(s[0] == &#x27;S&#x27;) update(p,-v,1,n,1); else printf(&quot;%d\\n&quot;,query(p,v,1,n,1)); &#125; &#125; return 0;&#125; 讲义1.单调栈 单调栈中存放的数据应该是有序的，所以单调栈也分为单调递增栈和单调递减栈 单调递增栈：数据出栈的序列为单调递增序列 单调递减栈：数据出栈的序列为单调递减序列 模拟实现一个递增单调栈：现在有一组数10，3，7，4，12。从左到右依次入栈，则如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。 10入栈时，栈为空，直接入栈，栈内元素为10。 3入栈时，栈顶元素10比3大，则入栈，栈内元素为10，3。 7入栈时，栈顶元素3比7小，则栈顶元素出栈，此时栈顶元素为10，比7大，则7入栈，栈内元素为10，7。 4入栈时，栈顶元素7比4大，则入栈，栈内元素为10，7，4。 12入栈时，栈顶元素4比12小，4出栈，此时栈顶元素为7，仍比12小,栈顶元素7继续出栈，此时栈顶元素为10，仍比12小，10出栈，此时栈为空，12入栈，栈内元素为12。 单调栈的实现 12345678910111213141516171819单调栈的伪代码:stack&lt;int&gt; st;//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解for (遍历这个数组)&#123; if (栈空 || 栈顶元素大于等于当前比较元素) &#123; 入栈; &#125; else &#123; while (栈不为空 &amp;&amp; 栈顶元素小于当前元素) &#123; 栈顶元素出栈; 更新结果; &#125; 当前数据入栈; &#125;&#125;","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"新生训练","slug":"新生训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"DP","slug":"DP","date":"2020-01-06T09:42:00.000Z","updated":"2022-02-26T04:29:57.199Z","comments":true,"path":"2020/01/06/DP/","link":"","permalink":"https://zouyunkai.github.io/myblog/2020/01/06/DP/","excerpt":"","text":"","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://zouyunkai.github.io/myblog/tags/DP/"}],"author":"aoyuehan"},{"title":"qlu_新生赛_2019","slug":"qlu-新生赛-2019","date":"2019-12-18T10:47:00.000Z","updated":"2022-02-26T03:52:51.834Z","comments":true,"path":"2019/12/18/qlu-新生赛-2019/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/12/18/qlu-%E6%96%B0%E7%94%9F%E8%B5%9B-2019/","excerpt":"","text":"两琴键间的音为多少123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*0 3, 4 6 8 9 11 13 15,16 18 20 21 23 25 27,28 30 32 33 35 37 39,40 42 44 45 47 49 51,52 54 56 57 59 61 63,64 66 68 69 71 73 75,76 78 80 81 83 85 87,88*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;#include&lt;bits/stdc++.h&gt;typedef long long ll; using namespace std; /* 本来想着要判断各个字母的前缀，后来发现还可以 跨组别来求相隔的半音，所以应该想到要直接用map把 这个按键的名字当做一个下标存下来 现代音乐用七个英文字母 C D E F G A B（或其小写）来标记音名。这七个不同高低的音，其相邻音之间的音高距离，有半音和全音之分，其中E与F 和 B与C 之间为半音关系，其余相邻音之间为全音关系。现代钢琴键盘上的全音和半音相邻两个琴键（包括白健和黑键）构成半音，相隔一个琴键的两键之间构成全音。 */int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int case1; map&lt;string,int&gt;shu;//map按key的ascii进行排序，而不是按输入顺序 cin&gt;&gt;case1; string name[52]=&#123;&quot;A_2&quot;,&quot;B_2&quot;, &quot;C_1&quot;,&quot;D_1&quot;,&quot;E_1&quot;,&quot;F_1&quot;,&quot;G_1&quot;,&quot;A_1&quot;,&quot;B_1&quot;,&quot;C&quot;,&quot;D&quot; ,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;A&quot;,&quot;B&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;g&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c^1&quot;,&quot;d^1&quot; ,&quot;e^1&quot;,&quot;f^1&quot;,&quot;g^1&quot;,&quot;a^1&quot;,&quot;b^1&quot;,&quot;c^2&quot;,&quot;d^2&quot;,&quot;e^2&quot;,&quot;f^2&quot;,&quot;g^2&quot;,&quot;a^2&quot;,&quot;b^2&quot;,&quot;c^3&quot;,&quot;d^3&quot; ,&quot;e^3&quot;,&quot;f^3&quot;,&quot;g^3&quot;,&quot;a^3&quot;,&quot;b^3&quot;,&quot;c^4&quot;,&quot;d^4&quot;,&quot;e^4&quot;,&quot;f^4&quot;,&quot;g^4&quot;,&quot;a^4&quot;,&quot;b^4&quot;,&quot;c^5&quot;&#125;; int zhi[52]=&#123; 0,3,4,6,8,9,11,13,15,16, 18,20,21,23,25,27,28,30,32,33, 35,37,39,40,42,44,45,47,49,51, 52,54,56,57,59,61,63,64,66,68,69,71,73,75 ,76,78,80,81,83,85,87,88&#125;; for(int i=0;i&lt;52;i++)&#123; shu.insert(make_pair(name[i],zhi[i])); &#125;// for(map&lt;string,int&gt;::iterator it=shu.begin();it!=shu.end();it++)&#123;// cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl;// &#125; while(case1--) &#123; string s1,s2; cin&gt;&gt;s1&gt;&gt;s2; cout&lt;&lt;abs(shu[s2]-shu[s1])&lt;&lt;endl; &#125; &#125; 讨伐青蛙这里的青蛙比较的神奇，每个青蛙有自身的稀有值和体积。其中稀有值越高的青蛙讨伐后获得报酬能够越多，体积越小的青蛙讨伐后获得的报酬也能越多。阿库娅与和真并不想错失这一个讨伐青蛙的机会，所以他们想尽可能的使自己所能获得报酬最大。这里可以认为他们的力量无穷大，想讨伐哪只青蛙就一定能讨伐成功(虽然不大现实)。在讨伐量固定的情况下，阿库娅与和真制定了两个讨伐计划，第一个是令稀有值之和最大，第二个是令体积之和最小，请分别计算第一种计划的最大稀有值之和，还有第二种计划的最小的体积之和。Input输入包含多组测试数据。第一行一个T(1≤𝑇≤5)代表测试数据组数。之后每组测试数据开头包含两个正整数n，m (1≤𝑚≤𝑛≤100)代表青蛙的数量n和这次需要讨伐青蛙的总数m。之后会有n行，每行包含两个个正整数a, b(1≤𝑎,𝑏≤1012)分别代表每只青蛙的稀有值，体积。Output对于每组测试数据输出两个正整数分别代表所能讨伐的最大稀有值之和与最小的体积之和。 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;algorithm&gt;typedef long long ll; using namespace std;const int maxn=110;struct ani&#123; ll x; ll y; &#125;an[maxn];bool cmp1(ani a,ani b)&#123; return a.x&gt;b.x;&#125; bool cmp2(ani a,ani b)&#123; return a.y&lt;b.y; &#125; int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int T,n,m; cin&gt;&gt;T; while(T--)&#123; ll ans=0,ans1=0; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;an[i].x&gt;&gt;an[i].y; &#125; sort(an,an+n,cmp1); for(int j=0;j&lt;m;j++)ans+=an[j].x; cout&lt;&lt;ans&lt;&lt;&quot; &quot;; sort(an,an+n,cmp2); for(int j=0;j&lt;m;j++)ans1+=an[j].y; cout&lt;&lt;ans1&lt;&lt;endl; &#125;&#125; cet41234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;typedef long long ll; using namespace std;int main()&#123; int T; ll a,b,c; ll ans; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(((a-b)&lt;1)&amp;&amp;c&lt;=3500||(a-b)==0)&#123; cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; &#125;else&#123; ans=3500/(a-b); if((3500%(a-b))&gt;0)ans++; if(ans&gt;c)&#123; cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;ans&lt;&lt;endl; &#125; &#125; &#125; &#125;/*这一题一定要预判a-b的值是否为0 比如说：①除以零②数组越界：int a[3]; a[10000000]=10;③指针越界：int * p; p=(int *)malloc(5 * sizeof(int)); *(p+1000000)=10;④使用已经释放的空间：int * p; p=(int *)malloc(5 * sizeof(int));free(p); *p=10;⑤数组开得太大，超出了栈的范围，造成栈溢出：int a[100000000];*/ H. 天野阳菜的祈祷123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;stack&gt;#include&lt;map&gt;typedef long long ll; using namespace std;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int case1; cin&gt;&gt;case1; while(case1--)&#123; string s,tmp; cin&gt;&gt;s; if(s==&quot;Rough&quot;) &#123; cin&gt;&gt;tmp; cout&lt;&lt;&quot;It will be a hard work!&quot;&lt;&lt;endl; &#125; else if(s==&quot;Sunny&quot;)&#123; cout&lt;&lt;&quot;Stay&quot;&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;&quot;Let us go!&quot;&lt;&lt;endl; &#125; &#125;&#125; I 23331234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;iostream&gt;typedef long long ll; using namespace std;const int maxn=1e7+5;int arr[maxn]=&#123;2,3,3&#125;;//数据开到1e4以上就不能在main函数里面定义数组了，否则程序会//直接蹦 ，这一题打表来做 int main()&#123; int T,case1; int cur=1; int last=2; int i=3; while(i&lt;maxn)&#123; if(arr[last]==3)&#123; if(arr[cur]==3)&#123; arr[i]=2; arr[i+1]=2; arr[i+2]=2; i=i+3; last+=3; &#125;else&#123; arr[i]=2; arr[i+1]=2; i=i+2; last+=2; &#125; &#125;else&#123; if(arr[cur]==3)&#123; arr[i]=3; arr[i+1]=3; arr[i+2]=3; i=i+3; last+=3; &#125;else&#123; arr[i]=3; arr[i+1]=3; i=i+2; last+=2; &#125; &#125; cur++; &#125; // for(int i=0;i&lt;10000;i++)cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;; cin&gt;&gt;T; while(T--)&#123; cin&gt;&gt;case1; cout&lt;&lt;arr[case1-1]&lt;&lt;endl; &#125; &#125;解法二：#include&lt;bits/stdc++.h&gt;using namespace std;const int xa=1e7+5;int a[xa];int main()&#123; int p; cin&gt;&gt;p; a[0]=2; int pan=1; int shu=0; int i=0; while(shu&lt;xa)&#123; if(a[i]==2)&#123; int t=2; while(t--)&#123; if(pan%2==1)&#123; a[++shu]=3; &#125;else&#123; a[++shu]=2; &#125; &#125; pan++; &#125; if(a[i]==3)&#123; int t=3; while(t--)&#123; if(pan%2==1)&#123; a[++shu]=3; &#125;else&#123; a[++shu]=2; &#125; &#125; pan++; &#125; i++; &#125; int x; while(p--)&#123; cin&gt;&gt;x; cout&lt;&lt;a[x-1]&lt;&lt;endl; &#125; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"2019校赛","slug":"2019校赛","permalink":"https://zouyunkai.github.io/myblog/tags/2019%E6%A0%A1%E8%B5%9B/"}],"author":"aoyuehan"},{"title":"山师闭训赛19_12_15","slug":"山师闭训赛19-12-15","date":"2019-12-17T13:47:00.000Z","updated":"2022-02-26T03:51:21.553Z","comments":true,"path":"2019/12/17/山师闭训赛19-12-15/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/12/17/%E5%B1%B1%E5%B8%88%E9%97%AD%E8%AE%AD%E8%B5%9B19-12-15/","excerpt":"","text":"柳予欣的舔狗行为Description 某一天柳予欣想去舔爱慕已久却得不到的小姐姐(f译萱)。第一天他去给她偷偷发了一条信息，第二和第三天每天发两条信息，第四到第六天每天发三条信息。。以此类推。可惜小姐姐早就把他给屏蔽了。请问到第K天位置柳予欣一共发了多少条信息？Input 输入为一个数字n(1&lt;&#x3D;n&lt;&#x3D;1e5)Output 输出柳予欣发的信息条数。Sample Input1000Sample Output29820 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); long k,i; bool isequ=false; long ans=0; cin&gt;&gt;k; for(i=1;i&lt;k;i++)&#123; if(i*(i+1)/2==k)&#123; isequ=true; break; &#125; if(i*(i+1)/2&gt;k)break; &#125; if(isequ)&#123; long n1=i; for(long j=1;j&lt;=n1;j++)&#123; ans+=j*j; &#125; &#125;else&#123; long n=i-1; for(long j=n*(n+1)/2+1;j&lt;=k;j++)&#123; ans+=i; &#125; for(long j=1;j&lt;=n;j++)&#123; ans+=j*j; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;解法二：#include &lt;iostream&gt;typedef long long ll;const int maxn=1e5+10; ll a[maxn];using namespace std;ll n,t,ans;int main()&#123; cin&gt;&gt;n; //发消息为2的有两天，发消息为3的有三天，，，，，；i为消息数，j记录发i条消息的天数 for (int i=1; i&lt;=maxn; i++) &#123; for (int j=0; j&lt;i; j++) &#123; ans+=i; t++;//记录总天数 if (t&gt;=n) &#123; cout&lt;&lt;ans&lt;&lt;endl; return 0; &#125; &#125; &#125;&#125; 柳予欣的女朋友们在分享水果Description The hot summer came so quickly that fyx and lmz decided to buy a big and sweet watermelon. They want to cut the watermelon in two parts, and the weight of each part is an even number(偶数).They quickly decide which melon to buy. Do you know if you want to buy this melon?Input Only one line contains one integer w (1≤w≤100),units are kilograms.Output If it can meet the requirements, you will output “YES”, otherwise output “NO”.Sample Input8Sample OutputYES 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int w; cin&gt;&gt;w; for(int i=1;i&lt;w;i++)&#123;// 因为不能一下全取w，所以从1开始到w（开） if((w-i)%2==0&amp;&amp;i%2==0)&#123; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; return 0; &#125; &#125; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; return 0;&#125;解法2#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int main()&#123; int n; cin&gt;&gt;n; if (n%2==0) &#123;//上面合在一起不就是n能不能余2嘛 if (n==2) cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; &#125; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125;解法三：#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); if(n==2||(n&amp;1)) printf(&quot;NO&quot;); else printf(&quot;YES&quot;); &#125; 柳予欣和她女朋友的购物计划Description 一天，柳予欣和她的一个女朋友fyx去买包包。可惜的是柳予欣现在手里只有两种面值的钱a,b（a,b彼此互为素数，即这两个整数的公因数只有1），数量无限大。为了不让自己没面子，他想知道无法准确支付的物品中（就是不通过找零，用非负数个钱a与钱b不能凑成的价格中），最贵的价值是多少金币？Input 输入数据仅一行，包含两个正整数，它们之间用一个空格隔开，分别表示a,b的面值。(a和b均大于1，且均小于1,000,000,000)Output 输出所求数即可。Sample Input3 7Sample Output11 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950错误思路#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=1e8;const int max1=1e7;int prime[max1];bool noPrime[max1];//本来以为是大于这两个数的最大中的一个数的后一个素数，其实//要读懂题意之后发现不是这样的 int eulerSieve(long long n)&#123; int num=1; memset(prime,0,sizeof(prime)); memset(noPrime,false,sizeof(noPrime)); noPrime[0]=noPrime[1]=true; for(long long i=2;i&lt;=n;i++)&#123; //从1开始存素数 if(noPrime[i]==false)prime[num++]=i; for(int j=1;j&lt;num&amp;&amp;i*prime[j]&lt;=n;j++)&#123; noPrime[i*prime[j]]=true; if(i%prime[j]==0)break; &#125; &#125; return num-1;&#125; int main()&#123; long long a,b,n; long long i; cin&gt;&gt;a&gt;&gt;b; n=max(a,b);eulerSieve(maxn); for(i=0;i&lt;n;i++) &#123; if(prime[i]==n)break; &#125; cout&lt;&lt;prime[i+1];&#125; ac代码：//打表找规律，不要没有根据的乱猜#include &lt;iostream&gt;using namespace std;typedef long long ll;int main()&#123; ll a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;(ll)a*b-a-b&lt;&lt;endl;&#125; FFFFFunctions Sample Input23 52 1Sample Output1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;//const int maxn=1e6+10;int a[1000005];int p[1000005];//inline int fun(int a,int b)&#123;// int tmp;// while(b!=0)&#123;// tmp=a;// a=b;// b=abs(tmp-b);// &#125;// return a;//&#125;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int n,ans; //这道题因为没看懂题意，以为要输入组数，所以错了 while(cin&gt;&gt;n)&#123; if(n==0)continue; for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++)cin&gt;&gt;p[i]; //ans=fun(a[p[1]],a[p[2]]); ans=__gcd(a[p[1]],a[p[2]]); for(int i=3;i&lt;=n;i++)&#123; //ans=fun(ans,a[p[i]]); ans=__gcd(ans,a[p[i]]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;方法2#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;int n;while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123; if(n==0) continue; long long int t; long long int a=0; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;t; a=__gcd(t,a); &#125; for(int z=1;z&lt;=n;z++)&#123; int y; cin&gt;&gt;y; &#125; cout&lt;&lt;a&lt;&lt;endl;&#125;return 0;&#125; 1586.柳予欣不想挂科题目链接:http://sdnuoj.rainng.com/problem/show/1586Description期末考试要到了，学习不好的柳予欣要挂科了。这时他的一个女朋友lmz过来帮他补习科目。一共有n门科目，柳予欣对于每门都有目标成绩mi。lmz每次可以让他任意一个连续区间的科目的目标成绩提升一（n门科目初始状态成绩全为0）。因为柳予欣太懒，他只想把每一门补习到他想要的成绩，高了不行低了也不行。请问最少要让lmz帮他补习多少次？Input第一行一个数表示n (n &lt;&#x3D; 100000)第二行n个数表示每个mi即每个科目的目标成绩。Output输出最小需要的帮助次数Sample Input52 3 4 1 2Sample Output5Hint对于样例来说，最少需要五次，每次补习科目区间为：[1,5] [1,3] [2,3] [3,3] [5,5]即可使所有科目的成绩提高到目标成绩了思路：补题的时候补着补着就笑啦～ 为啥这道水题我没看到呢～涨姿势。找规律，如果一个数在这个序列中下降了，分成块，就是找递增序列之间的差值。看代码： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;const int maxn=1e5+10;typedef long long ll;using namespace std;int n;int a[maxn];ll ans;int main()&#123; cin&gt;&gt;n; for (int i=1; i&lt;=n; i++) cin&gt;&gt;a[i]; ans=a[1]; for (int i=2; i&lt;=n;i++) if (a[i]&gt;a[i-1]) ans+=a[i]-a[i-1]; cout&lt;&lt;ans&lt;&lt;endl;&#125;解法二：#include &lt;bits/stdc++.h&gt;using namespace std;const int N=200005;long long maxn=0,re=0,a[N],ans=0,now=0;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); now=a[1]; for(int i=2;i&lt;=n-1;i++) &#123;//不是很懂？？？？ now=max(now,a[i]); if(a[i]&lt;a[i-1]&amp;&amp;a[i]&lt;=a[i+1]) ans+=now,ans-=a[i],now=0; &#125; now=max(now,a[n]); ans+=now; printf(&quot;%lld&quot;,ans);&#125; 斐波那锲问题中文名 斐波那契数列 、黄金分割数列、兔子数列 性质表达式 F[n]&#x3D;F[n-1]+F［n-2］（ n&gt;&#x3D;3,F[1]&#x3D;1,F[2]&#x3D;1） 1234567891011121314151617181920斐波那契数列规律总结 随着数列项数的增加，前一项与后一项之比越来越逼近黄金分割的数值0.6180339887.. 从第二项开始，每个奇数项的平方都比前后两项之积多1，每个偶数项的平方都比前后两项之积少1。（注：奇数项和偶数项是指项数的奇偶，而并不是指数列的数字本身的奇偶，比如第五项的平方比前后两项之积多1，第四项的平方比前后两项之积少1） 斐波那契数列的第n项同时也代表了集合&#123;1,2,…,n&#125;中所有不包含相邻正整数的子集个数。 f(0)+f(1)+f(2)+…+f(n)=f(n+2)-1 f(1)+f(3)+f(5)+…+f(2n-1)=f(2n) f(2)+f(4)+f(6)+…+f(2n) =f(2n+1)-1 [f(0)]^2+[f(1)]^2+…+[f(n)]^2=f(n)·f(n+1) f(0)-f(1)+f(2)-…+(-1)^n·f(n)=(-1)^n·[f(n+1)-f(n)]+1 f(m+n)=f(m-1)·f(n-1)+f(m)·f(n) (利用这一点，可以用程序编出时间复杂度仅为O（log n）的程序。) [f(n)]^2=(-1)^(n-1)+f(n-1)·f(n+1) f(2n-1)=[f(n)]^2-[f(n-2)]^2 3f(n)=f(n+2)+f(n-2) f(2n-2m-2)[f(2n)+f(2n+2)]=f(2m+2)+f(4n-2m) [ n〉m≥-1,且n≥1]斐波那契数列 通向公式 an=（1/√5）*[(1+√5/2)^n-(1-√5/2)^n]（n=1,2,3…..） gcd(fib(n),fib(m))=fib(gcd(n,m)) 如果fib(k)能被x整除，则fib(k*i)都可以被x整除。 数列中相邻两项的前项比后项的极限(-1+√5)/2 求递推公式a(1)=1，a(n+1)=1+1/a(n)的通项公式 a(n)=fib(n+1)/fib(n) 可用矩阵快速幂求 求斐波那锲数列的集中方法？？？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879因为任意一个数都可以用斐波那锲数来叠加求得，所以直接从后往前，直接减掉，直到减为0就好了。其实比赛的时候想到了这个解法，一想，任意一个数是可以用斐波那锲数表示吗，不确定是不是，就没敢写。#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;typedef long long ll;const ll maxn=5e18;using namespace std; ll a[1000],n;int t;int main() &#123; a[1]=1;a[2]=2; for (int i=3;; i++) &#123; a[i]=a[i-1]+a[i-2]; if (a[i]&gt;maxn) &#123; t=i-1; break; &#125; &#125;// 找出斐波那契数列 个数为t个 while (~scanf(&quot;%lld&quot;,&amp;n)) &#123; if (!n) continue; else &#123; for (int i=t; i&gt;0; i--) &#123; //从后向前找 if (n&gt;=a[i]) &#123; //n在不小于0的情况下能减去就减去。 n-=a[i]; if (n) printf(&quot;%lld &quot;,a[i]); else &#123; printf(&quot;%lld\\n&quot;,a[i]); //注意格式问题 break; &#125; &#125; &#125; &#125; &#125;&#125;解法二：#include &lt;bits/stdc++.h&gt;using namespace std;long long a[1005];int main()&#123; a[1]=1,a[2]=1; for(int i=3;i&lt;=92;i++)//因为long long范围中斐波那锲数为92个 a[i]=a[i-1]+a[i-2]; long long n; while(~scanf(&quot;%lld&quot;,&amp;n)) &#123; if(n==0) continue; while(n) &#123; int pos,f=0; for(int i=1;i&lt;=92;i++) &#123; pos=i; if(a[i]&gt;=n) &#123; if(a[i]&gt;n) f=1; break; &#125; &#125; if(f) &#123; n-=a[pos-1]; printf(&quot;%lld%c&quot;,a[pos-1],n?&#x27; &#x27;:&#x27;\\n&#x27;); &#125; else &#123; n-=a[pos]; printf(&quot;%lld%c&quot;,a[pos],n?&#x27; &#x27;:&#x27;\\n&#x27;); &#125; &#125; &#125;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"代办","slug":"代办","date":"2019-11-20T10:12:06.000Z","updated":"2022-02-26T04:31:40.586Z","comments":true,"path":"2019/11/20/代办/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/11/20/%E4%BB%A3%E5%8A%9E/","excerpt":"","text":"codeforces920B. Tea Queue【模拟】https://blog.csdn.net/nobleman__/article/details/79245053 Packets问题https://blog.csdn.net/weixin_34248487/article/details/93388816https://blog.csdn.net/hqf1992/article/details/47375923 蓝桥杯的集合问题https://blog.csdn.net/weixin_34248487/article/details/93388816 2018新生赛https://blog.csdn.net/weixin_43537190/article/details/84570246https://blog.csdn.net/qq_43627087/article/details/85167684 线段树https://www.luogu.org/problem/P3372https://www.cnblogs.com/jason2003/p/9676729.htmlhttps://www.cnblogs.com/xenny/p/9739600.html 单调栈https://blog.csdn.net/lucky52529/article/details/89155694 树状数组https://www.cnblogs.com/xenny/p/9739600.htmlhttps://blog.csdn.net/qq_45530271/article/details/100603921","categories":[],"tags":[],"author":"aoyuehan"},{"title":"算法竞赛的知识点","slug":"算法竞赛的知识点","date":"2019-11-20T09:51:00.000Z","updated":"2022-02-26T04:29:58.379Z","comments":true,"path":"2019/11/20/算法竞赛的知识点/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/11/20/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"转发其他教练消息：突然觉得好累，不知道这一年都忙了些啥。以下接近300个知识点，有一半以上大学计算机专业的课程不涉及。 ICPC、CCPC等竞赛，考核的算法知识包括：1、Ad Hoc，杂题2、Complete Search (Iterative&#x2F;Recursive) ，搜索 3、Divideand Conquer，分治法4、Greedy，贪心法5、Dynamic Programming，动态规划6、Graph，图论7、Mathematics，数学8、tringProcessing，字符串处理9、Computational Geometry，计算几何10、Some Harder&#x2F;Rare Problems，罕见问题数据结构知识点：数组、链表、栈、队列、优先队列、双端队列、第k大元素、块状链表、堆、哈希表、哈希数组、逆序对、跳跃表、并查集、字典树、线段树、周长并、LCA、莫队算法、树状数组、树、二叉树、平衡二叉树、二叉排序树、二叉搜索树、Treap树、伸展树、笛卡尔树、划分树、表达式树、RMQ、树链剖分、动态树、左偏堆、可并堆、主席树、KD 树、替罪羊树、动态 KD 树、树套树排序知识点：选择排序、冒泡排序、插入排序、归并排序、快速排序、堆排序、计数排序、基数排序、桶排序搜索知识点：子集生成、线性搜索、折半检索、三分搜索、BFS、双向广搜、广搜的状态优化、A算法、DFS、回溯、剪枝、深搜的优化、记忆化搜索、IDA算法、位运算、按位压缩存储状态、极大极小、利用M进制数存储状态、舞蹈链贪心知识点：常见问题、哈夫曼树、模拟退火算法、prim算法、kruskal算法、Dijkstra算法分治知识点：最近点对、归并排序、快速排序、CDQ分治动态规划知识点：编辑距离、扔鸡蛋问题、整数背包、最大独立集、最长公共子序列、最长公共递增子序列、最长公共子串、最长上升子序列、最长回文子序列、最长回文子串、最长不重复子字符串、矩阵链乘、最大正方形子矩阵、最长链对、最大递增子序列和、最优二叉搜索树、回文分割、最大两段子段和、最大M子段和、最长有序子序列、数位dp、插头dp、树型dp、区间dp、平行四边形优化、状压DP、概率DP、斯坦那树字符串知识点：kmp、扩展kmp、后缀数组、后缀树、AC自动机、后缀自动机、回文串、确定有穷自动机、字符串hash图论知识点：邻接矩阵、关联矩阵、邻接表、链式前向星、有向、无向、有权、无权、有向无环图、哈密顿图、欧拉图、判圈、割点、割边、桥、边双连通分量、点双连通分量、强连通分量、有向图的强连通分量、拓扑排序、二分图判定、2-SAT、最短路径、二分图判定、连通分量、Prim’s Algorithm、Kruskal Algorithm、次小生成树、曼哈顿最小生成树、Dijkstra(堆优化)、Bellman Ford、SPFA、差分约束系统、Floyd、Ford-Fulkerson、Edmonds-Karp、最小费用最大流、最小割、ISAP、dinic、最小树形图、二分图匹配、二分图多重匹配、最小路径覆盖问题、LCA、树分治、生成树计数计算几何知识点：二维基本模板、凸包、最近点对、旋转卡壳、半平面交、最小圆覆盖、三维模板、最小球覆盖、三维凸包数论知识点：GCD、LCM、素数判断、素数生成、分解质因数、欧拉定理、费马小定理、扩展欧几里得算法、逆元、随机素数测试和大数分解、高斯消元、模线性方程组、佩尔方程、整数拆分、求AB的约数之和对MOD去模、大步小步算法、斐波那契数列取模、原根、快速数论变换、线性丢番图方程、模运算、卢卡斯定理、中国剩余定理、威尔逊定理、米勒-罗宾随机素性测试完全数、哥德巴赫猜想、连分数概率论知识点：基本概率和条件概率、随机变量、概率生成函数、期望、概率分布组合数学知识点：容斥原理、鸽巢原理、乘法原理、stirling数、Catalan数、斐波拉契数、Polya计数、莫比乌斯反演、母函数、调和级数、幻方、N皇后线性代数知识点：矩阵的加减、矩阵变换、矩阵的行列式、秩和逆、线性方程组的求解、矩阵求幂、特征值和特征向量、多项式的根、拉格朗日插值、线性基博弈论知识点：尼姆游戏、P-position、N-position、图游戏与SG函数、Hackenbush游戏、威佐夫游戏群论知识点：伯恩赛德引理、波利亚定理、拉格朗日定理计算方法知识点：快速傅立叶变换、迭代法、三分法、定积分计算、自适应simpson积分高精度数知识点：大数加减乘除、大数取模、高精度阶乘、高精度幂、高精度进制转换、FFT高精度乘法、java高精度","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"aoyuehan"},{"title":"HTML上机","slug":"HTML上机","date":"2019-11-16T02:52:00.000Z","updated":"2022-02-26T03:51:21.439Z","comments":true,"path":"2019/11/16/HTML上机/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/11/16/HTML%E4%B8%8A%E6%9C%BA/","excerpt":"","text":"上机实验1 制作一个课表实验一 制作一个本学期使用的课程表 一、 实验目的和要求 制作一个本学期使用的课程表，要求有背景图像、背景音乐。 二、 实验内容 制作一个本学期使用的课程表。 三、 实验方法与步骤 用记事本写入html语句，依照本学期的课程，在文本文档写好后，改 文件的后缀名为html，用浏览器打开查看效果，并在body中加入了背景图片，在head标签中加入bgsound标签，添加背景音乐。 四、 实验数据记录、处理及结果分析1、其中表格的核心代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;table border=1 background=&quot;kebiao_2.jpg&quot; width=&quot;900&quot; height=&quot;700&quot; style=&quot;background-repeat: no-repeat;background-size: cover;&quot;&gt; &lt;caption&gt;本学期课程表&lt;/caption&gt; &lt;tr height=&quot;80&quot;&gt; &lt;th width=&quot;80&quot;&gt;节次\\星期&lt;/th&gt; &lt;th width=&quot;180&quot;&gt;星期一&lt;/th&gt; &lt;th width=&quot;180&quot;&gt;星期二&lt;/th&gt; &lt;th width=&quot;180&quot;&gt;星期三&lt;/th&gt; &lt;th width=&quot;180&quot;&gt;星期四&lt;/th&gt; &lt;th width=&quot;180&quot;&gt;星期五&lt;/th&gt; &lt;th width=&quot;180&quot;&gt;星期六&lt;/th&gt; &lt;th width=&quot;180&quot;&gt;星期天&lt;/th&gt; &lt;/tr&gt; &lt;tr height=&quot;80&quot;&gt; &lt;td&gt;第一二节&lt;/td&gt; &lt;td&gt;线性代数Ⅰ&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;线性代数Ⅰ&lt;/td&gt; &lt;td&gt;大学英语Ⅲ&lt;/td&gt; &lt;td&gt;数据结构&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;80&quot;&gt; &lt;td&gt;第三四节&lt;/td&gt; &lt;td &gt; 大 学 英 语 Ⅲ &lt;/td&gt; &lt;td&gt;大学体育（3）&lt;/td&gt; &lt;td&gt;C#程序设计&lt;/td&gt; &lt;td&gt;数据结构&lt;/td&gt; &lt;td&gt;C#程序设计&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr &gt; &lt;tr height=&quot;80&quot;&gt; &lt;td&gt;第五六节&lt;/td&gt; &lt;td&gt;Web设计基础&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;概率论与数理统计Ⅰ&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;数据结构&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;80&quot;&gt; &lt;td&gt;第七八节&lt;/td&gt; &lt;td&gt;概率论与数理统计Ⅰ&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;马克思主义&lt;br&gt;基本原理概论&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;80&quot;&gt; &lt;td&gt;第九十节&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;韩国语入门（智慧&lt;br&gt;树）&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 2、实验效果： 五、 相关讨论、实验心得1、在写table的时候要注意tr定义行，td定义列，在一行中写多个td标签，就会在一行中显示多列，注意tr和td标签的配对，否则会显示不成功。2、表格由 ＜table＞ 标签来定义。每个表格均有若干行（由 tr 标签定义），每行被分割为若干单元格（由 td 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。表格的表头使用 th 标签进行定义，本实验中的星期一，星期二…..等就是用th定义的。表格的标题用caption标签来定义，本实验中的表格上方的本学期课表就是该表格的标题数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。3、 1234567&lt;!DOCTYPE html&gt; 声明为 HTML5 文档&lt;html&gt; 元素是 HTML 页面的根元素&lt;head&gt; 元素包含了文档的元（meta）数据，如 &lt;meta charset=&quot;utf-8&quot;&gt; 定义网页编码格式为 utf-8。本实验中如果不写本句话，在别人的电脑上就会乱码。&lt;title&gt; 元素描述了文档的标题&lt;body&gt; 元素包含了可见的页面内容&lt;h1&gt; 元素定义一个大标题&lt;p&gt; 元素定义一个段落 4、什么是htmlHTML 指的是超文本标记语言，他不是一种编程语言，而是一种标记语言是一套标记标签 ，用标记标签来描述网页。 上机实验二 一、 实验目的和要求制作一个计算器界面二、 实验内容 制作一个计算器界面，能够在客户端实现加减乘除运算，示意图如P102 图4—22所示。三、 实验方法与步骤 根据课后题的模样，写一个界面，在form标签中写几个input标签，写入文本框，单选按钮和点击按钮，使得输入数据，点击单选按钮选择两数之间的操作，点击按钮实现两数之间的计算。四、 实验数据记录、处理及结果分析 12345678910111213141516171819202122232425262728293031323334353637383940 1、form标签的定义代码：&lt;form method=&quot;post&quot; action=&quot;&quot; name=&quot;jisuan_Form&quot;&gt; 请输入第一个操作数： &lt;input type=&quot;text&quot; name=&quot;one&quot; /&gt;&lt;br&gt; 请输入第二个操作数： &lt;input type=&quot;text&quot; name=&quot;two&quot; /&gt;&lt;br&gt; 请选择操作： &lt;input type=&quot;radio&quot; name=&quot;caozuo&quot; value=&quot;+&quot;/&gt;+ &lt;input type=&quot;radio&quot; name=&quot;caozuo&quot; value=&quot;-&quot;/&gt;- &lt;input type=&quot;radio&quot; name=&quot;caozuo&quot; value=&quot;*&quot;/&gt;* &lt;input type=&quot;radio&quot; name=&quot;caozuo&quot; value=&quot;/&quot;/&gt; /&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; name=&quot;submit&quot; value=&quot;=&quot; onclick=&quot;calculate()&quot; /&gt;&lt;br&gt;&lt;br&gt; 结果是：&lt;input type=&quot;text&quot; name=&quot;ans&quot; value=&quot;&quot;/&gt; &lt;/form&gt; 2、按钮点击的操作函数： &lt;script&gt; function calculate()&#123; var txt1=document.jisuan_Form.one.value-0; var txt2=document.jisuan_Form.two.value-0; var fuhao=document.jisuan_Form.caozuo; var ans; var tmp; &lt;!--找到选中的单选按钮,并将其赋值给tmp;而且这个i的类型不能是int类型,否则就不对--&gt; for(var i=0;i&lt;fuhao.length;i++)&#123; if(fuhao[i].checked)&#123; tmp=fuhao[i].value; break; &#125; &#125; &lt;!--匹配tmp的选项,进行相应的运算,然后输出--&gt; switch(tmp)&#123;case &quot;+&quot;: ans=txt1+txt2; document.jisuan_Form.ans.value=ans; break;case &quot;-&quot;: ans=txt1-txt2; document.jisuan_Form.ans.value=ans; break;case &quot;*&quot;: ans=txt1*txt2; document.jisuan_Form.ans.value=ans; break;default: ans=txt1/txt2; document.jisuan_Form.ans.value=ans; &#125; &#125; &lt;/script&gt; 3、实验效果： 五、 相关讨论、实验心得1、 首先就是写出界面，定义一个form表单，在其中写input标签，定义文本框，单选按钮和点击按钮，并且在按钮的定义时写入onclick事件，当点击时调用本网页中编写的calculate方法。 2、 在写calculate()的时候，radio必须name相同才能在一组中，否则单选按钮可以多选，我就忘记了，起初是挨个挨个获取单选按钮的值，后来发现可以获取一个单选按钮的组，然后用数组的形式获取其中是否选中。3、 其中：表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。4、 ＜input type&#x3D;”submit”＞ 定义了提交按钮.当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。 上机实验3 制作一个个人主页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148 一、 实验目的和要求 制作一个个人主页，页面内容包括“基本情况”和“教育经历”两个部分，其它内容自主添加，要求简洁美观。 二、 实验内容 制作一个个人主页，页面内容包括“基本情况”和“教育经历”两个部分，其它内容自主添加，要求简洁美观。 三、 实验方法与步骤 按照课本上的那个网上书店的例子，通过在一个网页中写两个frameset的方法，实现上方为独立的logo简介页面，下方的frameset嵌套两个frame，从而实现了在左方点击超链接在右下方的窗口显示连接到的网页的效果。其中超链接中的target属性应该指向右下方这个网页的name，这样才能实现在右方窗口单独显示网页的效果。 四、 实验数据记录、处理及结果分析 1. 首先是网页上方的logo.html&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;主页上方&lt;/title&gt; &lt;style&gt; body &#123; text-align: center; &#125; .vintage1 &#123; font-size: 8; text-shadow: 5px -5px black, 8px -8px white; font-weight: bold; -webkit-text-fill-color: transparent; -webkit-background-clip: text; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body bgcolor=&quot;#C4E3F3&quot;&gt; &lt;font size=&quot;5&quot;&gt; &lt;h1 class=&quot;vintage1&quot;&gt;我的个人主页&lt;/h1&gt;&lt;/font&gt; &lt;/body&gt;&lt;/html&gt;2. 网页左方的导航栏界面 &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;主页左边导航栏&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;&lt;a href=&quot;a.html&quot; target=&quot;main&quot;&gt;基本情况&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;b.html&quot; target=&quot;main&quot;&gt;教育经历&lt;/a&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;3. 网页右方的两个子窗口基本情况：&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;基本情况&lt;/title&gt; &lt;style&gt; #blog&#123; margin: 40px; border-radius: 25px; border: 2px solid #46B8DA; width: 30px; height: 15px; color: #999999; &#125; #name&#123; margin: 40px; &#125; #sex&#123; margin-right: 40px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body bgcolor=&quot;aliceblue&quot; &gt; &lt;div align=&quot;center&quot;&gt; &lt;table border=&quot;0&quot; width=&quot;800px&quot; height=&quot;600px&quot;&gt; &lt;tr height=&quot;50px&quot;&gt; &lt;td align=&quot;center&quot; background=&quot;timg.jpg &quot; height=&quot;80px&quot;&gt; &lt;h2&gt; ABOUT ME&lt;/h2&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr height=&quot;50px&quot;&gt; &lt;td align=&quot;center&quot; &gt; &lt;img src=&quot;renxiang.jpg&quot; width=&quot;55px&quot; height=&quot;90px&quot;/&gt; &lt;span id=&quot;name&quot;&gt; &lt;font size=&quot;5&quot;&gt;邹庆志&lt;/font&gt; &lt;/span&gt; &lt;img src=&quot;man.jpg&quot; width=&quot;30px&quot; height=&quot;30px&quot; id=&quot;sex&quot; /&gt; &lt;font size=&quot;5&quot;&gt;齐鲁工业大学学生&lt;/font&gt; &lt;hr&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=&quot;top&quot;&gt; &lt;ul &gt; &lt;li&gt;自入学以来，我始终把学习当做第一位。在学习生活中，我坦诚乐观，生活俭朴，尊敬师长，勤奋刻苦，有着较强学习能力和进取精神。在大一这学年中，担任班里的生活委员，关注同学们的生活状况和身体健康，积极帮助有困难的同学，团结同学。配合其他班委处理班级的各种事务，认真负责地完成学院和班级布置的各项工作。&lt;/li&gt; &lt;br&gt; &lt;li&gt;思想上，我积极向上，能主动，自觉地向党组织靠拢，现被选为入党积极分子，平常更是以一个党员的标准来严格要求自己。在课外活动中积极参加志愿活动并获得荣誉称号。&lt;/li&gt; &lt;br&gt; &lt;li&gt; 身为一个计算机系的学生对编程有着一番热情， 点击右侧按钮到达&lt;a id=&quot;blog&quot; href=&quot;https://aoyuehan.gitee.io/aoyue/&quot;&gt; 我的blog &lt;/a&gt; 在这里，我积累了许多的知识，包括对数据结构，ACM，数据库，编程语言的理解。 &lt;/li&gt; &lt;br&gt; &lt;/ul&gt; &lt;br&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;教育经历：&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;教育状态&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt; 2012年就读于莒南第八中学，完成初等义务教育。 &lt;/li&gt; &lt;br&gt; &lt;li&gt; 2015年就读于莒南第一中学,于2018年完成学业，参加高考。 &lt;/li&gt; &lt;br&gt; &lt;li&gt; &lt;a href=&quot;http://www.qlu.edu.cn/&quot;&gt;&lt;img src=&quot;qlu.jpg&quot; height=&quot;50px&quot; width=&quot;50px&quot; /&gt;&lt;/a&gt; 2018年就读于齐鲁工业大学计算机系，正在就读中。 &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 五、 相关讨论、实验心得1.首先认识到网页美观的重要性了，自己做出来的网页和网上的相比，简直是差了十万八千里，所以网页设计要美观大方，颜色搭配有序，布局要符合用户的需求，设计的更加人性化才可以。2.通过本次实验，让我对于html中的table，a，p，hr，br标签有了新的用法经验，其次是应用css调整网页元素，比如：给文字加背景，生成艺术字，设置网页背景，调整html元素的布局等等，从而让页面变得更加美观。4. 再者，是对html的框架有了更深的理解，其中frameset声明一个框架集，其包含frame声明的子窗口，而每个窗口都有自己的name属性，所以可以通过超链接等形式来改变各个子窗口的内容；并且各个子窗口之间是独立的，可以显示不同的内容。 5. 在子窗口设计时，我在jianjie.html即显示基本情况的界面中用到table来布局，在每一行显示不同的内容，最后把table的border属性设置为0，就可以分块显示想要的内容了。6. frameset 元素用来定义一个框架集。它被用来组织多个窗口（框架）。每个框架存有独立的文档。在其最简单的应用中，frameset 元素仅仅会规定在框架集中存在多少列或多少行。所以要使用 cols 或 rows 属性来定义框架的大小。而且不能与 &lt;frameset&gt;&lt;/frameset&gt; 标签一起使用 &lt;body&gt;&lt;/body&gt; 标签。 实验效果： 上机实验4 css的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119 一、 实验目的和要求 （ 1 ）熟练应用页面布局技术，使网页布局合理，内容丰富 （ 2 ）使用 CSS 样式使网站具有统一风格 二、 实验内容 1 、使用 CSS 技术的制作一个页面，页面内容及显示格式如下图所示 HTML 技术（红色） CSS 用于定义 Web 页面内容在浏览器上的显示方式，由于 HTML 的功能有限， 一般不能随意设计版面和编排文字，所以 W3C 公布了一套 HTML 的扩展标准 CSS ， 扩展了 HTML 在排版和文字式样上的功能（蓝色） 通过样式定义可以设定很多属性，如字号、颜色、 页边距， 元素在页面上的绝对位置等。 （绿色） （ 1 ）直接定义 HTML 标记中的 style 属性实现。 （ 2 ）定义内部样式表实现。 （ 3 ）嵌入外部样式表实现。 （ 4 ）链接外部样式表实现。 三、 实验方法与步骤 首先通过课本上关于css这一节的几个例题的引入，知道了通过css修改网页可以通过定义 HTML 标记中的 style 属性实现、定义内部样式表实现、嵌入外部样式表实现、链接外部样式表实现来实现，编写代码，记录报告。 四、 实验数据记录、处理及结果分析 （ 1 ）直接定义 HTML 标记中的 style 属性实现。 &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=&quot;center&quot; &gt; &lt;h1 style=&quot;color: #FF0000;&quot;&gt;HTML 技术&lt;/h1&gt; &lt;p style=&quot;color: #2A36FF; text-align: center;&quot;&gt;&amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp CSS 用于定义 Web 页面内容在浏览器上的显示方式，由于 HTML 的功能有限，&lt;br&gt; 一般不能随意设计版面和编排文字，所以 W3C 公布了一套 HTML 的扩展标准 CSS ，&lt;br&gt; 扩展了 HTML 在排版和文字式样上的功能（蓝色）&lt;/p&gt; &lt;p style=&quot; color: green;&quot;&gt;通过样式定义可以设定很多属性，如字号、颜色、 页边距，元素在页面上的绝对位置等。 （绿色） &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; （ 2 ）定义内部样式表实现。 &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; h1&#123; color: #FF0000; &#125; #p1&#123; color: #2A36FF; text-align: center; &#125; #p2&#123; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=&quot;center&quot; &gt; &lt;h1 &gt;HTML 技术&lt;/h1&gt; &lt;p id=&quot;p1&quot;&gt;&amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp CSS 用于定义 Web 页面内容在浏览器上的显示方式，由于 HTML 的功能有限，&lt;br&gt; 一般不能随意设计版面和编排文字，所以 W3C 公布了一套 HTML 的扩展标准 CSS ，&lt;br&gt; 扩展了 HTML 在排版和文字式样上的功能（蓝色）&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;通过样式定义可以设定很多属性，如字号、颜色、 页边距，元素在页面上的绝对位置等。 （绿色） &lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; （ 3 ）嵌入外部样式表实现。 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;!-- @import url(&quot;style1.css&quot;); --&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=&quot;center&quot; &gt; &lt;h1 &gt;HTML 技术&lt;/h1&gt; &lt;p id=&quot;p1&quot;&gt;&amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp CSS 用于定义 Web 页面内容在浏览器上的显示方式，由于 HTML 的功能有限，&lt;br&gt; 一般不能随意设计版面和编排文字，所以 W3C 公布了一套 HTML 的扩展标准 CSS ，&lt;br&gt; 扩展了 HTML 在排版和文字式样上的功能（蓝色）&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;通过样式定义可以设定很多属性，如字号、颜色、 页边距，元素在页面上的绝对位置等。 （绿色） &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; （ 4 ）链接外部样式表实现 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style2.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div align=&quot;center&quot; &gt; &lt;h1 &gt;HTML 技术&lt;/h1&gt; &lt;p id=&quot;p1&quot;&gt;&amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp CSS 用于定义 Web 页面内容在浏览器上的显示方式，由于 HTML 的功能有限，&lt;br&gt; 一般不能随意设计版面和编排文字，所以 W3C 公布了一套 HTML 的扩展标准 CSS ，&lt;br&gt; 扩展了 HTML 在排版和文字式样上的功能（蓝色）&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt;通过样式定义可以设定很多属性，如字号、颜色、 页边距，元素在页面上的绝对位置等。 （绿色） &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;(5)其中style1和style2的内容是一样的：h1 &#123; color: #FF0000;&#125;#p1 &#123; color: #2A36FF; text-align: center;&#125;#p2 &#123; color: green;&#125; （6）实现效果： 123456789101112131415161718192021五、 相关讨论、实验心得1.首先是关于直接在html中定义属性的方法来改变网页效果，这种方法通过直接在html标签中加入style属性来设置网页中字体的颜色，大小，文字的对齐方式，页边距等，但是比较繁琐，如果要修改一部分元素的效果时查找和修改都比较费劲，不直观。2.然后就是关于css选择器的理解：CSS选择器用于选择你想要的元素的样式的模式。每条声明由一个属性和一个值组成。属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。如：p &#123;color:red;text-align:center;&#125;选择器几种常用的用法总结：class选择器：例如.intro&#123;&#125;。这样的话选择所有class=&quot;intro&quot;的元素。id选择器：例如#firstname&#123;&#125;。选择所有id=&quot;firstname&quot;的元素一般来说，id用在名字唯一的上面，class用在多个元素同名的时候。（如果只是单纯的添加css样式，id不唯一也可以。但是如果与js或者是jquery结合时，只会对第一个起作用。）对于一般的html标签，可以通过element的形式来设置style属性，如：p&#123;&#125;。选择所有&lt;p&gt;元素；同样：div,p&#123;&#125; 选择所有&lt;div&gt;元素和&lt;p&gt;元素。 div+p&#123;&#125; 选择所有紧接着&lt;div&gt;元素之后的&lt;p&gt;元素 div&gt;p&#123;&#125; 选择所有父级是 &lt;div&gt; 元素的 &lt;p&gt; 元素 特别的：对于a标签， a:link&#123;&#125; 选择所有未访问链接 a:visited 选择所有访问过的链接3. 关于多重样式优先级的总结： 样式表允许以多种方式规定样式信息。样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。一般情况下，优先级如下：内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式（注意：如果外部 样式放在内部样式的后面，则外部样式将覆盖内部样式。） 上机实验5 js实现验证12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152一、 实验目的和要求 使用js编写一段代码，完成验证，并给出提示。二、 实验内容 使用JavaScript编制一段代码完成以下功能: 1.要求输入一个姓名 2.用确认框检查输入是否正确(是否为合法输字符,位长是否合理等) 3.根据输入给出相应的提示.三、 实验方法与步骤 按照课本的输入验证的例子来写这个例子，就是获取到文本框中的字符，然后判断这些字符是否全都是汉字，如果不全都是汉字，弹框提示；然后再判断字符串的长度是否符合要求，不符合要求给出提示。并且在文本框的按键松开的时候编写方法提示你输入了几个字符。 四、 实验数据记录、处理及结果分析 1.源代码：&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;js实现输入验证&lt;/title&gt; &lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt; function confirm_yanzheng()&#123; var str=document.getElementById(&quot;textin&quot;); if(!isChinese(str.value))&#123; alert(&quot;有非法字符,必须输入中文&quot;); &#125; else if(str.value.length &lt; 2 || str.value.length &gt; 6 ) &#123; alert(&quot;输入字符长度不符 必须在2-6之间&quot;); &#125; else &#123; alert(&quot;验证成功!&quot;); &#125; &#125; function isChinese(temp)&#123; var re=/[^\\u4e00-\\u9fa5]/; if (re.test(temp)) return false ; return true ; &#125; function tips()&#123; var str1=document.getElementById(&quot;textin&quot;); if(str1.value != &quot;&quot;) &#123; document.getElementById(&quot;text_tips&quot;).innerHTML = &quot;您当前已经输入&quot; + str1.value.length + &quot; 个字符&quot;; &#125; else &#123; (document.getElementById(&quot;text_tips&quot;)).innerHTML = &quot;内容不能为空请输入&quot;; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;textin&quot; onkeyup=&quot;tips()&quot; /&gt;&lt;input type=&quot;button&quot; id=&quot;confirm&quot; value=&quot;确认&quot; onclick=&quot;confirm_yanzheng()&quot; /&gt; &lt;div id=&quot;text_tips&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 2.效果展示 12345678910111213141516171819202122五、 相关讨论、实验心得1. 首先要注意的问题就是document.getElementById方法，这个方法的参数是字符串，当初在写的时候直接写了id名，然后一直不知道哪里错了，所以一定要细心。另外想想也是传递的参数应该为字符串才对呀，不然的话，id名又不是变量。2.另一个应该注意的地方就是验证的那部分，正则匹配方式function isChinese(temp)&#123; var re=/[^\\u4e00-\\u9fa5]/; if (re.test(temp)) return false ; return true ; &#125;这个re正则里面表示汉字的符号不应该是/u4e00，应该用反斜杠表示。这段代码的逻辑是，参数tmp和re相比，如果tmp里面的字符都是re里面的字符，那么就返回true，否则返回false。其中说明： u4e00-u9fbf : unicode CJK(中日韩)统一表意字符。u9fa5后至u9fbf为空3．还有就是在不知道怎么正则匹配汉字的时候找到了一个blog上写的一篇关于这个作业的源码，其中她的思想很好，就是function $(id) &#123; return document.getElementById(id); &#125;这样写来用$（id）就能直接获取该id的对象，这样写比较简洁，在需要获取多次id所代表的对象的时候比较方便。 #### 上机实验5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120 一、 实验目的和要求 1.在客户端验证用户输入信息。如果输入正确,允许链接到网站;如果不正确, 禁止链接。 要求用户界面友好。 2. 制作一个页面,背景颜色可以随机改变 二、 实验内容 1.验证用户输入的信息，如果输入的信息正确,就允许链接到网站;如果不正确, 禁止链接。 用户界面友好。 2.制作的这个页面的背景颜色可以随机改变。 三、 实验方法与步骤 1.首先是编写一个按钮，当点击这按钮的时候弹出一个输入确定框，输入管理员，点击确定连接到百度页面，就会跳转到百度页面；否则弹出提示框重新输入用户名。 2.编写js代码，编写一个定时器，每2s就执行一个函数，该函数产生个一个3以内的随机数，然后通过switch函数来选择当做背景图片的照片序号。通过dom结构的document.body.background=src;来改变背景图片。 3、改变背景颜色，产生一个随机数代表颜色，然后document.bgcolor=颜色；来改变背景颜色。 四、 实验数据记录、处理及结果分析 1. &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;script language=&quot;JavaScript&quot;&gt; function yanzheng()&#123; var Myname=prompt(&quot;请输入你的姓名：&quot;); if(Myname==&quot;管理员&quot;)&#123; var Mybool=confirm(Myname+&quot;你好，确认要连接到百度的网页吗？&quot;); if(Mybool)&#123; window.location.replace(&quot;https://www.baidu.com&quot;) &#125; &#125;else&#123; alert(&quot;对不起，用户名错误。请重新输入&quot;); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; width=&quot;200px&quot; height=&quot;20px&quot; onclick=&quot;yanzheng()&quot; value=&quot;点击登录到百度&quot;&gt; &lt;br&gt;点击次按钮登录，然后输入用户名为管理员，跳转到百度页面&lt;/input&gt; &lt;/body&gt; &lt;/html&gt; 2. 改变背景图片&lt;html&gt;&lt;meta charset=utf-8&quot; /&gt; &lt;/head&gt; &lt;body onLoad=&quot;randomimg();&quot; style=&quot;background-size: cover; width: 800px; height: 900px;&quot;&gt; &lt;script language=&quot;javascript&quot;&gt;function randomimg()&#123; var i = Math.floor(Math.random()*5);//随机选取照片 var src = &quot;&quot;; switch(i) &#123; case 0 : src = &quot;3.jpg&quot;; break; case 1: src = &quot;1.jpg&quot;; break; case 2: src = &quot;2.jpg&quot;; break; &#125; document.body.background=src; setTimeout(&quot;randomimg()&quot;,2000);&#125;&lt;/script&gt;&lt;/body&gt; &lt;/html&gt;3、改变背景颜色&lt;html&gt; &lt;head&gt; &lt;script&gt; function changeBg()&#123; var rand=Math.round(Math.random()*1000000); document.bgColor=&quot;#&quot;+rand; &#125; setTimeout(&quot;changeBg();&quot;,1000); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt;五、 相关讨论、实验心得 1. 在编写第7题的时候，因为在输入之后点击确定按钮的时候，把确认框返回的值赋给Mybool变量，而在下面进行页面刷新的时候写成了if(!Mybool),导致点击确认不进行跳转，纳闷了好久才发现这么简单的逻辑错误。2. js 刷新当前页面的几种方法：reload()方法用于刷新当前文档。如：location.reload();replace()replace 方法，该方法通过指定URL替换当前缓存在历史里（客户端）的项目，因此当使用replace方法之后，你不能通过“前进”和“后退”来访问已经被替换的URL。window.location.replace(&quot;要跳转的新的网页&quot;)或者： windows.location.href=&quot;NEW_URL&quot;;自动刷新的方法：&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20&quot;&gt;&lt;script language=&quot;JavaScript&quot;&gt;function myrefresh()&#123; window.location.reload();&#125;setTimeout(&#x27;myrefresh()&#x27;,1000); //指定1秒刷新一次&lt;/script&gt;3.当需要的类型与数据不同时，可以强制类型转换，使用强制类型转换可以访问特定的值，即使它是另一种类型的。 Boolean(value)——把给定的值转换成Boolean型； Number(value)——把给定的值转换成数字（可以是整数或浮点数）； String(value)——把给定的值转换成字符串。 上机实验六 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137 一、 实验目的和要求制作一个html程序，能计算到期后本金和利息的总和是多少。 二、 实验内容 某银行网站希望增加一个栏目，在界面中输入本金、存款方式和存款时间后，即可显示到期后的本金和利息之和共有多少，以利于客户选择存款方式。完成该栏目的设计与制作。 三、 实验方法与步骤 分为两个模块，输入数据和计算结果其中输入数据设计存储方式，定期类型，期限，每期存入的金额这几个块，其中他们都有一个id，这样在js函数时就可以通过dom来获取每个块的值。从而实现计算，最后把结果输出到下面的文本框中。 四、 实验数据记录、处理及结果分析 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;计算利息&lt;/title&gt; &lt;!-- 月利率=年利率÷12（月）=日利率×30（天） 利息的计算公式：本金×年利率（百分数）×存期 本息合计=本金+利息 --&gt; &lt;style&gt; .kuang1&#123; display: block; &#125; &lt;/style&gt; &lt;script language=&quot;JavaScript&quot;&gt; function xiaoshi()&#123; var a1=document.getElementById(&quot;leixing1&quot;).value; if(a1==2)&#123; document.getElementById(&quot;kuang1&quot;).style.display=&quot;none&quot;; &#125;else&#123; document.getElementById(&quot;kuang1&quot;).style.display=&quot;block&quot;; &#125; &#125; function jisuan()&#123; var benxi,lixi; var dingqi_leixing=document.getElementById(&quot;leixing2&quot;); var index_leixing=dingqi_leixing.selectedIndex var day=document.getElementById(&quot;qixian&quot;); var index_day=day.selectedIndex; var val_day=day.options[index_day].value; var money=document.getElementById(&quot;money&quot;).value-&#x27;0&#x27;; var a2=document.getElementById(&quot;leixing1&quot;).value; if(a2==1)&#123; //结算结果 if(index_leixing==0)&#123; //计算整存整取类型： lixi=money*val_day*0.0175; benxi=money+lixi; &#125; if(index_leixing==1)&#123; //计算整存零取类型： lixi=money*val_day*0.0275; benxi=money+lixi; &#125; if(index_leixing==2)&#123; //计算存本取息类型： lixi=money*val_day*0.0275; benxi=money+lixi; &#125; &#125;else&#123; //计算活期 lixi=money*val_day*0.0030; benxi=money+lixi; &#125; document.getElementById(&quot;lixi&quot;).value=lixi; document.getElementById(&quot;benxi&quot;).value=benxi; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 输入数据： &lt;form id=&quot;lixi_form&quot;&gt; &lt;span&gt;存储方式：&lt;/span&gt; &lt;select id=&quot;leixing1&quot; onchange=&quot;xiaoshi()&quot;&gt; &lt;option value=&quot;1&quot; selected=&quot;selected&quot;&gt;定期&lt;/option&gt; &lt;option value=&quot;2&quot; &gt;活期&lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;sapn id=&quot;kuang1&quot;&gt;定期类型： &lt;select id=&quot;leixing2&quot; &gt; &lt;option value=&quot;1&quot; selected=&quot;selected&quot;&gt;整存整取&lt;/option&gt; &lt;option value=&quot;2&quot; &gt;整存零取&lt;/option&gt; &lt;option value=&quot;3&quot; &gt;存本取息&lt;/option&gt; &lt;/select&gt; &lt;/sapn&gt; &lt;br&gt; &lt;span id=&quot;kuang2&quot;&gt;期限： &lt;/span&gt; &lt;select id=&quot;qixian&quot;&gt; &lt;option value=&quot;0.083&quot;&gt;一个月&lt;/option&gt; &lt;!-- 作者：2661444606@qq.com 时间：2019-12-07 描述 一个月就是一年的1/12 --&gt; &lt;option value=&quot;0.5&quot;&gt;半年&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;一年&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;三年&lt;/option&gt; &lt;option value=&quot;5&quot;&gt;五年&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span id=&quot;money_id&quot; &gt;每期存入的金额：&lt;/span&gt; &lt;input id=&quot;money&quot; /&gt;元&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;计算&quot; onclick=&quot;jisuan()&quot; style=&quot;background-color: #EEA236; width: 80px;&quot; /&gt; &lt;input type=&quot;reset&quot; style=&quot;width:80px;&quot;/&gt; &lt;/form&gt; &lt;br&gt; &lt;hr&gt; &lt;br&gt; &lt;div&gt; 计算结果：&lt;br&gt; 所得利息：&lt;input id=&quot;lixi&quot; disabled=&quot;disabled&quot; /&gt;&lt;br&gt; 本息合计：&lt;input id=&quot;benxi&quot; disabled=&quot;disabled&quot; /&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 实验效果： 定期： 活期： 五、 相关讨论、实验心得 12345678910111213141516171819202122232425261、 首先就是通过id来访问文本框，下拉列表的值其中可以通过var 值=选择框.value;直接得到选中的option的value其中总结一下关于下列列表的一些操作HTML DOM selectedIndex 属性selectedIndex 属性可设置或返回下拉列表中被选选项的索引号。1、运用new Option(&quot;文本&quot;,&quot;值&quot;)方法添加选项optionvar obj = document.getElementById(&quot;mySelect&quot;);obj.add(new Option(&quot;4&quot;,&quot;4&quot;)); 2、删除所有选项optionvar obj = document.getElementById(&quot;mySelect&quot;);obj.options.length = 0; 3、删除选中选项optionvar obj = document.getElementById(&quot;mySelect&quot;);var index = obj.selectedIndex;obj.options.remove(index);4、修改选中选项optionvar obj = document.getElementById(&quot;mySelect&quot;);var index = obj.selectedIndex;obj.options[index] = new Option(&quot;three&quot;,3); //更改对应的值obj.options[index].selected = true; //保持选中状态5、删除selectvar obj = document.getElementById(&quot;mySelect&quot;);obj.parentNode.removeChild(obj); //移除当前对象 2、 可以通过style的display属性来设置某个元素的显示还是隐藏，属性值为block为显示，为none的时候为隐藏。3、 在获取文本框的值的时候忘记了-‘0’;在最后的结果中会直接把利息和本金用字符串拼接的方式来得到本息。 tips小技巧","categories":[{"name":"前端","slug":"前端","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"https://zouyunkai.github.io/myblog/tags/html/"}],"author":"aoyuehan"},{"title":"qlu_新生赛_2018_代码汇总","slug":"qlu","date":"2019-11-08T10:15:00.000Z","updated":"2022-02-26T03:52:51.653Z","comments":true,"path":"2019/11/08/qlu/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/11/08/qlu/","excerpt":"","text":"https://blog.csdn.net/weixin_43537190/article/details/84570246记得看看梁延杰的blog 可能会有小惊喜还有就是别的学校的新生题本文章全都是转载，只为个人日后方便复习 1 输入3个字符串，按字典序从小到大进行排序。 就是a b c三个数，第一位置和第二位置比完之后，第一位置大于第二位置，然后第二位置和第三位置相比，第二位置大于第三位置，但是现在不知道第一位置和第二位置的大小了，所以还得在比较一下第一位置和第二位置。 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char a[100],b[100],c[100],d[100]; scanf(&quot;%s%s%s&quot;,a,b,c); //下面的abc其实就代表了第一个位置，第二个位置，第三个位置 if(strcmp(a,b)&gt;0)//若a&gt;b 将a值换成b的 实际还是a &#123; strcpy(d,a); strcpy(a,b); strcpy(b,d); &#125; if(strcmp(b,c)&gt;0)//b与c比较 若上一步改变 则是a与c的比较 &#123; strcpy(d,b); strcpy(b,c); strcpy(c,d); &#125; if(strcmp(a,b)&gt;0)//a与b比较 此时的a与b值发生变化 结果为b与c或者a与c比较 &#123; strcpy(d,a); strcpy(a,b); strcpy(b,d); &#125; printf(&quot;%s %s %s&quot;,a,b,c); return 0;&#125;上面加了注释 因为第一次做的时候只想着用a b c的比较来输出最终的结果 忘记了复制交换的过程中a b c字符串已经换了数据 所以要想都比较一遍必须按上面的 步骤 比较方法来！！！千万要注意 2 问题 M: 签到题题目描述恭喜你发现一道签到题，请输出“check in”来解决这道问题。输入无输出check in样例输入无样例输出check in 123456#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; cout&lt;&lt;&quot;check in&quot;;&#125; 3问题 B: Alice and Bob命题人:admin题目描述Alice and Bob decide to play a game. At the beginning of the game they put n piles of sweets on the table.The number of each pile of sweets may be different. Alice and Bob take away sweets in turn,and always Alice takes sweets first in every games.Each time in their turn they can get only one whole pile of sweets.When there is no sweet left, the game is over. Finally, The man who have the largest number of sweets in hand will win.Assume that Alice and Bob were very clever.输入The first line is an integer n, which means that there are n pile sweets.1 &lt;&#x3D; n &lt;&#x3D; 100000Next n integers, the i-th integer means the number of sweets in the i-th pile.The number of sweets in each pile is less than 10000.输出If Alice wins, output “A”, and if Bob wins, output “B”.Otherwise output “again”样例输入样例输入1:31 6 7样例输入2:43 3 3 3题目大意为桌子上有很多堆糖果，每一堆糖果的数量可能不相同，这个Alice姐姐和Bob玩一个游戏 每个人一次拿一堆，比较最后谁拿到的糖果比较多。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include&lt;bits/stdc++.h&gt;using namespace std;int b=0,c=0;unsigned long long int a[200000];bool cmp(int a,int b) &#123; return a&gt;b; //定义从大到小排列的算子&#125;int main() &#123; long long int n; //long long表示1e18;int 最大表示1e8 cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a+1,a+n+1,cmp); //因为他们都很聪明这句话，说明要从大到小排序 //因为i是从1开始的，所以sort要这么写才可以 for(int i=1;i&lt;=n;i++) &#123; if(n==1) &#123; if(a[n]&lt;=0) cout&lt;&lt;&quot;again&quot;; //对n==1这种特殊情况讨论 else if(a[n]&gt;0) cout&lt;&lt;&quot;A&quot;; return 0; &#125; else if(n&gt;1&amp;&amp;(i%2!=0)) //如果i%2！=0就代表alice取糖果 b+=a[i]; else if(n&gt;1&amp;&amp;(i%2==0)) c+=a[i]; &#125; if(b&gt;c) cout&lt;&lt;&quot;A&quot;; else if(b&lt;c) cout&lt;&lt;&quot;B&quot;; else if(b==c) cout&lt;&lt;&quot;again&quot;;&#125; 方法二：其实一想bob根本没有赢得机会，只要判断是否是平局就好了#include &lt;stdio.h&gt;int main()&#123; int n; int A=0,B=0; int temp; int a[100001]; scanf(&quot;%d&quot;,&amp;n); //没说输入数据有多组，就当只有一组处理就好了 for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) &#123; if(i%2!=0) A=A+a[i]; else if(i%2==0) B=B+a[i]; &#125; if(A==B) printf(&quot;again&quot;); else printf(&quot;A&quot;); return 0;&#125;方法三：#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[10005];int main()&#123; scanf(&quot;%d&quot;,&amp;n); int k; for(int i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;k); a[k]++;//我这里使用的桶来记录是否均分（均分就是alice和bob得到的糖果一样多） //数组a就相当于一个桶，这个桶记录了一堆糖果的个数的出现的次数； //如果桶全是偶数次就是均分，存在一个奇数次就不是均分 &#125; if(n&amp;1)//奇数堆，相当于n%2 &#123; printf(&quot;A\\n&quot;); return 0; &#125; else//偶数堆 &#123; for(int i=1;i&lt;=1000;i++) &#123; if(a[i]&amp;1)//存在奇数桶，不均分 &#123; printf(&quot;A\\n&quot;); return 0; &#125; &#125; printf(&quot;again\\n&quot;);//均分 &#125;&#125; 4 问题 C: 黑白黑命题人:admin题目描述黑白黑是一个很经典的游戏，规则也非常简单。三个人同时伸出一只手，手心为白，手背为黑，如果有两人为黑一人为白，或者两人为白一人为黑，则单独伸出手心或者手背的那个人就输了。又是一个周末，小A小B小C他们仨个懒虫又睡到了中午，外卖送到楼下了也不想下楼拿，于是他们决定用这个游戏来选出一个输的人去拿外卖。 输入三个整数a b c(0 &lt;&#x3D; a,b,c &lt;&#x3D; 1)a表示小Ab表示小Bc表示小C0表示伸出的手背1表示伸出的手心输出如果有人输了则输出他的名字A&#x2F;B&#x2F;C（大写）平局则输出”aha”（不含引号）样例输入样例输入1:0 0 0样例输入2:1 1 0样例输出样例输出1:aha样例输出2:C 123456789101112131415161718192021222324252627282930313233所有的情况不多，挨个枚举：#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if((a==0&amp;&amp;b==0&amp;&amp;c==0)||(a==1&amp;&amp;b==1&amp;&amp;c==1)) cout&lt;&lt;&quot;aha&quot;; else if((a==1&amp;&amp;b==1&amp;&amp;c==0)||(a==0&amp;&amp;b==0&amp;&amp;c==1)) cout&lt;&lt;&quot;C&quot;; else if((a==1&amp;&amp;b==0&amp;&amp;c==1)||(a==0&amp;&amp;b==1&amp;&amp;c==0)) cout&lt;&lt;&quot;B&quot;; else if((a==0&amp;&amp;b==1&amp;&amp;c==1)||(a==1&amp;&amp;b==0&amp;&amp;c==0)) cout&lt;&lt;&quot;A&quot;;&#125; 方法二（只需要判断 是不是两个相同的和一个不同的即可）：#include &lt;bits/stdc++.h&gt;using namespace std;int a, b, c;int main()&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (a == b &amp;&amp; b == c) cout &lt;&lt; &quot;aha&quot;; else if (a == b) cout &lt;&lt; &quot;C&quot;; else if (b == c) cout &lt;&lt; &quot;A&quot;; else if (a == c) cout &lt;&lt; &quot;B&quot;; return 0;&#125; 5问题 E: are you ok?题目描述小朋是一家超市的老板,他经常会来超市检查,每次都会让仓库管理员列出仓库中剩余商品的数量。但是仓库管理员是个非常健忘的人，有时候商品都卖光了也不去进货，这会让老板非常生气，因为这样超市卖不出去东西就没办法赚钱了。小朋有句口头禅”are you ok?”，如果发现所有商品的库存都为0的话，就会非常生气地喊出”are you ok?”，大声地质询仓库管理员。现在你就是仓库管理员，每次面对小朋的询问，你都会在电脑系统中对库存进行查询，然后列出剩余商品的清单。（如果所有商品库存都是0，那你就没办法交差了，你的老板会非常生气）。输入第一行一个整数n，表示有n种货物(2 &lt;&#x3D; n &lt;&#x3D; 100)往下一行有n个字符串s1,s2…si…sn 表示系统显示的第i种货物的名称（1&lt;&#x3D;i&lt;&#x3D;n）(字符串长度不超过10)往下一行有n个整数a1,a2…ai…an 表示系统显示的第i种货物的库存（1&lt;&#x3D;i&lt;&#x3D;n）(每种货物库存数量 &lt;&#x3D; 1000)输出如果还有商品（哪怕只有一个），你也可以列出剩余商品的清单。否则你就只能挨老板骂了。样例输入样例输入1:4a b c d0 0 0 0 样例输入2: 5 apple egg milk desk light 0 1 2 0 1 样例输出 样例输出1: are you ok? 样例1的说明： 所有的商品都没库存， 你的老板会非常生气 样例输出2:egg x 1milk x 2light x 1(x前后有空格) 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;int f=0;struct node &#123; string name; int num;&#125;a[2000];int main() &#123; int n; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i].name; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i].num; for(int i=0;i&lt;n;i++) &#123; if(a[i].num!=0) &#123; cout&lt;&lt;a[i].name&lt;&lt;&quot; x &quot;&lt;&lt;a[i].num&lt;&lt;&quot;\\n&quot;; f=1; &#125; &#125; if(f==0) cout&lt;&lt;&quot;are you ok?&quot;;&#125; 6 问题 G: 数数题目描述小凯今年上一年级了，他只学会了0-9这十个数字，对于两位以上的数字，小凯自创了一套读法。连续出现的x个y,小凯将其读作“xy”比如:11 小凯读作”21” (连续2个1)21 小凯读作”1211” (连续1个2 连续1个1)99 小凯读作”29” (连续2个9)310 小凯读作”131110”(连续1个3 连续1个1 连续1个0)330111 小凯读作”231031”(连续2个3 连续1个0 连续3个1)给定一个由数字组成的字符串n(2 &lt;&#x3D; |n| &lt;&#x3D; 100),请输出小凯对n的读法|n|表示字符串n的长度保证连续出现同一个数字的次数不会超过9次(因为小凯最多只能数到9)比如:2223311111111118(非法,因为数字1连续出现了10次) 输入由纯数字组成的一行字符串 输出在小凯的自创规则下这一长串数的读法 样例输入13145 样例输出1113111415 123456789101112131415161718192021222324252627282930313233343536373839404142434445这种的输出3a4b形式的可以用这种方法来解题，而不是用那种拼接字符串的形式#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string a; cin&gt;&gt;a; int sum=1; for(int i=0;i&lt;a.size();i++) &#123; if(a[i]==a[i+1]) //当为a[a.size()]的时候输出&#x27;\\0&#x27; sum++; else &#123; cout&lt;&lt;sum&lt;&lt;a[i]; sum=1; &#125; &#125;&#125;方法二：#include&lt;bits/stdc++.h&gt;using namespace std;string s;int Count=0; int main()&#123; cin&gt;&gt;s; Count=1;//第一个数字的 for(int i=1;i&lt;s.length();i++) &#123; if(s[i]==s[i-1])//前后相同 &#123; Count++; &#125; else//前后不同了 重新开始 &#123; cout&lt;&lt;Count&lt;&lt;s[i-1]; Count=1; &#125; if(i==s.length()-1&amp;&amp;Count) &#123;//特判，如果全是一个数字，因为这个是下标为i和i-1的相比，当i为最后一个 //的时候会执行count++语句，而不是输出count语句 cout&lt;&lt;Count&lt;&lt;s[i]; &#125; &#125;&#125; 7问题 H: 神奇老虎机不知道你有没有玩过老虎机，现在小明面前有一台神奇的老虎机，这台机器有n个滚轮，从左往右数第i个滚轮包含1到a_i的整数(包括1和a_i)。在按下按钮之后，所有的滚轮都会飞速旋转，最终停下来，每个滚轮将显示其中一个整数。这个过程是随机的。小明有一个有趣的想法，如果将滚轮显示的数字连接起来看做一长串字符串的话，将会有非常多的可能，在这所有的可能中字典序最小的字符串是哪个？（只能从左向右读） 对于字典序的说明:两个字符串S和T，从前往后比较，如果存在一个位置，在该位置两个字符串的字符不同，则比较小的那个所在的字符串字典序更小。例如: 123的字典序比14的小，因为在第二个位置上2小于412345的字典序比9的小220的字典序比22的大，因为22是220的一个前缀 输入一个整数t，表示有t组数据(1 &lt;&#x3D; t &lt;&#x3D; 100)每组第一行为一个整数n表示老虎机有n个滚轮(1 &lt;&#x3D; n &lt;&#x3D; 1000)第二行为n个整数（a_1 a_2 … a_i … a_n ）表示第i个滚轮上的数字范围(1~a_i)(1 &lt;&#x3D; a_i &lt;&#x3D; 100) 输出每组输入对应一行输出，输出字典序最小时老虎机滚轮上显示的数字两个数字之间用空格隔开 样例输入246 6 6 622 2 样例输出1 1 1 11 1 提示老虎机上显示的数都不含前导0比如：某一块滚轮包含[1,33]，如果它显示”1”的话，显示的是”1”而不是”01” 对于样例2的解释：所有情况分别为：“1 1”、“1 2”、“2 1”、“2 2”其中”1 1”是字典序最小的，所以答案为”1 1” 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int t,n,x; cin&gt;&gt;t; for(int i=0;i&lt;t;i++) &#123; cin&gt;&gt;n; for(int j=0;j&lt;n-1;j++) &#123; cin&gt;&gt;x; if(x&lt;10) cout&lt;&lt;1&lt;&lt;&quot; &quot;; if(x&gt;=10&amp;&amp;x&lt;100) cout&lt;&lt;10&lt;&lt;&quot; &quot;; if(x==100) cout&lt;&lt;100&lt;&lt;&quot; &quot;; &#125; cin&gt;&gt;x; cout&lt;&lt;1&lt;&lt;&quot; \\n&quot;; &#125; &#125;有个疑问：为什么最后要输出1呐，因为最后一个数的前缀只有是1的时候才最小1是10或者100的前缀 8问题 I: 五环题目描述提到五环，我想大家都非常熟悉。 “啊五环你比四环多一环~~”不好意思 跑题了。。。奥运五环由蓝、黄、黑、绿、红五种颜色的圆环组成。小迪认为五个圆环分别代表五大洲：蓝色 &#x3D; 欧洲黄色 &#x3D; 亚洲黑色 &#x3D; 非洲绿色 &#x3D; 大洋州红色 &#x3D; 美洲对应英文为Blue &#x3D; EuropeYellow &#x3D; AsiaBlack &#x3D; AfricaGreen &#x3D; OceaniaRed &#x3D; America 输入输入一行字符串字符串为五环的颜色或者五个大洲的名称 输出 如果输入的是颜色则输出对应的大洲如果输入的是大洲则输出对应的颜色 样例输入Blue 样例输出Europe 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748方法一（map集合）：#include&lt;bits/stdc++.h&gt;using namespace std;map&lt;string,string&gt;a;int main() &#123; a[&quot;Blue&quot;]=&quot;Europe&quot;; a[&quot;Yellow&quot;]=&quot;Asia&quot;; a[&quot;Black&quot;]=&quot;Africa&quot;; a[&quot;Green&quot;]=&quot;Oceania&quot;; a[&quot;Red&quot;]=&quot;America&quot;; a[&quot;Europe&quot;]=&quot;Blue&quot;; a[&quot;Asia&quot;]=&quot;Yellow&quot;; a[&quot;Africa&quot;]=&quot;Black&quot;; a[&quot;Oceania&quot;]=&quot;Green&quot;; a[&quot;America&quot;]=&quot;Red&quot;; string b; cin&gt;&gt;b; cout&lt;&lt;a[b];&#125;方法二：#include&lt;bits/stdc++.h&gt;using namespace std;int main() &#123; string a; cin&gt;&gt;a; if(a==&quot;Blue&quot;) cout&lt;&lt;&quot;Europe&quot;; else if(a==&quot;Yellow&quot;) cout&lt;&lt;&quot;Asia&quot;; else if(a==&quot;Black&quot;) cout&lt;&lt;&quot;Africa&quot;; else if(a==&quot;Green&quot;) cout&lt;&lt;&quot;Oceania&quot;; else if(a==&quot;Red&quot;) cout&lt;&lt;&quot;America&quot;; else if(a==&quot;Europe&quot;) cout&lt;&lt;&quot;Blue&quot;; else if(a==&quot;Asia&quot;) cout&lt;&lt;&quot;Yellow&quot;; else if(a==&quot;Africa&quot;) cout&lt;&lt;&quot;Black&quot;; else if(a==&quot;Oceania&quot;) cout&lt;&lt;&quot;Green&quot;; else if(a==&quot;America&quot;) cout&lt;&lt;&quot;Red&quot;;&#125; 9 问题 J: 开挂的小洋命题人:admin题目描述最近小洋迷上了一款名叫打地鼠的游戏,但是小洋是个游戏白痴,这么简单的游戏也总是得不到几分,有一天他发现这款游戏可以在网络上买到外挂,这款外挂可以提前预知所有地鼠出现的时间,并且他可以开局得到两把锤子,之前小洋1s只能挥动一次锤子,现在他左右开弓可以同时打中最多两只地鼠。每只地鼠在第i秒出现,在第i+1秒的时候就会消失。也就是说在第i秒小洋只能打到这一秒出现的地鼠,(i-1)秒以及(i+1)秒出现的地鼠他都没办法打中。 输入一个整数n,表示地鼠的数目一个整数m,表示此次游戏时长接下来n个整数a_1-a_n,表示地鼠会在第a_i秒出现1 &lt;&#x3D; a_i &lt;&#x3D; m1 &lt;&#x3D; n &lt;&#x3D; 1000;1 &lt;&#x3D; m &lt;&#x3D; 100000;每只地鼠最多停留一秒 输出一个整数,表示小洋最高得分（每打中一只地鼠得一分） 样例输入样例输入1:491 1 4 7 样例输入2:6103 3 3 3 9 1 样例输出样例输出1:4 样例输出2:4 提示对于样例1的解释：第1秒出现两只地鼠 左右开弓两只全打中得2分第4秒出现一只地鼠 打中得1分第7秒出现一只地鼠 打中得1分最终得分4分 对于样例2的解释:第1秒出现一只地鼠 打中得1分第3秒出现四只地鼠 两把锤子最多打中两只 得2分第9秒出现一只地鼠 打中得1分共4分 其实本题就是一个时间段内求不同位置的出现次数的个数问题，但同一时间出现大于两次的情况算两次，这就可以通过把不同位置当做数组的下标，然后通过数组的大小判断出现次数。 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int a[200000];int main() &#123; int n,m,count=0,b; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;b; a[b]++; &#125; for(int i=0;i&lt;200000;i++) &#123; if(a[i]!=0) &#123; if(a[i]&gt;=2) //因为同一时间出现2个以上的仓鼠，只能打死其中两个 count+=2; if(a[i]==1) count+=1; &#125; &#125; cout&lt;&lt;count;&#125; 10 问题 K: 数字匹配题目描述给出两个元素数量都为n的数组a和数组b。对于数组a中的每个元素，都必须找一个（而且最多一个）数组b中的元素进行匹配，数组b中的所有元素也都要被匹配到,也就是说一一匹配。匹配完成后，相互匹配的元素相乘，然后把所有的积相加。例如：数组a：1 5 3数组 b：2 3 4如果a中第一个元素跟b中第三个元素匹配，第二个元素跟b中第二个元素匹配，第三个元素跟b中第一个元素匹配，匹配完后相乘得到 14、53、32，求和得到结果14+53+32&#x3D;25。如果a中第一个元素跟b中第二个元素匹配，第二个元素跟b中第三个元素匹配，第三个元素跟b中第一个元素匹配，匹配完后相乘得到 13、54、32，求和得到结果13+54+32&#x3D;29。 给出n和两个数组，分别计算求和的最大结果与最小结果。 输入第一行 一个数n，表示两个数组元素的个数 1&lt;&#x3D;n&lt;&#x3D;1000。第二行 n个数 表示数组a的各个元素ai，0&lt;ai&lt;&#x3D;1000 ai为正整数，（1&lt;&#x3D;i&lt;&#x3D;n）。第三行 n个数 表示数组b的各个元素bi，0&lt;bi&lt;&#x3D;1000 bi为正整数，（1&lt;&#x3D;i&lt;&#x3D;n）。 输出两个数 分别表示最大结果和最小结果。最大结果和最小结果可以相等。 样例输入31 5 32 3 4 样例输出31 23 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152首先这一题可以不通过全部都遍历一遍（对a数组求next_pretutation(),数组a和数组b相乘）就可以求出结果；可以通过a的降序和b的降序1对1,2对#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[2000],b[2000];bool cmp(int a,int b) &#123; return a&gt;b;&#125;int main() &#123; int n,maxn=0,minn=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;b[i]; sort(a,a+n); //从小到大排列 sort(b,b+n); for(int i=0;i&lt;n;i++) &#123; maxn+=a[i]*b[i]; //就是最大的*最大的，第二大的*第二大的...... &#125; sort(b,b+n,cmp); for(int i=0;i&lt;n;i++) minn+=a[i]*b[i]; //a的最小*b的最大，a的第二小*b的第二大 cout&lt;&lt;maxn&lt;&lt;&quot; &quot;&lt;&lt;minn;&#125;方法二（这样写更巧妙）：#include&lt;bits/stdc++.h&gt;using namespace std;int a[1005],b[1005];int n;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; &#125; sort(a+1,a+n+1);//从小到大排序 for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;b[i]; &#125; sort(b+1,b+n+1); long long num1=0,num2=0; for(int i=1;i&lt;=n;i++) &#123; num1+=a[i]*b[i];//最大乘最大，最小乘最小 最大值 num2+=a[i]*b[n-i+1];//最大乘最小 最小值 &#125; printf(&quot;%lld %lld&quot;,num1,num2); &#125; 11A.约数个数 p^q表示p的q次方，正整数M可以分解为M&#x3D;(p1^a1)(p2^a2)(p3^a3)……(pn^an)的形式，其中p1，p2……pn为质数(大于1并且只能被1和自身整除的数叫做质数)。a1，a2……an为整数。例如18&#x3D;(2^1)(3^2)，45&#x3D;(3^2)(5^1)。 给出n和一个质数g，以及正整数M分解后的形式，求M的所有约数中，有多少能被g整除。第一反应是不是求出M然后找因数？那你就上当了，M可能很大很大的呢U•ェ•*U，这个题要注意pi是质数，并且g也是质数，所以如果，pi中没有g的话，M一定不会被g整除了，当pi里有g的时候就要看有多少个了。 tips：m&#x3D;(p1)^(x1)(p2)^(x2)(p3)^(x3)……其中p1,p2,p3…是质数（素数）,x1,x2,x3…是它们的指数则m的约数的个数是(x1+1)(x2+1)*(x3+1)……例如24&#x3D;(2^3) * (3^1)所以其约数的个数为(3+1)(1+1)&#x3D;8个 123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int n,m;int a[100],b[100];int main()&#123; cin&gt;&gt;n&gt;&gt;m; int flag=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; if(a[i]==m) //如果存在ai==m &#123; flag=i; //标记一下是第几个数 &#125; &#125; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;b[i]; //bi是幂数 &#125; long long num=b[flag]; //g的幂数 for(int i=1;i&lt;=n;i++) &#123; if(i!=flag) num+=num*b[i]; //上图推导出来的个数 &#125; if(!flag) //不存在直接为0 &#123; cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; &#125; else cout&lt;&lt;num&lt;&lt;endl;&#125; 12 题目描述 小明最近对折纸很感兴趣，他想知道一张正方形的纸在多次折叠以后沿纸的中线用剪刀将其剪开能得到多少张纸？输入第一行一个整数t,表示一共有t组数据(1 &lt;&#x3D; t &lt;&#x3D; 100)每组输入数据包括三行第一行为一个整数n，表示有n次操作(1 &lt;&#x3D; n &lt;&#x3D; 10^5) 第二行为n个大写字母(四种情况L,R,T,B L表示从左向右折 R表示从右向左折 T表示从上向下折 B表示从下向上折) 第三行为两个字母(四种情况 LR,RL,TB,BT LR表示从左向右剪 RL表示从右向左剪 TB表示从上往下剪 BT表示从下往上剪)输出输出一个整数表示能得到的纸的数目答案可能过大 需要对1000000007 (1e9+7)取模样例输入2 2BBLR 1RLR 样例输出52提示所有的“对折”与“剪”的操作均沿中线进行 拿张纸模拟折叠找出来的规律，其实多模拟几次就会发现，左右方向剪只对上下方向叠有贡献，上下方向剪只对左右方向叠有贡献，所有就可以对应一下怎样剪的，然后只算另一个方向叠所形成的数量，然后也是多模拟几次会发现数量是2^k+1，k是折叠数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const long long Mod=1000000007;char zhe[100005];string jian;int t,n;int LR,TB;int main()&#123; scanf(&quot;%d&quot;,&amp;t); while(t--) &#123; scanf(&quot;%d&quot;,&amp;n); LR=0; TB=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;zhe[i]; if(zhe[i]==&#x27;R&#x27;||zhe[i]==&#x27;L&#x27;) &#123; LR++;//左右方向折叠次数 &#125; else &#123; TB++;//上下方向折叠次数 &#125; &#125; cin&gt;&gt;jian; long long num=1; if(jian==&quot;LR&quot;||jian==&quot;RL&quot;)//左右方向剪 &#123; for(int i=1;i&lt;=TB;i++) &#123; num=num*2%Mod; &#125; num+=1; cout&lt;&lt;num&lt;&lt;endl; &#125; else //上下方向剪 &#123; for(int i=1;i&lt;=LR;i++) &#123; num=num*2%Mod; &#125; num+=1; cout&lt;&lt;num&lt;&lt;endl; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354二分来做（https://www.cnblogs.com/violet-acmer/p/10020199.html）：步骤： (1):特判圆周长sum[ n ]是否整除3，如果不整除，直接输出&quot;No&quot;。 (2):如果sum[ n ]整除3，遍历一遍数组，判断是否含有三点a,b,c，使得ab,bc,ca间的距离等于sum[ n ]/3，如果有，输出&quot;Yes&quot;,否则输出&quot;No&quot;。 #include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;const int maxn=1e6+10;int n;int a[maxn];int sum[maxn];bool isSat(int p1,int p2)&#123;//判断p1,p2点是否在范围内 return p1 &lt;= sum[n] &amp;&amp; p2 &lt;= sum[n];&#125;bool Check(int p1)//二分查找&#123; int l=0,r=n+1; while(r-l &gt; 1) &#123; int mid=l+((r-l)&gt;&gt;1); if(sum[mid] == p1) return true; if(sum[mid] &lt; p1) l=mid; else r=mid; &#125; return false;&#125;char *Solve()&#123; if(sum[n]%3 != 0)//特判 return &quot;No&quot;; int d=sum[n]/3; for(int i=1;i &lt;= n;++i)//遍历所有点，判断是否含有满足条件的三个点 &#123; int p1=sum[i]+d,p2=sum[i]+2*d; if(isSat(p1,p2) &amp;&amp; Check(p1) &amp;&amp; Check(p2))//二分查找点p2,p2是否存在 return &quot;Yes&quot;;//如果存在，返回&quot;Yes&quot; &#125; return &quot;No&quot;;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); sum[0]=0; for(int i=1;i &lt;= n;++i) scanf(&quot;%d&quot;,a+i),sum[i]=sum[i-1]+a[i];//前缀和 printf(&quot;%s\\n&quot;,Solve());&#125; 13L.寄蒜几盒 现在有一个圆圈，圆圈上有若干个点，请判断能否在若干个点中选择三个点两两相连组成一个等边三角形？这若干个点在圆圈上按顺时针顺序分布。如果可以的话输出”Yes”(不含引号)不可以的话输出”No”(不含引号) 输入 第一行一个整数n，表示圆圈上有n个点第二行n个整数，分别表示第1个点与第2个点之间圆弧的长度、第2个点与第3个点之间圆弧的长度······第n个点与第1个点之间圆弧的长度3 &lt;&#x3D; n &lt;&#x3D; 10^61 &lt;&#x3D; x_i &lt;&#x3D; 1000 ( 1 &lt;&#x3D; i &lt;&#x3D; n) 我和继朋小朋友有两种不同解法，一个模拟查找+优化，一个利用二分查找，等会找他写一下二分的题解 方法一：弦长相等的话，那么对应的弧也相等，所以周长一定是3的倍数。因为给的是与前面一个点的距离，所以我们可以前缀和求周长，要想构成等边三角形那么三个点之间两两相距d&#x3D;周长&#x2F;3，怎么求两个不同点之间的距离呢？别忘了 给出的是前一个点与后一个点之间相隔的距离，那么，就可以利用区间和求两点之间的距离。优化一利用1&#x2F;3周长和2&#x2F;3周长做判断点，判断是否能够继续找，优化二 如果两个点相隔1&#x2F;3周长，但找不到第三个点，这时候这两个点是不可能组成等边三角形了，所以有的话可以记录一下，然后跳过 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;bits/stdc++.h&gt;using namespace std;int n;int d[1000005];bool vis[100005];int main()&#123; cin&gt;&gt;n; int sum=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;d[i]; sum+=d[i]; &#125; if(sum%3) &#123; printf(&quot;No\\n&quot;); return 0; &#125; else &#123; int flag1=0,flag2=0,flag3=0; int s; for(int i=1;i&lt;=n;i++) &#123; if(vis[i]) &#123; continue; &#125; s=0; flag2=0;//第一个距离d的点 flag3=0;//第二个 for(int j=i;j&lt;=n;j++) &#123; s += d[j]; //区间和 求长度 if(s==sum/3)//第一个点找到 &#123; flag2=j; vis[j]=1; &#125; if(s&gt;sum/3&amp;&amp;(!flag2))//弧长&gt;1/3没找到第一个点 &#123; break; &#125; if(s==sum/3*2&amp;&amp;flag2)//第二个点找到 &#123; flag3=1; printf(&quot;Yes\\n&quot;); return 0; &#125; if(s&gt;sum/3*2&amp;&amp;(!flag3))//弧长&gt;2/3没找到第二个点 &#123; break; &#125; &#125; &#125; printf(&quot;No\\n&quot;); &#125;&#125; 14 一道c语言书上的题目 123456789101112131415161718192021222324252627282930313233结构体中存入书的名字和价格，然后在下面求出最大的价格和最小的价格的书名#include&lt;iostream&gt;using namespace std;struct book&#123; char n[10]; int p;&#125;b[10];int main()&#123; int s,i; scanf(&quot;%d&quot;,&amp;s); getchar(); int max,min; for(i=0;i&lt;s;i++) &#123; scanf(&quot;programming is %s%d&quot;,b[i].n,&amp;b[i].p); getchar();//每次输完不处理那个回车的话，就会执行scanf来读取回车，这样就不符合逻辑了 //cin&gt;&gt;b[i].n&gt;&gt;b[i].p; //但是cin是不用向上面那样考虑吞掉回车的 if(i==0)&#123; min=i; max=i; &#125; if(b[max].p&lt;b[i].p) max=i; if(b[min].p&gt;b[i].p) min=i; &#125; printf(&quot;%s%d&quot;,b[max].n,b[max].p);//最大值的数据 printf(&quot;%s%d&quot;,b[min].n,b[min].p);//最小值的数据 return 0;&#125; 15 提交时常见的错误如果出现编译错误(Compile Error)，是不会执行的。每个题目都有一个标准的时间和内存限制，例如时间1000ms，内存65536K，程序在执行的时候会实时检查其花费时间和使用内存信息，如果出现超时和超内存将会分别返回Time Limit Exceeded和Memory Limit Exceeded错误信息，如果程序执行时出现错误，比如非法指针，数组越界等，将会返回Runtime Error信息。如果你的程序没有出现上面的信息，说明程序顺利执行结束了。接下来，就是对你的程序的输出也就是运行结果进行检查，如果你的执行结果和我们的标准答案完全一样，则返回Accepted，也就说明你这个题目做对了。如果除去空格，换行，tab外完全相同，则说明你的代码格式错误，将返回Presentation Error（比如多输出了什么空格啥的），如果你输出的内容有一部分和标准答案完全一样，但是还输出了一些其他内容，则说明你多输出了，这时候将返回Output Limit Exceeded错误信息，出现其他情况，就说明你的输出结果和标准答案不一样，就是Wrong Answer了。 总结一下错误的出现顺序： Compile Error -&gt; Memory Limit Exceeded &#x3D; Time Limit Exceeded &#x3D; Runtime Error -&gt; Wrong Answer -&gt; Output Limit Exceeded -&gt;Presentation Error -&gt; Accepted 其中：Runtime Error(ACCESS_VIOLATION) runtime error （运行时错误）就是程序运行到一半，程序就崩溃了。当出现这种错误时，先看看定义的范围是不是与题目不符，比如题目要求m&lt;1000,定义数组时只定义为a[100]，这种错误多次出现。一定要注意题目中数据的范围！如果不是这种错误，还有可能是程序太麻烦，太复杂 比如说：①除以零②数组越界：int a[3]; a[10000000]&#x3D;10;③指针越界：int * p; p&#x3D;(int *)malloc(5 * sizeof(int)); *(p+1000000)&#x3D;10;④使用已经释放的空间：int * p; p&#x3D;(int *)malloc(5 * sizeof(int));free(p); *p&#x3D;10;⑤数组开得太大，超出了栈的范围，造成栈溢出：int a[100000000]; 16 17 18 19","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"新生训练","slug":"新生训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"新生训练class 3- 二分/分治","slug":"新生训练class-3-二分-分治","date":"2019-11-06T11:02:00.000Z","updated":"2022-02-26T03:52:50.978Z","comments":true,"path":"2019/11/06/新生训练class-3-二分-分治/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/11/06/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83class-3-%E4%BA%8C%E5%88%86-%E5%88%86%E6%B2%BB/","excerpt":"","text":"A Discounts题目大意： 你要买n种巧克力， 第i种巧克力花费ai的钱，你有m种优惠券， 第i种优惠券的值为bi， 你可以从n种巧克力中买bi种， 可以优惠这bi种巧克力中最便宜的那种巧克力的价钱。** 但是你要买全部的巧克力**， 对应每种优惠券， 请输出所花的最少的钱。思路： 贪心水题， 题目说可以优惠bi种巧克力中最便宜的那种巧克力的钱， 自然要买最贵的bi种巧克力， 这样才能省的钱多。 用前缀和数组和后缀和数组优化。 小技巧：其中用前（后）缀和可以在O（1）的时间复杂度中求出前（后）n项的和 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;typedef long long ll; //因为每一项的大小为2~10^9,所以用longlongusing namespace std;const int maxn=300005; int a[maxn];ll psum[maxn];//前缀和ll nsum[maxn];//后缀和 int main()&#123; int n,m; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+1+n); for(int i=1;i&lt;=n;i++) psum[i]=psum[i-1]+a[i]; 前缀和 for(int i=n;i&gt;=1;i--) nsum[i]=nsum[i+1]+a[i]; 后缀和 scanf(&quot;%d&quot;,&amp;m); int temp; for(int i=0;i&lt;m;i++) &#123; scanf(&quot;%d&quot;,&amp;temp); printf(&quot;%lld\\n&quot;,nsum[n-temp+2]+psum[n-temp]); //因为数组a是自从小到大排列的，所以求第三大的数的时候应该是n-3+2的前缀和+n-3的后缀和 //printf打印longlong类型的要格式化为lld类型 &#125; return 0;&#125; B Lost Numbers（交互式题目）题意:简单来说就是 4, 8, 15, 16, 23, 42 让你猜这几个数的排列方式, 你可以询问四次 ? i j 来询问 i j 位置上两数之积, 然后读入计算机告诉你的答案然后再输出你猜到的整个序列. 其实就是你询问？ i j的值，计算机给出i j两个位置乘积的值，让你求符合要求的该序列 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt; using namespace std;int a[6] = &#123;4, 8, 15, 16, 23, 42&#125;, dp[5];int main() &#123; for(int i = 1; i &lt;= 4; i++)&#123; printf(&quot;? %d %d\\n&quot;, i, i+1); fflush(stdout); scanf(&quot;%d&quot;, &amp;dp[i]); &#125; do&#123; if(a[1]*a[0] == dp[1] &amp;&amp; a[2]*a[1] == dp[2] &amp;&amp; a[3]*a[2] == dp[3] &amp;&amp; a[4]*a[3] == dp[4]) break; &#125;while(next_permutation(a, a+6)); //这样到某一步时跳出来，因为next_per这函数能改变原来数组的值， //所以下面可以直接输出数组a的值，就是符合要求的序列 cout&lt;&lt;&quot;!&quot;; for(int i = 0; i &lt; 6; i++) printf(&quot; %d&quot;, a[i]); cout&lt;&lt;&quot;\\n&quot;; return 0;&#125; 交式题目例题(codeforces 679A)：系统随机给你一个 [2,100]的数x你可以进行不超过20次询问每次询问输出一个数 系统会回答是否x的因子如果是则输入yes 否则则为no请问x为合数还是素数题解：任意一个合数都有两个或以上素数的因子因此我们只要先打表打出2-50的素数， 还有不超过50的素数的平方int prime[] &#x3D; { 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,4,9,25,49 };一共有19个所以只要询问19次即可 交互式题目有个需要注意的每次输出完 进行交互 都要强制刷新输出缓冲区以下为各种编程语言的 强制刷新输出缓冲区的函数fflush(stdout) in C++; &#x2F;&#x2F;交互完了都要强制刷新输出缓冲区System.out.flush() in Java; 123456789101112131415161718192021222324252627//其中：cstdio是将stdio.h的内容用C++头文件的形式表示出来。/*小结： 在C++下，若要使用C中已有库中的函数如stdio，文件包含方式为前面加一个c，同时去掉.h后缀，如#include &lt;cstdio&gt;，同时必须加上using namaspace;对于其他类似的函数同样； 对于C++特有的库，直接用去掉.h后缀的文件包含，并加上using namaspace;*/#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int prime[] = &#123; 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,4,9,25,49 &#125;;char s[10];int main() &#123; int cnt = 0; for (int i = 0;i&lt;19;i++) &#123; printf(&quot;%d\\n&quot;, prime[i]); fflush(stdout); scanf(&quot;%s&quot;, s); if (!strcmp(s, &quot;yes&quot;)) cnt++; &#125; if (cnt &gt;= 2) printf(&quot;composite\\n&quot;); else printf(&quot;prime\\n&quot;); fflush(stdout); return 0;&#125; C Code For 1题意：把一个数n拆分，奇数拆成n&#x2F;2,1,n&#x2F;2，偶数拆成n&#x2F;2,0,n&#x2F;2，1和0不可拆，问拆分后从l位置到r位置1的个数思路：分治递归拆分即可…想的太多…n最大是2^50，最多递归调用也才是高为 50的二叉树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;#define ll long long#define max_ 200100#define mod 1000000007#define inf 0x3f3f3f3f#define eps 1e-9ll n;ll l,r;ll length(ll n)&#123; if(n&lt;=1) return 1; return 2*length(n/2)+1;&#125;ll cal(ll n,ll l,ll r)&#123; if(l&gt;r||l&lt;=0||r&lt;=0||n==0) return 0; if(n==1) return 1; ll len=length(n); ll mid=len/2+1; //找到一个中间值 if(r&lt;mid) return cal(n/2,l,r); //若果[l，r]这个区间在mid的左边 else if(l&gt;mid) return cal(n/2,l-mid,r-mid); //若果[l，r]这个区间在mid的右边 else return cal(n/2,l,mid-1)+cal(n/2,1,r-mid)+(n&amp;1); //若果mid在区间[l，r]的中间，那么对两部分判断一下，还要判断此时n是否为奇数&#125;int main(int argc, char const *argv[]) &#123; scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;l,&amp;r); printf(&quot;%lld\\n&quot;,cal(n,l,r)); return 0;&#125; 该题还有第二种方法：仔细观察可以发现 每个数被拆分成的最终序列是有规律的 这里以10举例先将该数用二进制表示 1010观察序列 发现二进制中的第一位的1位于1 3 5 7 9 11 13 15的位置第二位的0位于2 6 10 14第三位的1位于4 12第四位的0位于8将1010这个二进制数的每一位附上权值 每一位对应为1 2 4 8 从左到右位置为 0 1 2 3 （其实就是2的次方对应关系）于是可以发现 对于序列中任意一个位置的值 都具有以下规律设当前位置为positionposition的值对应于 position的因子中最大的2的N次方数 即为该数二进制的第N位的值有点难懂 还是举10的例子对于序列的第3位 他的因子中最大的2的N次方数为1 即N&#x3D;0 所以为二进制1010的第0位 也就是第一个1对于序列的第6位 她的因子中最大的2的N次方数为2 即N&#x3D;1 所以对应1010的第一个0。。。。。。12。。。。。。。。。。。。。。。4 即N&#x3D;2 所以对应第三位 也就是第二个1找出规律之后 代码就很简单了因为范围不大 因此枚举他需要的区间的每个位置 根据规律计算当前的数是不是1 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#include &lt;set&gt;using namespace std;vector&lt;long long int &gt; s;int main()&#123; long long int n,l,r; cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; while(n!=0) &#123; s.push_back(n%2); n/=2; &#125; long long int cnt=0; reverse(s.begin(),s.end()); s.push_back(0); for(long long int i=l;i&lt;=r;i++) &#123; long long int j=0; long long int mid=i; while(mid%2==0) j++,mid/=2; if(s[j]==1) cnt++; &#125; cout &lt;&lt; cnt;&#125; D - Can you find it?题意：给你三个数组，再给你一些数，判断三个数组内是否有Ai+Bi+Ci&#x3D;&#x3D;x.如果有输出YES,否则输出NO、思路：先将前两个数组两两相加构成一个新数组(d数组），快排。然后依次将新数组和第三个数组中的值相加，二分，不断用二分法中的中间值（此时为d数组中的值和c数组中的值的和）第三个数组的元素（即x）相加，直到得x或者跳出循环为止。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;#define xps 1e-12using namespace std;int main()&#123; long long l,m,n,o=1; while(cin&gt;&gt;l&gt;&gt;m&gt;&gt;n) &#123; long long a[510],b[510],c[510],d[250010]; for(int i=0;i&lt;l;i++)//输入三个数组 cin&gt;&gt;a[i]; for(int i=0;i&lt;m;i++) cin&gt;&gt;b[i]; for(int i=0;i&lt;n;i++) cin&gt;&gt;c[i]; int k=0; for(int i=0;i&lt;l;i++) for(int j=0;j&lt;m;j++) d[k++]=a[i]+b[j];//前两个数组两两相加得到新数组 sort(d,d+k);//从小到大排序 int s; cin&gt;&gt;s; cout&lt;&lt;&quot;Case &quot;&lt;&lt;o++&lt;&lt;&quot;:&quot;&lt;&lt;endl;//输出第几个测试实例 while(s--) &#123; long long x; cin&gt;&gt;x; bool sign =false; for(int i=0;i&lt;n;i++)//第三个数组和新数组mid相加判断 &#123; int l=0,r=k-1; while(l&lt;=r) &#123; int mid=(l+r)&gt;&gt;1; if(d[mid]+c[i]==x) &#123; sign=true; break; &#125; else if(d[mid]+c[i]&lt;x) &#123; l=mid+1; &#125; else r=mid-1; &#125; if(sign) break; &#125; if(sign) cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"新生训练","slug":"新生训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"java开发","slug":"java开发","date":"2019-10-31T12:49:00.000Z","updated":"2022-02-26T04:29:57.049Z","comments":true,"path":"2019/10/31/java开发/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/10/31/java%E5%BC%80%E5%8F%91/","excerpt":"","text":"https://blog.csdn.net/sunnyyoona/article/category/9264957","categories":[{"name":"JAVA开发","slug":"JAVA开发","permalink":"https://zouyunkai.github.io/myblog/categories/JAVA%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"java","slug":"java","permalink":"https://zouyunkai.github.io/myblog/tags/java/"}],"author":"aoyuehan"},{"title":"常用技巧的例题","slug":"常用技巧的例题","date":"2019-10-30T12:58:00.000Z","updated":"2022-02-26T04:29:56.649Z","comments":true,"path":"2019/10/30/常用技巧的例题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/10/30/%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E7%9A%84%E4%BE%8B%E9%A2%98/","excerpt":"","text":"https://www.cnblogs.com/acgoto/category/1286070.html","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"aoyuehan"},{"title":"新生训练class2_暴力","slug":"新生训练class2-暴力","date":"2019-10-29T11:53:00.000Z","updated":"2022-02-26T03:52:52.486Z","comments":true,"path":"2019/10/29/新生训练class2-暴力/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/10/29/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83class2-%E6%9A%B4%E5%8A%9B/","excerpt":"","text":"A New Year and Counting Cards题意：每张牌两面分别是字母和数字。定义一个规则：如果一张牌的字母是元音字母那么另一面一定对照着偶数。给你n个牌的一面，问你最少翻多少张牌最终判断这些牌的对照是正确的。解题思路：直接统计有多少个是元音字母或者是奇数。根据以上规则，1.元音字母只能对应偶数。2.偶数可以对应所有字母，而奇数只能对应非元音字母。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include&lt;ctype.h&gt;//isdigit(),isalpha()函数的头文件 using namespace std;bool isyuanyin(char s)&#123; if(s==&#x27;a&#x27;||s==&#x27;e&#x27;||s==&#x27;i&#x27;||s==&#x27;o&#x27;||s==&#x27;u&#x27;)return true; else return false;&#125;int main()&#123; string s; int cnt; int tmp1; char tmp2; while(getline(cin,s))&#123; cnt=0; for(int i=0;i&lt;s.length();i++)&#123; if(isdigit(s[i]))&#123;//判断是否为数字 tmp1=int(s[i]); if(tmp1&amp;1==1)cnt++; //判断是否为奇数 &#125; else if(isalpha(s[i]))&#123;//判断是否为字母 tmp2=s[i]; if(isyuanyin(tmp2))&#123; cnt++; &#125; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; //要清空 s吗,不需要每次都清空s，在getline的时候就会把s清空的 &#125;&#125; 解法二（统计元音和奇数个数）：#include&lt;bits/stdc++.h&gt;using namespace std;string c=&quot;aeiou13579&quot;;int main()&#123; string s; cin&gt;&gt;s; int ans=0; for(int i=0;s[i];i++) for(int j=0;c[j];j++) if(s[i]==c[j]) ans++; cout&lt;&lt;ans; return 0;&#125; B New Year and Buggy Bot 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;iostream&gt;using namespace std;int a[55][55];// 1上 2 下 3 左 4 右int s1,s2,e1,e2;int ans;int n,m;string abc;int main()&#123; mem(a,0); cin&gt;&gt;n&gt;&gt;m; string str; ans=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;str; for(int j=0;j&lt;str.length();j++) &#123; if(str[j]==&#x27;.&#x27;) a[i][j]=1; else if(str[j]==&#x27;#&#x27;) a[i][j]=2; else if(str[j]==&#x27;S&#x27;) &#123; s1=i,s2=j; //a[i][j]=1; &#125; else if(str[j]==&#x27;E&#x27;) &#123; //a[i][j]=1; e1=i;e2=j; &#125; &#125; &#125; //cout&lt;&lt;s1&lt;&lt;&quot; &quot;&lt;&lt;s2&lt;&lt;&quot; &quot;&lt;&lt;e1&lt;&lt;&quot; &quot;&lt;&lt;e2&lt;&lt;endl; cin&gt;&gt;abc; for(int x=1;x&lt;=4;x++) &#123; for(int y=1;y&lt;=4;y++) &#123; for(int z=1;z&lt;=4;z++) &#123; for(int d=1;d&lt;=4;d++) &#123; if(x!=y&amp;&amp;x!=z&amp;&amp;x!=d&amp;&amp;y!=z&amp;&amp;y!=d&amp;&amp;z!=d) &#123; // cout&lt;&lt;x&lt;&lt;y&lt;&lt;z&lt;&lt;d&lt;&lt;endl; int i,j,c; for(i=s1,j=s2,c=0;c&lt;abc.length();c++) &#123; if(abc[c]==&#x27;0&#x27;) &#123; if(x==1)//shang i-=1; else if(x==2)//xia i+=1; else if(x==3)//zuo j-=1; else if(x==4)//you j+=1; &#125; else if(abc[c]==&#x27;1&#x27;) &#123; if(y==1) i-=1; else if(y==2) i+=1; else if(y==3) j-=1; else if(y==4) j+=1; &#125; else if(abc[c]==&#x27;2&#x27;) &#123; if(z==1) i-=1; else if(z==2) i+=1; else if(z==3) j-=1; else if(z==4) j+=1; &#125; else if(abc[c]==&#x27;3&#x27;) &#123; if(d==1) i-=1; else if(d==2) i+=1; else if(d==3) j-=1; else if(d==4) j+=1; &#125; if(a[i][j]==2) break; if(i&lt;0||i&gt;=n||j&lt;0||j&gt;=m) break; if(i==e1&amp;&amp;j==e2) &#123; // cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;z&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl; ans++; break; &#125; &#125; &#125; &#125; &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;/*解法二：#include&lt;bits/stdc++.h&gt;using namespace std;string s[51];int a[6],sx,sy;int main()&#123;//4！=24种 最大24种 24种排列，就是a4 4 //a[0],a[1],a[2],a[3]分别带别上下左右，来全排列找到结果 int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) cin&gt;&gt;s[i]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++) if(s[i][j]==&#x27;S&#x27;)sx=i,sy=j; string c; cin&gt;&gt;c; for(int i=0;i&lt;4;i++) a[i]=i+48;//把a[i]转换为与字符型相对应的a[i] int ans=0; do &#123; int f=0; int tx=sx,ty=sy; for(int i=0;c[i];i++) &#123; if(c[i]==a[0]) tx-=1; else if(c[i]==a[1]) tx+=1; else if(c[i]==a[2]) ty-=1; else ty+=1; if(tx&lt;0||ty&lt;0||tx&gt;=n||ty&gt;=m) break; if(s[tx][ty]==&#x27;#&#x27;)break; if(s[tx][ty]==&#x27;E&#x27;)&#123;f=1;break;&#125; &#125; ans+=f; &#125;while(next_permutation(a,a+4)); cout&lt;&lt;ans; return 0;&#125;*/ C - Water The Garden 题意：给你编号1~n的花园，花园从左到右排成一排。其中有k个花园有水龙头，当水龙头所在的花园浇满后，会流向左右相邻花园，现在同时打开所有水龙头，问你多长时间后n个花园能被浇满。 解法一：思路：这个题目很有意思，只用把握一点就好：所有水龙头同时开启，所有水流同时流动。所以先看边界情况，从编号最小的水龙头到最左端，这一段只有一个方向的水流，最右端也是同理，这两个边界都只有一个方向的水流，而且它们同时流动，所以边界所花时间是两者中较大的：ans&#x3D;max（a[1]-1,n-a[k]）。然后是中间部分，一定是来自两个方向的水流，此时要看间隔的个数x，如果x是奇数，那么时间就是x&#x2F;2+1，偶数就是x&#x2F;2，这个自己想一下就能想明白，而且所有中间间隔的双向水流都是同时流动，所以依然是取最大值即可，而不是累加。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778解法一： #include&lt;bits/stdc++.h&gt; #define ll long long using namespace std; ll a[110],n,k; int main() &#123; ll t; scanf(&quot;%lld&quot;,&amp;t); while(t--) &#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); for(ll i=1;i&lt;=k;i++)scanf(&quot;%lld&quot;,&amp;a[i]); ll ans=max(a[1]-1,n-a[k]); //处理边界的单向水流 for(ll i=2;i&lt;=k;i++) &#123; ll tmp=a[i]-a[i-1]-1; if(tmp&amp;1)tmp=tmp/2+1; else tmp/=2; ans=max(ans,tmp); //更新中间的双向水流 &#125; printf(&quot;%lld\\n&quot;,ans+1); &#125; return 0; &#125;解法二：#include &lt;bits/stdc++.h&gt;using namespace std;bool check(bool flag[], int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; if (flag[i] == false) return true; &#125; return false;&#125;int main() &#123; int cas; cin &gt;&gt; cas; for (int i = 1; i &lt;= cas; i++) &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; int val[k]; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; val[j]; &#125; //1-n bool flag[n+1];//对应1-n for (int j = 1; j &lt;= n; j++) flag[j] = false; for (int j = 0; j &lt; k; j++) &#123; flag[val[j]] = true;//标记已填满 &#125; int cnt = 1; while (check(flag, n)) &#123; //对每次的进行遍历，每次都遍历val数组中的每个元素 int change[n]; int count = 0; for (int j = 1; j &lt;= n; j++) &#123; if (flag[j] == true) &#123; int left = j-1;// int right = j+1; if (left &gt;= 1 &amp;&amp; flag[left] == false) &#123; // flag[left] = true; change[count++] = left; &#125; if (right &lt;= n &amp;&amp; flag[right] == false) &#123; // flag[right] = true; change[count++] = right; &#125; &#125; &#125; for (int j = 0; j &lt; count; j++) flag[change[j]] = true; cnt++; &#125; cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125; D - Tea Queue题意： 已知n个人来接水，每秒可以接一个人的水，给出每个人的到达接水地点的时间，和走的时间，如果同一时间来的，先来的可以接到水，如果可以接到水，记录下这个人的接水时间，如果接不到，记录为0 分析： 我们可以枚举时间轴，当当前时间大于这个人走的时间，则这人的最后记录为0，否则记录答案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;bool vis[maxn];int l[maxn];int r[maxn];int res[maxn];int main()&#123; int T;cin&gt;&gt;T; while(T--) &#123; memset(vis,0,sizeof vis); int n;cin&gt;&gt;n; for(int i = 0;i &lt; n;i++) cin&gt;&gt;l[i]&gt;&gt;r[i]; for(int i = 1;i &lt;= 5100;i++) &#123; bool flg = false; for(int j = 0;j &lt; n;j++) &#123; if(!vis[j]) &#123; flg = true;break; &#125; &#125; if(!flg) break; for(int j = 0;j &lt; n;j++) &#123; if(vis[j]) continue; if(i &gt; r[j]) &#123; vis[j] = true; res[j] = 0; &#125; if(l[j] &lt;= i &amp;&amp; r[j] &gt;= i) &#123; vis[j] = true; res[j] = i; break; &#125; &#125; &#125; for(int i = 0;i &lt; n;i++) &#123; printf(&quot;%d &quot;,res[i]); &#125;cout&lt;&lt;endl; &#125; return 0;&#125; E-A Compatible Pair就是两个数组，其中前一个数组中去掉一个最大之后，与后一个数组相乘，求这个相乘的最大值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define IO ios::sync_with_stdio(false);cin.tie(0);#define INF 1e18typedef long long ll;using namespace std;ll n, m, a[110], b[110];ll maxm;int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a[i]; &#125; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; b[i]; &#125; sort(a,a+n); sort(b,b+m); maxm=max(a[n-2]*b[m-1],a[1]*b[0]); //为什么最大值不是排序完了之后这两个的值呐，因为最大值有可能如下面那种解法 cout &lt;&lt; maxm &lt;&lt; endl; &#125; return 0;&#125;/*解法一： #include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst ll INF_LL = 9223372036854775807LL;ll a[maxn];ll b[maxn];int main()&#123; ios_base::sync_with_stdio(0); int n,m;cin&gt;&gt;n&gt;&gt;m; for(int i = 0;i &lt; n;i++) cin&gt;&gt;a[i]; for(int i = 0;i &lt; m;i++) cin&gt;&gt;b[i]; sort(a,a+n); sort(b,b+m); ll a1 = a[0],a2 = a[1],a3 = a[n - 2],a4 = a[n - 1]; ll b1 = b[0],b2 = b[1],b3 = b[m - 2],b4 = b[m - 1]; ll res = -INF_LL; if(n &gt; 2) &#123; res = max(res,a2*b1); res = max(res,a2*b4); res = max(res,a3*b1); res = max(res,a3*b4); res = max(res,min(a[n - 1]*b[m - 1],a[0]*b[0])); //就有可能少了这种情况，所以只比较那两种结果会漏掉 res = max(res,min(a[n - 1]*b[0],a[0]*b[m - 1])); &#125; else &#123; res = max(res,a2*b1); res = max(res,a3*b4); &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125;*/ /*解法二： #include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define IO ios::sync_with_stdio(false);cin.tie(0);#define INF 1e18typedef long long ll;using namespace std;ll n, m, a[110], b[110];int main()&#123; while(cin &gt;&gt; n &gt;&gt; m)&#123; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; a[i]; &#125; for(int i = 0; i &lt; m; i++)&#123; cin &gt;&gt; b[i]; &#125; ll maxm = -INF, loc; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(a[i]*b[j] &gt; maxm)&#123; maxm = a[i]*b[j]; loc=i;//记录最大值的下标，然后再一次遍历求最大值 &#125; &#125; &#125; maxm=-INF;//这样写代表maxn为负无穷小，这样就不会在比较时把更小的数给漏掉了 for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; if(i == loc) continue; if(a[i]*b[j] &gt;maxm)&#123; maxm = a[i]*b[j]; &#125; &#125; &#125; cout &lt;&lt; maxm &lt;&lt; endl; &#125; return 0;&#125;*//*解法三： #include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int main()&#123; int n,m;LL a[55],b[55],c[55]; cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;++i)cin&gt;&gt;a[i]; for(int i=0;i&lt;m;++i)cin&gt;&gt;b[i]; for(int i=0;i&lt;n;++i)&#123; c[i]=a[i]*b[0]; for(int j=1;j&lt;m;++j) c[i]=max(c[i],a[i]*b[j]); //其实这个把那个c[i]的值存放 b[0]到b[m-1],b这一整个数组的最大值 // ？？？？那有可能第二大的值是从a[i]*b[j] 里面运算的时候出现了呐 //,不会的因为a[i]取得的最大值要把此时的a[i]去掉,所以才会有 最大值，第二大，，，，第n*m-n大的值只能从c[]中取得 &#125; sort(c,c+n);cout&lt;&lt;c[n-2]&lt;&lt;endl; return 0;&#125;*/ F-A Prosperous Lot题意： 0 4 6 9有一个环，8有两个环，其他没有环。求出一个数字，上面数位的环和答案为给定的x。如果这个数字超过1e18，输出-1.思路： 很明显，贪8就可以了。到了37，就超过1e18了。 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n;scanf(&quot;%d&quot;,&amp;n); if(n &gt; 36)printf(&quot;-1\\n&quot;); else if(n % 2 == 0) &#123; for(int i = 1;i &lt;= n / 2;i++) printf(&quot;%d&quot;,8); &#125; else &#123; printf(&quot;4&quot;); for(int i = 1;i &lt;= n / 2;i++) printf(&quot;%d&quot;,8); &#125; return 0;&#125; G Subsequence给定长度n的数列整数，以及整数s，求出总和不小于S的连续子序列的长度的最小值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647解法一（不利用尺取法，利用lower_bound（）： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include&lt;cstdio&gt; using namespace std; int n,ss; int a[100005],s[100005]; int main()&#123; int t; cin&gt;&gt;t; while(t--)&#123; memset(a,0,sizeof(a)); memset(s,0,sizeof(s)); int kk=100005; cin&gt;&gt;n&gt;&gt;ss; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a[i]; s[i]=s[i-1]+a[i]; &#125; if(s[n]&lt;ss) cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; else&#123; for(int i=1;s[i]+ss&lt;=s[n];i++)&#123; int k=lower_bound(s+i,s+n+1,s[i]+ss)-s; kk=min(kk,k-i); &#125; cout&lt;&lt;kk&lt;&lt;endl; &#125; &#125; return 0; &#125; 其中lower_bound该函数的用法： 在从小到大的排序数组中，lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。在从大到小的排序数组中，重载lower_bound()和upper_bound()lower_bound( begin,end,num,greater&lt;type&gt;() ):从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。upper_bound( begin,end,num,greater&lt;type&gt;() ):从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 解法二：因为枚举满足条件的区间，要枚举起点和终点，所以时间复杂度是o(n^3)，所以考虑只枚举起点或者终点,即要去掉最后一个循环，所以：我们试试只枚举终点。对于终点j，我们的目标是要找到一个让Bj-Bi-1≥S，且i尽量大（i越大，序列长度j-i+1就越小）的i值，也就是找一个让Bi-1≤Bj-S最大的i。考虑图1-29所示的序列。（前缀和技巧，数组B就是存储前几项的和） 当j&#x3D;5时，B5&#x3D;12，因此目标是找一个Bi-1≤12-7&#x3D;5的最大i。注意到B是递增的（别忘了，本题中所有Ai均为整数），所以可以用二分查找。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std; #define N 100001 int A[N];int B[N]; //二分查找最接近target但不大于targetint BinarySerach(int target,int R)&#123; int L = 0; int mid = 0; while(L &lt; R)&#123; mid = L + (R - L) / 2; if(B[mid] &gt; target)&#123; R = mid; &#125; else&#123; L = mid + 1; &#125; &#125; return L;&#125; int main()&#123; int n,s,i,j; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;s) != EOF)&#123; int minLen = n+1; B[0] = 0; for(i = 1;i &lt;= n;i++)&#123; scanf(&quot;%d&quot;,&amp;A[i]); //序列前缀和 B[i] = B[i-1] + A[i]; &#125; for(j = 1;j &lt;= n;j++)&#123; int target = B[j] - s; //二分查找 int index = BinarySerach(target,j-1); if(index &gt; 0)&#123; minLen = min(minLen,j-index+1); &#125; &#125; //没有满足条件的序列 if(minLen == n+1)&#123; minLen = 0; &#125; cout&lt;&lt;minLen&lt;&lt;endl; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667解法三（尺取法求前多少项的和，就是l和r两个指针，找到一个符合条件的区间，l++，子区间和减左边的第一个元素，然后在向后比较，这样把整个区间都走一遍，就能得到最重的结果。）：#include&lt;iostream&gt;using namespace std;#define min(a,b) a&gt;b?b:a;#define MAXN 100010#define INF 0xfffffffint a[MAXN];int main()&#123; int n,N,S,l,r,len; long long sum = 0; cin &gt;&gt;n; while(n--)&#123; cin&gt;&gt;N&gt;&gt;S; for(int i=0;i&lt;N;i++)&#123; cin&gt;&gt;a[i]; &#125; l = r = 0;//初始化 sum = 0; len = INF; while(1)&#123; while(r&lt;N &amp;&amp; sum&lt;S)&#123; sum+=a[r]; r++; &#125;//此时的sum是区间[l,r)上的和 if(sum&lt;S)&#123;//如果说 sum&lt;S但是r&gt;=N了 结束循环 break; &#125; len = min(len,r-l);//更新长度 取较小的 sum -= a[l];//看看减去左边一个元素 还满不满足sum&gt;=S l++; //l右移一个 &#125; if(len == INF)&#123;//如果说len没有变化 说明所有的数加起来&lt;S cout&lt;&lt;&quot;0&quot;&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;len&lt;&lt;endl; &#125; &#125; return 0;&#125;变式：最大子列和问题给定N个整数的序列 a1,a2,,,,,, an 求 求做大子列和，如果子列和为负数，那么结果为0 #include&lt;iostream&gt; using namespace std; int a[100100]; int main() &#123; int maxsum,sum,N; maxsum = sum = 0; cin&gt;&gt;N; for(int i=0;i&lt;N;i++)&#123; cin&gt;&gt;a[i]; &#125;//先读入数据 for(int i=0;i&lt;N;i++)&#123; sum += a[i]; if(sum &gt; maxsum)&#123; maxsum = sum; &#125; else if(sum &lt;0 )&#123; sum = 0; &#125; &#125; cout&lt;&lt;maxsum&lt;&lt;endl; return 0; &#125; 本题的变题：编程之美求子数组最大值：https://blog.csdn.net/sunnyyoona/article/details/26288943 CodeForces - 908C New Year and Curling（圆与圆之间的关系的问题）题意： 已知一些圆在(xi,10100)处，然后依次落下，下落时只要碰到某个圆，就会停止，求这些圆的最后的y值，也即是水平高度分析： 首先看了下n的范围很小，可以到O(n2)的复杂度，直接暴力枚举，可以画图分析下，见下图 可以看到高度h &#x3D; y1 + sqrt(2r*2r - (x2-x1)(x2-x1));枚举个最高的高度即可，因为 一旦碰到就不会落下了 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int h[1500];double res[1500];int abs(int x,int y) &#123;if(x - y &gt; 0) return x - y;return y - x;&#125;int main()&#123; ios_base::sync_with_stdio(0); int n; double r; cin&gt;&gt;n&gt;&gt;r; for(int i = 0;i &lt; n;i++) &#123; cin&gt;&gt;h[i]; double rs = r; for(int j = 0;j &lt; i;j++) &#123; int dx = abs(h[i],h[j]); if(dx &lt;= 2*r) &#123; rs = max(rs,res[j] + sqrt(4*r*r - dx*dx)); &#125; &#125; res[i] = rs; &#125; for(int i = 0;i &lt; n;i++) printf(&quot;%.10f &quot;,res[i]); return 0;&#125; H-Jessica’s Reading Problem题目大意： XXX要准备考试，书总共有P页，第i页恰好有一个知识点ai，书中的同一个知识点可能会被多次提到，所以他希望看其中连续的一些页的书来把所有的知识点都给看完。。 题目分析： 其实页数可以看作连续的序列，然后就是要求出一个子序列，子序列的要求的包涵所有知识点都有的页数，且子序列的长度要最短。 首先我们并不知道总共有多少个知识点，这是个先要记录的。 不断的把序列中的元素加入到子序列中，知识点的数目会不断的增加，当知识点是数目满了之后，把子序列前面的元素开始剔除，再看看现在的子序列还是否满足这个条件。满足继续删除子序列前面的元素，否则的话把后面的元素加入到子序列中，然后按上述步骤继续执行。 注意中间过程知识点数的增加或减少的维护。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647尺取法求前多少项出现的次数（与前面那种求前多少项的和区别开来）：#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;const int N=100000+999;int n,m;int num[N];//尺取法int main()&#123; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; memset(num,0,sizeof(num)); set&lt;int&gt; all; //利用集合元素的单一性 map&lt;int,int&gt; cot; for(int i=0; i&lt;n; i++) &#123; scanf(&quot;%d&quot;,&amp;num[i]); all.insert(num[i]); &#125; int res=n; m=all.size(); //算出种类 int s=0,e=0,sum=0; while(1) &#123; while(e&lt;n &amp;&amp; sum&lt;m) &#123; if(cot[ num[e++] ]++ == 0) //如果这个种类未出现 则sum++ sum++; &#125; if(sum&lt;m) break;//这一句是为了让最后e=n之后，能跳出外层的while循环。 res=min(res,e-s); if(--cot[ num[s++] ] == 0) //如果这个种类-1后为0 则sum-1 sum--; &#125; printf(&quot;%d\\n&quot;,res); &#125; return 0;&#125; I Graveyard Design求一组连续整数的平方和的问题，可以用尺取法模拟一个符合要去的区间的左边和右边，找到符合要求的区间就记录下来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define LL __int64/*一般来说，64位整型的定义方式有long long和__int64两种(VC还支持_int64)，而输出到标准输出方式有printf(“%lld”,a)，printf(“%I64d”,a)，和cout &lt;&lt; a三种方式。*/int num[2000],left[2000],right[2000]; //对于数组，若下标大于1e7，就应该放到数组外面声明才可以void solve(LL n)&#123; int i,j; LL m=(LL)sqrt(n*1.0);//因为sqrt只能对double类型运算 LL sum=0,l=1,r=0; int cnt=0; while(1) &#123; while(sum&lt;n) &#123; r++; sum+=r*r; &#125; if(r&gt;m) break; //这一步是为了让当r&gt;m的时候，已经不会有连续整数的平方和大于m了， //所以要跳出外层的while循环 if(sum==n) &#123; num[cnt]=r-l+1; left[cnt]=l; right[cnt]=r; cnt++; &#125; sum-=(l*l); l++; &#125; printf(&quot;%d\\n&quot;,cnt); for(i=0;i&lt;cnt;++i) &#123; printf(&quot;%d &quot;,num[i]); for(j=left[i];j&lt;right[i];++j) printf(&quot;%d &quot;,j); printf(&quot;%d\\n&quot;,right[i]); &#125;&#125; int main()&#123; LL n; while(scanf(&quot;%I64d&quot;,&amp;n)!=EOF) solve(n); return 0; &#125; J-骗分导论–ODT珂朵莉树 讲义： 1.区间求和： 前缀和，o(1)时间内求出前n项的和，或者某个区间的和（两个区间头减尾）前缀和前缀和S[i]&#x3D;A[1]+A[2]+……+A[i];可以用A[i]&#x3D;S[i]-S[i-1]来还原;还有二维的前缀和S[i][j] &#x3D; S[i-1][j] + S[i][j-1] - S[i-1][j-1] + A[i][j];这个公式可以用容斥原理推得。 2.区间修改： 单点查询（差分法） 差分就是将数列中的每一项分别与前一项数做差，例如： 一个序列 1 2 5, 4 7 3， 差分后得到1 1 3, -1 3 -4, -3 上面整个序列+2后: 3 4 7, 6 9 5 3 1 3, -1 3 -4, -5 &#x2F;&#x2F; 只有整个区间的首和尾不同，其他的差分相同 ，即将首+2,(尾+1)的位置-2 这里注意得到的差分序列第一个数和原来的第一个数一样（相当于第一个数减0） 差分序列最后比原序列多一个数（相当于0减最后一个数） 性质： 1、差分序列求前缀和可得原序列 2、将原序列区间[L,R]中的元素全部+x，可以转化操作为差分序列L处+x，R+1处-x 3、按照性质2得到，每次修改原序列一个区间+x，那么每次差分序列修改相应的位置 增加的和减少的相同 tips：前缀和与差分是一对逆运算。差分操作有助于把原序列上的“区间操作” 转化为差分序列上的“单点操作”，在树上有着独特的应用。 尺取法： 头尾双指针 123456789 形式为： while(1)&#123; while(表达式1)&#123; if(条件1)语句1 &#125; if(条件2)&#123;break;&#125; 语句2 if(条件3)语句3 &#125; 其中：表达式1为边界判断条件，目的是让在语句1中移动左指针，直到移动到符合要求的那个地方；条件2是边界判断（如：个数超过要求的总个数，sum超过要求的总和，其实就是左指针从头跑到尾了，可以结束外层while了;语句2可以执行一些操作，如对结果的处理，如res&#x3D;min(res,e-s);条件3为边界判断，是左指针右移后对结果的处理， 如： if(–cot[ num[s++] ] &#x3D;&#x3D; 0) &#x2F;&#x2F;如果这个种类-1后为0 则sum-1 sum–; &#x2F;&#x2F;这样的话，就是集合中少了那一种元素，对结果产生了影响， 就应该对结果进行相应的处理； 其中语句2和语句3试情况而定，可调换顺序或者没有该语句； 4.要想区间求和并且实现单点查询 分为根下n块，每一块就有根下n个数 5 4 1, 8 10 1, 8 7 6, 5 4 &#x3D;&gt; 求区间第三个到第十个的和 10 19 21 9 &#x3D;&gt;那么结果就是1+19+21+5 5 4 6, 8 10 1, 8 7 6,10 4 重新分块后： 5 4 6, 8 1 2, 3 4 10, 1 8 7, 6 10 4 &#x3D;&gt;若果在第四个位置插入4个数，那么可以用再分块(当插入的数大于 根下12为3，所以先3个一组，)的方法来维系块的性质 [省选题]（https://www.luogu.org/problem/P4799） 100 1500, 500 500 1000 &#x3D;&gt;分为两块进行搜索，在第一个块中进行搜索，在第二个快中进行搜索，再拼凑起来，对结果是没有影响的 折半搜索，分治 参考blog:https://www.cnblogs.com/ZAGER/p/9827160.html 123456789101112131415161718192021222324252627282930313233其中：1-4组数据N≤20，爆搜就可以解决。 inline void dfs(R ll dep,R ll sum)&#123; if(sum&gt;m)return;//只要sum大于总的m就可以结束本次递归 if(dep==n+1)&#123;//只要满足搜索到的深度到了n+1了，就可以退回上一步了 ans++;//ans初始化为0 return; &#125; dfs(dep+1,sum+a[dep]);// 买这一次的票 dfs(dep+1,sum);//不买这一次票 &#125; int main()&#123; read(n);read(m); for(R int i=1;i&lt;=n;i++)read(a[i]); if(n&lt;=20)&#123; dfs(1,0); //从深度为1，到n+1， 一共有n次 printf(&quot;%lld\\n&quot;,ans); &#125; return 0; &#125; 5-7组数据M≤106，裸的背包啊。 int main()&#123; read(n);read(m); for(R int i=1;i&lt;=n;i++)read(a[i]); if(m&lt;=1e6)&#123; f[0]=1; for(R int i=1;i&lt;=n;i++) for(R int j=m;j&gt;=a[i];j--) f[j]+=f[j-a[i]]; //这一句到底是什么意思 for(R int i=0;i&lt;=m;i++)ans+=f[i]; printf(&quot;%lld\\n&quot;,ans); &#125; return 0; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;#define ll long long#define R register#define N 55using namespace std;template&lt;typename T&gt;inline void read(T &amp;a)&#123; char c=getchar();T x=0,f=1; while(!isdigit(c))&#123;if(c==&#x27;-&#x27;)f=-1;c=getchar();&#125; while(isdigit(c))&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#x27;0&#x27;;c=getchar();&#125; a=f*x;&#125;ll n,m,w[N],mid,suma[1&lt;&lt;21],sumb[1&lt;&lt;21],cnta,cntb,ans;inline void dfs(R int l,R int r,R ll sum,R ll a[],R ll &amp;cnt)&#123; if(sum&gt;m)return; if(l&gt;r)&#123; a[++cnt]=sum; return; &#125; dfs(l+1,r,sum+w[l],a,cnt); dfs(l+1,r,sum,a,cnt);&#125;int main()&#123; read(n);read(m); for(R int i=1;i&lt;=n;i++)read(w[i]); mid=n&gt;&gt;1; dfs(1,mid,0,suma,cnta); dfs(mid+1,n,0,sumb,cntb); sort(suma+1,suma+1+cnta); for(R int i=1;i&lt;=cntb;i++) ans+=upper_bound(suma+1,suma+1+cnta,m-sumb[i])-suma-1; printf(&quot;%lld\\n&quot;,ans); return 0;&#125;tips:在从小到大的排序数组中:lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。 7.P2572 [SCOI2010]序列操作 区间染色问题，老司机树(Chtholly Tree (珂朵莉树) ODT)模板；思想和分块差不多，减少无效的访问次数 [codeforces 896C Willem, Chtholly and Seniorious] 暴力可以加上点技巧（技巧性的暴力）：如分块，前缀和，差分","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"新生训练","slug":"新生训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"新生训练class 1- 熟悉oj的使用方法&&贪心 ","slug":"新生训练class-1-熟悉oj的使用方法-贪心","date":"2019-10-23T11:15:00.000Z","updated":"2022-02-26T03:52:52.017Z","comments":true,"path":"2019/10/23/新生训练class-1-熟悉oj的使用方法-贪心/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/10/23/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83class-1-%E7%86%9F%E6%82%89oj%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E8%B4%AA%E5%BF%83/","excerpt":"","text":"Calculate a+b 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; int a,b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a+b &lt;&lt; endl; return 0;&#125; B ASCII码排序（输入三个字符后，按各字符的ASCII码从小到大的顺序输出这三个字符。 ） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;algorithm&gt; //sort函数 时间复杂度为 n*log2n using namespace std;const int maxn=3;struct ascii&#123; char zi;// ascii(char a,char b,char c):a(a),b(b),c(c)&#123;&#125; 如果有多个数的话，可以用构造函数来赋值 &#125;asc[maxn];bool cmp(ascii x, ascii y)&#123; return (int )x.zi&lt;(int)y.zi;&#125; int main()&#123; //方法一： char a,b,c; char tmp; //这种方法三个if，各个if之间可以相互调换顺序 //比较的逻辑是a&gt;b,a&gt;c,b&gt;c;这样就实现了大的往后排 while((cin&gt;&gt;a&gt;&gt;b&gt;&gt;c))&#123; if((int)a&gt;(int)b)&#123; tmp=a; a=b; b=tmp; &#125; if((int)a&gt;(int)c)&#123; tmp=a; a=c; c=tmp; &#125; if((int )b&gt;(int )c)&#123; tmp=b; b=c; c=tmp; &#125; cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl; //cout&lt;&lt;&quot;\\n&quot;;这样要比cout&lt;&lt;endl;要快 &#125; //方法二：sort(a,a+3);这样写可以对一个char类型的char数组按ascii码进行排序 //方法三，利用结构体排序： while(cin&gt;&gt;asc[0].zi&gt;&gt;asc[1].zi&gt;&gt;asc[2].zi)&#123; sort(asc,asc+3,cmp); for(int i=0;i&lt;3;i++)&#123; if(i==2)cout&lt;&lt;asc[i].zi&lt;&lt;endl; else cout&lt;&lt;asc[i].zi&lt;&lt;&quot; &quot;; &#125; &#125; &#125; C 计算两点间的距离 （输入两点坐标（X1,Y1）,（X2,Y2）,计算并输出两点间的距离。 ） 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;math.h&gt;#include &lt;iomanip&gt; using namespace std;//c语言版 //编写时scanf写为scanf(&quot;%lf,%lf,%lf,%lf&quot;,x1,x2,y1,y2); ,一直出错 //int main()&#123;// float x1,x2,y1,y2;// while(~scanf(&quot;%f%f%f%f&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2))&#123;// printf(&quot;%.2f\\n&quot;,sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)));// &#125;//&#125; //c++版本int main()&#123; //切断cin和cout的联系，加快速度 std::ios::sync_with_stdio(false); std::cin.tie(0); double x1,x2,y1,y2; while(cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2)&#123; cout&lt;&lt;setprecision(2)&lt;&lt;fixed&lt;&lt;sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))&lt;&lt;endl; &#125;&#125; D - 计算球体积（根据输入的半径值，计算球的体积。 ） 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;math.h&gt;#include &lt;iomanip&gt; using namespace std;#define PI 3.1415927int main()&#123; //切断cin和cout的联系，加快速度 std::ios::sync_with_stdio(false); std::cin.tie(0); double r; while(cin&gt;&gt;r)&#123; cout&lt;&lt;setprecision(3)&lt;&lt;fixed&lt;&lt;4*PI*pow(r,3)/3&lt;&lt;endl;// cout&lt;&lt;setprecision(3)&lt;&lt;fixed&lt;&lt;(4/3)*PI*pow(r,3)&lt;&lt;endl;//上面这样的结果是不对的，应该乘完了之后在去除 // cout&lt;&lt;setprecision(3)&lt;&lt;fixed&lt;&lt;4*PI*r*r*r/3&lt;&lt;endl; &#125;&#125; E - 求绝对值(求实数的绝对值。 ) 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;math.h&gt;#include &lt;iomanip&gt; using namespace std;int main()&#123; //切断cin和cout的联系，加快速度 std::ios::sync_with_stdio(false); std::cin.tie(0); double r; while(cin&gt;&gt;r)&#123; if(r&lt;0)&#123; //cout&lt;&lt;setprecision(2)&lt;&lt;fixed&lt;&lt;r*(-1)&lt;&lt;endl; 这两种方法都可以 cout&lt;&lt;setprecision(2)&lt;&lt;fixed&lt;&lt;-r&lt;&lt;endl; &#125; else&#123; cout&lt;&lt;setprecision(2)&lt;&lt;fixed&lt;&lt;r&lt;&lt;endl; &#125; &#125;&#125; -F - 成绩转换 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;math.h&gt;#include &lt;iomanip&gt; using namespace std;#define PI 3.1415927int main()&#123; //切断cin和cout的联系，加快速度 std::ios::sync_with_stdio(false); std::cin.tie(0); int n; while(cin&gt;&gt;n)&#123; if(90&lt;=n&amp;&amp;n&lt;=100 )cout&lt;&lt;&quot;A&quot;&lt;&lt;endl; else if(80&lt;=n&amp;&amp;n&lt;=89)cout&lt;&lt;&quot;B&quot;&lt;&lt;endl; else if(70&lt;=n&amp;&amp;n&lt;=79)cout&lt;&lt;&quot;C&quot;&lt;&lt;endl; else if(60&lt;=n&amp;&amp;n&lt;=69)cout&lt;&lt;&quot;D&quot;&lt;&lt;endl; else if(0&lt;=n&amp;&amp;n&lt;=59)cout&lt;&lt;&quot;E&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Score is error!&quot;&lt;&lt;endl; &#125;&#125; G - 第几天？(给定一个日期，输出这个日期是该年的第几天。 ) 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;bool isLeapYear(int y) &#123; return (y % 4 == 0 &amp;&amp; y % 100 != 0) || (y % 400 == 0);&#125;int main()&#123; int m,d,y,tianshu; int rn[13]=&#123;0,31,29,31,30,31,30,31,31,30,31,30,31&#125;; int pn[13]=&#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;; //格式化输入，%d/%d/%d这样才可以 while(~scanf(&quot;%d/%d/%d&quot;,&amp;y,&amp;m,&amp;d))&#123; //~scanf(&quot;%d%c%d%c%d&quot;,&amp;y,&amp;ch,&amp;m,&amp;ch,&amp;d)这种方法也是可以的 tianshu=0; //在这地方一定要重新初始化，不然tianshu会加上上一次运算的值 if(isLeapYear(y))&#123; for(int i=1;i&lt;m;i++)&#123; //从1月加到第m-1个月 tianshu +=rn[i]; &#125; tianshu+=d; &#125; else&#123; for(int j=1;j&lt;m;j++)&#123; tianshu +=pn[j]; &#125; tianshu+=d; &#125; cout&lt;&lt;tianshu&lt;&lt;endl; &#125;&#125; H - 平方和与立方和（给定一段连续的整数，求出他们中所有偶数的平方和以及所有奇数的立方和。 ） 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int main()&#123; int m,n,jishu,oshu; while((cin&gt;&gt;m&gt;&gt;n))&#123; jishu=0;oshu=0; if(n&lt;m)&#123; //可以用swap(n,m)来交换n和m的值 for(int i=n;i&lt;=m;i++) if(i&amp;1==1)&#123;//是奇数 jishu+=i*i*i; &#125;else&#123; oshu+=i*i; &#125; &#125;else&#123; for(int i=m;i&lt;=n;i++) if(i&amp;1==1)&#123;//是奇数 jishu+=i*i*i; &#125;else&#123; oshu+=i*i; &#125; &#125; cout&lt;&lt;oshu&lt;&lt;&quot; &quot;&lt;&lt;jishu&lt;&lt;endl; &#125; &#125; I - 数值统计(统计给定的n个数中，负数、零和正数的个数。 ) 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int n;double shu[101];int ling,zhengshu,fushu;int main()&#123; //输入n并且！0时的语句为下面的这条语句 while(cin&gt;&gt;n,n!=0)&#123; ling=zhengshu=fushu=0; for(int i=0;i&lt;n;i++)cin&gt;&gt;shu[i]; for(int i=0;i&lt;n;i++)&#123; if(shu[i]&gt;0)zhengshu++; else if(shu[i]&lt;0)fushu++; else ling++; &#125; cout&lt;&lt;fushu&lt;&lt;&quot; &quot;&lt;&lt;ling&lt;&lt;&quot; &quot;&lt;&lt;zhengshu&lt;&lt;endl; &#125; &#125; J - 求数列的和(数列的第一项为n，以后各项为前一项的平方根，求数列的前m项的和。 ) 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;math.h&gt;#include &lt;iomanip&gt; using namespace std;int main()&#123; int n,m; double sum=0,tmp; while(cin&gt;&gt;n&gt;&gt;m)&#123; sum=0; if(m==1)&#123; cout&lt;&lt;setprecision(2)&lt;&lt;fixed&lt;&lt;n&lt;&lt;endl; &#125;else&#123; sum+=n; tmp=n; for(int i=1;i&lt;m;i++)&#123;//m-1项 sum+=sqrt(tmp); tmp=sqrt(tmp); &#125; cout&lt;&lt;setprecision(2)&lt;&lt;fixed&lt;&lt;sum&lt;&lt;endl; &#125; &#125;&#125; K - 水仙花数 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int shiwei(int shu)&#123; return ((shu/10)%10); &#125;int baiwei(int shu)&#123; return ((shu/100)%10);&#125;int main()&#123; int xia; int m,n; int a[1000]; int flag; while(cin&gt;&gt;m&gt;&gt;n)&#123; memset(a,0,sizeof(a)); xia=0; flag=0;//这地方以为内下一次循环要用到这些变量， //所以要对一些变量初始化才可以不会出错 for(int i=m;i&lt;=n;i++)&#123; if(i==((i%10)*(i%10)*(i%10)+shiwei(i)*shiwei(i)*shiwei(i)+baiwei(i)*baiwei(i)*baiwei(i))) &#123; flag=1; xia++; a[xia]=i; &#125; &#125; if(flag==0)&#123; cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; &#125;else&#123; for(int i=1;i&lt;=xia;i++)&#123; if(i==xia)cout&lt;&lt;a[i]&lt;&lt;endl; else&#123; cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; &#125; &#125; &#125;&#125; L - 多项式求和 (1 - 1&#x2F;2 + 1&#x2F;3 - 1&#x2F;4 + 1&#x2F;5 - 1&#x2F;6 + …现在请你求出该多项式的前n项的和。 ) 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;math.h&gt;#include &lt;iomanip&gt; using namespace std;double duo(int n)&#123; double sum=0.00; for(int i=1;i&lt;=n;i++)&#123; if(i%2==1)sum=sum+1.0/i; else sum=sum-1.0/i; &#125; return sum;&#125;int main()&#123; int m; int a[110];//不能在cin&gt;&gt;m之后写a[m] cin&gt;&gt;m; for(int i=0;i&lt;m;i++)cin&gt;&gt;a[i]; for(int i=0;i&lt;m;i++)&#123; printf(&quot;%.2lf\\n&quot;,duo(a[i]) ); &#125; &#125; M - 素数判定(对于表达式n^2+n+41，当n在（x,y）范围内取整数值时（包括x,y）(-39&lt;&#x3D;x&lt;y&lt;&#x3D;50)，判定该表达式的值是否都为素数。 ) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;iostream&gt;#include&lt;string.h&gt; using namespace std;const int maxn=20000;int prime[maxn];bool isPrime[maxn];bool noPrime[maxn];//2591//1523int eulerSieve_1(int n)&#123; int num=0; memset(isPrime,true,sizeof(isPrime)); isPrime[0]=isPrime[1]=false; for(int i=2;i&lt;=n;i++)&#123; //这个从prime的0下标开始存素数 if(isPrime[i])prime[num++]=i; //第一次执行num++，prime[0]存入i，之后num为1，那么下面这个for中num为1 for(int j=0;j&lt;num&amp;&amp;i*prime[j]&lt;=n;j++)&#123; //这个从j开始到num，遍历一遍prime数组，所以遍历的次数为数组个数 isPrime[i*prime[j]]=false; if(i%prime[j]==0)break; &#125; &#125; return num;&#125;int sieve(int n)&#123; int num=0; memset(isPrime,true,sizeof(isPrime)); isPrime[0]=isPrime[1]=false; for(int i=2;i&lt;=n;i++)&#123; if(isPrime[i])&#123; prime[num++]=i; for(int j=2;j*i&lt;=n;j++)&#123; isPrime[j*i]=false; &#125; &#125; &#125; return num;&#125;int eulerSieve_3(int n)&#123; int num=0; memset(prime,0,sizeof(prime)); memset(noPrime,false,sizeof(noPrime)); noPrime[0]=noPrime[1]=true; for(int i=2;i&lt;=n;++i)&#123; if(noPrime[i]==false)prime[++num]=i; //从1开始存素数 for(int j=1;j&lt;=num&amp;&amp;i*prime[j]&lt;=n;++j)&#123; noPrime[i*prime[j]]=true; if(i%prime[j] ==0)break; &#125; &#125; return num;&#125;int main()&#123; int x,y,flag=0; int tmp; sieve(20000); //for(int i=0;i&lt;100;i++) cout&lt;&lt;prime[i]&lt;&lt;&quot; &quot;; while(cin&gt;&gt;x&gt;&gt;y)&#123; if(x==0&amp;&amp;y==0)break; flag=0; for(int i=x;i&lt;=y;i++)&#123; tmp=i*i+i+41; if(noPrime[tmp]==true)&#123; //但是这一句写为了isPrime[tmp]==false就会出现错误，不知道为什么 flag=1; break; &#125; &#125; if(flag==0)cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Sorry&quot;&lt;&lt;endl; &#125;&#125; N - 蟠桃记 (第一天悟空吃掉桃子总数一半多一个，第二天又将剩下的桃子吃掉一半多一个，以后每天吃掉前一天剩下的一半多一个，到第n天准备吃的时候只剩下一个桃子。聪明的你，请帮悟空算一下，他第一天开始吃的时候桃子一共有多少个呢？ ) 123456789101112131415#include&lt;iostream&gt;using namespace std;int digui(int n)&#123; if(n==1)return 1; else return 2*(digui(n-1)+1);&#125;int main()&#123;//一定要把main写对了，写成mian就会出现id已存在的错误 int n; while(cin&gt;&gt;n)&#123; cout&lt;&lt;digui(n)&lt;&lt;endl; &#125;&#125; O - 青年歌手大奖赛_评委会打分 1234567891011121314151617#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=110;int main()&#123; int n; double sum; int a[maxn]; while(cin&gt;&gt;n)&#123; sum=0; for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i]; sort(a,a+n); for(int i=1;i&lt;n-1;i++)sum+=a[i]; printf(&quot;%.2lf\\n&quot;,sum/(n-2)); &#125;&#125; P-Best Cow Line (字典序问题）可以用cin.getline();但是时间慢， 也可以用 scanf(“%s”, tmp);s[i] &#x3D; tmp[0]; 参考了网上的思路发现，还可以用scanf(“ %c”, &amp;ch)； 在格式串中，空格的意思是匹配输入中的所有换行、TAB、空格，所以加上一个空格，就可以屏蔽掉在输入中的所有的不愉快的因素了。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;char s[2002];int main()&#123;int n; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; for(int i=0;i&lt;n;i++)&#123; scanf(&quot; %c&quot;,&amp;s[i]); //前面的空格用来匹配空白符号 &#125; int a=0,b=n-1; int ans=0; while(a&lt;=b)&#123; bool left=false; for(int i=0;a+i&lt;=b;i++)&#123; //字符串反转比较， if(s[a+i]&lt;s[b-i])&#123; left=true; break; &#125; else if(s[a+i]&gt;s[b-i])&#123; left=false; break; &#125; &#125; if(left) putchar(s[a++]); else putchar(s[b--]); //如果相等就返回字符串右边的 ans++; if(ans==80)&#123; printf(&quot;\\n&quot;); ans=0; &#125; &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; Q Saruman’s Army 题意：在一条直线上，有n个点。从这n个点中选择若干个，给他们加上标记。对于每一个点，其距离为R以内的区域里必须有一个被标记的点。问至少要有多少点被加上标记。 题解：我们从最左边的开始考虑。对于这个点，到距其R以内的区域必须要有带有标记的点。带有标记的点一定在其右侧（包含这个点本身）。给从最左边开始，距离为R以内的最远的点加上标记，尽可能的覆盖更靠右边的点。对于添加了标记的点右侧相距超过R的下一个点，采用同样的方法找到最右侧R距离以内最远的点添加标记。在所有点都被覆盖之前不断重复这一过程。 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int a[1010];int main()&#123; int n,R,i,ans; while(scanf(&quot;%d%d&quot;,&amp;R,&amp;n)&amp;&amp;R!=-1||n!=-1) &#123; for(i=0;i&lt;n;++i) scanf(&quot;%d&quot;,&amp;a[i]); sort(a,a+n); i=0;ans=0; while(i&lt;n) &#123; int s=a[i++];//s表示没有被覆盖的最左边的点 while(i&lt;n&amp;&amp;a[i]&lt;=s+R)//一直向右前进直到距s的距离大于R的点 i++; int p=a[i-1];//被标记的点 while(i&lt;n&amp;&amp;a[i]&lt;=p+R)//一直向右前进直到距p的距离大于R的点 i++; ans++; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; R - Fence Repair每次都要先从大长木板上切下要分割的木板中的较大的小木板，这样才能最后切割的费用最小。 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int main()&#123; priority_queue&lt;long long,vector&lt;long long int&gt;,greater&lt;long long int&gt; &gt;p;//逆着来，就找两个最小的，然后压进去，倒这来求 long long int i,n,a,s,x,y; scanf(&quot;%lld&quot;,&amp;n); s=0; for(i=0;i&lt;n;i++) &#123; scanf(&quot;%lld&quot;,&amp;a); p.push(a); &#125; while(p.size()&gt;1) &#123; x=p.top(); p.pop(); y=p.top(); p.pop(); s=s+x+y; p.push(x+y); &#125; printf(&quot;%lld\\n&quot;,s); return 0;&#125; S - Cleaning Shifts 题意：给出区间[ 1,T ]和N个小区间，要求用尽可能少的小区间覆盖区间[ 1,T ]，输出最少的小区间数量；若不能覆盖，输出-1。 思路：贪心。 具体：令begin为当前未被覆盖的区间起点。 贪心策略：选取包含点begin的区间中右端点最大的那个；若不存在包含begin的区间，输出-1。 证明：因为begin为未被覆盖的区间起点，所以begin一定要被小区间覆盖，将最优解中覆盖begin的小区间命名为区间X。 以下使用剪贴技术证明。 若存在包含begin的小区间Y( Y != X )使最终所需的小区间数少于原最优解，那么Y一定包含了X之后的某些小区间， 即Y的右端点大于X的右端点，与贪心策略矛盾，得证。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int N=25010;int n, T, sum, start=1, end;struct node&#123; int s, e; &#125;cow[N]; bool cmp( node a, node b ) &#123; return a.s&lt;b.s;&#125; int main() &#123; scanf( &quot;%d%d&quot;, &amp;n, &amp;T ); for( int i=1; i&lt;=n; i++ ) &#123; scanf( &quot;%d%d&quot;, &amp;cow[i].s, &amp;cow[i].e ); end=max( end, cow[i].e ); cow[i].e++; &#125; sort( cow+1, cow+n+1, cmp ); if( 1&lt;cow[1].s || end&lt;T )&#123; printf( &quot;-1\\n&quot; ); return 0; &#125; end=0; for( int i=1; i&lt;=n; ) &#123; bool flg=0; while( i&lt;=n &amp;&amp; cow[i].s&lt;=start ) &#123; end=max( end, cow[i].e ); i++; flg=1; &#125; if( !flg )&#123; printf( &quot;-1\\n&quot; ); return 0; &#125; sum++; if( end&gt;T ) break; start=end; &#125; printf( &quot;%d\\n&quot;, sum ); return 0;&#125; T poj3190Stall Reservations(贪心+优先队列)思路：首先根据挤奶时间的先后顺序排序。。。然后将第一头牛加入优先队列。。然后就是加入优先队列的牛应该根据越早结束挤奶那么优先级更高，如果时间结束点相等，那么开始时间早的优先级高。。。然后从前向后枚举。如果碰到有牛的挤奶时间的开始值大于优先队列的首部的结束值，那么说明这两头牛可以一起公用一个挤奶房。。然后从优先队列中删除这头牛。。那么这个问题就得到解决了。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;limits.h&gt;#include&lt;queue&gt;using namespace std;const int maxn=1000000+10;struct node&#123; int st,ed; int pos;//pos记录是第几个奶牛 bool operator&lt;(const node &amp;a)const &#123; if(ed==a.ed) return st&gt;a.st; return ed&gt;a.ed; &#125;&#125;a[maxn];int used[maxn];//used记录奶牛挤奶的位置=。=int cmp(node l1,node l2)&#123; if(l1.st==l2.st) return l1.ed&lt;l2.ed; return l1.st&lt;l2.st;&#125;int main()&#123; int n; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; priority_queue&lt;node&gt;q; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i].st,&amp;a[i].ed); a[i].pos=i; &#125; sort(a+1,a+n+1,cmp); q.push(a[1]); int ans=1; used[a[1].pos]=1; for(int i=2;i&lt;=n;i++) &#123; if(!q.empty()&amp;&amp;q.top().ed&lt;a[i].st)//判定是否符合条件 &#123; used[a[i].pos]=used[q.top().pos]; q.pop(); &#125; else//不符合条件槽的数量加一，同时这个奶牛应该在新加的槽 &#123; ans++; used[a[i].pos]=ans; &#125; q.push(a[i]); &#125; printf(&quot;%d\\n&quot;,ans); for(int i=1;i&lt;=n;i++) printf(&quot;%d\\n&quot;,used[i]); &#125; return 0;&#125; U POJ 1017 Packets(贪心 题意：工厂出售边长分别为1,2,3,4,5,6的正方形板子，但工厂只有66的板子，其他的板子都是从这种板子上裁剪而来的。现在给出分别这些板子的需求量，问最少需要多少块66的板子。 题解：从面积大的开始取，一块66的板子可以去一块55的板子剩下11个 11的板子。取一块44的板子剩下5个22的板子。 66的板子可以取四块33的板子，在一块66板子上取33的板子数目为 1 2 3 4 的时候剩下 22的板子分别为 5 3 1 0，剩余部分还可以去11的板子。 若22的板子有剩余，还可以分割成1*1的板子。 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cstring&gt;int dir[4]=&#123;0,5,3,1&#125;;int a[10];int main()&#123; int i,sum,ans; while(1) &#123; sum=0; for(i=1;i&lt;7;++i) &#123; scanf(&quot;%d&quot;,&amp;a[i]); sum+=a[i]; &#125; if(!sum) break; ans=a[6]+a[5]+a[4]+(a[3]+3)/4;//计算边长为3 4 5 6的板子消耗量 int cnt_2=a[4]*5+dir[a[3]%4]; if(a[2]&gt;cnt_2) ans+=(a[2]-cnt_2+8)/9;//当上面剩余的2*2板子量不足时，需要消耗新的板子 int cnt_1=ans*36-a[6]*36-a[5]*25-a[4]*16-a[3]*9-a[2]*4; if(a[1]&gt;cnt_1)//当上面剩余的1*1板子量不足时，需要消耗新的板子 ans+=(a[1]-cnt_1+35)/36; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; V Stripies （和R题Fence Repair是一样一样的）题意：介绍了一大堆，全废话。 题目就是说有n个物品，每个物品重w_i，对于两个物品他们合并时重量就会变成w &#x3D; 2 * sqrt(w_a * w_b)。 问当n个物品合成一个时，最小重量是多少？题解：贪心啊，不过要用到一点数学知识，在n个物品中取两个物品合并，要想最后总重最小，要每次取两个重量最大的物品。关于这个结论，下面给出证明：设：n&#x3D;3，三个物品的重量分比为：a，b，c， 合并之后最小重量为w。则w &#x3D; 2 * sqrt( a* 2 * sqrt(b * c) )化简后的 w^2&#x2F;8 &#x3D; sqrt( aab*c )， 此式可得 a 取最小时 w 的值最小。归纳总结，n个物品每次取最大的两个合并，总重最小。 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int main()&#123; int n; double num; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; priority_queue&lt;double&gt;q; while(n--) &#123; scanf(&quot;%lf&quot;,&amp;num); q.push(num); &#125; double ans=q.top();//注意n为1的情况 while(q.size()&gt;1) &#123; double a=q.top(); q.pop(); double b=q.top(); q.pop(); ans=2*sqrt(a*b); q.push(ans); &#125; printf(&quot;%.3f\\n&quot;,ans); &#125; return 0;&#125; W-Protecting the Flowers 题解：因为农夫每抱走一头牛，剩下的n-1头牛的问题还是和上面的问题一致。故要想使最终结果最优，所以必须要求当前最优解，所以可以判定是贪心问题。刚开始，以为先优先d值大的，d值相等时优先t值小的。 WA了，应该优先 t&#x2F;d 小的。若先取走a牛，则食花量为 2 * t_a * d_b ；若先取走b牛，则食花量为 2 * t_b * d_a ；两式分别除以 d_a * d_b ；分别为 2 * t_a &#x2F; d_a 2 * t_b &#x2F; d_b所以要优先 t&#x2F;d 值小的。 对于贪心问题n与n-1的策略是相同的，所以由n&#x3D;2的情况推广到任意n的情况。 注意：O(n^2)算法是会超时的，除去排序情况，其他部分可以优化到O(n)的。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define ll __int64using namespace std;ll sum[100010];struct node&#123; ll t,d; &#125;cow[100010]; int cmp(node a,node b)&#123; return (a.t*1.0/a.d)&lt;(b.t*1.0/b.d);&#125; int main()&#123; int n,i,j; ll ans; while(scanf(&quot;%d&quot;,&amp;n)!=EOF) &#123; for(i=0;i&lt;n;++i) scanf(&quot;%I64d%I64d&quot;,&amp;cow[i].t,&amp;cow[i].d); sort(cow,cow+n,cmp); sum[n-1]=0;//最后一头牛的消耗为0 for(i=n-2;i&gt;=0;i--)//其余每头牛的消耗为上一头牛的消耗+本头牛去的时候的消耗 sum[i]=sum[i+1]+cow[i+1].d; ans=0; for(i=0;i&lt;n;++i) ans+=2*cow[i].t*sum[i]; //遍历一遍得到总的消耗 printf(&quot;%I64d\\n&quot;,ans); &#125; return 0;&#125; X-The Dragon of Loowater题意有n头龙🐉和m个骑士，需要让这些骑士杀掉所有的龙，骑士能杀死龙的条件是骑士的身高比龙头的直径要高，每个骑士只能被雇用一次，且雇佣的费用是骑士的身高，求杀死所有龙所需要的最少费用 如果不能杀死所有的龙输出 Loowater is doomed!思路把龙头的直径和骑士的身高从小到大排序，从第一头龙开始找，然后从所有的骑士里面找能杀死他的，如果找到一个肯定是最小的，然后把他标记上（代表不能再雇佣他了） 如果可以杀死所有的龙🐉，那么输出答案，否则输出 Loowater is doomed! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 20000+100;int a[maxn],b[maxn];//数组a代表龙首的个数，b代表骑士身高 bool bk[maxn];//记录该龙是否被杀死 int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); int n,m;//n为龙的个数，m为骑士人数 while(cin&gt;&gt;n&gt;&gt;m) &#123; if(m==0 &amp;&amp; n==0) break; memset(bk,false,sizeof(bk)); for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;m;i++) cin&gt;&gt;b[i]; sort(a,a+n); sort(b,b+m); int sum=0,cnt=0; //sum计数需要的金币数，cnt计数可以被杀死龙的头数 for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) &#123; if(!bk[j] &amp;&amp; b[i]&gt;=a[j]) &#123; cnt++; sum+=b[i]; bk[j]=true; break; &#125; &#125; if(cnt==n ) cout&lt;&lt;sum&lt;&lt;&quot;\\n&quot;; else cout&lt;&lt;&quot;Loowater is doomed! \\n&quot;; &#125;&#125; Y Commando War 突击队战争 调度问题，直接贪心出完成任务需要的时间最长的那个人排序，就行了。 一种贪心的证明思路是：先假设找到了一种最优解，然后看我们贪心的方法是否会改变这个最优解，如果改变不了，那么说明我们的方法一定是没有问题的。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define ll long long#define pb push_back#define pm make_pair#define fi first#define se secondusing namespace std;const int MAX = 2e5 + 5;struct Node &#123; int a,b;&#125; node[MAX];bool cmp(Node a,Node b) &#123; return a.b&gt;b.b; //让执行时间长的排在前面&#125;int n;int main()&#123; int iCase = 0; while(~scanf(&quot;%d&quot;,&amp;n)) &#123; if(n == 0) break; for(int i = 1; i&lt;=n; i++) scanf(&quot;%d%d&quot;,&amp;node[i].a,&amp;node[i].b); int ans = 0,tmp=0; sort(node+1,node+n+1,cmp); for(int i = 1; i&lt;=n; i++) &#123; tmp += node[i].a; ans = max(ans,tmp + node[i].b); &#125; printf(&quot;Case %d: %d\\n&quot;,++iCase,ans); &#125; return 0 ;&#125; Z - Children’s Game （字典序问题）题意让你从给定的n个字符串中组成一个字典序最大的字符串思路如果是9 和 90 两个字符串，如果按照字典序排序的话是909 但是990比它要大，要重载运算符符&lt;，定义a+b &gt; b+a为less真，按字典序从大到小的顺序来排列， 这样排完之后就是字典序最大的字符串了.不能挨个位数的比较，要找到好的比较方法。 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std; string num[55]; bool cmp(string a, string b)&#123;//要转换方法为这样，而不是单纯的比较每位数字的大小（要找到好的排序方法） return a+b &gt; b+a; //‘+’表示a和b的连接 &#125; int main()&#123; int n; while(scanf(&quot;%d&quot;, &amp;n), n) &#123; for(int i=0; i&lt;n; i++) &#123; cin &gt;&gt; num[i]; &#125; sort(num, num+n, cmp); for(int i=0; i&lt;n; i++) &#123; cout &lt;&lt; num[i]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"新生训练","slug":"新生训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"杭电那10道题","slug":"杭电那10道题","date":"2019-10-12T07:23:00.000Z","updated":"2022-02-26T03:31:35.612Z","comments":true,"path":"2019/10/12/杭电那10道题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/10/12/%E6%9D%AD%E7%94%B5%E9%82%A310%E9%81%93%E9%A2%98/","excerpt":"","text":"","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"杭电","slug":"杭电","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%9D%AD%E7%94%B5/"}],"author":"aoyuehan"},{"title":"最小生成树，最短路径，哈夫曼编码","slug":"最小生成树，最短路径，哈夫曼编码","date":"2019-10-10T11:36:00.000Z","updated":"2022-02-26T04:29:56.582Z","comments":true,"path":"2019/10/10/最小生成树，最短路径，哈夫曼编码/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/10/10/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/","excerpt":"","text":"最小生成树（趣学算法2.7 沟通无限校园网）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;using namespace std;const int INF =0x3fffffff;const int N=100;bool s[N];int closest[N];int lowcost[N];void Prim(int n,int u0,int c[N][N])&#123; s[u0]=true; int i; int j; for(int i=1;i&lt;=n;i++) &#123; if(i!=u0)&#123; lowcost[i]=c[u0][i]; closest[i]=u0; s[i]=false; &#125; //这就是那个u0的情况 else lowcost[i]=0; &#125; for(int i=1;i&lt;=n;i++)&#123; int temp=INF; int t=u0; for(int j=1;j&lt;=n;j++)&#123; if((!s[j])&amp;&amp;lowcost[j]&lt;temp)&#123; t=j; temp=lowcost[j]; &#125; &#125; if(t==u0)break; s[t]=true; //把t加进来 for(int j=1;j&lt;=n;j++)&#123; if((!s[j])&amp;&amp;(c[t][j]&lt;lowcost[j])) &#123; lowcost[j]=c[t][j]; closest[j]=t; &#125; &#125; &#125; &#125; int main()&#123; int n,c[N][N],m,u,v,w; int u0 ; cout&lt;&lt;&quot;shuru jiedianshu n and bianshu m&quot;&lt;&lt;endl; cin&gt;&gt;n&gt;&gt;m; int sumcost=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) c[i][j]=INF; cout&lt;&lt;&quot;shuru jiedianshu n v de bianzhi w&quot;&lt;&lt;endl; for(int i=1;i&lt;=m;i++)&#123; cin&gt;&gt;u&gt;&gt;v&gt;&gt;w; c[u][v]=c[v][u]=w; &#125; cout&lt;&lt;&quot;shuru renyijiedian u0&quot;&lt;&lt;endl; cin&gt;&gt;u0; Prim(n,u0,c); cout&lt;&lt;&quot;数组lowcost的内容为：&quot;&lt;&lt;endl; for(int i=1;i&lt;=n;i++) cout&lt;&lt;lowcost[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; for(int i=1;i&lt;=n;i++) sumcost+=lowcost[i]; cout&lt;&lt;&quot; 最小花费是：&quot;&lt;&lt;sumcost&lt;&lt;endl&lt;&lt;endl; return 0; &#125; 还有优化，p93","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"最短路径","slug":"最短路径","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"哈夫曼编码","slug":"哈夫曼编码","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"}],"author":"aoyuehan"},{"title":"qlu_acm个人赛第一场","slug":"qlu-acm个人赛第一场","date":"2019-10-09T12:41:00.000Z","updated":"2022-02-26T03:52:51.320Z","comments":true,"path":"2019/10/09/qlu-acm个人赛第一场/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/10/09/qlu-acm%E4%B8%AA%E4%BA%BA%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA/","excerpt":"","text":"A. Minimum Integer求某一范围之外的最小能整除某个数的数是多少 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;typedef long long ll;int q;ll l,r,d;int main() &#123; ios::sync_with_stdio(0); cin &gt;&gt; q; while (q--) &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; d; ll L, R; //分L，R能否被d取余得0来分类求解 if (l%d != 0) &#123; L = (l / d); &#125; else if (l%d == 0)L = l / d - 1; if (r%d == 0)R = r / d + 1; else if (r%d != 0)R = r / d + 1; //最后由L的值来决定输出的结果 if (L == 0) &#123; cout &lt;&lt; d * R &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; 1 * d &lt;&lt; endl; &#125; &#125; return 0;&#125; B. Accordion题意：左边是[:中间可以有|，右边是:]；问最长的串； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int l,r,d;char a[500005];int main()&#123; scanf(&quot;%s&quot;,a); int l=strlen(a); int left=0,right=0; int i,j; //从左右搜索[::]这几个字符，其中[和：要用一个变量连续搜索 for(i=0;i&lt;l;++i) &#123; if(a[i]==&#x27;[&#x27;) &#123; ++left; break; &#125; &#125; for(;i&lt;l;++i) &#123; if(a[i]==&#x27;:&#x27;) &#123; ++left; break; &#125; &#125; for(j=l-1;j&gt;i;--j) &#123; if(a[j]==&#x27;]&#x27;) &#123; ++right; break; &#125; &#125; for(;j&gt;i;--j) &#123; if(a[j]==&#x27;:&#x27;) &#123; ++right; break; &#125; &#125; int num=0; if(left!=right) &#123; printf(&quot;-1\\n&quot;); &#125; else &#123; for(int kk=i+1;kk&lt;j;++kk) &#123; if(a[kk]==&#x27;|&#x27;) ++num; &#125; printf(&quot;%d\\n&quot;,num+4); &#125; return 0;&#125; D. GCD Counting 洛谷讲解dp问题https://www.luogu.org/problemnew/solution/CF1101D","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"训练","slug":"训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":" Longest Increasing Subsequence","slug":"最长连续递增字序列问题","date":"2019-10-06T04:06:00.000Z","updated":"2022-02-26T03:52:51.329Z","comments":true,"path":"2019/10/06/最长连续递增字序列问题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/10/06/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%AD%97%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/","excerpt":"","text":"https://blog.csdn.net/winner647520/article/details/80514947这一题的代码没看懂 快排三指针？？？ 最长上升子序列问题描述:给出一个序列a1,a2,a3,a4,a5,a6,a7….an,求它的一个子序列（设为s1,s2,…sn），使得这个子序列满足这样的性质，s1&lt;s2&lt;s3&lt;…&lt;sn并且这个子序列的长度最长。输出这个最长的长度。 O(n^2)算法：我们依次遍历整个序列，每一次求出从第一个数到当前这个数的最长上升子序列，直至遍历到最后一个数字为止，然后再取dp数组里最大的那个即为整个序列的最长上升子序列。我们用dp[i]来存放序列下标0到i-1中最长上升子序列的长度，那么dp[i]&#x3D;max(dp[j])+1,(j∈[0, i-1]); 显然dp[i]&#x3D;1,我们从i&#x3D;0开始遍历后面的元素即可。 1234567891011121314151617const int MAXN = 100005;int a[MAXN], dp[MAXN];//最长上升子序列int LIS(int n)&#123; int res = 0; for(int i = 0; i &lt; n; ++i) &#123; dp[i] = 1; for(int j = 0; j &lt; i; ++j) if(a[j] &lt; a[i]) dp[i] = max(dp[i], dp[j]+1); res = max(res, dp[i]); &#125; return res;&#125; DP之最长上升子序列O(n*logn)算法 假设一个序列d[1..9] &#x3D; 2 1 5 3 6 4 8 9 7，可以看出来它的LIS长度为5.下面慢慢的一步一步的找出它的LIS. 我们定义一个了序列为B,然后用i从1到9慢慢的考察。另外再定义一个len来记录当前的最长序列的长度 首先，把d[1]有序地放到B里，令B[1] &#x3D; 2，就是说当只有一个数字为2的时候，长度为1的LIS的最小末尾是2，这时Len&#x3D;1， 然后，把d[2]有序地放到B里，令B[1] &#x3D; 1，就是说长度为1的LIS的最小末尾是1，d[1]&#x3D;2已经没用了，很容易理解，是吧。这时Len&#x3D;1。接着，d[3] &#x3D; 5，d[3]&gt;B[1]，所以令B[1+1]&#x3D;B[2]&#x3D;d[3]&#x3D;5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候B[1..2] &#x3D; 1, 5，Len＝2。再来，d[4] &#x3D; 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] &#x3D; 1, 3，Len &#x3D; 2。继续， d[5] &#x3D; 6，它在3后面，因为B[2] &#x3D; 3, 而6在3后面，于是很容易可以推知B[3] &#x3D; 6, 这时B[1..3] &#x3D; 1, 3, 6，还是很容易理解吧？ Len &#x3D; 3 了。 第6个, d[6] &#x3D; 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] &#x3D; 4。B[1..3] &#x3D; 1, 3, 4， Len继续等于3. 第7个, d[7] &#x3D; 8，它很大，比4大，嗯。于是B[4] &#x3D; 8。Len变成4了 第8个, d[8] &#x3D; 9，得到B[5] &#x3D; 9，嗯。Len继续增大，到5了。 最后一个, d[9] &#x3D; 7，它在B[3] &#x3D; 4和B[4] &#x3D; 8之间，所以我们知道，最新的B[4] &#x3D;7，B[1..5] &#x3D; 1, 3, 4, 7, 9，Len &#x3D; 5。 于是我们知道了LIS的长度为5。 !!!!! 注意。这个1,3,4,7,9不是LIS，它只是存储的对应长度LIS的最小末尾。有了这个末尾，我们就可以一个一个地插入数据。虽然最后一个d[9] &#x3D; 7更新进去对于这组数据没有什么意义，但是如果后面再出现两个数字 8 和 9，那么就可以把8更新到d[5], 9更新到d[6]，得出LIS的长度为6。 然后应该发现一件事情了：在B中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到O(logN) 于是算法的时间复杂度就降低到了O(NlogN) 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;int find(int *a,int len,int n)&#123; int left=0,right=len,mid=(right+left)/2; while(left&lt;=right) &#123; if(n&gt;a[mid]) left=mid+1; else if(n&lt;a[mid]) right=mid-1; else return mid; mid=(right+left)/2; &#125; return left;&#125;int main()&#123; int c[100],i,j,len; int a[9]=&#123;2 ,1 ,5 ,3 ,6 ,4 ,8 ,9 ,7&#125;; c[0]=-1; c[1]=a[0]; len=1; for(i=0;i&lt;9;i++) &#123; j=find(c,len,a[i]); c[j]=a[i]; if(j&gt;len) len=j; &#125; cout&lt;&lt;len&lt;&lt;endl; return 0;&#125; 最长下降子序列1234567891011121314//最长下降子序列int LDS(int n)&#123; int res = 0; for(int i = 0; i &lt; n; ++i) &#123; dp[i] = 1; for(int j = 0; j &lt; i; ++j) if(a[j] &gt; a[i]) dp[i] = max(dp[i], dp[j] + 1); res = max(res, dp[i]); &#125; return res;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"数据结构上机实验","slug":"数据结构","date":"2019-10-03T12:36:00.000Z","updated":"2022-02-26T03:52:50.986Z","comments":true,"path":"2019/10/03/数据结构/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/10/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"对分易作业：表的操作算法设计作业内容：所有操作的函数头已经给出，分别写出函数体。1）已知单链表L，设计算法求单链表的表长。 int ListLength ( LinkList L )2）设计一个算法，求顺序表中值最大的结点的值。 int Max (SqList L )3)设计一个算法，求单链表中值最大的结点的值。 int Max (LinkList L )4）设计一个算法，删除数组s中的最大元素。 void DeleteMax (int s[], int n)5）设计一个算法，删除单链表中值最大的结点。 void DeleteMax (LinkList L )6）设计算法删除单链表L中所有值为x的结点。 void DeleteX (LinkList L, int x ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;typedef struct LNode&#123; int data; struct LNode *next;&#125;LNode,*LinkList;//后插法 顺序相同 void CreateList_R(LinkList &amp;L,int n)&#123; L=new LNode; //头结点 L-&gt;next=NULL; LinkList r=L; //r为尾指针 for(int i=0;i&lt;n;i++)&#123; LinkList p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=NULL; r-&gt;next=p; r=p; &#125; &#125;//第一题 求表长度 int ListLength(LinkList L)&#123; int len=0; LinkList p=L-&gt;next; while(p)&#123; len++; p=p-&gt;next; &#125; return len;&#125;//第三题 求表中最大的节点的值 int Max(LinkList L)&#123; LinkList p=L-&gt;next; int maxnum=L-&gt;data; while(p)&#123; if(p-&gt;data&gt;maxnum) maxnum=p-&gt;data; p=p-&gt;next; &#125; return maxnum;&#125; //第四题 删除数组中最大元素 void DeleteMax(int s[],int n)&#123; int maxid=0; int maxnum=s[0]; //假设s[0]是最小的那个元素 for(int i=1;i&lt;n;i++)&#123; if(s[i]&gt;maxnum)&#123; maxid=i; maxnum=s[i]; &#125; &#125;for(int i=maxid;i&lt;n-1;i++)&#123; //注意这时候这个i到n-1，因为那个数组的最大下标是i-1 s[i]=s[i+1]; &#125; &#125;//第五题 删单链表中值最大的节点 void DeleteMax( LinkList L)&#123; LinkList p=L-&gt;next; int maxx=p-&gt;data; while(p)&#123; if(p-&gt;data&gt;maxx) maxx=p-&gt;data; p=p-&gt;next; &#125; p=L; while(p-&gt;next)&#123; bool flag=false; if(p-&gt;next-&gt;data==maxx)&#123; flag=true; LinkList q=p-&gt;next; p-&gt;next=q-&gt;next; delete q; &#125; if(flag)continue; else p=p-&gt;next; &#125;&#125;//第六题 删除单链表中所有值为x的节点 void DeleteX(LinkList L,int x)&#123; LinkList p=L; while(p-&gt;next)&#123; bool flag=false; if(p-&gt;next-&gt;data==x)&#123; flag=true; LinkList q=p-&gt;next; p-&gt;next=q-&gt;next; delete q; &#125; if(flag)continue; else p=p-&gt;next; &#125;&#125;int main()&#123; int n; LinkList L; cin&gt;&gt;n; CreateList_R(L,n); //测试第一题 cout&lt;&lt;ListLength(L)&lt;&lt;endl; //测试第三题 cout&lt;&lt;MAX(L)&lt;&lt;endl; //测试第五题 DeleteMax(L); //输出链表的内容 LinkList p=L-&gt;next;while(p)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p=p-&gt;next; &#125; cout&lt;&lt;endl; //测试第六题 DeleteX(L,4); p=L-&gt;next; while(p)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p=p-&gt;next; &#125;/*测试第四题 int s[4]; for(int i=0;i&lt;4;i++)&#123; cin&gt;&gt;s[i]; &#125; DeleteMax(s,4); for(int i=0;i&lt;3;i++)cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;*/&#125;//顺序表的后插法 顺序相同 void CreateList_R(LinkList &amp;L,int n)&#123; L=new LNode; //头结点 L-&gt;next=NULL; LinkList r; //r为尾指针 int len=ListLength(L); cin&gt;&gt;r.data; for(int i=0;i&lt;n;i++)&#123; if(p) &#125; for(int i=0;i&lt;n;i++)&#123; LinkList p=new LNode; cin&gt;&gt;p-&gt;data; p-&gt;next=NULL; r-&gt;next=p; r=p; &#125; &#125;//前插法 顺序相反 void CreateList_H(LinkList &amp;L,int n)&#123; L=new LNode; L-&gt;next=NULL; for(int i=0;i&lt;n;i++)&#123; LinkList p=new LNode ; cin&gt;&gt;p-&gt;data; p-&gt;next=L-&gt;next; L-&gt;next=p; &#125;&#125;LNode *locateElem(LinkList L,int e)&#123; LinkList p=L-&gt;next; while(p&amp;&amp;p-&gt;data!=e) p=p-&gt;next; return p;&#125;还有一部分作业就是顺序表那部分：#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;#define MAXSIZE 100#define OVERFLOW 0typedef struct &#123; int *elem; int length;&#125;SQList;void InitList(SQList &amp;L)&#123; L.elem=new int[MAXSIZE]; if(!L.elem)exit(OVERFLOW); L.length=0; &#125;/*产生一个顺序表，先输入n，在输入n个数据，思想就是先输入n，在输入一个数存到L.elem[0],然后比较一下顺序表中元素的值，然后插入元素 */ void CreatList(SQList &amp;L)&#123; int n,num; cin&gt;&gt;n; cin&gt;&gt;L.elem[0]; L.length=1; for(int i=1;i&lt;n;i++)&#123; cin&gt;&gt;num; int j; for(j=1;j&lt;L.length;j++)&#123; if(num&lt;L.elem[j])&#123; break; &#125; &#125; for(int k=L.length-1;k&gt;=j-1;k--)&#123; L.elem[k+1]=L.elem[k]; &#125; ++L.length; L.elem[j]=num; &#125; &#125;//第二题 求顺序表中值最大的节点的值 int MAX(SQList L)&#123; int maxx=L.elem[0]; int maxid; for(int i=1;i&lt;L.length;i++)&#123; if(L.elem[i]&gt;maxx)&#123; maxid=i; maxx=L.elem[i]; &#125; &#125; return maxid;&#125;//测试函数 int main()&#123; SQList L; InitList(L); CreatList(L); for(int i=0;i&lt;L.length;i++)&#123; cout&lt;&lt;L.elem[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;L.elem[MAX(L)];&#125;int MAX_1(SQList L,int e)&#123; int maxx=e; int maxid; for(int i=0;i&lt;L.length;i++)&#123; if(L.elem[i]&gt;maxx)&#123; maxid=i; maxx=L.elem[i]; &#125; &#125; return maxid;&#125;void ListInsert(SQList &amp;L,int i,int e)&#123; if((i&lt;1)||(i&gt;L.length+1)) return error; if(L.length==MAXSIZE) return error; for(int j=L.length-1;j&gt;=i-1;j--) L.elem[j+1]=L.elem[j]; L.elem[i-1]=e; ++L.length; return OK;&#125; 上机实验1（字符串链表的插入，删除，查找）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include&quot;stdio.h&quot;#include&quot;string.h&quot;#include&quot;stdlib.h&quot;#include&quot;ctype.h&quot;typedef struct node //定义结点&#123; char data[10]; //结点的数据域为字符串 struct node *next; //结点的指针域&#125;ListNode;typedef ListNode * LinkList; // 自定义 LinkList 单链表类型LinkList CreatListR1(); //函数，用尾插入法建立带头结点的单链表LinkList CreatList(void); //函数，用头插入法建立带头结点的单链表ListNode *LocateNode(); //函数，按值查找结点void DeleteList(); //函数，删除指定值的结点void printlist(); //函数，打印链表中的所有值void DeleteAll(); //函数，删除所有结点，释放内存ListNode * AddNode(); //修改程序：增加节点。用头插法，返回头指针//==========主函数==============void main()&#123; char ch[10], num[5]; LinkList head; head = CreatList(); //用头插入法建立单链表，返回头指针 printlist(head); //遍历链表输出其值 printf(&quot; Delete node (y/n):&quot;); //输入&quot;y&quot;或&quot;n&quot;去选择是否删除结点 scanf(&quot;%s&quot;, num); if (strcmp(num, &quot;y&quot;) == 0 || strcmp(num, &quot;Y&quot;) == 0) &#123; printf(&quot;Please input Delete_data:&quot;); scanf(&quot;%s&quot;, ch); //输入要删除的字符串 DeleteList(head, ch); printlist(head); &#125; printf(&quot; Add node ? (y/n):&quot;); //输入&quot;y&quot;或&quot;n&quot;去选择是否增加结点 scanf(&quot;%s&quot;, num); if (strcmp(num, &quot;y&quot;) == 0 || strcmp(num, &quot;Y&quot;) == 0) &#123; head = AddNode(head); &#125; printlist(head); system(&quot;pause&quot;); DeleteAll(head); //删除所有结点，释放内存&#125;////==========用尾插入法建立带头结点的单链表===========//LinkList CreatListR1(void)//&#123;// char ch[10];// LinkList head = (LinkList)malloc(sizeof(ListNode)); //生成头结点// ListNode *s, *r, *pp;// r = head;// r-&gt;next = NULL;// printf(&quot;Input # to end &quot;); //输入&quot;#&quot;代表输入结束// printf(&quot;\\nPlease input Node_data:&quot;);// scanf(&quot;%s&quot;, ch); //输入各结点的字符串// while (strcmp(ch, &quot;#&quot;) != 0) &#123;// pp = LocateNode(head, ch); //按值查找结点，返回结点指针// if (pp == NULL) &#123; //没有重复的字符串，插入到链表中// s = (ListNode *)malloc(sizeof(ListNode));// strcpy(s-&gt;data, ch);// r-&gt;next = s;// r = s;// r-&gt;next = NULL;// &#125;// printf(&quot;Input # to end &quot;);// printf(&quot;Please input Node_data:&quot;);// scanf(&quot;%s&quot;, ch);// &#125;// return head; //返回头指针//&#125;//==========用头插入法建立带头结点的单链表===========LinkList CreatList(void)&#123; char ch[100]; LinkList head, p; head = (LinkList)malloc(sizeof(ListNode));//只声明一个数据空间 head-&gt;next = NULL; while (1) &#123; printf(&quot;Input # to end &quot;); printf(&quot;Please input Node_data:&quot;); scanf(&quot;%s&quot;, ch); if (strcmp(ch, &quot;#&quot;)) &#123; if (LocateNode(head, ch) == NULL)//只有一个字符串 &#123; strcpy(head-&gt;data, ch); p = (LinkList)malloc(sizeof(ListNode)); p-&gt;next = head; head = p;//p只是一个临时的节点，并没有存到LinkList中 &#125; &#125; else break; &#125; return head;&#125;//==========按值查找结点，找到则返回该结点的位置，否则返回 NULL==========ListNode *LocateNode(LinkList head, char *key)&#123; ListNode *p = head-&gt;next; //从开始结点比较 while (p != NULL &amp;&amp; strcmp(p-&gt;data, key) != 0) //直到 p 为 NULL 或 p-&gt;data 为 key 止 p = p-&gt;next; //扫描下一个结点 return p; //若 p=NULL 则查找失败，否则 p 指向找到的值为 key 的结点&#125;//==========修改程序：增加节点=======ListNode * AddNode(LinkList head)&#123; char ch[10];int pos; int i; ListNode *s, *pp,*p; printf(&quot;\\nPlease input Insert_data:&quot;); scanf(&quot;%s&quot;, ch); //输入各结点的字符串 printf(&quot;\\nposition:&quot;); scanf(&quot;%d&quot;,&amp;pos); //c语言的scanf中一定要加&amp;，上面那个赋值给ch不用加，因为ch本身就是地质 pp = LocateNode(head, ch); //按值查找结点，返回结点指针// p = (ListNode *)malloc(sizeof(ListNode)); p=head-&gt;next; if (pp == NULL) &#123; //没有重复的字符串，插入到链表中 s = (ListNode *)malloc(sizeof(ListNode)); strcpy(s-&gt;data, ch); for(i=1;i&lt;pos-1;i++)p=p-&gt;next; s-&gt;next = p-&gt;next; p-&gt;next = s; &#125; return head;&#125;//==========删除带头结点的单链表中的指定结点=======void DeleteList(LinkList head, char *key)&#123; ListNode *p, *r, *q = head; p = LocateNode(head, key); //按 key 值查找结点的 if (p == NULL) &#123; //若没有找到结点，退出 printf(&quot;position error&quot;); exit(0); &#125; while (q-&gt;next != p) //p 为要删除的结点，q 为 p 的前结点 q = q-&gt;next; r = q-&gt;next; q-&gt;next = r-&gt;next; free(r); //释放结点&#125;//===========打印链表=======void printlist(LinkList head)&#123; ListNode *p = head-&gt;next; //从开始结点打印 while (p) &#123; if(p-&gt;next==NULL)printf(&quot;%s&quot;, p-&gt;data); else printf(&quot;%s, &quot;, p-&gt;data); p = p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;//==========删除所有结点，释放空间===========void DeleteAll(LinkList head)&#123; ListNode *p = head, *r; while (p-&gt;next) &#123; r = p-&gt;next; free(p); p = r; &#125; free(p);&#125;/*1,首先明白了头插法和尾插法的区别：头插法是从一个表开始，重复读入数据，生成新节点，将读入数据存放到新节点的数据域中，然后将新节点插入到当前链表的头结点之后，直至读入结束标志为止。其插入的顺序和存储的逻辑顺序相反，而尾插法相同。2，在按值查找这个函数中，要返回指定值的节点，可以这么写：while (p != NULL &amp;&amp; strcmp(p-&gt;data, key) != 0)p = p-&gt;next;这样的话，当程序跳出while循环之后，p就只要求的节点（p为NULL说明链表中没有该值的节点）。3，在打印链表的时候while（）中要写p而不是p-&gt;next,否则的话最后一个节点就打印不出来了；在删除所有节点的函数中，while函数中写的是p-&gt;next,而不是p，这样的话，p走到最后一个节点的时候就不会进入while循环了，那么在while循环外面还要写free(p)来删除最后那个节点*/ 上机实验二 实验二：顺序表的基本操作实验目的：1、理解什么是顺序表；2、掌握顺序表的基本操作，如建立、查找、插入和删除等。实验内容：定义一个包含学生信息（学号，姓名，成绩）的顺序表，使其具有如下功能：(1) 根据指定学生个数，逐个输入学生信息；(2) 逐个显示学生表中所有学生的相关信息；(3) 根据姓名进行查找，返回此学生的学号和成绩；(4) 根据指定的位置可返回相应的学生信息（学号，姓名，成绩）；(5) 给定一个学生信息，插入到表中指定的位置；(6) 删除指定位置的学生记录；(7) 统计表中学生个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251#include&lt;stdio.h&gt; #include&lt;malloc.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; #define OK 1 #define ERROR 0 #define OVERFLOW -2 #define MAXSIZE 100 typedef int Status; // 定义函数返回值类型 typedef struct &#123; char num[10]; // 学号 char name[20]; // 姓名 double grade; // 成绩 &#125;student; typedef student ElemType; typedef struct &#123; ElemType *elem; // 存储空间的基地址 int length; // 当前长度 &#125;SqList; Status InitList(SqList *L) // 构造空的顺序表 L &#123; L-&gt;elem=(ElemType *)malloc(sizeof(ElemType)*MAXSIZE); if(!L-&gt;elem) exit(OVERFLOW); L-&gt;length=0; return OK; &#125; ElemType GetElem(SqList &amp;L,int i) // 访问顺序表，找到 i位置，返回给 e &#123; return L.elem[i]; &#125; int Search(SqList &amp;L,char str[]) // 根据名字查找，返回该同学在顺序表中的编号 &#123; for(int i=1;i&lt;=L.length;i++) &#123; if(strcmp(L.elem[i].name,str)==0) return i; &#125; return 0; &#125; Status ListInsert(SqList &amp;L,int i,ElemType e) // 在 i位置插入某个学生的信息 &#123; if((i&lt;1)||(i&gt;L.length+1)) return ERROR; if(L.length==MAXSIZE) return ERROR; for(int j=L.length;j&gt;=i;j--) &#123; L.elem[j+1]=L.elem[j]; &#125; L.elem[i]=e; ++L.length; return OK; &#125; Status ListDelete(SqList &amp;L,int i) // 在顺序表中删除 i位置的学生信息 &#123; if((i&lt;1)||(i&gt;L.length)) return ERROR; for(int j=i;j&lt;=L.length;j++) &#123; L.elem[j]=L.elem[j+1]; &#125; --L.length; return OK; &#125; void Input(ElemType *e) &#123; printf(&quot;姓名:&quot;); scanf(&quot;%s&quot;,e-&gt;name); printf(&quot;学号:&quot;); scanf(&quot;%s&quot;,e-&gt;num); printf(&quot;成绩:&quot;); scanf(&quot;%lf&quot;,&amp;e-&gt;grade); printf(&quot;输入完成\\n\\n&quot;); &#125; void Output(ElemType *e) &#123; printf(&quot;\\t%s\\t%s\\t%f\\n&quot;,e-&gt;name,e-&gt;num,e-&gt;grade); &#125; int main() &#123; SqList L; ElemType a,b,c,d; printf(&quot;\\n********************************\\n\\n&quot;); puts(&quot;1. 构造顺序表&quot;); puts(&quot;2. 录入学生信息&quot;); puts(&quot;3. 显示学生信息&quot;); puts(&quot;4. 输入姓名，查找该学生&quot;); puts(&quot;5. 显示某位置该学生信息&quot;); puts(&quot;6. 在指定位置插入学生信息&quot;); puts(&quot;7. 在指定位置删除学生信息&quot;); puts(&quot;8. 统计学生个数&quot;); puts(&quot;0. 退出&quot;); printf(&quot;\\n********************************\\n\\n&quot;); int x,choose; while(1) &#123; puts(&quot;请选择:&quot;); scanf(&quot;%d&quot;,&amp;choose); if(choose==0) break; switch(choose) &#123; case 1: if(InitList(&amp;L)) printf(&quot;成功建立顺序表\\n\\n&quot;); else printf(&quot;顺序表建立失败\\n\\n&quot;); break; case 2: printf(&quot;请输入要录入学生的人数（小于100）:&quot;); scanf(&quot;%d&quot;,&amp;x); for(int i=1;i&lt;=x;i++) &#123; printf(&quot;第%d个学生:\\n&quot;,i); Input(&amp;L.elem[i]); &#125; L.length=x; puts(&quot;&quot;); break; case 3: printf(&quot;\\t姓名\\t学号\\t成绩\\n&quot;); for(int i=1;i&lt;=x;i++) &#123; a=GetElem(L,i); Output(&amp;a); &#125; break; case 4: char s[20]; printf(&quot;请输入要查找的学生姓名:&quot;); scanf(&quot;%s&quot;,s); if(Search(L,s)) Output(&amp;L.elem[Search(L,s)]); else puts(&quot;对不起，查无此人&quot;); puts(&quot;&quot;); break; case 5: printf(&quot;请输入要查询的位置:&quot;); int id1; scanf(&quot;%d&quot;,&amp;id1); if((id1&lt;1)||(id1&gt;L.length+1)) &#123; puts(&quot;要查询的位置不合法&quot;); continue; &#125; b=GetElem(L,id1); Output(&amp;b); break; case 6: printf (&quot;请输入要插入的位置:&quot;); int id2; scanf(&quot;%d&quot;,&amp;id2); printf(&quot;请输入学生信息:\\n&quot;); Input(&amp;c); if(ListInsert(L,id2,c)) &#123; x++; puts(&quot;插入成功&quot;); puts(&quot;&quot;); &#125; else &#123; puts(&quot;插入失败&quot;); puts(&quot;&quot;); &#125; break; case 7: printf(&quot;请输入要删除的位置:&quot;); int id3; scanf(&quot;%d&quot;,&amp;id3); if(ListDelete(L,id3)) &#123; x--; puts(&quot;删除成功&quot;); puts(&quot;&quot;); &#125; else &#123; puts(&quot;删除失败&quot;); puts(&quot;&quot;); &#125; break; case 8: printf(&quot;已录入的学生个数为:%d\\n\\n&quot;,L.length); break; &#125; &#125; printf(&quot;\\n\\n谢谢您的使用，请按任意键退出\\n\\n\\n&quot;); system(&quot;pause&quot;); return 0; &#125; /* 预习报告1. 按学生的姓名来查找学生信息时，声明一个sceach的函数判断一下顺序表中是否有该同学，如果存在，那么返回该同学在顺序表中的位置k，然后output函数返回第k个位置的学生信息；如果不存在，就输出信息提示没有该同学。预习报告代码：int Search(SqList &amp;L,char str[]) // 根据名字查找，返回该同学在顺序表中的编号 &#123; for(int i=1;i&lt;=L.length;i++) &#123; if(strcmp(L.elem[i].name,str)==0) return i; &#125; return 0; &#125; 2. 删除的顺序应该先声明一个用来计数的变量，该变量的值从第i个元素开始，依次加1，直到j大于表长度，让每个变量对应存储的值向前移动，实现删除第i个元素的功能 实现for循环 for(int j=i;j&lt;=L.length;j++) &#123; L.elem[j]=L.elem[j+1]; &#125; 3.在指定位置插入元素，实现ListInsert函数，把顺序表，id2（要插入的位置），c（包含一个学生的信息的student类型的结构体变量），该函数应该判断插入的位置id2是否合法，然后在id2以后的所有已经存在的结构题变量往后一一个位置，空出要插入的位置，插入要插入的位置，表长加1。如果插入成功返回1，否则放那会0.4.要查询指定位置的学生信息时，首先把顺序表和指定位置i当作参数，实现GetElem的方法，让该方法返回指定位置的学生信息。实验心得1. 程序的健壮性是指程序能对输入的非法数据进行处理，并不会因为输入非法数据导致程序的崩溃。写程序要考虑程序的健壮性，比如本次实验在ListDelete这个方法中要对传进来的参数i（要插入的位置）进行判断，如果插入的位置小于1或者大于表长度+1，就提示输入数据有误。2. 为了方便阅读，书写程序要有层次的缩进，这样一眼就能看出来每个语句块的内容，方便理解 3. Input函数中，那个向传过来的参数e赋值grade语句时，一定要加&amp;，因为name和num都是引用型数据，可以不加&amp;。4. switch语句，要在每个case语句中加入break语句，否则的话，执行完一条case语句，就会接着执行下一跳语句。可以在if语句之后写continue和break，但满足if条件时，就执行该语句，跳过循环或者退出循环 5. 删除指定位置的元素时，该方法首先要判断删除的位置是否合法，然后从第i个位置到最后一个元素依次往前移动，覆盖要删除的位置，表长减1.6. Output(&amp;a);这一条语句调用output函数要加&amp;来运行，因为原函数当中是ElemType *e当作形参的，那个a是student类型的，&amp;a就代表这个参数为指向student类型的地址。*/ 上机实验三 栈一、实验目的熟悉栈的顺序表示与实现。熟悉栈的应用。理解并掌握递归函数的设计与实现。二、实验内容1 问题描述：利用栈实现十进制数n转化为d（分别是2,8,16）进制数要求：输入一个n和d，打印输出d进制数序列。利用顺序栈来实现十进制数n转化为其他d进制数。此时，需要同时实现初始化空栈、入栈、出栈、判栈空等辅助功能。测试数据：8进制：输入n:1348 输出：25042进制：输入n:1348 输出：101 0100 0100‬16进制：输入n:1348 输出：544 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define STACK_INIT_SIZE 10 /* 存储空间初始分配量 */ #define STACK_INCREMENT 2 /* 存储空间分配增量 */ #define TRUE 1 #define FALSE 0 #define OK 1 #define ERROR 0 #define OVERFLOW 0 typedef struct SqStack &#123; int *base; /* 在栈构造之前和销毁之后，base 的值为 NULL */ int *top; /* 栈顶指针 */ int stacksize; /* 当前已分配的存储空间，以元素为单位 */ //整个sqStack的大小是24，所以base，top和stacksize各为8 &#125;SqStack; /* 顺序栈 */ void InitStack(SqStack *s) &#123; /* 构造一个空栈 S */ s-&gt;base=(int *)malloc(STACK_INIT_SIZE*sizeof(int)); if(!s-&gt;base) exit(OVERFLOW); /* 存储分配失败 */ s-&gt;top=s-&gt;base; s-&gt;stacksize=STACK_INIT_SIZE; &#125; int StackEmpty(SqStack s) &#123; /* 若栈 S 为空栈，则返回 TRUE，否则返回 FALSE */ if(s.top==s.base) return TRUE; else return FALSE; &#125; int StackLength(SqStack s) &#123; /* 返回 S 的元素个数，即栈的长度 */ return s.top-s.base; &#125; void Push(SqStack *s,int e) &#123; /* 插入元素 e 为新的栈顶元素 */ if(s-&gt;top-s-&gt;base&gt;=s-&gt;stacksize) //这两个相等的时候重新分配内存 /* 栈满，追加存储空间 */ &#123; s-&gt;base=(int *)realloc(s-&gt;base,(s-&gt;stacksize+STACK_INCREMENT)*sizeof(int)); //每次开辟两个空间，下一次让top指针指向刚stacksisze的位置，然后s-&gt;top++之后也不会溢出 if(!s-&gt;base) exit(1); /* 存储分配失败 */ s-&gt;top=s-&gt;base+s-&gt;stacksize; //s-&gt;stacksize这个是原来没改变之前的那个 //是为了让top指针指向刚刚大一size之后的第一个位置; s-&gt;stacksize+=STACK_INCREMENT; &#125; *(s-&gt;top)++=e; //这是数值和数值的赋值，*(s-&gt;top)是指向这个地址的数值 &#125; int Pop(SqStack *s,int *e) &#123; /* 若栈不空，则删除 S 的栈顶元素，用 e 返回其值，并返回 OK；否则 返回 ERROR */ if(s-&gt;top==s-&gt;base) return ERROR; *e=*--s-&gt;top; return OK; &#125; void conversion_16() &#123; /* 对于输入的任意一个非负 10 进制整数，打印输出与其等值的 16 进制数 */ SqStack s; int n; /* 非负整数 */ int e; InitStack(&amp;s); /* 初始化栈 */ printf(&quot;将 10 进制整数 n 转换为 16 进制数\\n 请输入 n( &gt;0 )：&quot;); scanf(&quot;%d&quot;,&amp;n); /* 输入非负十进制整数 n */ while(n)&#123;/* 当 n 不等于 0 */ Push(&amp;s,n%16); /* 入栈 n 除以 16 的余数(16 进制的低位) */ n=n/16; &#125; while(!StackEmpty(s)) /* 当栈不空 */ &#123; Pop(&amp;s,&amp;e); /* 弹出栈顶元素且赋值给 e */ if(e&lt;=9) printf(&quot;%d&quot;,e); else printf(&quot;%c&quot;,e+55); /* 大于 9 的余数，输出相应的字符*/ &#125; printf(&quot;\\n&quot;);&#125; void conversion_8() &#123; /* 对于输入的任意一个非负 10 进制整数，打印输出与其等值的 8 进制数 */ SqStack s; int n; /* 非负整数 */ int e; InitStack(&amp;s); /* 初始化栈 */ printf(&quot;将 10 进制整数 n 转换为 8 进制数\\n 请输入 n( &gt;0 )：&quot;); scanf(&quot;%d&quot;,&amp;n); /* 输入非负十进制整数 n */ while(n)&#123;/* 当 n 不等于 0 */ Push(&amp;s,n%8); /* 入栈 n 除以 8 的余数(8 进制的低位) */ n=n/8; &#125; while(!StackEmpty(s)) /* 当栈不空 */ &#123; Pop(&amp;s,&amp;e); /* 弹出栈顶元素且赋值给 e */ printf(&quot;%d&quot;,e); &#125; printf(&quot;\\n&quot;);&#125; void conversion_2() &#123; /* 对于输入的任意一个非负 10 进制整数，打印输出与其等值的 2进制数 */ SqStack s; int n; /* 非负整数 */ int e; InitStack(&amp;s); /* 初始化栈 */ printf(&quot;将 10 进制整数 n 转换为 2 进制数\\n 请输入 n( &gt;0 )：&quot;); scanf(&quot;%d&quot;,&amp;n); /* 输入非负十进制整数 n */ while(n)&#123;/* 当 n 不等于 0 */ Push(&amp;s,n%2); /* 入栈 n 除以 2 的余数(2 进制的低位) */ n=n/2; &#125; while(!StackEmpty(s)) /* 当栈不空 */ &#123; Pop(&amp;s,&amp;e); /* 弹出栈顶元素且赋值给 e */ printf(&quot;%d&quot;,e); &#125; printf(&quot;\\n&quot;);&#125; int main() &#123; SqStack s; int n; /* 非负整数 */ int e; InitStack(&amp;s); /* 初始化栈 */ // Push(&amp;s,3);// Push(&amp;s,4); Push(&amp;s,4); printf(&quot;%d&quot;,s.stacksize); //ans是10 printf(&quot;%d&quot;,sizeof(s)); //ans24 // int choice;// printf(&quot;%s&quot;,&quot;1.十进制转二进制\\n&quot;);// printf(&quot;%s&quot;,&quot;2.十进制转八进制\\n&quot;);// printf(&quot;%s&quot;,&quot;3.十进制转十六进制\\n&quot;);// while(1)&#123;// // printf(&quot;%s&quot;,&quot;请输入序号：&quot;);// scanf(&quot;%d&quot;,&amp;choice);// switch(choice)&#123;// case 1: conversion_2(); break;// case 2: conversion_8();break;// case 3: conversion_16();break;// default: return 0;// &#125; // &#125; &#125; /* 预习报告 1.进制转换可以使用顺序栈这种数据结构，SqStack 结构包括两个int 类型的指针，top和base，还保存着顺序栈的存储空间的大小。其结构体定义如下： typedef struct SqStack &#123; int *base; int *top; int stacksize; &#125;SqStack; 2.栈是一种只在表尾进行插入或者删除的操作的线性表，表尾 叫栈顶（本题中的top指针），表头端称为栈底（本题中的base指针）；栈的修改是按照后进先出的原则 进行的。本题目正好符合进制转换中先得到的余数后输出，即先得到的余数 是低位，可以用栈这种数据结构来实现。 3.ASCII表中A对应的十进制数为65，9对应的十进制数为57，若对 16取余的余数大于9，则可用余数+55得到其相应字母对应的10进制数 然后将该十进制数转换为相应的字符，这种方法实现了10进制转换为相应的16进制数。 4.5.八进制转换 void conversion_8() &#123; /* 对于输入的任意一个非负 10 进制整数，打印输出与其等值的 8 进制数 */ // SqStack s; int n; /* 非负整数 */ // int e; InitStack(&amp;s); /* 初始化栈 */ // printf(&quot;将 10 进制整数 n 转换为 8 进制数\\n 请输入 n( &gt;0 )：&quot;); // scanf(&quot;%d&quot;,&amp;n); /* 输入非负十进制整数 n */ // while(n)&#123;/* 当 n 不等于 0 */// Push(&amp;s,n%8); /* 入栈 n 除以 8 的余数(8 进制的低位) */ // n=n/8; // &#125; // while(!StackEmpty(s)) /* 当栈不空 */ // &#123; // Pop(&amp;s,&amp;e); /* 弹出栈顶元素且赋值给 e */ // printf(&quot;%d&quot;,e);// &#125; // printf(&quot;\\n&quot;);//&#125; /* 心得 1.对于输入一个任意的非负十进制整数n，对n除以16结果为a，余数为b， 将余数b压入顺序栈，继续对a进行此操作，直至a为0； 当栈不为空时，弹出相应的数输出即可；对于16进制输出，首先判断弹出的元素e 是否小于9，若大于9输出（e+55）对应的字符即可 。 2. 根据问题的要求，利用顺序栈实现将十进制数n转换为 16,2,8进制数， 此时 同时要实现初始化空栈，入栈，出栈，判栈空，栈的长度等功能。 其中：判断栈空的条件是栈顶指针和栈底指针相等。栈的长度是 栈顶指针和栈底指针的差值 。 3.在栈顶插入元素，即入栈操作 ，首先是先判断栈是否已满，如果栈满就realloc 函数重新为栈分配新的空间， 初始化栈顶到没扩展之前的base+stacksize的位置 */ 上机实验四 实验题目：循环队列基本操作 循环队列基本操作【 实验目的 】1、 掌握用 VC 工具上机调试循环队列的基本方法；2、 掌握循环队列的基本操作，循环队列初始化、入队、出队、判断队空、判断队满以及求队列长度操作；3、 掌握队列的先进先出运算规则及其在病人看病模拟程序中的应用，理解队列在运算过程中状态的变化。【 实验要求 】 循环队列的初始化、入队、出队、判断是否为空、求队列长度及队列输出操作的实现； 编写程序模拟实现病人看病排队。【 需求分析 】1、 程序应该达到的功能：在病人排队看医生的过程中，主要重复两件事：（1） 病人到达诊室，将病历本交给护士，排到等待队列中候诊；（2） 护士从等待队列中取出下一位病人的病历，该病人进入诊室就诊。要求程序能够模拟病人等待就诊这一过程，因此程序应采取菜单方式，且各选项的功能如下：（1） 排队——输入排队病人的病历号，加入病人排队队列中；（2） 就诊——病人排队队列中最前面的病人就诊，并将其从队列中删除；（3） 查看队列——从队首到队尾依次列出所有的排队病人的病历号；（4） 不再接受排队，队列中现有病人依次就诊。（5） 下班——退出系统。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;#define MaxSize 5// 队列结构体定义typedef struct &#123; ElementType patient[MaxSize]; int front, rear;&#125; Queue;// 排队(入队)void AddQ(Queue *PtrQ) &#123; int flag = 0, i, item; i = PtrQ-&gt;front;//第一次加的时候，i指向front初始值为0 if( (PtrQ-&gt;rear+1)%MaxSize == PtrQ-&gt;front ) &#123;//判断队满了没有 printf(&quot; &gt;&gt;排队人数已超出范围, 请先诊断病人.\\n&quot;); return; &#125; do &#123; scanf(&quot;%d&quot;, &amp;item); while((i++)%MaxSize != PtrQ-&gt;rear ) &#123; //如果只有两个的话，++i之后就会直接不运行下面这个while了 //这地方不能改为++i，为什么呀，font队头本身就不用判断呀，因为有时候要 if(item == PtrQ-&gt;patient[i%MaxSize]) &#123;//i修改为i%MaxSize，因为i++之后有可能会跳过一些数 flag = 1; break; &#125; else flag = 0; &#125; if( flag == 1 ) &#123; printf(&quot; &gt;&gt;病历号重复, 请重新输入:&quot;); i = PtrQ-&gt;front;//重新跟新一下i，新加上的 &#125; &#125; while( flag ); PtrQ-&gt;rear = (PtrQ-&gt;rear+1) % MaxSize; PtrQ-&gt;patient[PtrQ-&gt;rear] = item;//没与下一行调换顺序 ，为了让在0的位置存一下数据 ？？ return;&#125;// 就诊(出队)void Treatment(Queue *PtrQ) &#123; int patient; if( PtrQ-&gt;front == PtrQ-&gt;rear ) &#123;//不要+1 ，相等就是队满了 printf(&quot; &gt;&gt;没人在排队看病.\\n&quot;); return; &#125; else &#123; PtrQ-&gt;front = (PtrQ-&gt;front+1) % MaxSize; patient = PtrQ-&gt;patient[PtrQ-&gt;front]; printf(&quot; &gt;&gt;病人%d 就诊\\n&quot;, patient); return; &#125;&#125;// 查看排队情况(遍历循环队列)void print(Queue *PtrQ) &#123; int i = PtrQ-&gt;front;//头部指向数据的前一个没有数据的节点 if( PtrQ-&gt;front == PtrQ-&gt;rear ) &#123; printf(&quot; &gt;&gt;没有人在排队.\\n&quot;); return; &#125; else &#123; printf(&quot; &gt;&gt;排队的人有:&quot;); while( (i % MaxSize) != PtrQ-&gt;rear) &#123; //while中i修改为(i % MaxSize) //如果i是队尾了，就不用输出了，因为队尾在上一次就已经输出来了 printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]);//i+1修改为 (i+1)%MaxSize //最开始的时候从下标为1的头开始读取 i++; &#125; printf(&quot;\\n&quot;); &#125; return;&#125;// 余下依次就诊，不再排队(遍历队列)void NoMoreQueue(Queue *PtrQ) &#123; int i; if(PtrQ-&gt;front == PtrQ-&gt;rear) &#123; printf(&quot; &gt;&gt;没有排队的人.\\n&quot;); return; &#125; else &#123; i = PtrQ-&gt;front; printf(&quot; &gt;&gt;病人按以下顺序就诊:&quot;); while( i%MaxSize != PtrQ-&gt;rear ) &#123; printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]); //第一次就输出队头的下一个元素 ，i+1修改为 (i+1)%MaxSize i++; PtrQ-&gt;front = (PtrQ-&gt;front+1) % MaxSize; &#125; printf(&quot;\\n&quot;); &#125; return;&#125;int main() &#123; int flag = 1, sel; Queue *p; p = (Queue *)malloc(sizeof(Queue)); p-&gt;front = 0; p-&gt;rear = 0; while( flag ) &#123; printf(&quot;1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:&quot;); scanf(&quot;%d&quot;, &amp;sel); switch( sel ) &#123; case 1 : printf(&quot; &gt;&gt;请输入病历号:&quot;); AddQ( p ); break; case 2 : Treatment( p ); break; case 3 : print( p ); break; case 4 : NoMoreQueue( p ); break; case 5 : if(p-&gt;front != p-&gt;rear ) printf(&quot; &gt;&gt;请排队的病人明天就医!现在要下班了\\n&quot;); else printf(&quot; &gt;&gt;已经没有排队的病人,现在准备下班!\\n&quot;); flag = 0; break; &#125; &#125; return 0;&#125;/*1:bug1:那个不再排队直接一次就诊之后还要不要能看那个查看排队bug2：为什么在排队时第一次输入一个重复的病历单后，之后输入不同的病历单也会出现病历单重复的信息，而且程序会直接会崩 预习报告： 1.余下的一次就诊的方法设计思路：首先是判断一下队列的头指针和尾指针是否相同，相同的话队列为空，就显示没有正在排队的人，否则，声明一个临时变量i，让它指向队列的头部， printf(&quot;%d &quot;, PtrQ-&gt;patient[i+1]);因为i+1 有可能比5要大，不对 MaxSize取模的话就会出现显示未知数据的情况，所以应该这样写:printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]); 并且应该在i++之后写PtrQ-&gt;front = (PtrQ-&gt;front+1) % MaxSize;，这样的话每一个病人就诊完后，头指针+1(将该病人从队列中删除)， 这样的话选择4之后就还可以选择1，再添加病人。 2. 入队操作的设计思路，应该先判断队列是否已满，已满的话就提示信息；否则获取要排队的 序号，与此同时对队列中已有的序号与输入的序号进行比较，如果相同就提示再次输入 ，然后队列尾指针向后移动一位，在尾指针处存入相应的数据，头部指针是不存储数据的。 实验心得： 1. 在AddQ方法中判断输入的序号是否出现时，while(i++!=PtrQ-&gt;rear) 该条语句应该改为 while((i++)%MaxSize != PtrQ-&gt;rear )并且本条语句if(item == PtrQ-&gt;patient[i]) 也应该 改为if(item == PtrQ-&gt;patient[i%MaxSize]) 否则会因为在while语句中i++后i的值比原来增加1，少比较一些值，会出现在队列中加入与原来相同的序号2.在NoMoreQueue方法中，printf(&quot;%d &quot;, PtrQ-&gt;patient[i+1]);也会出现显示相同序号的问题，printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]); 同样在print方法中， printf(&quot;%d &quot;, PtrQ-&gt;patient[i+1]);该条语句的后果可能会出现 两个相同的序号，但是在选择2挨个就诊的时候并不会出现两个相同的序号 ，所以该条语句应改为printf(&quot;%d &quot;, PtrQ-&gt;patient[(i+1)%MaxSize]); 实验结果 1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1 &gt;&gt;请输入病历号:11:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1 &gt;&gt;请输入病历号:21:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1 &gt;&gt;请输入病历号:31:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1 &gt;&gt;请输入病历号:41:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:3 &gt;&gt;排队的人有:1 2 3 41:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:2 &gt;&gt;病人1 就诊1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:2 &gt;&gt;病人2 就诊1:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:1 &gt;&gt;请输入病历号:11:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:4 &gt;&gt;病人按以下顺序就诊:3 4 11:排队 2:就诊 3:查看排队 4.不再排队,余下依次就诊 5:下班请选择:5 &gt;&gt;已经没有排队的病人,现在准备下班! */ 上机实验五 二叉树一、实验目的 1．掌握二叉树树的结构及非线性特点，递归特点和动态性。 2．巩固对指针的使用和二叉树的三种遍历方法、建立方法。二、实验内容 二叉树的实现和运算 预习报告： 首先是树的节点的声明typedef struct BitNode { &#x2F;&#x2F;节点存放char类型的数据 char data; &#x2F;&#x2F;声明两个节点类型的左指针和右指针 struct BitNode *lchild,*rchild;}*BitTree; 先序建立二叉树BinTreeCreat的方法，首先本算法要在叶子结点下输入#来代表下面没有节点了，所以先获取输入节点的值，如果该节点的值为#，那么该节点的子树为空，如果该节点的值不为#，那么递归的建立左子树右子树。 先序遍历二叉树BinTraverse方法，首先应该判断输入的树是否为不为空就输出该节点的值，递归的输出左子树和右子树的值 求二叉树的深度BinTreeDepth函数的设计思路为：首先声明一个int类型的变量depthval，判断二叉树是否为空，不为空就递归的调用该方法求左子树右子树的深度，求完的时候还要在 depthLeft和depthRight中求最大值还要+1，该结果就是二叉树的深度。 求二叉树中所有结点数的BinTreeCount方法，首先要声明int类型的变量node，和求二叉树的深度的函数的设计方法相似，判断二叉树是否为空，不为空就递归的调用该方法求左子树右子树的节点，最后总的节点数为左子树+右子树+1。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107实验代码：#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;typedef char DataType;typedef struct BitNode &#123; DataType data; struct BitNode *lchild,*rchild;&#125;*BitTree;void BinTreeInit(BitTree &amp;BT) &#123; // 初始化二叉树，即把树根指针置空 BT=(BitTree)malloc(sizeof(BitNode)); BT-&gt;data=NULL; cout&lt;&lt;&quot; 二叉树初始化成功 !&quot;&lt;&lt;endl;&#125;int BinTreeCreat(BitTree &amp;BT) &#123; // 按先序次序建立一个二叉树 char ch; cin&gt;&gt;ch; if(ch==&#x27;#&#x27;) BT=NULL; else &#123; if(!(BT=(BitTree)malloc(sizeof(BitNode)))) exit(0); BT-&gt;data=ch; BinTreeCreat(BT-&gt;lchild); BinTreeCreat(BT-&gt;rchild); &#125; return 0;&#125;void BinTreeEmpty(BitTree &amp;BT) &#123; // 检查二叉树是否为空 if(BT-&gt;data==NULL) cout&lt;&lt;&quot; 是空二叉树 !&quot;&lt;&lt;endl; else cout&lt;&lt;&quot; 不是空二叉树 !&quot;&lt;&lt;endl;&#125;void BinTraverse(BitTree &amp;BT) &#123; // 先序序列遍历二叉树 if(BT!=NULL) &#123; cout&lt;&lt;BT-&gt;data; BinTraverse(BT-&gt;lchild); BinTraverse(BT-&gt;rchild); &#125;&#125;int BinTreeDepth(BitTree BT) &#123; // 求二叉树的深度 int depthval; if(BT)&#123; int depthLeft=BinTreeDepth(BT-&gt;lchild); int depthRight=BinTreeDepth(BT-&gt;rchild); depthval = 1+(depthLeft&gt;depthRight?depthLeft:depthRight); &#125; else depthval=0; return depthval;&#125;int BinTreeCount(BitTree BT) &#123; // 求二叉树中所有结点数 int node; if(BT) &#123; int lchild=BinTreeCount(BT-&gt;lchild); int rchild=BinTreeCount(BT-&gt;rchild); node=lchild+rchild+1; &#125; else node= 0; return node;&#125;int main() &#123; int i; BitTree BT; cout&lt;&lt;&quot;1 、初始化二叉树 :&quot;&lt;&lt;&quot;\\n2 、按先序序列建立二叉树 &quot;&lt;&lt;&quot;\\n3 、判断二叉树是否为空 :&quot;; cout&lt;&lt;&quot;\\n4 、先序序列遍历二叉树 &quot;&lt;&lt;&quot;\\n5 、求二叉树的深度 &quot;&lt;&lt;&quot;\\n6 、求二叉树节点的个数 &quot;&lt;&lt;endl; for(;;) &#123; cout&lt;&lt;&quot; 输出你所需的操作 :&quot;; cin&gt;&gt;i; if(i==1) BinTreeInit(BT); else if(i==2) &#123; cout&lt;&lt;&quot; 输入你要建立的二叉树 :&quot;&lt;&lt;endl; BinTreeCreat(BT); &#125; else if(i==3) BinTreeEmpty(BT); else if(i==4) BinTraverse(BT); else if(i==5) cout&lt;&lt;&quot; 二叉树的深度 :&quot;&lt;&lt;BinTreeDepth(BT)&lt;&lt;endl; else if(i==6) cout&lt;&lt;&quot; 二叉树的节点数 &quot;&lt;&lt;BinTreeCount(BT)&lt;&lt;endl; else return 0; &#125; return 0;&#125;/*实验结果：1 、初始化二叉树 :2 、按先序序列建立二叉树3 、判断二叉树是否为空 :4 、先序序列遍历二叉树5 、求二叉树的深度6 、求二叉树节点的个数 输出你所需的操作 :1 二叉树初始化成功 ! 输出你所需的操作 :2 输入你要建立的二叉树 :1 2 4 # # 5 # # 3 # 6 # # 输出你所需的操作 :3 不是空二叉树 ! 输出你所需的操作 :4124536 输出你所需的操作 :5 二叉树的深度 :3 输出你所需的操作 :6 二叉树的节点数 6 */ 上机实验六 实验题目 ： 图的 存储与遍历实验目的 ：掌握有向图和无向图的概念；掌握邻接矩阵和邻接链表建立图的存储结构；掌握 DFS 及BFS 对图的遍历操作。实验要求：采用邻接矩阵作为图的存储结构，完成有向图和无向图的 DFS 和 BFS 操作。实验主要步骤：设计一个有向图和一个无向图，任选一种存储结构，完成有向图和无向图的 DFS（深度优先遍历）和 BFS（广度优先遍历）的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include&quot;stdio.h&quot;#include&quot;stdlib.h&quot;#define MaxVertexNum 100//定义最大顶点数typedef struct &#123; char vexs[MaxVertexNum]; //顶点表 int edges[MaxVertexNum][MaxVertexNum]; //邻接矩阵，可看作边表 int n,e; //图中的顶点数 n 和边数 e&#125; MGraph;//用邻接矩阵表示的图的类型//=========建立邻接矩阵=======void CreatMGraph(MGraph *G) &#123; int i,j,k; char a; printf(&quot;Input VertexNum(n) and EdgesNum(e): &quot;); scanf(&quot;%d,%d&quot;,&amp;G-&gt;n,&amp;G-&gt;e); //输入顶点数和边数 scanf(&quot;%c&quot;,&amp;a); printf(&quot;Input Vertex string:&quot;); for(i=0; i&lt;G-&gt;n; i++) &#123; scanf(&quot;%c&quot;,&amp;a); G-&gt;vexs[i]=a; //读入顶点信息，建立顶点表 &#125; for(i=0; i&lt;G-&gt;n; i++) for(j=0; j&lt;G-&gt;n; j++) G-&gt;edges[i][j]=0; //初始化邻接矩阵 printf(&quot;Input edges,Creat Adjacency Matrix\\n&quot;); for(k=0; k&lt;G-&gt;e; k++) &#123; //读入 e 条边，建立邻接矩阵 scanf(&quot;%d%d&quot;,&amp;i,&amp;j); //输入边（Vi，Vj）的顶点序号 G-&gt;edges[i][j]=1; G-&gt;edges[j][i]=1; //若为无向图，矩阵为对称矩阵；若建立有向图，去掉该条语句 &#125;&#125; //=========定义标志向量，为全局变量=======typedef enum &#123;FALSE,TRUE&#125; Boolean;Boolean visited[MaxVertexNum];//========DFS：深度优先遍历的递归算法======void DFSM(MGraph *G,int i) &#123;//以 Vi 为出发点对邻接矩阵表示的图 G 进行 DFS 搜索，邻接矩阵是 0，1 矩阵 int j; printf(&quot;%c&quot;,G-&gt;vexs[i]); //访问顶点 Vi visited[i]=TRUE; //置已访问标志 for(j=0; j&lt;G-&gt;n; j++) //依次搜索 Vi 的邻接点 if(G-&gt;edges[i][j]==1 &amp;&amp; ! visited[j]) DFSM(G,j); //（Vi，Vj）∈E，且 Vj 未访问过，故 Vj 为新出发点&#125;void DFS(MGraph *G) &#123; int i; for(i=0; i&lt;G-&gt;n; i++) visited[i]=FALSE; //标志向量初始化 for(i=0; i&lt;G-&gt;n; i++) if(!visited[i]) //Vi 未访问过 DFSM(G,i); //以 Vi 为源点开始 DFS 搜索&#125;//===========BFS：广度优先遍历=======void BFS(MGraph *G,int k) &#123; //以 Vk 为源点对用邻接矩阵表示的图 G 进行广度优先搜索 int i,j,f=0,r=0; int cq[MaxVertexNum]; //定义队列 for(i=0; i&lt;G-&gt;n; i++) visited[i]=FALSE; //标志向量初始化 for(i=0; i&lt;G-&gt;n; i++) cq[i]=-1; //队列初始化 printf(&quot;%c&quot;,G-&gt;vexs[k]); //访问源点 Vk visited[k]=TRUE; cq[r]=k; //Vk 已访问，将其入队。注意，实际上是将其序号入队 while(cq[f]!=-1) &#123; //队非空则执行 i=cq[f]; f=f+1; //Vf 出队 for(j=0; j&lt;G-&gt;n; j++) //依次 Vi 的邻接点 Vj if(G-&gt;edges[i][j]==1 &amp;&amp; !visited[j]) &#123; //Vj 未访问 printf(&quot;%c&quot;,G-&gt;vexs[j]); //访问 Vj visited[j]=TRUE; r=r+1; cq[r]=j; //访问过 Vj 入队 &#125; &#125;&#125; //==========main=====int main() &#123; int i; MGraph *G; G=(MGraph *)malloc(sizeof(MGraph)); //为图 G 申请内存空间 CreatMGraph(G); //建立邻接矩阵 printf(&quot;Print Graph DFS: &quot;); DFS(G); //深度优先遍历 printf(&quot;\\n&quot;); printf(&quot;Print Graph BFS: &quot;); BFS(G,3); //以序号为 3 的顶点开始广度优先遍历 printf(&quot;\\n&quot;); system(&quot;pause&quot;); return 0;&#125;/* 实验结果： Input VertexNum(n) and EdgesNum(e): 8,9Input Vertex string:01234567Input edges,Creat Adjacency Matrix0 10 21 31 42 52 63 74 75 6Print Graph DFS: 01374256Print Graph BFS: 31704256 预习报告： 1,在树形结构中，数据元素之间有着明显的层次关系，并且每一层 中和上一层中的元素可能和下一层中的多个元素相关；而在图的 结构中，节点之间的关系可以是任意的，图中任意两个数据元素之间 都有可能相关。 2. 关于图的一些基本术语，邻接点：对于无向图G，如果图的边(v,v&#x27;) 属于E，那么顶点v,v&#x27;互为邻接点。 路径：从一个顶点到另一个顶点的顶点序列叫做路径。 路径长度：是一条路径上经过的边或弧的数目。 连通：在无向图中，两个顶点之间存在路径，就说这两个顶点是连通的。 实验心得： 1.深度优先搜索遍历类似于数的先序遍历，是树的先序遍历的推广。 本实验中：首先进行标志向量初始化，对没有访问过的节点进行 DFS搜索，对于顶点vi进行搜索时，先输出本节点的值，在输出与本节点 的邻接点。这样就对整个图进行了搜索。 2.广度优先搜索遍历类似于数的按层次遍历的过程，设x和y是来给你个相继 被访问的顶点，若当前是以x为出发点进行搜索，则在访问x的所有未曾访问 过的领节点之后，紧接着是以y为出发点进行横向搜索； 3.本此实验中用到的是邻接矩阵，骑士表示是顶点之间相邻关系的矩阵， 用他表示图，可以很容易的通过邻接矩阵的值来判断两个顶点之间是否有边 也很容易的计算各个顶点的度。 */ 上机实验七 题目： 顺序查找与二分查找【 实验目的 】本次实习的主要目的在于熟悉顺序表和有序表的查找方法和特点。其中以熟悉各种顺序表的操作为侧重点。通过本次实习还可帮助读者复习高级语言的使用方法。【实验要求】【问题描述】①建立一个查找表，使用顺序查找算法对其元素进行查找，并输出查找时比较的元素和最终的比较的次数。如果没有找到，则把该元素插入到该查找表中。②建立一个有序查找表，使用二分查找算法对其元素进行查找，并输出查找时比较的元素和最终的比较的次数；如果没有找到，则把该元素插入到该查找表中。【基本要求】查找过程中，同时输出查找时比较的元素和最终的比较的次数，当没有找到元素时输出“没有此元素”，然后把该元素插入到该查找表中；否则输出此元素在查找表中的位置。【测试数据】1、查找表中的元素{1，5，7，2，8，9，6，0，4，3}，查找元素为 8，查找元素 10。2、查找表中的元素{0，1，2，3，4，5，6，7，8，9}，查找元素为 8，查找元素 10。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;math.h&gt;#include&lt;process.h&gt; // exit()函数包含在此头文件中 #define LIST_INIT_SIZE 100 // 初始化大小#define LISTINCREMENT 15#define EQ(a,b) ((a)==(b))#define LT(a,b) ((a)&lt;(b))#define LQ(a,b) ((a)&lt;=(b))#define MT(a,b) ((a)&gt;(b))#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define OVERFLOW 0typedef int ElemType; // 基本(元素)类型typedef struct &#123; ElemType * elem; int length; int listsize;&#125; SSTable;int InitTable(SSTable *L)// 操作结果：构造一个空的顺序线性表&#123; (*L).elem=(ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType)); if(!(*L).elem) // 存储分配失败 exit(OVERFLOW); (*L).length=0; // 空表长度为 0 (*L).listsize=LIST_INIT_SIZE; // 初始存储容量 return OK;&#125;int TableInsert(SSTable *L,int i,ElemType e)// 初始条件：顺序线性表 L 已存在，1≤i≤ListLength(L)+1 。操作结果：在 L 中第 i 个位置//之前插入新的数据元素 e，L 的长度加 1&#123; ElemType *newbase,*q,*p; if(i&lt;1||i&gt;(*L).length+1) // i 值不合法 return ERROR; if((*L).length&gt;=(*L).listsize) &#123; // 当前存储空间已满，增加分配 newbase=(ElemType *)realloc((*L).elem,((*L).listsize+LISTINCREMENT)*sizeof(ElemType)); if(!newbase) // 存储分配失败 exit(OVERFLOW); (*L).elem=newbase; // 新基址 (*L).listsize+=LISTINCREMENT; // 增加存储容量 &#125; q=(*L).elem+i-1; // q 为插入位置 for(p=(*L).elem+(*L).length-1; p&gt;=q; --p) // 插入位置及之后的元素右移 *(p+1)=*p; *q=e; // 插入 e ++(*L).length; // 表长增 1 return OK;&#125;int Search_Seq(SSTable ST,ElemType key) &#123;//在顺序表 ST 中顺序查找其关键字等于 key 的数据元素。若找到，则函数值为该元素 //在表中的位置，否则为 0。 int i,j,k=0; for(i=ST.length-1; !EQ(ST.elem[i],key)&amp;&amp;i&gt;=0; --i) &#123; //从后往前找，因为啥？？不从头忘后找呀 k++; printf(&quot;比较的元素为：%d\\n&quot;,ST.elem[i]); &#125; if(!EQ(ST.elem[i],key)) &#123; //这句话就是在for循环比较完了之后在判断 //一下，如果表中没有这个key就添加进去， //否则就输出比较的次数 printf(&quot;查找该元素，比较的次数为：%d\\n&quot;,k); j=TableInsert(&amp;ST,ST.length+1,key); return 1; &#125; else &#123; k++; printf(&quot;比较的元素为：%d\\n&quot;,ST.elem[i]); printf(&quot;查找该元素，比较的次数为：%d\\n&quot;,k); return 0; &#125;&#125;int Search_Bin(SSTable ST,ElemType key) &#123;//在有序表 ST 中折半查找其他关键字等于 key 的数据元素。若找到，则函数值为该元 //素在表中的位置，否则为 0。 int low,high,mid,j,k=0; low=0; high=ST.length-1; //置区间初值 while(low&lt;=high) &#123; mid=(low+high)/2; if(EQ(key,ST.elem[mid])) &#123; k++; printf(&quot;比较的元素为：%d\\n&quot;,ST.elem[mid]); printf(&quot;查找该元素，比较的次数为：%d\\n&quot;,k); //找到待查元素 return 0; &#125; else if(LT(key,ST.elem[mid])) &#123; k++; printf(&quot;比较的元素为：%d\\n&quot;,ST.elem[mid]); high=mid-1; //继续在前半区间进行查找 &#125; else if(MT(key,ST.elem[mid])) &#123; k++; printf(&quot;比较的元素为：%d\\n&quot;,ST.elem[mid]); low=mid+1; &#125; &#125; if(!EQ(key,ST.elem[mid])) &#123; printf(&quot;查找该元素，比较的次数为：%d\\n&quot;,k);//没有找到待查元素 if(LT(key,ST.elem[mid])) j=TableInsert(&amp;ST,mid+1,key); else if(MT(key,ST.elem[mid])) j=TableInsert(&amp;ST,ST.length+1,key); &#125; return 1;&#125;int Menu() &#123; int choice; printf(&quot;************************\\n&quot;); printf(&quot; 1.新建静态查找表\\n&quot;); printf(&quot; 2.输出静态查找表\\n&quot;); printf(&quot; 3.顺序查找\\n&quot;); printf(&quot; 4.二分查找查找\\n&quot;); printf(&quot; 5.退出\\n&quot;); printf(&quot;============================\\n&quot;); printf(&quot;请选择：&quot;); scanf(&quot;%d&quot;, &amp;choice); return choice;&#125;void print(ElemType *c) &#123; printf(&quot;%d &quot;,*c);&#125;int main() &#123; SSTable L; int i,j,k,m,n,ch; while (ch!=5) &#123; ch=Menu(); switch(ch) &#123; case 1: printf(&quot;请输入表 L 的元素个数 n 的值：&quot;); scanf(&quot;%d&quot;,&amp;n); InitTable(&amp;L); // 创建空表 L 成功 printf(&quot;请输入顺序表 L 的%d 个元素（格式为：元素 1 元素 2）：\\n&quot;,n); for(j=1; j&lt;=n; j++) &#123; // 在表 L 中插入 n 个元素 scanf(&quot;%d&quot;,&amp;k); i=TableInsert(&amp;L,j,k); &#125; break; case 2: printf(&quot;顺序表 L 的元素分别为：&quot;); // 输出表 L 的内容 for(i=0; i&lt;L.length; i++) print(&amp;L.elem[i]); printf(&quot;\\n&quot;); break; case 3: printf(&quot;请输入查找的元素的值 m(顺序查找)：&quot;); scanf(&quot;%d&quot;,&amp;m); if(Search_Seq(L,m)) L.length=L.length+1; break; case 4: printf(&quot;请输入查找的元素的值 m(折半查找)：&quot;); scanf(&quot;%d&quot;,&amp;m); if(Search_Bin(L,m)) L.length=L.length+1; break; case 5: printf(&quot;结束程序。\\n&quot;); return 0; break; default: printf(&quot;输入错误！请重新输入！\\n\\n&quot;); break; &#125; &#125;&#125;/* 测试数据1：************************ 1.新建静态查找表 2.输出静态查找表 3.顺序查找 4.二分查找查找 5.退出============================请选择：1请输入表 L 的元素个数 n 的值：10请输入顺序表 L 的10 个元素（格式为：元素 1 元素 2）：1 5 7 2 8 9 6 0 4 3************************ 1.新建静态查找表 2.输出静态查找表 3.顺序查找 4.二分查找查找 5.退出============================请选择：2顺序表 L 的元素分别为：1 5 7 2 8 9 6 0 4 3************************ 1.新建静态查找表 2.输出静态查找表 3.顺序查找 4.二分查找查找 5.退出============================请选择：3请输入查找的元素的值 m(顺序查找)：8比较的元素为：3比较的元素为：4比较的元素为：0比较的元素为：6比较的元素为：9比较的元素为：8查找该元素，比较的次数为：6 (因为是从后往前比较的)************************ 1.新建静态查找表 2.输出静态查找表 3.顺序查找 4.二分查找查找 5.退出============================请选择：4请输入查找的元素的值 m(折半查找)：10比较的元素为：8比较的元素为：0比较的元素为：4比较的元素为：3查找该元素，比较的次数为：4************************ 1.新建静态查找表 2.输出静态查找表 3.顺序查找 4.二分查找查找 5.退出============================请选择：5结束程序。测试数据 2：************************ 1.新建静态查找表 2.输出静态查找表 3.顺序查找 4.二分查找查找 5.退出============================请选择：1请输入表 L 的元素个数 n 的值：10请输入顺序表 L 的10 个元素（格式为：元素 1 元素 2）：0 1 2 3 4 5 6 7 8 9************************ 1.新建静态查找表 2.输出静态查找表 3.顺序查找 4.二分查找查找 5.退出============================请选择：2顺序表 L 的元素分别为：0 1 2 3 4 5 6 7 8 9************************ 1.新建静态查找表 2.输出静态查找表 3.顺序查找 4.二分查找查找 5.退出============================请选择：3请输入查找的元素的值 m(顺序查找)：8比较的元素为：9比较的元素为：8查找该元素，比较的次数为：2************************ 1.新建静态查找表 2.输出静态查找表 3.顺序查找 4.二分查找查找 5.退出============================请选择：4请输入查找的元素的值 m(折半查找)：10比较的元素为：4比较的元素为：7比较的元素为：8比较的元素为：9查找该元素，比较的次数为：4************************ 1.新建静态查找表 2.输出静态查找表 3.顺序查找 4.二分查找查找 5.退出============================请选择：5结束程序。预习报告：1.顺序查找定义：从线性表中的第一个（或最后一个） 数据元素开始，逐个进行数据元素关键字和给定值的比 较，若某个数据元素的关键字和给定值相等则查找成功； 如果直到最后一个（或第一个） 数据元素，其关键字和给定值都不等时，则查找失败。 若有n个数据，其查找次数为（n+1）/2；2.折半查找：先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或找不到记录为止。基本思想：首先将查找表进行排序；取中间数据元素进行比较； 当给定值与中间数据元素的关键字相等时，查找成功； 当给定值小于中间元素时，在中间元素左区间进行二分查找； 当给定值大于中间元素时，在中间元素右区间进行二分查找；当任意区间均无记录时，查找失败。其时间复杂度是O(log2 n)实验心得：1. TableInsert方法： 顺序线性表 L 已存在，1≤i≤ListLength(L)+1 。操作结果：在 L 中第 i 个位置之前插入新的数据元素 e，L 的长度加 1 。 其中一个重要的思想就是在插入位置之后的元素要 从最后一个元素开始位往后移。并且表长+12. Search_Seq方法的目的是在顺序表 ST 中顺序查找其关键字等于 key 的数据元素。若找到，则函数值为该元素 在表中的位置，否则为 0。 在for循环比较完了之后在判断一下，如果表中没有这个key就添加进去，否则就输出比较的次数。其中for循环这样设计会减少判断是否到达表尾的次数从而一定程度上加快程序执行的速度。3.Search_Bin方法 的执行结果是有序表 ST 中折半查找其他关键字等于key 的数据元素。若找到，则函数值为该元素在表中的位置，否则为 0。在这个方法中用到了折半查找的思维， 首先将查找的整个区间的左端点置为0，右端点 置为表长-1；然后进行while语句，其中while的 判断条件是low&lt;=high;因为当退出本循环的时候 双指针会交错；如果key和mid的值相等就输出该比较的 元素，如果key小于mid就对左半区间查找，若果key 大于mid就对右半区间查找。*/ 实验题目： 内部排序【 实验目的 】１． 掌握常见的排序算法的思想及其适用条件。２． 掌握常见的排序算法的程序实现。【实验要求】输入一组关键字序列分别实现下列排序: : 实现直接插入排序、折半插入排序和希尔排序算法。 实现直接插入排序、折半插入排序和希尔排序算法。 实现 实现 快速排序算法。 实现归并排序算法。 实现归并排序算法。 在主函数中设计一个简单的菜单，分别测试上述算法。 在主函数中设计一个简单的菜单，分别测试上述算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350#include&lt;string.h&gt;#include&lt;ctype.h&gt;#include&lt;malloc.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include &quot;iostream&quot;//函数结果状态代码#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1typedef int Status;typedef int Boolean;//对两个数值型关键字的比较#define EQ(a,b) ((a)==(b))#define LT(a,b) ((a)&lt;(b))#define LQ(a,b) ((a)&lt;=(b))//待排记录的数据类型#define MAXSIZE 20 //一个用作示例的小顺序表的最大长度typedef int KeyType; //定义关键字类型为整型typedef int InfoType; //定义其它数据项的类型typedef struct &#123; KeyType key; //关键字项 InfoType otherinfo;//其他数据项&#125; RedType; //记录类型typedef struct &#123; RedType r[MAXSIZE+1];//r[0]闲置或用作哨兵单元 int length;//顺序表长度&#125; SqList; //顺序表类型typedef SqList HeapType; // 堆采用顺序表存储表示//顺序表插入排序的函数void InsertSort(SqList &amp;L);void BInsertSort(SqList &amp;L);void ShellInsert(SqList &amp;L,int dk);void ShellSort(SqList &amp;L,int dlta[],int t);//快速排序int Partition(SqList &amp;L,int low,int high);void QSort(SqList &amp;L,int low,int high);void QuickSort(SqList &amp;L);//归并排序void Merge(RedType SR[],RedType TR[],int i,int m,int n);void MSort(RedType SR[],RedType TR1[],int s, int t);void MergeSort(SqList &amp;L);//输出函数void print(SqList L);#define N 8#define T 3using namespace std;int main() &#123; RedType d[N]= &#123;&#123;20,6&#125;,&#123;52,1&#125;,&#123;65,3&#125;,&#123;88,9&#125;,&#123;47,8&#125;,&#123;22,4&#125;,&#123;39,5&#125;,&#123;74,7&#125;&#125;; int i; SqList LL; int dt[T]= &#123;5,3,1&#125;; // 增量序列数组 int choice;s123: cout&lt;&lt;&quot;请选择要使用的排序算法：\\n0..............退出\\n&quot;; cout&lt;&lt;&quot;1..............插入排序\\n2..............交换排序\\n&quot;; cout&lt;&lt;&quot;3..............归并排序\\n&quot;; cin&gt;&gt;choice; switch(choice) &#123; case 0: break; case 1: //插入排序 for(i=0; i&lt;N; i++) //给 LL.r 赋值 LL.r[i+1]=d[i]; LL.length=N; printf(&quot;直接插入排序前:\\n&quot;); print(LL); InsertSort(LL); printf(&quot;直接插入排序后:\\n&quot;); print(LL); for(i=0; i&lt;N; i++) LL.r[i+1]=d[i]; LL.length=N; printf(&quot;\\n 折半插入排序前:\\n&quot;); print(LL); BInsertSort(LL); printf(&quot;折半插入排序后:\\n&quot;); print(LL); for(i=0; i&lt;N; i++) LL.r[i+1]=d[i]; LL.length=N; printf(&quot;\\n 希尔排序前: \\n&quot;); print(LL); ShellSort(LL,dt,T); printf(&quot;希尔排序后: \\n&quot;); print(LL); goto s123; case 2: //交换排序 for(i=0; i&lt;N; i++) LL.r[i+1]=d[i]; LL.length=N; printf(&quot;快速排序前:\\n&quot;); print(LL); QuickSort(LL); printf(&quot;快速排序后:\\n&quot;); print(LL); goto s123; case 3: //归并排序 for(i=0; i&lt;N; i++) LL.r[i+1]=d[i]; LL.length=N; printf(&quot;归并排序前:\\n&quot;); print(LL); MergeSort(LL); printf(&quot;归并排序后:\\n&quot;); print(LL); goto s123; default: cout&lt;&lt;&quot;输入有误，请输入正确的选项！\\n&quot;; goto s123; &#125; return 0;&#125;//顺序表插入排序的函数(3 个)//InsertSortvoid InsertSort(SqList &amp;L) &#123; // 对顺序表 L 作直接插入排序。 int i,j; for(i=2; i&lt;=L.length; ++i) if(LT(L.r[i].key,L.r[i-1].key)) &#123; L.r[0]=L.r[i]; L.r[i]=L.r[i-1]; for(j=i-2; LT(L.r[0].key,L.r[j].key); --j) L.r[j+1]=L.r[j]; L.r[j+1]=L.r[0]; &#125;&#125;//BInsertSortvoid BInsertSort(SqList &amp;L) &#123; //对顺序表 L 作折半插入排序。 int low,high,m; for(int i=2; i&lt;=L.length; ++i) &#123; L.r[0]=L.r[i]; low=1; high=i-1; while(low&lt;=high) &#123; m=(low+high)/2; if(LT(L.r[0].key,L.r[m].key)) high=m-1; else low=m+1; &#125;//while for(int j=i-1; j&gt;=high+1; --j) L.r[j+1]=L.r[j]; L.r[high+1]=L.r[0]; &#125;//for&#125;//希尔排序 void ShellInsert(SqList &amp;L,int dk) &#123; //对顺序表 L 作一趟希尔插入排序。本算法是和一趟直接插入排序相比，作了以下修改：// 1.前后记录位置的增量是 dk,而不是 1;// 2.r[0]只是暂存单元,不是哨兵。当 j&lt;=0 时,插入位置已找到。 int i,j; for(i=dk+1; i&lt;=L.length; ++i) if LT(L.r[i].key,L.r[i-dk].key) &#123; //需将 L.r[i]插入有序增量子表 L.r[0]=L.r[i]; //暂存在 L.r[0] for(j=i-dk; j&gt;0&amp;&amp;LT(L.r[0].key,L.r[j].key); j-=dk) L.r[j+dk]=L.r[j]; //记录后移，查找插入位置 L.r[j+dk]=L.r[0]; //插入 &#125;&#125;void ShellSort(SqList &amp;L,int dlta[],int t) &#123; //按增量序列 dlta[0..t-1]对顺序表 L 作希尔排序。 int k; for(k=0; k&lt;t; ++k) &#123; ShellInsert(L,dlta[k]); //一趟增量为 dlta[k]的插入排序 printf(&quot;第%d 趟排序结果: \\n&quot;,k+1); print(L); &#125;&#125;//QuickSortint Partition(SqList &amp;L,int low,int high) &#123; //交换顺序表 L 中子表 r[low..high]的记录，枢轴记录到位，并返回其//所在位置，此时在它之前（后）的记录均不大（小）于它。 KeyType pivotkey; L.r[0]=L.r[low]; //用子表的第一个记录作枢轴记录 pivotkey=L.r[low].key; //枢轴记录关键字 while(low&lt; high) &#123; //从表的两端交替地向中间扫描 while(low&lt;high&amp;&amp;L.r[high].key&gt;=pivotkey) --high; L.r[low]=L.r[high]; //将比枢轴记录小的记录移到低端 while(low&lt;high&amp;&amp;L.r[low].key&lt;=pivotkey) ++low; L.r[high]=L.r[low]; //将比枢轴记录大的记录移到高端 &#125; L.r[low]=L.r[0]; //枢轴记录到位 return low; //返回枢轴位置&#125;void QSort(SqList &amp;L,int low,int high) &#123; //对顺序表 L 中的子序列 L.r[low..high]作快速排序。 if(low&lt;high) &#123; int pivotloc; pivotloc=Partition(L,low,high); QSort(L,low,pivotloc-1); QSort(L,pivotloc+1,high); &#125;//if&#125;//QSortvoid QuickSort(SqList &amp;L) &#123; //对顺序表 L 作快速排序。 QSort(L,1,L.length);&#125;//归并排序 void Merge(RedType SR[],RedType TR[],int i,int m,int n) &#123; //将有序的 SR[i..m]和 SR[m+1..n]归并为有序的 TR[i..n] int j,k,l; for(j=m+1,k=i; i&lt;=m&amp;&amp;j&lt;=n; ++k) //将 SR 中记录由小到大地并入 TR if LQ(SR[i].key,SR[j].key) TR[k]=SR[i++]; else TR[k]=SR[j++]; if(i&lt;=m) for(l=0; l&lt;=m-i; l++) TR[k+l]=SR[i+l]; //将剩余的 SR[i..m]复制到 TR if(j&lt;=n) for(l=0; l&lt;=n-j; l++) TR[k+l]=SR[j+l]; //将剩余的 SR[j..n]复制到 TR&#125;void MSort(RedType SR[],RedType TR1[],int s, int t) &#123; //将 SR[s..t]归并排序为 TR1[s..t]。 RedType TR2[MAXSIZE]; if(s==t) TR1[s]=SR[s]; else &#123; int m=(s+t)/2; MSort(SR,TR2,s,m); MSort(SR,TR2,m+1,t); Merge(TR2,TR1,s,m,t); &#125;&#125;void MergeSort(SqList &amp;L) &#123; //对顺序表 L 作归并排序。 MSort(L.r,L.r,1,L.length);&#125;void print(SqList L) &#123; int i; for(i=1; i&lt;=L.length; i++) printf(&quot; (%d,%d) &quot;,L.r[i].key,L.r[i].otherinfo); printf(&quot;\\n&quot;);&#125;/*实验结果： 请选择要使用的排序算法：0..............退出1..............插入排序2..............交换排序3..............归并排序1直接插入排序前: (20,6) (52,1) (65,3) (88,9) (47,8) (22,4) (39,5) (74,7)直接插入排序后: (20,6) (22,4) (39,5) (47,8) (52,1) (65,3) (74,7) (88,9) 折半插入排序前: (20,6) (52,1) (65,3) (88,9) (47,8) (22,4) (39,5) (74,7)折半插入排序后: (20,6) (22,4) (39,5) (47,8) (52,1) (65,3) (74,7) (88,9) 希尔排序前: (20,6) (52,1) (65,3) (88,9) (47,8) (22,4) (39,5) (74,7)第1 趟排序结果: (20,6) (39,5) (65,3) (88,9) (47,8) (22,4) (52,1) (74,7)第2 趟排序结果: (20,6) (39,5) (22,4) (52,1) (47,8) (65,3) (88,9) (74,7)第3 趟排序结果: (20,6) (22,4) (39,5) (47,8) (52,1) (65,3) (74,7) (88,9)希尔排序后: (20,6) (22,4) (39,5) (47,8) (52,1) (65,3) (74,7) (88,9)请选择要使用的排序算法：0..............退出1..............插入排序2..............交换排序3..............归并排序2快速排序前: (20,6) (52,1) (65,3) (88,9) (47,8) (22,4) (39,5) (74,7)快速排序后: (20,6) (22,4) (39,5) (47,8) (52,1) (65,3) (74,7) (88,9)请选择要使用的排序算法：0..............退出1..............插入排序2..............交换排序3..............归并排序3归并排序前: (20,6) (52,1) (65,3) (88,9) (47,8) (22,4) (39,5) (74,7)归并排序后: (20,6) (22,4) (39,5) (47,8) (52,1) (65,3) (74,7) (88,9) 预习报告： 1.直接插入排序的核心思想就是：将数组中的所 有元素依次跟前面已经排好的元素相比较，如果 选择的元素比已排序的元素小，则交换，直到全 部元素都比较过。 2.尔排序的算法思想：将待排序数组按照步长gap 进行分组，然后将每组的元素利用直接插入排序的 方法进行排序；每次将增量折半减小，循环上述操作 ；当增量=1时，利用直接插入，完成排序。 3.堆的概念堆：本质是一种数组对象。特别重要的一点性质：任意的叶子节点小于（或大于）它所有的父节点。对此，又分为大顶堆和小顶堆，大顶堆要求节点的元素都要大于其孩子，小顶堆要求节点元素都小于其左右孩子，两者对左右孩子的大小关系不做任何要求。利用堆排序，就是基于大顶堆或者小顶堆的一种排序方法。下面，我们通过大顶堆来实现。 实验心得： 1.在写冒泡排序的时候因为没有想到因为第一个位置 空闲不用，而导致写错了，是每次都把最小的冒到最上面 然后最大的就沉到最下面，从上向下就成了有序的。 所以冒泡排序思路为： 将序列当中的左右元素，依次比较，保证右边的元素始终大于左边的元素； （ 第一轮结束后，序列最后一个元素一定是当前序列的最大值；） 对序列当中剩下的n-1个元素再次执行步骤1。 对于长度为n的序列，一共需要执行n-1轮比较 （利用while循环可以减少执行次数） 2.快速排序的基本思想：挖坑填数+分治法 从序列当中选择一个基准数(pivot) 在这里我们选择序列当中第一个数最为基准数 将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧 重复步骤1.2，直到所有子集当中只有一个元素为止。 用伪代码描述如下： 1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。 2．j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。 3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。 4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中3.基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[ ]对新形成的序列L[]重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束 */","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"aoyuehan"},{"title":"排序算法","slug":"排序算法","date":"2019-10-01T01:25:00.000Z","updated":"2022-02-26T03:52:52.104Z","comments":true,"path":"2019/10/01/排序算法/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/10/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"冒泡排序和选择排序 冒泡排序的本质就是交换，选择排序的本质就是求最大最小， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int g; void bubblesort(int a[],int g); void selectsort(int a[],int g) ; while(1)&#123; if((cin&gt;&gt;g)==0)break; int a[g]; for(int i=0;i&lt;g;i++) cin&gt;&gt;a[i]; //selectsort(a,g); bubblesort(a,g); for(int i=0;i&lt;g;i++)&#123; if(i==g-1) cout&lt;&lt;a[i]&lt;&lt;endl; else cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; &#125;&#125;//冒泡排序 void bubblesort(int a[],int n) &#123; //把最大的冒到最后一个，倒数第二个，依次进行 int temp; for(int i=0;i&lt;=n-1;i++) //n-1是小一位数 ,因为外循环要比n-1次，如三次比两次就好了 for(int j=0;j&lt;=n-i-1;j++) //不能j=i+1 /*也可以这样写 for(int i=1;i&lt;n;i++) for(int j=0;j&lt;n-i;j++) //1 n 0 n-i */ if(a[j]&gt;a[j+1])&#123; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; //a[j+1]=temp;这行是a[j+1]而不是 a[j] //或者 swap(a[j],a[j+1]); &#125; &#125; //选择排序void selectsort(int a[],int n) &#123; //if(a[j]&lt;a[index]) index=j; index存放最小值（最大值）的下标 //就是把最小的换到第一个位置 ，第二小的换到第二位置，依次排列 int temp,index; for(int i=0;i&lt;n-1;i++)&#123; //比较n-1次就行了 0 n-1 i+1 n index=i; //假设i=0为最小值（最大值）的下标 for(int j=i+1;j&lt;n;j++) //是j&lt;n而不是n-1 if(a[j]&lt;a[index]) index=j; temp=a[index]; //最小值（最大值）与下标为i的换 a[index]=a[i]; a[i]=temp; &#125; &#125; 插入排序（挪动数组）123456789101112131415161718192021222324//插入排序实现从小到大排列（若果想从大到小排列，那么改为if（a[k-1）&lt;x） a[k]=a[k-1],这样的话就是当前位置的数比x小就往后移。#include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; #define N 5 int a[N];//有序数组 int main ( ) &#123; int i, k, x; printf(&quot;Please input %d numbers:\\n&quot;,N); for (i=0; i&lt;N; i++) &#123; scanf (&quot;%d&quot;, &amp;x); for ( k=i; k&gt;0; k-- ) &#123; /* 从后向前比较 */ if ( a[k-1] &gt; x ) //x前面的数比它大 a[k]=a[k-1]; /* 将大数向后移动*/ else break; /* 找到插入的位置，退出 */ &#125; a[k] = x; /* 完成插入操作 */ &#125; for (i=0; i&lt;N; i++) printf(&quot;%d &quot;, a[i]); return 0; &#125; 快速排序（分治法的一个体现） 快排之单向扫描分区法 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;//快速排序单向扫描分区法 void swap(int A[],int p,int r)&#123; //交换数组A下标为p和r的值 int tmp=A[p]; A[p]=A[r]; A[r]=tmp; &#125;int partition(int A[],int p,int r)&#123; int pivot=A[p];//初始化pivot(主元)指向A[p],就是最靠左的位置 int sp=p+1; //扫描指针 int bigger=r; //右侧指针 while(sp&lt;=bigger)&#123; //bigger指向的 if(A[sp]&lt;=pivot) //扫描元素小于主元，右指针向右移 sp++; else&#123; swap(A,sp,bigger);//扫描元素大于主元，二指针的元素互换，右指针左移 bigger--; &#125; &#125; swap(A,p,bigger); return bigger;&#125;void quickSort(int A[],int p,int r)&#123; if(p&lt;r)&#123; int q=partition(A,p,r); quickSort(A,p,q-1); quickSort(A,q+1,r); &#125;&#125;int main()&#123; int a[]=&#123;11,9,2,9,4,6&#125;; quickSort(a,0,5);//因为从0开始存的，所以此时的右侧指针为下标5 for(int i=0;i&lt;6;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;&#125; 双向扫描法 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;//快速排序双向扫描分区法 //void swap(int A[],int p,int r)&#123;// //交换数组A下标为p和r的值 // int tmp=A[p];// A[p]=A[r];// A[r]=tmp;// 可以用stl中的swap函数来交换两个数或数组的值 //&#125;int partition2(int A[],int p,int r)&#123; int pivot=A[p];//初始化pivot(主元)指向A[p],就是最靠左的位置 int left=p+1; //左侧指针 int right=r; //右侧指针 while(left&lt;=right)&#123; //left不停的往右走，直到遇到大于主元的元素 while(left&lt;=right&amp;&amp;A[left]&lt;=pivot)left++; //上面这个循环退出时，left一定是指向第一个大于主元的位置 while(left&lt;=right&amp;&amp;A[right]&gt;pivot)right--; //上面这个循环退出时，right一定是指向最后一个小于或等于主元的位置 if(left&lt;right) swap(A[left],A[right]); &#125; //while退出时，两者相错，且right指向的是最后一个小于等于主元的位置，也就是主元应该待的位置 swap(A[p],A[right]); return right;&#125;void quickSort(int A[],int p,int r)&#123; if(p&lt;r)&#123; int q=partition2(A,p,r); quickSort(A,p,q-1); quickSort(A,q+1,r); &#125;&#125;int main()&#123; int a[]=&#123;11,9,2,9,4,6&#125;; quickSort(a,0,5); for(int i=0;i&lt;6;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;&#125; 三指针分区法 123456789101112131415161718192021222324252627282930313233343536373839404142434445void quickSort(int a[], int low, int high)&#123; if (low &lt;= high) return; int i = low; int j = high; int key = a[i]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; a[j] &gt;= key) --j; a[i] = a[j]; while (i &lt; j &amp;&amp; a[i] &lt;= key) ++i; a[j] = a[i]; &#125; a[i] = key; quickSort(a, low, i - 1); quickSort(a, i + 1, high);&#125; 3.6 快排在工程实践中的优化 希尔排序 希尔排序的过程 希尔排序在排序前：将一个序列分成了好几个序列 在第一趟排序时：将这几个序列做插入排序。 在第二趟排序时：将这个序列又分了好几个序列做插入排序。 ……………. 在第n趟排序时：将原序列进行插入排序，从宏观上看，此序列就基本是有序的了。这时就用简单插入排序将数列直至已序 从直观上看希尔排序： 就是把数列进行分组(不停使用插入排序)，直至从宏观上看起来有序，最后插入排序起来就容易了(无须多次移位或交换)。就是increase后面的第一个分组中的元素和数列的第一个分组比较，然后后面第二个分组和数列的第二个分组比较．．．． 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//希尔排序的ｊａｖａ实现数组从小到大排列public static void shellSort(int[] nums)&#123; for(int increase = nums.length/2;increase &gt; 0;increase/=2)&#123;//increase为希尔排序增量 //对每一个增量序列进行插入排序 for(int i = increase;i&lt;nums.length;i++)&#123; int target = nums[i]; int j = i - increase; while(j&gt;=0 &amp;&amp; target&lt;nums[j])&#123; nums[j+increase] = nums[j]; j = j - increase; //进行下一组的排序 &#125; nums[j+increase] = target; &#125; &#125;&#125;c++的实现#include&lt;bits/stdc++.h&gt;using namespace std;template &lt;typename T&gt; void ShellSort(T *array, const int length)&#123; int gap = length/2; do&#123;//第一次因为length不为0，所以肯定能执行一次while语句 T tmp; for(int i=gap; i&lt;length; ++i)&#123; tmp = array[i]; int j = i; while(j&gt;=gap &amp;&amp; tmp&lt;array[j-gap])&#123; array[j] = array[j-gap]; j-=gap; &#125; array[j] = tmp; &#125; gap/=2; &#125;while(gap);&#125;int main()&#123; int a[5]=&#123;12,1,6,3,2&#125;; ShellSort(a,5); for(int i=0;i&lt;5;i++)cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;&#125; 归并排序 #include&lt;bits/stdc++.h&gt; using namespace std; //归并过程 void merge(int arr[], int l, int mid, int r)&#123; int help[r-l+1];//辅助数组 int i = 0; int lIndex = l; int rIndex = mid+1; while(lIndex &lt;= mid &amp;&amp; rIndex &lt;= r)&#123; help[i++] = arr[lIndex] &lt; arr[rIndex] ? arr[lIndex++]:arr[rIndex++]; &#125; //左边和右边肯定有一边到头了，不可能同时，因为每次只移动一边 while(lIndex &lt;= mid)&#123; help[i++] = arr[lIndex++]; &#125; while(rIndex &lt;= r)&#123; help[i++] = arr[rIndex++]; &#125; //将排好序的辅助数组赋值给原始数组，不需要返回值 for(i = 0; i &lt; r-l+1; i++)&#123; arr[l+i] = help[i]; &#125; &#125; //递归 static void mergeSort(int arr[], int l, int r)&#123; if(l == r)&#123; return; &#125; int mid = (l + r) / 2; //左半部分归并排序 mergeSort(arr, l, mid); //右半部分归并排序 mergeSort(arr, mid+1, r); //左右部分归并 merge(arr, l, mid, r); &#125; //归并排序整个数组 void mergeSort(int arr[], int n)&#123; //如果数组为空或只有一个元素，不需要排序 if(arr == NULL || n &lt; 2)&#123; return; &#125; mergeSort(arr,0,n-1); &#125; int main()&#123; int n; while(cin &gt;&gt; n)&#123; int arr[n]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i]; mergeSort(arr, n); for(int i = 0; i &lt; n; i++)&#123; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0; &#125; 堆排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*堆排序最差时间复杂度：O(nlogn)最优时间复杂度：O(nlogn)平均时间复杂度：O(nlogn)稳定性：不稳定堆排序，利用堆这种数据结构设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足性质：即子节点的键值或索引总是小于（或者大于）它的父节点。通常堆是通过一维数组来实现的，在起始数组为0的情形中，对于节点i：其左子节点的下标为 (2*i+1)；其右子节点的下标为 (2*i+2)；其父节点的下标为 floor((i-1)/2)。在堆的数据结构中，堆中的最大值总是位于根节点。堆中定义一下三个操作：1.最大堆调整（Max Heapify）：在假定节点i的左右子节点为根的两棵二叉树都是最大堆的前提下，确保父节点大于子节点，否则下降原父节点，最终使以i为根的子树成为最大堆。2.创建最大堆（Build Max Heap）：将堆所有数据重新排序，对所有非叶子节点调用一次Max Heapify。3.堆排序（Heap Sort）：首先创建最大堆，然后依次将堆的根节点与末节点交换、剔除末节点、对根节点进行最大堆调整，直到堆中的节点数为1，排序结束。*/template &lt;typename T&gt; void MaxHeapify(T *array, int i, int heapSize)&#123; int l = 2*i+1; int r = 2*i+2; int tmp = i; if(l&lt;=heapSize &amp;&amp; array[l]&gt;array[i])&#123; tmp = l; &#125;else&#123; tmp = i; &#125; if(r&lt;=heapSize &amp;&amp; array[r]&gt;array[tmp])&#123; tmp = r; &#125; if(tmp != i)&#123; swap(array[i], array[tmp]); MaxHeapify(array, tmp, heapSize); &#125;&#125;template &lt;typename T&gt; void HeapSort(T *array, const int length)&#123; if(array == NULL)&#123; throw invalid_argument(&quot;Array must not be empty&quot;); &#125; if(length&lt;=0) return; for(auto i = length/2; i&gt;=0; --i)&#123; //构建最大堆 MaxHeapify(array, i, length-1); &#125; for(auto i = length-1; i&gt;=0; --i)&#123; swap(array[0], array[i]); MaxHeapify(array, 0, i-1); &#125;&#125; sort函数的时间复杂度为 O(N log(N)) 这篇将排序将的很好https://www.imooc.com/article/9429","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"author":"aoyuehan"},{"title":"大数运算","slug":"大数运算","date":"2019-10-01T00:53:00.000Z","updated":"2022-02-26T03:52:51.178Z","comments":true,"path":"2019/10/01/大数运算/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/10/01/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/","excerpt":"","text":"首先是java的BigInter类的大数运算：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package big_shu_yunsuan;import java.util.*;import java.math.*;public class Main&#123; public static void main(String args[])&#123; Scanner cin = new Scanner(System.in); BigInteger a, b; //声明两个大整数变量 //以文件EOF结束 while (cin.hasNext())&#123; a = cin.nextBigInteger(); b = cin.nextBigInteger(); BigInteger bi1 = new BigInteger(&quot;123456789&quot;) ; // 声明BigInteger对象;还可以这样声明 System.out.println(a.add(b)); //大整数加法;a+b System.out.println(a.subtract(b)); //大整数减法;a-b System.out.println(a.multiply(b)); //大整数乘法; a*b System.out.println(a.divide(b)); //大整数除法(取整); a/b System.out.println(a.remainder(b)); //大整数取模 System.out.println(a.mod(b));//取余 System.out.println(a.gcd(b));//最大公约数GCD System.out.println(a.abs());//取绝对值 System.out.println(a.negate());//取反 System.out.println(a.max(b));//取最大值 System.out.println(a.min(b));//取最小值 System.out.println(a.equals(b)); //是否相等 //大整数的比较 if( a.compareTo(b) == 0 ) System.out.println(&quot;a == b&quot;); //大整数a==b else if( a.compareTo(b) &gt; 0 ) System.out.println(&quot;a &gt; b&quot;); //大整数a&gt;b else if( a.compareTo(b) &lt; 0 ) System.out.println(&quot;a &lt; b&quot;); //大整数a&lt;b //大整数绝对值 System.out.println(a.abs()); //大整数a的绝对值 //大整数的幂 int exponent=10; System.out.println(a.pow(exponent)); //大整数a的exponent次幂 //返回大整数十进制的字符串表示 System.out.println(a.toString()); //返回大整数p进制的字符串表示 int p=8; System.out.println(a.toString(p)); &#125; &#125;&#125; 其次就是关于取模和取余的区别：通常取模运算也叫取余运算，它们返回结果都是余数 .rem 和 mod 唯一的区别在于:当 x 和 y 的正负号一样的时候，两个函数结果是等同的；当 x 和 y 的符号不同时，rem 函数结果的符号和 x 的一样，而 mod 和 y 一样。这是由于这两个函数的生成机制不同，rem 函数采用 fix 函数，而 mod 函数采用了 floor 函数（这两个函数是用来取整的，fix 函数向 0 方向舍入，floor 函数向无穷小方向舍入）。 rem（x，y）命令返回的是 x-n.*y，如果 y 不等于 0，其中的 n &#x3D; fix(x.&#x2F;y)，而 mod(x,y) 返回的是 x-n.*y，当 y 不等于 0 时，n&#x3D;floor(x.&#x2F;y) 求法：先将两个整数看作是正数，再作除法运算: 1、能整除时，其值为 0 2、不能整除时，其值&#x3D;除数×(整商+1)-被除数 （在算的时候都不用考虑结果，只在最后结果取符号的时候看被除数或者除数的符号。） 例： mod(36,-10)&#x3D;-4 ；即：36 除以 10 的整数商为 3，加 1 后为 4；其与除数之积为 40；再与被除数之差为（40-36&#x3D;4）；取除数的符号。所以值为 -4。 例： rem(36,-10)&#x3D;4 ；即：36 除以 10 的整数商为 3，加 1 后为 4；其与除数之积为 40；再与被除数之差为（40-36&#x3D;4）；取被除数的符号。所以值为 4。 **对于整数 a，b 来说，取模运算或者求余运算的方法要分如下两步： ** 1、求整数商：c&#x3D;a&#x2F;b 2、计算模或者余数：r&#x3D;a-(c×b) ;此时c为舍弃小数位后的值求模运算和求余运算在第一步不同 取余运算在计算商值向0方向舍弃小数位 取模运算在计算商值向负无穷方向舍弃小数位例如：4&#x2F;(-3) 约等于 -1.3在取余运算时候商值向 0 方向舍弃小数位为 -1在取模运算时商值向负无穷方向舍弃小数位为-2所以4rem(-3)&#x3D;14mod(-3)&#x3D;-2 java的BigDecimal（多位小数） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package ustc.lichunchun.bigdataapi; import java.math.BigDecimal; public class BigDecimalDemo01 &#123; public static void main(String[] args) &#123; System.out.println(&quot;加法运算：&quot; + MyMath.round(MyMath.add(10.345,3.333),1)) ; System.out.println(&quot;减法运算：&quot; + MyMath.round(MyMath.sub(10.345,3.333),3)) ; System.out.println(&quot;乘法运算：&quot; + MyMath.round(MyMath.mul(10.345,3.333),4)) ; System.out.println(&quot;除法运算：&quot; + MyMath.div(10.345,3.333,3)) ; &#125;&#125;class MyMath&#123; public static double add(double d1,double d2)&#123; // 进行加法计算 BigDecimal b1 = new BigDecimal(d1) ; BigDecimal b2 = new BigDecimal(d2) ; return b1.add(b2).doubleValue() ; &#125; public static double sub(double d1,double d2)&#123; // 进行减法计算 BigDecimal b1 = new BigDecimal(d1) ; BigDecimal b2 = new BigDecimal(d2) ; return b1.subtract(b2).doubleValue() ; &#125; public static double mul(double d1,double d2)&#123; // 进行乘法计算 BigDecimal b1 = new BigDecimal(d1) ; BigDecimal b2 = new BigDecimal(d2) ; return b1.multiply(b2).doubleValue() ; &#125; public static double div(double d1,double d2,int len)&#123; // 进行除法计算 BigDecimal b1 = new BigDecimal(d1) ; BigDecimal b2 = new BigDecimal(d2) ; return b1.divide(b2,len,BigDecimal.ROUND_HALF_UP).doubleValue() ; &#125; public static double round(double d,int len)&#123; // 进行四舍五入 BigDecimal b1 = new BigDecimal(d) ; BigDecimal b2 = new BigDecimal(1) ; // 技巧 return b1.divide(b2,len,BigDecimal.ROUND_HALF_UP).doubleValue() ; &#125;&#125;;/*tips:1. round() 方法返回一个最接近的 int、long 型值，四舍五入。round 表示&quot;四舍五入&quot;，算法为Math.floor(x+0.5) ，即将原来的数字加上 0.5 后再向下取整，所以 Math.round(11.5) 的结果为 12，Math.round(-11.5) 的结果为 -11。2. public BigDecimal divide(BigDecimal divisor,int scale, int roundingMode) 第一个参数是除数，第二个参数代表保留几位小数，第三个代表的是使用的模式。其中第三个参数的模式有： BigDecimal.ROUND_DOWN:直接省略多余的小数，比如1.28如果保留1位小数，得到的就是1.2 BigDecimal.ROUND_UP:直接进位，比如1.21如果保留1位小数，得到的就是1.3 BigDecimal.ROUND_HALF_UP:四舍五入，2.35保留1位，变成2.4 BigDecimal.ROUND_HALF_DOWN:四舍五入，2.35保留1位，变成2.3 3. doubleValue() 方法把BigDecimal转化成Double类型的对象，相应的可以把Integer和String类型的转换为double类型。*/ 关于c语言中的__int128类型关于__int128的介绍（可用于1e18以上的数的运算）：128位的int类型的数，官方上写了GCC提供了两种128位整数类型，分别是__int128_t和__uint128_t，分别用于声明有符号整数变量和无符号整数变量。由于这种大整数无法使用函数printf()输出其值，所以自己做了一个整数转字符串函数myitoa()，用于实现128位整数的输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354实现大整数的输出 #include &lt;iostream&gt;using namespace std;void myitoa(__int128_t v, char* s)&#123; char temp; int i=0, j; while(v &gt;0) &#123; s[i++] = v % 10 + &#x27;0&#x27;; v /= 10; &#125; s[i] = &#x27;\\0&#x27;; j=0; i--; while(j &lt; i) &#123; temp = s[j]; s[j] = s[i]; s[i] = temp; j++; i--; &#125;&#125;int main()&#123; __uint128_t n = 0; n = ~n; int count = 0; while(n &gt; 0) &#123; count++; n &gt;&gt;= 1; &#125; cout &lt;&lt; &quot;count=&quot; &lt;&lt; count &lt;&lt; endl; cout &lt;&lt; &quot;__uint128_t size=&quot; &lt;&lt; sizeof(__uint128_t) &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; &quot;__int128_t size=&quot; &lt;&lt; sizeof(__int128_t) &lt;&lt; endl; __int128_t x = 1100000000000000L; __int128_t y = 2200000000000000L; char s[40]; x *= y; myitoa(x, s); cout &lt;&lt; &quot;x=&quot; &lt;&lt; s &lt;&lt; endl; return 0;&#125;结果count=128 __uint128_t size=16 __int128_t size=16 x=2420000000000000000000000000000 其中可以用于大数运算a+b 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;inline __int128 read()&#123; __int128 x=0,f=1; char ch=getchar(); while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123; if(ch==&#x27;-&#x27;) f=-1; ch=getchar(); &#125; while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123; x=x*10+ch-&#x27;0&#x27;; ch=getchar(); &#125; return x*f;&#125;inline void write(__int128 x)&#123; if(x&lt;0) &#123; putchar(&#x27;-&#x27;); x=-x; &#125; if(x&gt;9) write(x/10); //递归输出 putchar(x%10+&#x27;0&#x27;);&#125;int main()&#123; __int128 a = read(); __int128 b = read(); write(a + b); return 0;&#125; c++大数运算 算法笔记板子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//高精度运算#include&lt;iostream&gt;#include&lt;string.h&gt; using namespace std;struct bign&#123; int d[1000]; int len; bign()&#123; memset(d,0,sizeof(d)); len=0; &#125;&#125;;bign change(char str[])&#123;//将str的整数转为bign bign a; a.len=strlen(str); for(int i=0;i&lt;a.len;i++)&#123; a.d[i]=str[a.len-i-1]-&#x27;0&#x27;;//逆着赋值 &#125; return a;&#125;int compare(bign a,bign b)&#123; if(a.len&gt;b.len)return 1;//a大 else if(a.len&lt;b.len)return -1;//a小 else &#123; for(int i=a.len-1;i&gt;=0;i--)&#123;//因为从d的0坐标开始存 if(a.d[i]&gt;b.d[i])return 1; else if(a.d[i]&lt;b.d[i])return -1; &#125; return 0;//相等 &#125;&#125; bign add(bign a,bign b)&#123; bign c; int carry=0; for(int i=0;i&lt;a.len||i&lt;b.len;i++)&#123;//以较长的作为界限 int temp=a.d[i]+b.d[i]+carry; c.d[c.len++]=temp%10; carry=temp/10; &#125; if(carry!=0)&#123; c.d[c.len++]=carry;//新增一位 &#125; return c;&#125;bign sub(bign a,bign b)&#123; bign c; for(int i=0;i&lt;a.len||i&lt;b.len;i++)&#123; if(a.d[i]&lt;b.d[i])&#123; a.d[i+1]--;//不够减，向高位借 a.d[i]+=10; &#125; c.d[c.len++]=a.d[i]-b.d[i];//计算结果储存起来 &#125; while(c.len-1&gt;=1&amp;&amp;c.d[c.len-1]==0)&#123; c.len--;//取出高为的0，并且保留最低位的0 &#125; return c; &#125;bign multi(bign a,int b)&#123; bign c; int carry;//进位 for(int i=0;i&lt;a.len;i++)&#123; int temp=a.d[i]*b+carry; c.d[c.len++]=temp%10; carry=temp/10; &#125; while(carry!=0)&#123;//乘法的进位可能不止一位 c.d[c.len++]=carry%10; carry/=10; &#125; return c;&#125;bign divide(bign a,int b,int &amp;r)&#123;//r为余数 bign c; c.len=a.len; for(int i=a.len-1;i&gt;=0;i--)&#123;//从高为开始除 r=r*10+a.d[i]; if(r&lt;b)c.d[i]=0;//不够除 else &#123;//够除 c.d[i]=r/b; r=r%b; &#125; &#125; while(c.len-1&gt;=1&amp;&amp;c.d[c.len-1]==0)&#123; c.len--; &#125; return c;&#125;void print(bign a)&#123; for(int i=a.len-1;i&gt;=0;i--)&#123; cout&lt;&lt;a.d[i]; &#125; cout&lt;&lt;endl;&#125;int main()&#123; char str1[1000],str2[1000]; int r=0; int c=-2; scanf(&quot;%s&quot;,str1); scanf(&quot;%s&quot;,str2); bign a=change(str1); bign b=change(str2); cout&lt;&lt;&quot;a是否小于b&quot;&lt;&lt;compare(a,b)&lt;&lt;endl; cout&lt;&lt;&quot;a+b=&quot;; print(add(a,b)); cout&lt;&lt;&quot;a-b=&quot;; if(compare(a,b)==1)print(sub(a,b)); else print(sub(b,a)); cout&lt;&lt;&quot;a*c=&quot;; if(c&lt;0)&#123; cout&lt;&lt;&quot;-&quot;;print(multi(a,-c)); &#125;else&#123; print(multi(a,c)); &#125; cout&lt;&lt;&quot;a/c=&quot;;if(c&lt;0)&#123; cout&lt;&lt;&quot;-&quot;;print(divide(a,-c,r)); &#125;else&#123; print(divide(a,c,r)); &#125;cout&lt;&lt;&quot; 余数为：&quot;&lt;&lt;r&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"大数运算","slug":"大数运算","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/"}],"author":"aoyuehan"},{"title":"蓝桥杯2016省赛","slug":"蓝桥杯2016省赛","date":"2019-09-30T11:16:00.000Z","updated":"2022-02-26T04:29:56.695Z","comments":true,"path":"2019/09/30/蓝桥杯2016省赛/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/09/30/%E8%93%9D%E6%A1%A5%E6%9D%AF2016%E7%9C%81%E8%B5%9B/","excerpt":"","text":"1234567891011 总结 总结","categories":[{"name":"acwing蓝桥","slug":"acwing蓝桥","permalink":"https://zouyunkai.github.io/myblog/categories/acwing%E8%93%9D%E6%A1%A5/"}],"tags":[{"name":"蓝桥省赛","slug":"蓝桥省赛","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B/"}],"author":"aoyuehan"},{"title":"蓝桥杯2017省赛","slug":"蓝桥杯2017省赛","date":"2019-09-30T11:16:00.000Z","updated":"2022-02-26T04:29:57.281Z","comments":true,"path":"2019/09/30/蓝桥杯2017省赛/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/09/30/%E8%93%9D%E6%A1%A5%E6%9D%AF2017%E7%9C%81%E8%B5%9B/","excerpt":"","text":"1234567891011 总结 总结","categories":[{"name":"acwing蓝桥","slug":"acwing蓝桥","permalink":"https://zouyunkai.github.io/myblog/categories/acwing%E8%93%9D%E6%A1%A5/"}],"tags":[{"name":"蓝桥省赛","slug":"蓝桥省赛","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B/"}],"author":"aoyuehan"},{"title":"蓝桥杯2015省赛","slug":"蓝桥杯2015省赛","date":"2019-09-30T11:15:00.000Z","updated":"2022-02-26T03:52:51.324Z","comments":true,"path":"2019/09/30/蓝桥杯2015省赛/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/09/30/%E8%93%9D%E6%A1%A5%E6%9D%AF2015%E7%9C%81%E8%B5%9B/","excerpt":"","text":"1234567891011 总结 奖券数目 12345678910111213141516171819202122232425262728 有些人很迷信数字，比如带“4”的数字，认为和“死”谐音，就觉得不吉利。虽然这些说法纯属无稽之谈，但有时还要迎合大众的需求。 某抽奖活动的奖券号码是5位数（10000-99999），要求其中不要出现带“4”的号码，主办单位请你计算一下， 如果任何两张奖券不重号，最多可发出奖券多少张。请提交该数字（一个整数），不要写任何多余的内容或说明性文字。*/#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;void i2s(int num, string &amp;str) &#123; stringstream ss; ss &lt;&lt; num; ss &gt;&gt; str;&#125;//其中如果除了4之外的数字全排列，和枚举每个位上的数，都不如这样s.find(4)==string::npos；来的快速和方便int main(int argc, const char * argv[]) &#123; int ans=0; for (int i = 10000; i &lt;=99999 ; ++i) &#123; string s; i2s(i,s); if(s.find(&#x27;4&#x27;)==string::npos)ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 星系炸弹之日期计算 12345678910111213141516171819202122/* 在X星系的广袤空间中漂浮着许多X星人造“炸弹”，用来作为宇宙中的路标。每个炸弹都可以设定多少天之后爆炸。比如：阿尔法炸弹2015年1月1日放置，定时为15天，则它在2015年1月16日爆炸。有一个贝塔炸弹，2014年11月9日放置，定时为1000天，请你计算它爆炸的准确日期。请填写该日期，格式为 yyyy-mm-dd 即4位年份2位月份2位日期。比如：2015-02-19请严格按照格式书写。不能出现其它文字或符号。*///方法1：excel//方法2：#include &lt;iostream&gt;using namespace std;int main(int argc, const char * argv[]) &#123; int i=21+31; i+=365;//2015年 i+=366;//2016年 i+=31+28+31+30+31+30+31+5; cout&lt;&lt;i&lt;&lt;endl; return 0;&#125;//2017-08-05 三羊献瑞 找到如图片那种运算之后进位的格式的数，先找一下看得出来的规律，然后减少枚举的规模。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*三羊献瑞观察下面的加法算式： 祥 瑞 生 辉 + 三 羊 献 瑞------------------- 三 羊 生 瑞 气(如果有对齐问题，可以参看【图1.jpg】)其中，相同的汉字代表相同的数字，不同的汉字代表不同的数字。请你填写“三羊献瑞”所代表的4位数字（答案唯一），不要填写任何多余内容。*//* a b c d + e f g b------------------- e f c b i e=1,a=9,f=0,c=b+1,c+g&gt;10 */#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;void i2s(int num, string &amp;str) &#123; stringstream ss; ss &lt;&lt; num; ss &gt;&gt; str;&#125;int main(int argc, const char * argv[]) &#123; for (int b = 2; b &lt; 9; ++b) &#123; for (int d = 2; d &lt; 9; ++d) &#123; if(b==d)continue; for (int g = 2; g &lt; 9; ++g) &#123; if(g==b||g==d)continue; int c=b+1; if(c==b||c==d||c==g)continue;//因为要有多个条件，因为不能各个相同 if(c+g&lt;=10)continue;/* a b c d + e f g b------------------- e f c b i e=1,a=9,f=0,c=b+1,c+g&gt;10 */ int sum = 9000 + b * 100 + c * 10 + d + 1000 + g * 10 + b; for (int i = 2; i &lt; 9; ++i) &#123; if(i==b||i==d||i==g||i==c)continue; if(sum&lt;=(10000+c*100+b*10+i)&amp;&amp;sum&gt;=(10000+c*100+b*10+i)) &#123; printf(&quot;%2d%d%d%d\\n&quot;, 9, b, c, d); printf(&quot;%2d%d%d%d\\n&quot;, 1, 0, g, b); printf(&quot;%d\\n&quot;, sum); printf(&quot;---------\\n&quot;); &#125; &#125; &#125; &#125; &#125; return 0;&#125; %*s的作用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//// Created by zhengwei.///*格子中输出StringInGrid函数会在一个指定大小的格子中打印指定的字符串。要求字符串在水平、垂直两个方向上都居中。如果字符串太长，就截断。如果不能恰好居中，可以稍稍偏左或者偏上一点。下面的程序实现这个逻辑，请填写划线部分缺少的代码。#include &lt;stdio.h&gt;#include &lt;string.h&gt;void StringInGrid(int width, int height, const char* s)&#123; int i,k; char buf[1000]; strcpy(buf, s); if(strlen(s)&gt;width-2) buf[width-2]=0; printf(&quot;+&quot;); for(i=0;i&lt;width-2;i++) printf(&quot;-&quot;); printf(&quot;+\\n&quot;); for(k=1; k&lt;(height-1)/2;k++)&#123; printf(&quot;|&quot;); for(i=0;i&lt;width-2;i++) printf(&quot; &quot;); printf(&quot;|\\n&quot;); &#125; printf(&quot;|&quot;); printf(&quot;%*s%s%*s&quot;,_____________________________________________); //填空 printf(&quot;|\\n&quot;); for(k=(height-1)/2+1; k&lt;height-1; k++)&#123; printf(&quot;|&quot;); for(i=0;i&lt;width-2;i++) printf(&quot; &quot;); printf(&quot;|\\n&quot;); &#125; printf(&quot;+&quot;); for(i=0;i&lt;width-2;i++) printf(&quot;-&quot;); printf(&quot;+\\n&quot;);&#125;int main()&#123; StringInGrid(20,6,&quot;abcd1234&quot;); return 0;&#125;对于题目中数据，应该输出：+------------------+| || abcd1234 || || |+------------------+（如果出现对齐问题，参看【图1.jpg】）注意：只填写缺少的内容，不要书写任何题面已有代码或说明性文字。*/#include &lt;stdio.h&gt;#include &lt;string.h&gt;void StringInGrid(int width, int height, const char* s)&#123; int i,k; char buf[1000]; strcpy(buf, s); if(strlen(s)&gt;width-2) buf[width-2]=0; printf(&quot;+&quot;); for(i=0;i&lt;width-2;i++) printf(&quot;-&quot;); printf(&quot;+\\n&quot;); for(k=1; k&lt;(height-1)/2;k++)&#123; printf(&quot;|&quot;); for(i=0;i&lt;width-2;i++) printf(&quot; &quot;); printf(&quot;|\\n&quot;); &#125; printf(&quot;|&quot;);// printf(&quot;%*s%s%*s&quot;,_____________________________________________); //填空 printf(&quot;%*s%s%*s&quot;,(width-strlen(buf)-2)/2,&quot;&quot;,buf,(width-strlen(buf)-2)/2,&quot;&quot;); //填空 printf(&quot;|\\n&quot;); for(k=(height-1)/2+1; k&lt;height-1; k++)&#123; printf(&quot;|&quot;); for(i=0;i&lt;width-2;i++) printf(&quot; &quot;); printf(&quot;|\\n&quot;); &#125; printf(&quot;+&quot;); for(i=0;i&lt;width-2;i++) printf(&quot;-&quot;); printf(&quot;+\\n&quot;);&#125;int main()&#123;// printf (&quot;%*s \\n&quot;,5, &quot;1&quot;);//该结果为11111// printf (&quot;%*s \\n&quot;,5, &quot;&quot;);//该结果为五个空格 StringInGrid(20,6,&quot;abcd1234&quot;); return 0;&#125; 九数 组分数 递归+回溯求全排列的一个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374九数组分数1,2,3...9 这九个数字组成一个分数，其值恰好为1/3，如何组法？下面的程序实现了该功能，请填写划线部分缺失的代码。#include &lt;stdio.h&gt;void test(int x[])&#123; int a = x[0]*1000 + x[1]*100 + x[2]*10 + x[3]; int b = x[4]*10000 + x[5]*1000 + x[6]*100 + x[7]*10 + x[8]; if(a*3==b) printf(&quot;%d / %d\\n&quot;, a, b);&#125;void f(int x[], int k)&#123; int i,t; if(k&gt;=9)&#123; test(x); return; &#125; for(i=k; i&lt;9; i++)&#123; &#123;t=x[k]; x[k]=x[i]; x[i]=t;&#125; f(x,k+1); _____________________________________________ // 填空处 &#125;&#125;int main()&#123; int x[] = &#123;1,2,3,4,5,6,7,8,9&#125;; f(x,0); return 0;&#125;注意：只填写缺少的内容，不要书写任何题面已有代码或说明性文字。*/#include &lt;stdio.h&gt;void test(int x[])&#123; int a = x[0]*1000 + x[1]*100 + x[2]*10 + x[3]; int b = x[4]*10000 + x[5]*1000 + x[6]*100 + x[7]*10 + x[8]; if(a*3==b) printf(&quot;%d / %d\\n&quot;, a, b);&#125;void f(int x[], int k)//这就是递归+回溯求全排列&#123; int i,t; if(k&gt;=9)&#123;//形成一个排列 test(x);//检查 return; &#125; for(i=k; i&lt;9; i++)&#123; &#123;t=x[k]; x[k]=x[i]; x[i]=t;&#125;//交换，确定这一位 f(x,k+1); &#123;t=x[k]; x[k]=x[i]; x[i]=t;&#125;//回溯，恢复到下探之前的状态// _____________________________________________ // 填空处 &#125;&#125;int main()&#123; int x[] = &#123;1,2,3,4,5,6,7,8,9&#125;; f(x,0); return 0;&#125; 加法变乘法 12345678910111213141516171819202122232425加法变乘法我们都知道：1+2+3+ ... + 49 = 1225现在要求你把其中两个不相邻的加号变成乘号，使得结果为2015比如：1+2+3+...+10*11+12+...+27*28+29+...+49 = 2015就是符合要求的答案。请你寻找另外一个可能的答案，并把位置靠前的那个乘号左边的数字提交（对于示例，就是提交10）。注意：需要你提交的是一个整数，不要填写任何多余的内容。*///两重循环，计算验证#include &lt;iostream&gt;using namespace std;int main(int argc, const char * argv[]) &#123; for (int i = 1; i &lt;=46 ; ++i) &#123; for (int j = i+2; j &lt;=48 ; ++j) &#123; if(i*(i+1)-(i+i+1)+j*(j+1)-(j+j+1)==2015-1225);//两段的差值就是两组数的乘积 cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl; &#125; &#125; return 0;&#125; 牌型种数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485方法一：小明被劫持到X赌城，被迫与其他3人玩牌。一副扑克牌（去掉大小王牌，共52张），均匀发给4个人，每个人13张。这时，小明脑子里突然冒出一个问题：如果不考虑花色，只考虑点数，也不考虑自己得到的牌的先后顺序，自己手里能拿到的初始牌型组合一共有多少种呢？请填写该整数，不要填写任何多余的内容或说明文字。*/#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string pai[13];int countOf(vector&lt;string&gt; path, string p) &#123; int ans = 0;//该函数统计历史上已经抓到p这张牌的个数 for (int i = 0; i &lt; path.size(); ++i) &#123; if (path[i] == p) ans++; &#125; return ans;&#125;int ans;void f(int k, vector&lt;string&gt; path) &#123;//还能抓k张，此时抓的都存放在path中 if (k == 0)ans++;//已经有13张牌了，所以可以直接计数回溯 for (int i = 0; i &lt; 13; ++i) &#123; if (countOf(path, pai[i]) == 4)continue;//同一种点数不能装4张 path.push_back(pai[i]);//拼接，代表采纳这张牌 f(k - 1, path); path.erase(path.end() - 1);//回溯 &#125;&#125;void i2s(int num, string &amp;str) &#123;//将int类型转换为string类型 stringstream ss; ss &lt;&lt; num; ss &gt;&gt; str;&#125;int main(int argc, const char *argv[]) &#123; for (int i = 1; i &lt;= 13; ++i) &#123; i2s(i, pai[i - 1]);//pai这个数组存放每一种牌各一张 &#125; vector&lt;string&gt; v; f(13, v); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;方法二：巧妙#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int ans;void f(int k,int cnt) &#123;//k表示有13钟的牌，cnt表示捉到几张牌了 if(cnt&gt;13||k&gt;13)return; //注意这地方是大于13的return，而不是等于13的时候return，因为最后一次抓牌的数量有可能大于13 if(k==13&amp;&amp;cnt==13)&#123; ans++; return; &#125; for (int i = 0; i &lt; 5; ++i) &#123;//0 1 2 3 代表每一种牌的张数，如i=1就代表k这种牌取1张 f(k+1,cnt+i); &#125;&#125;int main(int argc, const char *argv[]) &#123; f(0, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 移动距离 -蛇形走位 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263X星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为1,2,3...当排满一行时，从下一行相邻的楼往反方向排号。比如：当小区排号宽度为6时，开始情形如下：1 2 3 4 5 612 11 10 9 8 713 14 15 .....我们的问题是：已知了两个楼号m和n，需要求出它们之间的最短移动距离（不能斜线方向移动）输入为3个整数w m n，空格分开，都在1到10000范围内w为排号宽度，m,n为待计算的楼号。要求输出一个整数，表示m n 两楼间最短移动距离。例如：用户输入：6 8 2则，程序应该输出：4再例如：用户输入：4 7 20则，程序应该输出：5资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 1000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。*/#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;int main(int argc, const char *argv[]) &#123; int w, m, n; scanf(&quot;%d %d %d&quot;, &amp;w, &amp;m, &amp;n); int rm = m % w == 0 ? m / w : m / w + 1;//判断m点所在的行 int rn = n % w == 0 ? n / w : n / w + 1; int cm = 0; int cn = 0; if (rm % 2 == 0)cm = rm * w - m + 1;//判断m点所在的列（分奇偶讨论 else cm = w - (rm * w - m); if (rn % 2 == 0)cn = rn * w - n + 1; else cn = w - (rn * w - n); printf(&quot;%d\\n&quot;,abs(cm-cn)+abs(rm-rn));//结果就是两者横纵坐标的差 return 0;&#125; 垒骰子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091题意：赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。atm想计算一下有多少种不同的可能的垒骰子方式。两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。由于方案数可能过多，请输出模 10^9 + 7 的结果。不要小看了 atm 的骰子数量哦～「输入格式」第一行两个整数 n mn表示骰子数目接下来 m 行，每行两个整数 a b ，表示 a 和 b 数字不能紧贴在一起。「输出格式」一行一个数，表示答案模 10^9 + 7 的结果。「样例输入」2 11 2「样例输出」544「数据范围」对于 30% 的数据：n &lt;= 5对于 60% 的数据：n &lt;= 100对于 100% 的数据：0 &lt; n &lt;= 10^9, m &lt;= 36资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 2000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。递归方法一：#define MOD 1000000007#include &lt;iostream&gt;using namespace std;int n, m;int op[7];//定义相对面bool conflict[7][7];//定义冲突/** * 上一层定好了朝上的数字为up的情况下，垒好cnt个骰子的方案数 * @param up * @param cnt * @return */long long int f(int up, int cnt) &#123;//首先要传过来上一个骰子向上的面是什么，还要累几个骰子 if (cnt == 0) return 4; long long ans = 0; for (int upp = 1; upp &lt;= 6; ++upp) &#123;//这一个骰子的面也可以选6中 if (conflict[op[up]][upp])continue;//如果选的这个面冲突了，返回 ans =(ans+ f(upp, cnt - 1))%MOD;//这地方也要mod才行 &#125; return ans;&#125;void init() &#123;//预处理化，把一个面的另一个面映射出来 op[1] = 4; op[4] = 1; op[2] = 5; op[5] = 2; op[3] = 6; op[6] = 3;&#125;int main(int argc, const char *argv[]) &#123; init(); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; ++i) &#123; int x, y;//标记冲突的数对 scanf(&quot;%d %d&quot;, &amp;x, &amp;y); conflict[x][y] = true;//x对y冲突，y对x也冲突 conflict[y][x] = true; &#125; long long ans = 0; for (int up = 1; up &lt;= 6; ++up) &#123; ans = (ans + 4 * f(up, n - 1)) % MOD;//最上面的那个可以转四下 &#125; printf(&quot;%lli&quot;, ans); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172动规方法二：#define MOD 1000000007#include &lt;map&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;long long dp[2][7];//dp[i][j]表示有i层，限定朝上的数字为j的稳定方案数int n, m;bool conflict[7][7];map&lt;int, int&gt; op;void init() &#123; op[1] = 4; op[4] = 1; op[2] = 5; op[5] = 2; op[3] = 6; op[6] = 3;&#125;int main(int argc, const char *argv[]) &#123; init(); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; m; ++i) &#123; int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); conflict[a][b] = true; conflict[b][a] = true; &#125;// 输入完成 for (int j = 1; j &lt;= 6; ++j) &#123; dp[0][j] = 1;//初始化最下面的哪一行的种数都是1中 &#125; int cur = 0;// 迭代层数 for (int level = 2; level &lt;= n; ++level) &#123; cur = 1 - cur;// 尝试将6个面放在当前一层朝上的方向 for (int j = 1; j &lt;= 6; ++j) &#123; dp[cur][j] = 0;//初始化一下// 将与op[j]不冲突的上一层格子里面的数累加起来 for (int i = 1; i &lt;= 6; ++i) &#123; if (conflict[op[j]][i])continue;//冲突的面朝上是不可取的 dp[cur][j] = (dp[cur][j] + dp[1 - cur][i]) % MOD; &#125; &#125; &#125; long long sum = 0; for (int k = 1; k &lt;= 6; ++k) &#123; sum = (sum + dp[cur][k]) % MOD;//将最上面一层的那个dp数组的和加起来 &#125;// 快速幂，求4的n次方 long long ans = 1; long long tmp = 4; long long p = n; while (p != 0) &#123; if (p &amp; 1 == 1) ans = (ans * tmp) % MOD; tmp = (tmp * tmp) % MOD; p &gt;&gt;= 1; &#125; printf(&quot;%d\\n&quot;, (sum * ans) % MOD);//因为每一种放上去之后，还能转四下，总共就是4^n return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#define MOD 1000000007typedef long long LL;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int n, m;map&lt;int, int&gt; op;void init() &#123; op[1] = 4; op[4] = 1; op[2] = 5; op[5] = 2; op[3] = 6; op[6] = 3;&#125;struct M &#123; LL a[6][6]; M() &#123;// memset(a,1, sizeof(a)); 这样不行，因为sizeof是按字符的，这是个二维矩阵，所以要手动来 for (int i = 0; i &lt; 6; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; a[i][j] = 1; &#125; &#125; &#125;&#125;;M mMultiply(M m1,M m2)&#123; M ans; for (int i = 0; i &lt; 6; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; ans.a[i][j]=0; for (int k = 0; k &lt; 6; ++k) &#123; ans.a[i][j]=(ans.a[i][j]+m1.a[i][k]*m2.a[k][j])%MOD; &#125; &#125; &#125; return ans;&#125;//求M的k次方M mPow(M m, int k) &#123; M ans;//单位矩阵// 对角线为1，其余为0 for (int i = 0; i &lt; 6; ++i) &#123; for (int j = 0; j &lt; 6; ++j) &#123; if (i == j) ans.a[i][j] = 1; else ans.a[i][j] = 0; &#125; &#125; while (k != 0) &#123; if ((k &amp; 1) == 1) &#123; ans = mMultiply(ans,m); &#125; m=mMultiply(m,m); k &gt;&gt;= 1;//向右移动1位 &#125; return ans;&#125;int main(int argc, const char *argv[]) &#123; init(); scanf(&quot;%d %d&quot;, &amp;n, &amp;m); M cMatrix;//冲突矩阵 for (int i = 0; i &lt; m; ++i) &#123; int a, b; scanf(&quot;%d %d&quot;, &amp;a, &amp;b); //完善冲突矩阵 cMatrix.a[op[a] - 1][b - 1] = 0; cMatrix.a[op[b] - 1][a - 1] = 0; &#125; M cMatrix_n_1 = mPow(cMatrix, n - 1);//冲突矩阵的n-1次方 LL ans=0; for (int j = 0; j &lt; 6; ++j) &#123; for (int i = 0; i &lt; 6; ++i) &#123; ans=(ans+cMatrix_n_1.a[i][j])%MOD; &#125; &#125; // 快速幂，求4的n次方 long long t = 1; long long tmp = 4; long long p = n; while (p != 0) &#123; if (p &amp; 1 == 1) t = (t * tmp) % MOD; tmp = (tmp * tmp) % MOD; p &gt;&gt;= 1; &#125; printf(&quot;%lli&quot;,ans*t%MOD); return 0;&#125; 生命之树 -无根树，子集权值最大 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192在X森林里，上帝创建了生命之树。他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。上帝要在这棵树内选出一个非空节点集S，使得对于S中的任意两个点a,b，都存在一个点列 &#123;a, v1, v2, ..., vk, b&#125; 使得这个点列中的每个点都是S里面的元素，且序列中相邻两个点间有一条边相连。在这个前提下，上帝要使得S中的点所对应的整数的和尽量大。这个最大的和就是上帝给生命之树的评分。经过atm的努力，他已经知道了上帝给每棵树上每个节点上的整数。但是由于 atm 不擅长计算，他不知道怎样有效的求评分。 他需要你为他写一个程序来计算一棵树的分数。「输入格式」第一行一个整数 n 表示这棵树有 n 个节点。第二行 n 个整数，依次表示每个节点的评分。接下来 n-1 行，每行 2 个整数 u, v，表示存在一条 u 到 v 的边。由于这是一棵树，所以是不存在环的。「输出格式」输出一行一个数，表示上帝给这棵树的分数。「样例输入」51 -2 -3 4 54 23 11 22 5「样例输出」8「数据范围」对于 30% 的数据，n &lt;= 10对于 100% 的数据，0 &lt; n &lt;= 10^5, 每个节点的评分的绝对值不超过 10^6 。资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 3000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n;const int MaxN = 1e5;long long w[MaxN + 1];//每个点的权重，或者为每个点作为根节点时能得到的最大权和 long long ans;vector&lt;int&gt; g[MaxN + 1];//邻接表/*以root为根，算出最大的权和*/void dfs(int root, int fa) &#123; for (int i = 0; i &lt; g[root].size(); ++i) &#123;//遍历以root为根的每一个孩子 int son = g[root][i];//其中一个孩子 if (son != fa) &#123; dfs(son, root); if (w[son] &gt; 0) w[root] += w[son];//从最底层往上走，加上这个以这个节点为根的子树的总权值 &#125; &#125; if (w[root] &gt; ans)ans = w[root];//求子树最大的权值&#125;int main(int argc, const char *argv[]) &#123; freopen(&quot;/Users/in8.txt&quot;,&quot;r&quot;,stdin); scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(&quot;%lld&quot;, &amp;w[i]); &#125; for (int j = 0; j &lt; n - 1; ++j) &#123;//初始化邻接表 int u, v; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); g[u].push_back(v); g[v].push_back(u); &#125;// 输入处理完成 dfs(1, 0); //传入根节点为1,根节点没有，传进去0就好了 printf(&quot;%lld\\n&quot;, ans); return 0;&#125; 总结 01 奖券数目 枚举+字符串查找02 星系炸弹 简单计算03 三羊献瑞 枚举+判断，数学推理减少未知数04 格子中输出 %*s需要两个参：宽度和输出内容05 九数组分数 递归求全排列06 加法变乘法 枚举，巧算*07 牌型种数 递归08 移动距离 通过举例来找到符号化公式***09 垒骰子 矩阵运算***10 生命之树 无根树转有根数，dfs，维护每个节点作为根时能得到的最大权和","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[{"name":"蓝桥省赛","slug":"蓝桥省赛","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B/"}],"author":"aoyuehan"},{"title":"蓝桥杯2014省赛","slug":"蓝桥杯2014省赛","date":"2019-09-30T11:14:00.000Z","updated":"2022-02-26T03:52:51.286Z","comments":true,"path":"2019/09/30/蓝桥杯2014省赛/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/09/30/%E8%93%9D%E6%A1%A5%E6%9D%AF2014%E7%9C%81%E8%B5%9B/","excerpt":"","text":"1234567891011 总结 标题：啤酒和饮料 1234567891011121314151617 啤酒每罐2.3元，饮料每罐1.9元。小明买了若干啤酒和饮料，一共花了82.3元。 我们还知道他买的啤酒比饮料的数量少，请你计算他买了几罐啤酒。 注意：答案是一个整数。请通过浏览器提交答案。 不要书写任何多余的内容（例如：写了饮料的数量，添加说明文字等）。 */ #include &lt;iostream&gt;using namespace std;int main(int argc, const char * argv[]) &#123; for (int i = 1; i &lt;=50 ; ++i) &#123; for (int j = 1; j &lt;=60 ; ++j) &#123; if(i&lt;j&amp;&amp;2.3*i+1.9*j==82.3) cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl; &#125; &#125; return 0;&#125; 标题：切面条 一根高筋拉面，中间切一刀，可以得到2根面条。 如果先对折1次，中间切一刀，可以得到3根面条。 如果连续对折2次，中间切一刀，可以得到5根面条。 那么，连续对折10次，中间切一刀，会得到多少面条呢？ 答案是个整数，请通过浏览器提交答案。不要填写任何多余的内容。 *&#x2F;&#x2F;&#x2F;1025 标题：李白打酒 1234567891011121314151617181920212223242526 话说大诗人李白，一生好饮。幸好他从不开车。 一天，他提着酒壶，从家里出来，酒壶中有酒2斗。他边走边唱： 无事街上走，提壶去打酒。 逢店加一倍，遇花喝一斗。 这一路上，他一共遇到店5次，遇到花10次，已知最后一次遇到的是花，他正好把酒喝光了。 请你计算李白遇到店和花的次序，可以把遇店记为a，遇花记为b。则：babaabbabbabbbb 就是合理的次序。 像这样的答案一共有多少呢？请你计算出所有可能方案的个数（包含题目给出的）。 注意：通过浏览器提交答案。答案是个整数。不要书写任何多余的内容。*/#include &lt;iostream&gt;using namespace std;int ans;void f(int dian, int hua, int jiu) &#123; if (dian == 0 &amp;&amp; hua == 0 &amp;&amp; jiu == 1) //要是不写jiu等于1，那么最后一次就有可能遇到的是店 ans++; if (dian &gt; 0) f(dian - 1, hua, jiu * 2); if (hua &gt; 0) f(dian, hua - 1, jiu - 1);&#125;int main(int argc, const char *argv[]) &#123; f(5, 9, 2); //初始状态，那个花的状态一定要是9才可以，因为最后一次规定是花了 cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 标题：史丰收速算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 史丰收速算法的革命性贡献是：从高位算起，预测进位。不需要九九表，彻底颠覆了传统手算! 速算的核心基础是：1位数乘以多位数的乘法。 其中，乘以7是最复杂的，就以它为例。 因为，1/7 是个循环小数：0.142857...，如果多位数超过 142857...，就要进1 同理，2/7, 3/7, ... 6/7 也都是类似的循环小数，多位数超过 n/7，就要进n 下面的程序模拟了史丰收速算法中乘以7的运算过程。 乘以 7 的个位规律是：偶数乘以2，奇数乘以2再加5，都只取个位。 乘以 7 的进位规律是： 满 142857... 进1, 满 285714... 进2, 满 428571... 进3, 满 571428... 进4, 满 714285... 进5, 满 857142... 进6 请分析程序流程，填写划线部分缺少的代码。注意：通过浏览器提交答案。只填写缺少的内容，不要填写任何多余的内容（例如：说明性文字）*/#include &lt;iostream&gt;using namespace std;//计算个位int ge_wei(int a)&#123; if(a % 2 == 0)//偶数 return (a * 2) % 10;//乘以2保留个位 else return (a * 2 + 5) % 10;//奇数，乘以2加上5，保留个位&#125;//计算进位int jin_wei(char* mod)&#123; char* level[] = &#123; &quot;142857&quot;, &quot;285714&quot;, &quot;428571&quot;, &quot;571428&quot;, &quot;714285&quot;, &quot;857142&quot; &#125;;//多位数超过 n/7，就要进n char buf[7]; buf[6] = &#x27;\\0&#x27;; strncpy(buf,mod,6);//将mod这个字符串的前6个字符，拷贝到buff中 int i; for(i=5; i&gt;=0; i--)&#123; int tr = strcmp(level[i], buf);//从后往前，依次level中的串和buff比较 if(tr&lt;0)//buff更大 ，得出了进位数=i+1 return i+1; while(tr==0)&#123;//buff和level[i]相同了 mod += 6;//往后偏移6位 strncpy(buf,mod,6);//再拷贝6个字符到buff中 tr = strcmp(level[i], buf);//再比较 if(tr&lt;0) return i+1;//buf更大// ______________________________; //填空// //buff更小的情况，可以debug看变量i的值，因为答案猜测与i有关 if(tr&gt;0) return i; &#125; &#125; return 0;&#125;//多位数乘以7void f(char* s)//s代表多位数&#123; int head = jin_wei(s);//head是s的进位 if(head &gt; 0) printf(&quot;%d&quot;, head);//输出进位 char* mod = s;//拷贝字符串指针 while(*mod)&#123;//没有到末尾 int a = (*mod-&#x27;0&#x27;);//依次字符转数字 int ge = ge_wei(a);//算出个位 int jin = jin_wei(mod + 1);//后续字符串的进位 int x = (ge + jin) % 10;//两者相加取个位 printf(&quot;%d&quot;,x);//打印 mod++;//指针后移 &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; f(&quot;4285711&quot;); f(&quot;34553834937543&quot;); return 0;&#125; 小知识（史丰收一位数与多位数的速算进位规律如下）乘数为2时，满5进1；乘数为3时，超3进1，超6进2；乘数为4时，满25进1，满50进2，满75进3；乘数为5时，满2进1，满4进2，满6进3，满8进4；乘数为6时（就看后两位因为1&#x2F;6&#x3D;1.666667），超16进1，超3进2，满5进3，超6进4，超83进5；乘数为7时，超142857进1，超285714进2，超428571进3，超571428进4，超714285进5，超857142进6；乘数为8时，满125进1，满250进2，满375进3，满500进4，满625进5，满750进6，满875进7；乘数为9时，超1进1，超2进2……超几进几。例如：多位数乘以8时 标题：打印图形 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 小明在X星球的城堡中发现了如下图形和文字：rank=3 * * * * ** * * *rank=5 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ** * * * * * * * * * * * * * * *ran=6 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 小明开动脑筋，编写了如下的程序，实现该图形的打印。 请仔细分析程序逻辑，填写缺失代码部分。 通过浏览器提交答案。注意不要填写题目中已有的代码。也不要写任何多余内容（比如说明性的文字）*/#include &lt;iostream&gt;using namespace std;#define N 70void f(char a[][N], int rank, int row, int col) &#123; if (rank == 1) &#123; a[row][col] = &#x27;*&#x27;; return; &#125; int w = 1; int i; for (i = 0; i &lt; rank - 1; i++) w *= 2;// __________________;填空 ，这地方依照下面给出的两个递归，综合地看待问//题，debug出w的值，进而分析问题，然后找到这地方要填的是处理上面那个三角形的情况 f(a, rank - 1, row , col+w/2);//a,5,0,16，处理顶上的三角形（即为填空处的答案） f(a, rank - 1, row + w / 2, col);//a,5,16,0，处理左下角 f(a, rank - 1, row + w / 2, col + w);//a,5,16,16，处理右下角&#125;int main() &#123; char a[N][N]; int i, j; for (i = 0; i &lt; N; i++) for (j = 0; j &lt; N; j++) a[i][j] = &#x27; &#x27;; f(a, 5, 0, 0); for (i = 0; i &lt; N; i++) &#123; for (j = 0; j &lt; N; j++) printf(&quot;%c&quot;, a[i][j]); printf(&quot;\\n&quot;); &#125; return 0;&#125; 标题：奇怪的分式 123456789101112131415161718192021222324252627282930313233343536373839404142 上小学的时候，小明经常自己发明新算法。一次，老师出的题目是： 1/4 乘以 8/5 小明居然把分子拼接在一起，分母拼接在一起，答案是：18/45 （参见图1.png） 老师刚想批评他，转念一想，这个答案凑巧也对啊，真是见鬼！ 对于分子、分母都是 1~9 中的一位数的情况，还有哪些算式可以这样计算呢？ 请写出所有不同算式的个数（包括题中举例的）。 显然，交换分子分母后，例如：4/1 乘以 5/8 是满足要求的，这算做不同的算式。 但对于分子分母相同的情况，2/2 乘以 3/3 这样的类型太多了，不在计数之列!注意：答案是个整数（考虑对称性，肯定是偶数）。请通过浏览器提交。不要书写多余的内容。 */ #include &lt;iostream&gt;using namespace std;int ans;int gcd(int a, int b) &#123; if (b == 0) return a; return gcd(b, a % b);&#125;int main(int argc, const char *argv[]) &#123; cout &lt;&lt; gcd(12, 16) &lt;&lt; endl; for (int a = 1; a &lt; 10; ++a) &#123; for (int b = 1; b &lt; 10; ++b) &#123; if (b == a)continue; for (int c = 1; c &lt; 10; ++c) &#123; for (int d = 1; d &lt; 10; ++d) &#123; if (c == d)continue; int g1 = gcd(a * c, b * d); int g2 = gcd(a * 10 + c, b * 10 + d); if (a * c / g1 == (a * 10 + c) / g2 &amp;&amp; b * d / g1 == (b * 10 + d) / g2) &#123; printf(&quot;%d %d %d %d\\n&quot;, a, b, c, d); ans++; &#125; &#125; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 标题：六角填数 首先本题是浏览器提交结果，所以可以不考虑算法的效率和优化，得出最后的结果就好了 其中vector中下标对应的顶点和直线标号 123456789101112131415161718192021222324252627282930313233343536373839404142 如图【1.png】所示六角形中，填入1~12的数字。 使得每条直线上的数字之和都相同。 图中，已经替你填好了3个数字，请你计算星号位置所代表的数字是多少？请通过浏览器提交答案，不要填写多余的内容。 */#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;//声明check函数void check(vector&lt;int&gt; v);int main(int argc, const char *argv[]) &#123; vector&lt;int&gt; v; v.push_back(2); for (int i = 4; i &lt;= 7; ++i) &#123; v.push_back(i); &#125; for (int i = 9; i &lt;= 12; ++i) &#123; v.push_back(i); &#125; //全排列，遍历所有可能的值，然后check来筛选 do &#123; check(v); &#125; while (next_permutation(v.begin(), v.end())); return 0;&#125;void check(vector&lt;int&gt; v) &#123; //其中1,3,8的位置已经固定值为1,3,8 int r1 = 1 + v[0] + v[3] + v[5]; int r2 = 1 + v[1] + v[4] + v[8]; int r3 = 8 + v[0] + v[1] + v[2]; int r4 = 11 + v[3] + v[6]; int r5 = 3 + v[2] + v[4] + v[7]; int r6 = v[5] + v[6] + v[7] + v[8]; if (r1 == r2 &amp;&amp; r2 == r3 &amp;&amp; r3 == r4 &amp;&amp; r4 == r5 &amp;&amp; r5 == r6) &#123; for (int i = 0; i &lt; 9; ++i) &#123; cout &lt;&lt; v[i] &lt;&lt; &quot; &quot; &lt;&lt; endl; &#125; &#125;&#125; 标题：蚂蚁感冒 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 长100厘米的细长直杆子上有n只蚂蚁。它们的头有的朝左，有的朝右。 每只蚂蚁都只能沿着杆子向前爬，速度是1厘米/秒。 当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。 这些蚂蚁中，有1只蚂蚁感冒了。并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。 请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。【数据格式】 第一行输入一个整数n (1 &lt; n &lt; 50), 表示蚂蚁的总数。 接着的一行是n个用空格分开的整数 Xi (-100 &lt; Xi &lt; 100), Xi的绝对值，表示蚂蚁离开杆子左边端点的距离。 正值表示头朝右，负值表示头朝左，数据中不会出现0值，也不会出现两只蚂蚁占用同一位置。 其中，第一个数据代表的蚂蚁感冒了。 要求输出1个整数，表示最后感冒蚂蚁的数目。例如，输入：35 -2 8程序应输出：1再例如，输入：5-10 8 -20 12 25程序应输出：3资源约定：峰值内存消耗 &lt; 256MCPU消耗 &lt; 1000ms请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。注意: main函数需要返回0注意: 只使用ANSI C/ANSI C++ 标准，不要调用依赖于编译环境或操作系统的特殊函数。注意: 所有依赖的函数必须明确地在源文件中 #include &lt;xxx&gt;， 不能通过工程设置而省略常用头文件。提交时，注意选择所期望的编译器类型。这一题要是暴力求解是不可以的*/#include &lt;iostream&gt;using namespace std;int main(int argc, const char * argv[]) &#123; int n; scanf(&quot;%d&quot;,&amp;n); int arr[n]; for (int i = 0; i &lt; n; ++i) &#123; scanf(&quot;%d&quot;,&amp;arr[i]); &#125; int x = arr[0]; if(x&gt;0)&#123;//向右 int ans=1; for (int i = 0; i &lt; n; ++i) &#123; if(arr[i]&lt;0&amp;&amp;-arr[i]&gt;x)//从右向左 ans++; &#125; if(ans!=1)//有从右到左 for (int i = 0; i &lt; n; ++i) &#123; if(arr[i]&gt;0&amp;&amp;arr[i]&lt;x)//从右向左 ans++; &#125; printf(&quot;%d\\n&quot;,ans); &#125; if(x&lt;0)&#123;//向左// 左侧从左到右的 int ans=1; for (int i = 0; i &lt; n; ++i) &#123; if(arr[i]&gt;0&amp;&amp;arr[i]&lt;-x) ans++; &#125; if(ans!=1) for (int i = 0; i &lt; n; ++i) &#123; if(arr[i]&lt;0&amp;&amp;-arr[i]&gt;-x) ans++; &#125; printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; 总结","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[{"name":"蓝桥省赛","slug":"蓝桥省赛","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B/"}],"author":"aoyuehan"},{"title":"C#笔记","slug":"C-笔记","date":"2019-09-27T02:47:00.000Z","updated":"2022-02-26T03:52:52.605Z","comments":true,"path":"2019/09/27/C-笔记/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/09/27/C-%E7%AC%94%E8%AE%B0/","excerpt":"","text":"上机四小测试：银行卡ATM机上机泛型类，类的实现 https://blog.csdn.net/lmm0513/article/details/88917685 https://blog.csdn.net/lmm0513/article/details/88918750 https://blog.csdn.net/lmm0513/article/details/88918160 #### 上机四 - 实验4-1,界面中获取四个值初始化两个点，然后调用Distance方法计算两点之间的距离。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace shixun4_1&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; private void button1_Click(object sender, EventArgs e) &#123; int x1, y1, x2, y2; x1 = Convert.ToInt32(textBox1.Text); x2 = Convert.ToInt32(textBox2.Text); y1 = Convert.ToInt32(textBox3.Text); y2 = Convert.ToInt32(textBox4.Text); Point p1 = new Point(x1, y1); Point p2 = new Point(x2, y2); lalShow.Text = Convert.ToString(p1.Distance(p2)); &#125; &#125;&#125; class Point&#123;//定义这一个类，类中有一个方法（不是静态的，所以要有Point类型的对象来调用） private int x, y; //定义为私有的，然后通过属性来访问和赋值 public int X &#123; set =&gt; x = value; get =&gt; x; &#125; public int Y &#123; set =&gt; y = value; get =&gt; y; &#125; public Point(int x, int y) &#123;//有参构造函数（构造参数也是可以重载的，一旦我们在类中编写了构造方法，那么这个自动生成的无参构造函数就不会生成。） this.x = x; this.y = y; &#125; public double Distance(Point p)&#123; return System.Math.Sqrt((this.X - p.X) * (this.X - p.X) + (this.Y - p.Y) * (this.Y - p.Y));; &#125;&#125; 小知识： 初始化对象的形式 a.常规的形式为“对象名.属性名&#x3D;值;“ b.构造方法； c.对象初始化器；实现方式：对象初始化器 对象初始化器与构造方法的异同点 a.构造方法具有强制性，对象初始化器没有强制性。构造方法本质上是一种特性的方法，所有就要遵循方法的调用逻辑。 b.对象初始化器功能单一，只能完成对象属性初始化。而构造方法可以在方法体中灵活的分配，如对象创建时读取文件等需求。 c.顺序的不同，对象初始化器是在调用了构造方法才执行的属性赋值。而构造方法在new 的时候进行调用，并且逻辑代码都是在类里面的。 那个上机的new student ， 实例化对象用构造函数 Teacher t&#x3D;new Teacher(string name，int id); a[0]&#x3D;new Teacher(); a[0]&#x3D;t; - 模拟银行卡，刷卡消费，还款，转账，提现等操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390 基类（类放在命名空间里）： public abstract class IDcard &#123; protected double id; protected double pass; protected double balance; protected string name; public virtual string type &#123; get &#123; return &quot;信用卡&quot;; &#125; &#125; public double ID &#123; get &#123; return id; &#125; set &#123; id = value; &#125; &#125; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public double Pass &#123; get &#123; return pass; &#125; set &#123; pass = value; &#125; &#125; public double Balance &#123; get &#123; return balance; &#125; set &#123; balance = value; &#125; &#125; &#125; 普通卡： public class NomalCard : IDcard &#123; public NomalCard(double id, double pass,string name, double balance) &#123; this.balance = balance; this.id = id; this.pass = pass; this.Name = name; &#125; public double n_edu = 10000; public override string type &#123; get &#123; return &quot;普通卡&quot;; &#125; &#125; &#125; 金卡： public class GoldCard : IDcard &#123; public GoldCard(double id, double pass,string name, double balance) &#123; this.balance = balance; this.ID = id; this.Pass = pass; this.Name = name; &#125; public double g_edu = 20000; public override string type &#123; get &#123; return &quot;金卡&quot;; &#125; &#125; &#125;窗口1：namespace 主程序&#123; public partial class Form1 : Form &#123; public Form1() &#123; InitializeComponent(); &#125; public static double CurId = 0;//读卡登录成功之后的账户id public static string CurName = &quot;&quot;;//读卡成功之后的账户名 public static ArrayList array = new ArrayList(); // List&lt;NomalCard&gt; list = new List&lt;NomalCard&gt;(); //读卡登录,成功之后跳转到主界面 private void button1_Click(object sender, EventArgs e) &#123; double id = Convert.ToDouble(textBox1.Text); double pass = Convert.ToDouble(textBox2.Text); foreach (object x in array) &#123; IDcard idcard = (IDcard)x; if (idcard.ID == id &amp;&amp; idcard.Pass == pass) &#123; //lalShow.Text = &quot;cehgnogn&quot;; CurId = idcard.ID; CurName = idcard.Name; this.Hide(); Form2 form2 = new Form2(); form2.Show(); &#125; &#125; &#125; //申请卡 private void button2_Click(object sender, EventArgs e) &#123; string name = textBox3.Text; double pass_1 = Convert.ToDouble(textBox4.Text); double pass_2 = Convert.ToDouble(textBox5.Text); double id; Boolean IdSame=false ; //判断生成的随机卡号是否在数据库中存在 Boolean PassSame = false; //判断两次输入的密码是否相同 if (pass_1 == pass_2) PassSame = true; //判断密码是否相同 Random random = new Random(0); //前面那12位固定，随机生成后4位 int tmp = Convert.ToInt32(random.Next() % 10000); id = Convert.ToDouble(&quot;62170012&quot; + tmp); do &#123; foreach (object x in Form1.array) &#123; IDcard idcard_s = (IDcard)x; if (id == idcard_s.ID) IdSame = true; &#125; Random random_1 = new Random(1); //前面那12位固定，给出种子，随机生成后4位 tmp = Convert.ToInt32(random_1.Next() % 10000); id = Convert.ToDouble(&quot;62170012&quot; + tmp ); &#125; while (IdSame); if (radioButton1.Checked&amp;&amp;PassSame ) &#123; lalShow.Text = &quot;恭喜用户&quot; + name + &quot;申请信用卡成功，你的卡号为&quot;+id; NomalCard n = new NomalCard(id, pass_1, name , 0); array.Add(n); &#125; else if (radioButton2.Checked&amp;&amp;PassSame ) &#123; GoldCard n = new GoldCard(id, pass_1, name, 0); array.Add(n); &#125; &#125; private void Form1_Load(object sender, EventArgs e) &#123; //窗口载入时的测试数据 NomalCard id3 = new NomalCard(111, 111, &quot;xiaozhi1&quot;, 111); NomalCard id4 = new NomalCard(222, 222, &quot;xiaozhi2&quot;, 222); GoldCard id1 = new GoldCard(333, 333, &quot;xiaozhi3&quot;, 333); GoldCard id2 = new GoldCard(444, 444, &quot;xiaozhi4&quot;, 444); Form1.array.Add(id1); Form1.array.Add(id4); Form1.array.Add(id3); Form1.array.Add(id2); &#125; &#125;&#125;窗口2：namespace 主程序&#123; public partial class Form2 : Form &#123; public Form2() &#123; InitializeComponent(); &#125; //初始化为普通卡 public static Boolean IsNormal=true; //显示上方欢迎文字，判断本用户的type private void Form2_Load(object sender, EventArgs e) &#123; ShowName.Text = &quot;欢迎您&quot;+Form1.CurName+&quot;使用该系统&quot;; //判断读卡成功的用户的类型 foreach (object x in Form1.array) &#123; IDcard idcard_n = (IDcard)x; if (idcard_n.ID == Form1.CurId) &#123; if (idcard_n.type == &quot;金卡&quot;) IsNormal = false; break; &#125; &#125; &#125; //点击进行余额查询,并在右侧输出余额 private void button1_Click(object sender, EventArgs e) &#123; foreach(object x in Form1.array) &#123; IDcard idcard_c = (IDcard)x; if (idcard_c.ID == Form1.CurId) &#123; tishi.Text += (idcard_c.Name +&quot;的余额为&quot;+Convert.ToString(idcard_c.Balance)+&#x27;\\n&#x27; ); break; &#125; &#125; &#125; //点击进行刷卡消费 private void button2_Click(object sender, EventArgs e) &#123; double xiaofei = Convert.ToDouble(textBox1.Text); foreach (object x in Form1.array) &#123; IDcard idcard_x = (IDcard)x; if (idcard_x.ID == Form1.CurId) &#123; if(idcard_x.Balance &gt;= xiaofei ) //余额不用借款 还够本次消费 &#123; idcard_x.Balance -= xiaofei; tishi.Text += (idcard_x.Name + &quot;成功消费&quot; + textBox1.Text + &quot;元，账户余额为：&quot;+ idcard_x.Balance + &#x27;\\n&#x27;); &#125;else&#123; if (IsNormal) //判断是否为普通卡，余额不足进行透支 &#123; if ((idcard_x.Balance + 10000) &gt;= xiaofei) &#123; idcard_x.Balance -= xiaofei; tishi.Text += (idcard_x.Name + &quot;成功透支消费&quot; + textBox1.Text + &quot;元，账户余额为:&quot; + idcard_x.Balance + &#x27;\\n&#x27;); &#125; else &#123; tishi.Text += (idcard_x.Name + &quot;余额不足，不能进行消费。账户余额为：&quot; + idcard_x.Balance + &#x27;\\n&#x27;); &#125; &#125; else &#123; if ((idcard_x.Balance + 20000) &gt;= xiaofei) &#123; idcard_x.Balance -= xiaofei; tishi.Text += (idcard_x.Name + &quot;成功透支消费&quot; + textBox1.Text + &quot;元，账户余额为:&quot; + idcard_x.Balance + &#x27;\\n&#x27;); &#125; else &#123; tishi.Text += (idcard_x.Name + &quot;余额不足，不能进行消费。账户余额为：&quot; + idcard_x.Balance + &#x27;\\n&#x27;); &#125; &#125; &#125; break; &#125; &#125; &#125; //实现还款的功能 private void button3_Click(object sender, EventArgs e) &#123; double huankuan = Convert.ToDouble(textBox2.Text); foreach (object x in Form1.array) &#123; IDcard idcard_h = (IDcard)x; if (idcard_h.ID == Form1.CurId) &#123; idcard_h.Balance += huankuan; tishi.Text += (&quot;还款成功，&quot;+idcard_h.Name + &quot;的余额为&quot; +idcard_h.Balance + &#x27;\\n&#x27;); break; &#125; &#125; &#125; //实现转账功能 private void button4_Click(object sender, EventArgs e) &#123; string name_h = textBox3.Text;//对方账户名 double id_h = Convert.ToDouble(textBox4.Text);//对方卡号 double zhuanMoney = Convert.ToDouble(textBox5.Text);//转账金额 Boolean isSearch = false;//记录对方账户是否找到 double OwnBalanceAfter=0;//记录自己转账之后的余额 double OwnBalanceBefore = 0;//记录自己转账之前的余额 foreach (object x2 in Form1.array) &#123;//找到自己的账户，并把其引用赋值给idcard_Own IDcard idcard_Own = (IDcard)x2; if (idcard_Own.ID == Form1.CurId) &#123;//初始化OwnBalanceBefore和OwnBalanceAfter相同，如果后面不相同的了，就要改变idcard_Own的余额 OwnBalanceBefore = idcard_Own.Balance; OwnBalanceAfter = OwnBalanceBefore; break; &#125; &#125; foreach (object x in Form1.array) &#123; IDcard idcard_h = (IDcard)x; //对方的对象 if (idcard_h.ID == id_h&amp;&amp; idcard_h.Name==name_h)//当用户名和卡号都对的时候才能进行转账 &#123; if (OwnBalanceBefore &gt;= zhuanMoney ) &#123; //转账要在自己的余额里减掉，在她的账户余额里加上 OwnBalanceAfter -= zhuanMoney; idcard_h.Balance += zhuanMoney; tishi.Text += (&quot;转账成功，&quot;+ Form1.CurName + &quot;的余额为&quot; + Convert.ToString(OwnBalanceAfter) + &#x27;\\n&#x27;); isSearch = true; &#125; else &#123; isSearch = true; tishi.Text += (&quot;余额不足，转账失败，&quot;+ Form1.CurName + &quot;的余额为&quot; + Convert.ToString(OwnBalanceBefore) + &#x27;\\n&#x27;); &#125; break; &#125; &#125; if (!isSearch) &#123; tishi.Text += &quot;对不起，你输入的用户名和信用卡号不匹配，转账失败\\n&quot;; &#125; if(OwnBalanceAfter!= OwnBalanceBefore) &#123;//这样写是因为类中声明一个idcard_Own，他不能在下面用，因为会出现使用对象未赋值的错误 foreach (object x3 in Form1.array) &#123;//找到自己的账户，并把其引用赋值给idcard_Own IDcard idcard_Own = (IDcard)x3; if (idcard_Own.ID == Form1.CurId) &#123; idcard_Own.Balance = OwnBalanceAfter; break; &#125; &#125; &#125; &#125; //实现提现功能 private void button5_Click(object sender, EventArgs e) &#123; double tixian = Convert.ToDouble(textBox6.Text); foreach (object x in Form1.array) &#123; IDcard idcard_t = (IDcard)x; if (idcard_t.ID == Form1.CurId) &#123; if (idcard_t.Balance&gt;=tixian) &#123; idcard_t.Balance -= tixian; tishi.Text += (&quot;提现成功&quot;+idcard_t.Name + &quot;的余额为&quot; + Convert.ToString(idcard_t.Balance) + &#x27;\\n&#x27;); &#125; else &#123; tishi.Text += (&quot;余额不足，提现失败&quot;+idcard_t.Name + &quot;的余额为&quot; + Convert.ToString(idcard_t.Balance) + &#x27;\\n&#x27;); &#125; break; &#125; &#125; &#125; //点击安全退出 private void button6_Click(object sender, EventArgs e) &#123; Application.Exit(); &#125; &#125;&#125; 第九章 windows窗体程序的设计tips（字体）：fontfamily 就是像是word中的字体（规定元素的字体系列），font是fontfamily +大小+修饰 设置字体的方法：1.方法一，通过Font类设置控件名.Font&#x3D;new Font(“华文新魏”,22.2f, FontStyle.Bold |Ityle.ItalicFontStyle.Underline);2.方法二，通过字体对话框设置首先，要添加FontDialog控件其次，要在代码页中写上这两行代码： fontDialog1.ShowDialog();&#x2F;&#x2F;此方法用于弹出字体对话框 control.Font&#x3D;fontDialog1.Font； 如果没有fontDialog.ShowDialog()这一行，就不会弹出对话框。Font中只包含字形等信息，没有包含字体颜 色，如果要设置字体颜色，就要在字体对话框中开启颜色选 项，具体做法是在fontDiaglog1.ShowDialog() 这行代码之前加一行代码fontDialog1.ShowColor&#x3D;true。具体做法如下： fontDialog1.ShowColor&#x3D;true;&#x2F;&#x2F;这行代码一定要出现在fontDialog1.ShowDialog()之前。 fontDialog1.ShowDialog(); control.Font&#x3D;fontDialog1.Font； control.ForeColor&#x3D;fontDialog1.Color；&#x2F;&#x2F;设置字体颜色","categories":[{"name":"C#","slug":"C","permalink":"https://zouyunkai.github.io/myblog/categories/C/"}],"tags":[{"name":"c#","slug":"c","permalink":"https://zouyunkai.github.io/myblog/tags/c/"}],"author":"aoyuehan"},{"title":"QLU_OJ","slug":"QLU-OJ","date":"2019-09-25T09:39:00.000Z","updated":"2022-02-26T04:29:57.888Z","comments":true,"path":"2019/09/25/QLU-OJ/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/09/25/QLU-OJ/","excerpt":"","text":"-A+B的计算 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); ll a,b,n; while(cin&gt;&gt;n) &#123; ll sum=0; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a; sum+=a; &#125; cout&lt;&lt;sum&lt;&lt;&quot;\\n&quot;; &#125;&#125; 小知识： 原来而cin，cout之所以效率低，是因为先把要输出的东西存入缓冲区，再输出，导致效率降低，而这段语句可以来打消iostream的输入输出缓存，可以节省许多时间，使效率与scanf与printf相差无几，还有应注意的是scanf与printf使用的头文件应是stdio.h而不是 iostream。 在ACM里，经常出现 数据集超大造成 cin TLE的情况。这时候大部分人（包括原来我也是）认为这是cin的效率不及scanf的错，甚至还上升到C语言和C++语言的执行效率层面的无聊争论。其实像上文所说，这只是C++为了兼容而采取的保守措施。我们可以在IO之前将stdio解除绑定，这样做了之后要注意不要同时混用cout和printf 之类。 在默认的情况下cin绑定的是cout，每次执行 &lt;&lt; 操作符的时候都要调用flush，这样会增加IO负担。可以通过tie(0)（0表示NULL）来解除cin与cout的绑定，进一步加快执行效率。 统计单词书 题目描述给你一段语句，其中该语句仅由26个英文字母组成，让你统计该语句共有多少个单词；所谓单词，就是指的是被标点符号分割开的连续的英文字母；输入输入仅包含一行，表示一段语句； 输出输出该语句包含的单词个数样例输入I love ACM,and you?love or hate?样例输出8 提示样例1共出现8个英语单词，分别为： I love ACM and you love or hate给出的语句的长度不超过 200,每两个单词间仅被一个字符（空格或英文标点符号）分隔开； 123456789101112131415161718192021222324 #include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); string s; getline(cin,s); int len = s.size(); int sum=1; for(int i=0;i&lt;len;i++) &#123; if(!isalpha(s[i])) //一种函数：判断字符ch是否为英文字母，若为英文字母，返回非0（小写字母为2，大写字母为1）。若不是字母，返回0。 &#123; sum++; &#125; &#125; if(!isalpha(s[len-1])) cout&lt;&lt;sum-1; else cout&lt;&lt;sum;&#125;","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"qluoj","slug":"qluoj","permalink":"https://zouyunkai.github.io/myblog/tags/qluoj/"}],"author":"aoyuehan"},{"title":"qlu_acm个人赛第二场","slug":"qlu-acm个人赛第二场","date":"2019-09-23T15:11:00.000Z","updated":"2022-02-26T03:52:51.639Z","comments":true,"path":"2019/09/23/qlu-acm个人赛第二场/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/09/23/qlu-acm%E4%B8%AA%E4%BA%BA%E8%B5%9B%E7%AC%AC%E4%BA%8C%E5%9C%BA/","excerpt":"","text":"A. BowWow and the Timetable 借的图，讲的很详细 题意大致是给你一个二进制串，然后问4^k （k &#x3D; 0，1，2…..）小于这个二进制串的数有多少个。 这一题中的4^x所占的奇偶数不同来找规律，然后分情况计算10000和10010这两种除最高位是否还有1的情况，有1的话就strlen(str)&#x2F;2+1，否则就strlen(str)&#x2F;2。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788方法一：#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;string s;int i,j;int ans;int cnt;int main()&#123; cin&gt;&gt;s; int n=s.length()-1; for(i=0;i&lt;=n;i++)//从0到n-1有s.length()个元素 &#123; if(s[i]==&#x27;1&#x27;) cnt++;//统计所有位置的1的情况（包括最高位） &#125; if(n%2==0&amp;&amp;cnt==1) //这就是10000的那种情况，也就是2的多少次幂的情况 ans=n/2; else if(n!=0)//就是相当于 2^4的时候有2辆错过了，但是若这个二进制串中有一个1，那么在2^4的时候这辆也会错过，所以要+1 ans=n/2+1; else ans=0; cout&lt;&lt;ans; return 0;&#125;方法二：#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; char str[200]; scanf(&quot;%s&quot;, str); int len = strlen(str); cout&lt;&lt;len&lt;&lt;endl; cout&lt;&lt;(len%2)&lt;&lt;endl; int m = 0; if (len % 2 == 1) &#123; for (int i = 1; i &lt; strlen(str); i++) &#123;//少统计最高位的那个位的数（str[0]）为0 or 1，因为最高位是奇数位然后后面没有1和最高位是偶数的情况可以归为一类，即ans=len/2 int t = str[i] - &#x27;0&#x27;; m = m + t; &#125; &#125; if (m &gt; 0) &#123; m = 1; &#125; int ans = len / 2 + m; printf(&quot;%d\\n&quot;, ans); return 0;&#125;小知识：#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; char s[3]; cin&gt;&gt;s; cout&lt;&lt;s[0]&lt;&lt;s[1]&lt;&lt;s[2]; //输入：abc；输出cba，即c为s[0]&#125;相应的可以用for循环来高低位互换#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; string ss; cin&gt;&gt;ss; char s[100]; int n=ss.size(); for(int i=0;i&lt;n;i++)&#123; //换n位，下标为0与下标为n-1互换，1与n-2互换 s[i]=ss[n-i-1]; &#125; for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;s[i]; &#125; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"训练","slug":"训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%AE%AD%E7%BB%83/"}],"author":"aoyuehan"},{"title":"图论基础 ","slug":"图","date":"2019-09-09T13:03:00.000Z","updated":"2022-02-26T03:51:21.551Z","comments":true,"path":"2019/09/09/图/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/09/09/%E5%9B%BE/","excerpt":"","text":"图基本概念 图是（Graph）一种较线性表和数更为复杂的数据结构。 在线性结构中，数据元素之间仅存在线性关系。 在树型结构中，数据元素之间存在明显的一对多的层次关系（有一个直接前驱，多个直接后继）。 在图型结构中，节点之间是多对多的任意关系。 图的定义 注意：线性表可以是空表，树可以是空树，图不可以是空图，图可以没有边，但是至少要有一个顶点。 例如： 123G=(V, E)V=&#123;1,2,3,4&#125;E=&#123;(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)&#125; 123G=(V,E)V=&#123;1,2,3&#125;E=&#123;&lt;1,2&gt;, &lt;2,1&gt;, &lt;2,3&gt;&#125; 图的表示 邻接矩阵 二维矩阵memset是按字节来赋值的，赋值给二维数组时可能会出错，所以用for来赋值比较好。 1.memeset函数只能对连续的内存空间初始化。两次用malloc函数在堆上分的内存可能会不连续，因此错误。2.如果是直接声明的多维数组如a[5][5]，其内存肯定是连续的，此时统一memset没问题。 领接表 链表或者vector来存无向图的时候 要v[from].push_back(to),v[to].push_back(from),两个数组中都要存一下，有向图只要前者就好。 链式前向星 图的最小生成树 完全图：任意两个顶点之间都有直达的边想连的无向图。 连通图：任意两个顶点之间都有路径相通的无向图。（对于有向图，若任意两个顶点之间都存在一条有向路径，则称此有向图为强连通图。否则，其各强连通子图称作它的强连通分量。） 生成树：一个连通图的生成树是指一个极小连通子图，含有图中的全部n个节点，但只有足以构成一棵树的n-1条边。（树中除根节点之外的每一个节点都有一个直接前驱，即有n-1条边），并且对于一个连通图来说，它的生成树并不唯一。 最小生成树要解决的两个问题：首先尽可能选取权值小的边，但不能构成回路。其次就是选取n-1条恰当的边以连接网的n个顶点。算法一：普里姆算法（Prim） 基本思想： 算法二：克鲁斯卡尔算法（Kruskal）搜索 bfs 求字母的的变换如果tle之后，可以考虑把queue这种的stl变为queue数组来模拟一下C++ std::unordered_map 用法详解 和map的区别就是不排序，快o（1）的求出对应的值。 求树上的最大的直径dfs遍历一下求最大 例题 拓扑排序先标记一个in数组，然后遇到一个in为0的点，就把该节点加入队列中，然后把该点为起始边的in减1，然后在遇到in为0的点，在加入队列中，最后如果队列中的点比图中的点少的话，那么就说明有环。 具有拓扑序列的图中两点间的最长距离（DAG中的最长路径）https://blog.csdn.net/qq_32108329/article/details/78618182?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task DAG中的最短路径https://www.jianshu.com/p/cf1b9fcfe3bf https://www.cnblogs.com/gtarcoder/p/4895103.html 最小生成树的应用 最短路径时间复杂度：dij&lt;spfa&lt;flord spfa可以用来求带负权边的最短路 多源最短路","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://zouyunkai.github.io/myblog/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://zouyunkai.github.io/myblog/tags/BFS/"},{"name":"图","slug":"图","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%9B%BE/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"}],"author":"aoyuehan"},{"title":"哲学","slug":"哲学","date":"2019-09-09T11:16:00.000Z","updated":"2022-02-26T04:29:58.297Z","comments":true,"path":"2019/09/09/哲学/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/09/09/%E5%93%B2%E5%AD%A6/","excerpt":"","text":"哲学问题（浙江大学之哲学问题）无用之用 哲学作为无用之用的知识 哲学不是政治，政治是关于人类社会组织形式的知识；而哲学是一种理论,是关于知识的学问，关于社会的关切，关于自身的关切。 哲学的知识特性是回答自己的好奇,为惊奇而求知，为求知而求知，是要把人们从无知当中解放出来，是黑暗中的曙光，会给人类带来自由（因为我们对无知有着深深的恐惧，因为无知限制了我们的自由）。 哲学这一个学科指向自由，通过消除无知来指向自由，所以亚里士多德说它并不是为了实用的目的，不是为了造一张椅子，造一个房子，也不是为了造出航天飞机，他就是出于为什么，我是处在这么一个黑暗之中的一个恐惧感，一个惊奇感，一个方向感，来寻找认知。 为消除人无知，不是为了看具体事物，看事物本身，看世界本身。 并且哲学是有整体性的，比如一个苍蝇在一个捕蝇瓶中，他不知道这个透明的瓶子那地方是瓶口，就像我们人一样，用手，脚等感受生活，是无法得知世界本身的，所以哲学是什么呢，指出那条路径，指出那个整体性，哲学是为了事物本身的缘故，是啊吧事物本身当做目的，而不是当做一个片段来研究，哲学是一种智慧，智慧就是提供整体性原则的。哲学的最终是建立自我，定位自我，寻找价值的方位，发现人存在的意义和价值。 哲学的无用 一个不自足的人可以自足的生活，哲学是一个反思性的知识，让你有一个更丰富的自我意识，无用之用并不是真的无用，而是发现自我发现的有效性。 在一个技术的时代，人跟容易被控制，人更容易从自我意识中异化出去，也就是自己成了自己的敌人， （就比如上课的时候，你的手指在划动手机上的视频，这时候那个手机就成了你手指的主人，这个时候你就成了一个工具性的存在），就是这样，哲学让我们在技术的时代我们如何能够让技术是我们的生活变得美好，而不是让技术是我们的生活变得空洞。论辩 论辩的形式 论辩是一个民族下的产物。论辩起于文化。你要用理性去说服别人，展现你思考的逻辑，展现你为何这样思考的逻辑，包含论题和论证的逻辑。 论辩的核心文化形式：首先是公民的主权，其次是论辩与广场文化有关系，再次讲道理的说服记忆。 辩证法和修辞学的差别是用短句一问一答，轮番问答，来说服别人；而修辞学是长篇大论，滔滔不绝的说服你。 修辞学","categories":[{"name":"生活知识","slug":"生活知识","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%93%B2%E5%AD%A6/"}],"author":"aoyuehan"},{"title":"栈和队列 表达式求值","slug":"栈和队列","date":"2019-08-31T14:07:00.000Z","updated":"2022-02-26T03:51:21.585Z","comments":true,"path":"2019/08/31/栈和队列/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/08/31/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"","text":"栈队列表达式求值问题 表达式求值：首先要考虑的是运算符的优先级的顺序，其次是运算符的结合方向。（例如：表达式x+yz，首先要先运算yz，再运算x+（y*z），其存入计算机的顺序是从左到右的顺序。） 问题分析： 其中，例如 ：x+y+z这个表达式，依据表中运算符的优先级顺序，先算x+y再算第二个加号。 算法思路： 算法实现：要是251的话，用getchar（）就不能实现了，那该怎么办；还有就是要是单目运算符的怎么办，还有就是后缀运算符？？？？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150实现代码：其中3.22.h文件中定义了有关栈的操作（如初始化栈，压栈，弾栈取栈顶的操作）和运算符比较优先级的操作，3.22.cpp为测试主文件。&lt;3.22.h文件&gt;/***链栈实现表达式求值***/#include&lt;iostream&gt;using namespace std;const char oper[7] = &#123; &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;#&#x27; &#125;;#define OK 1#define ERROR 0#define OVERFLOW -2typedef char SElemType;typedef int Status;typedef struct SNode &#123; int data; struct SNode *next;&#125; SNode, *LinkStack;Status InitStack(LinkStack &amp;S) &#123; S = NULL; return OK;&#125;bool StackEmpty(LinkStack S) &#123; if (!S) return true; return false;&#125;Status Push(LinkStack &amp;S, SElemType e) &#123; SNode *p = new SNode; if (!p) &#123; return OVERFLOW; &#125; p-&gt;data = e; p-&gt;next = S; S = p; return OK;&#125;Status Pop(LinkStack &amp;S, SElemType &amp;e) &#123; SNode *p; if (!S) return ERROR; e = S-&gt;data; p = S; S = S-&gt;next; delete p; return OK;&#125;Status GetTop(LinkStack &amp;S) &#123; if (!S) return ERROR; return S-&gt;data;&#125;bool In(char ch) &#123;//判断ch是否为运算符 for (int i = 0; i &lt; 7; i++) &#123; if (ch == oper[i]) &#123; return true; &#125; &#125; return false;&#125;char Precede(char theta1, char theta2) &#123;//判断运算符优先级 if ((theta1 == &#x27;(&#x27; &amp;&amp; theta2 == &#x27;)&#x27;) || (theta1 == &#x27;#&#x27; &amp;&amp; theta2 == &#x27;#&#x27;)) &#123; return &#x27;=&#x27;; &#125; else if (theta1 == &#x27;(&#x27; || theta1 == &#x27;#&#x27; || theta2 == &#x27;(&#x27; || (theta1 == &#x27;+&#x27; || theta1 == &#x27;-&#x27;) &amp;&amp; (theta2 == &#x27;*&#x27; || theta2 == &#x27;/&#x27;)) &#123; return &#x27;&lt;&#x27;; &#125; else return &#x27;&gt;&#x27;;&#125;char Operate(char first, char theta, char second) &#123;//计算两数运算结果 switch (theta) &#123; case &#x27;+&#x27;: return (first - &#x27;0&#x27;) + (second - &#x27;0&#x27;) + 48; //因为0对应的ascii值为48，该函数返回值为char类型，所以要转换为char类型返回； case &#x27;-&#x27;: return (first - &#x27;0&#x27;) - (second - &#x27;0&#x27;) + 48; case &#x27;*&#x27;: return (first - &#x27;0&#x27;) * (second - &#x27;0&#x27;) + 48; case &#x27;/&#x27;: return (first - &#x27;0&#x27;) / (second - &#x27;0&#x27;) + 48; &#125; return 0;&#125;//算法3.22 表达式求值char EvaluateExpression() &#123;//算术表达式求值的算符优先算法，设OPTR和OPND分别为运算符栈和操作数栈 LinkStack OPTR, OPND; char ch, theta, a, b, x, top; InitStack(OPND); //初始化OPND栈 InitStack(OPTR); //初始化OPTR栈 Push(OPTR, &#x27;#&#x27;); //将表达式起始符“#”压入OPTR栈 cin &gt;&gt; ch; while (ch != &#x27;#&#x27; || (GetTop(OPTR) != &#x27;#&#x27;)) //表达式没有扫描完毕或OPTR的栈顶元素不为“#” &#123; if (!In(ch)) &#123; Push(OPND, ch); cin &gt;&gt; ch; &#125; //ch不是运算符则进OPND栈 else switch (Precede(GetTop(OPTR), ch)) //比较OPTR的栈顶元素和ch的优先级 &#123; case &#x27;&lt;&#x27;: Push(OPTR, ch); cin &gt;&gt; ch; //当前字符ch压入OPTR栈，读入下一字符ch break; case &#x27;&gt;&#x27;: Pop(OPTR, theta); //弹出OPTR栈顶的运算符 Pop(OPND, b); Pop(OPND, a); //弹出OPND栈顶的两个运算数 Push(OPND, Operate(a, theta, b)); //将运算结果压入OPND栈 break; case &#x27;=&#x27;: //OPTR的栈顶元素是“(”且ch是“)” Pop(OPTR, x); cin &gt;&gt; ch; //弹出OPTR栈顶的“(”，读入下一字符ch break; &#125; //switch &#125; //while return GetTop(OPND); //OPND栈顶元素即为表达式求值结果&#125;&lt;3.22.cpp文件&gt;#include&quot;3.22.h&quot;int menu() &#123; int c; cout &lt;&lt; &quot;0-9以内的多项式计算&quot; &lt;&lt; endl; cout &lt;&lt; &quot;1.计算&quot; &lt;&lt; endl; cout &lt;&lt; &quot;0.退出\\n&quot; &lt;&lt; endl; cout &lt;&lt; &quot;选择：&quot;; cin &gt;&gt; c; return c;&#125;void main() &#123; while (1) &#123; switch (menu()) &#123; case 1: &#123; cout &lt;&lt; &quot;请输入要计算的表达式（操作数和结果都在0-9的范围内，以#结束）：&quot; &lt;&lt; endl; char res = EvaluateExpression();//算法3.22 表达式求值 cout &lt;&lt; &quot;计算结果为&quot; &lt;&lt; res - 48 &lt;&lt; endl &lt;&lt; endl; &#125; break; case 0: cout &lt;&lt; &quot;退出成功\\n&quot; &lt;&lt; endl; exit(0); default: break; &#125; &#125;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://zouyunkai.github.io/myblog/tags/%E9%98%9F%E5%88%97/"},{"name":"递归","slug":"递归","permalink":"https://zouyunkai.github.io/myblog/tags/%E9%80%92%E5%BD%92/"}],"author":"aoyuehan"},{"title":"字符串匹配算法","slug":"KMP算法","date":"2019-08-09T14:06:00.000Z","updated":"2022-02-26T03:52:51.919Z","comments":true,"path":"2019/08/09/KMP算法/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/08/09/KMP%E7%AE%97%E6%B3%95/","excerpt":"","text":"BF算法 概念介绍 暴力匹配（BF）算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较，直到得出最后的匹配结果。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/***字符串匹配算法***/#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;#define OK 1#define ERROR 0#define OVERFLOW -2typedef int Status;#define MAXSTRLEN 255 //用户可在255以内定义最长串长typedef char SString[MAXSTRLEN+1]; //0号单元存放串的长度Status StrAssign(SString T, char *chars) &#123; //生成一个其值等于chars的串T int i; if (strlen(chars) &gt; MAXSTRLEN) return ERROR; else &#123; T[0] = strlen(chars); for (i = 1; i &lt;= T[0]; i++) T[i] = *(chars + i - 1); return OK; &#125;&#125;//算法4.1 BF算法int Index(SString S, SString T, int pos)&#123; //返回模式T在主串S中第pos个字符之后第s一次出现的位置。若不存在，则返回值为0 //其中，T非空，1≤pos≤StrLength(S) int i = pos; int j = 1; while(i &lt;= S[0]&amp;&amp;j &lt;= T[0]) &#123; if(S[i]==T[j]) &#123; ++i; ++j; &#125; //继续比较后继字符 else &#123; i=i-j+2; //这地方要让i指针回溯到i-j+2这个位置 j=1; &#125; //指针后退重新开始匹配 &#125; if (j &gt; T[0]) return i - T[0]; else return 0; return 0;&#125;int main()&#123; SString S; StrAssign(S,&quot;bbaaabbaba&quot;) ; SString T; StrAssign(T,&quot;abb&quot;) ; cout&lt;&lt;&quot;主串和子串在第&quot;&lt;&lt;Index(S,T,1)&lt;&lt;&quot;个字符处首次匹配\\n&quot;; return 0;&#125; KMP算法KMP算法求解什么类型问题 字符串匹配。给你两个字符串，寻找其中一个字符串是否包含另一个字符串，如果包含，返回包含的起始位置。如下面两个字符串： 123char *str = &quot;bacbababadababacambabacaddababacasdsd&quot;;char *ptr = &quot;ababaca&quot;;str有两处包含ptr 分别在str的下标10，26处包含ptr。 算法说明 概念介绍 一般匹配字符串时，我们从目标字符串str（假设长度为n）的第一个下标选取和ptr长度（长度为m）一样的子字符串进行比较，如果一样，就返回开始处的下标值，不一样，选取str下一个下标，同样选取长度为n的字符串进行比较，直到str的末尾（实际比较时，下标移动到n-m）。这样的时间复杂度是O(n*m)。 KMP算法：可以实现复杂度为O(m+n)为何简化了时间复杂度： 充分利用了目标字符串ptr的性质（比如里面部分字符串的重复性，即使不存在重复字段，在比较时，实现最大的移动量）。 KMP算法中,每当一趟匹配过程中出现失配时，主串S中的i指针不需要回溯，而是利用已经得到的“部分匹配”结果，将模式串向右“滑动”尽可能远的一段距离后，继续进行比较，从而快速达到匹配结果。 模式串中next值的计算思想 next数组的含义就是一个固定字符串的最长前缀和最长后缀相同的长度的值(它加不加1都可以，加1的原因是：例如当模式串是abcaba的时候，在匹配主串的时候，当j&#x3D;6这个位置时（即第三个a的时候），next[6]的值就是3，在这时出现失配，j指针变为next[6]的值，即从字母c处重新比较,；若不加1就会从那个相同的那个字母开始继续比较)注意最长前缀：是说以第一个字符开始，但是不包含最后一个字符。 比如：aaaa相同的最长前缀和最长后缀是aaa。 abcjkdabc，那么这个数组的最长前缀和最长后缀相同必然是abc。 cbcbc，最长前缀和最长后缀相同是cbc。 abcbc，最长前缀和最长后缀相同是不存在的。对于目标字符串ptr，ababaca，长度是7，所以next[0]，next[1]，next[2]，next[3]，next[4]，next[5]，next[6]分别计算的是a，ab，aba，abab，ababa，ababac，ababaca的相同的最长前缀和最长后缀的长度。由于a，ab，aba，abab，ababa，ababac，ababaca的相同的最长前缀和最长后缀是“”，“”，“a”，“ab”，“aba”，“”，“a”,所以next数组的值是[-1,-1,0,1,2,-1,0]，这里-1表示不存在，0表示存在长度为1，2表示存在长度为3。这是为了和代码相对应。 next值的计算实例：具体的实现过程： 具体实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/***字符串匹配算法***/#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;#define OK 1#define ERROR 0#define OVERFLOW -2typedef int Status;#define MAXSTRLEN 255 //用户可在255以内定义最长串长typedef char SString[MAXSTRLEN+1]; //0号单元存放串的长度Status StrAssign(SString T, char *chars) &#123; //生成一个其值等于chars的串T int i; if (strlen(chars) &gt; MAXSTRLEN) //strlen()只能用于char *s求长度，不能用于求字符串的长度。 return ERROR; else &#123; T[0] = strlen(chars); for (i = 1; i &lt;= T[0]; i++) T[i] = *(chars + i - 1); return OK; &#125;&#125;//算法4.3 计算next函数值void get_next(SString T, int next[])&#123; //求模式串T的next函数值并存入数组next，没有用到next[0] int i = 1, j = 0; next[1] = 0; while (i &lt; T[0]) if (j == 0 || T[i] == T[j]) &#123;//即让next[2]的值是1 ++i; ++j; next[i] = j; &#125; else j = next[j];&#125;//算法4.2 KMP算法int Index_KMP(SString S, SString T, int pos, int next[])&#123; // 利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法 //其中，T非空，1≤pos≤StrLength(S) int i = pos, j = 1; while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) if (j == 0 || S[i] == T[j]) // 继续比较后继字 &#123; ++i; ++j; &#125; else j = next[j]; // 模式串向右移动 if (j &gt; T[0]) // 匹配成功 return i - T[0]; else return 0;&#125;int main()&#123; SString S; //主串 StrAssign(S,&quot;aaabbaba&quot;) ; SString T; //模式串 StrAssign(T,&quot;abb&quot;) ; int *p = new int[T[0]+1]; // 生成T的next数组，因为next[0]没有用,所以要声明一个长度为模式串长度加1的数组。 get_next(T,p); cout&lt;&lt;&quot;主串和子串在第&quot;&lt;&lt;Index_KMP(S,T,1,p)&lt;&lt;&quot;个字符处首次匹配\\n&quot;; return 0;&#125;其中拓展优化的get_next函数为：void get_nextval（SString T ,int nextval[]）&#123; int i=1;nextval[1]=0;j=0; while(i&lt;T.length)&#123; if(j==0||T.ch[i]==T.ch[j] &#123; ++i;++j; if(T.ch[i]!=T.ch[j]) nextval[i ]=j; else nextval[i]=nactval[j]; &#125; &#125; else j=nextval[j]; &#125;&#125; 解决另一个小疑问： 1234567891011121314151617181920212223242526272829303132333435363738394041424344char类型指针和string类型数据可以实现下标访问元素值吗？#include&lt;iostream&gt;using namespace std;int main()&#123; char *p=&quot;xiaozhi&quot;; cout&lt;&lt;p[1]&lt;&lt;endl&lt;&lt;p&lt;&lt;endl&lt;&lt;*p&lt;&lt;endl; string s=&quot;xiaozhi&quot;; cout&lt;&lt;s[2]&lt;&lt;endl&lt;&lt;s;&#125; 运算结果：ixiaozhixaxiaozhi--------------------------------Process exited after 0.3133 seconds with return value 0请按任意键继续. . .char *s和char s[]的区别：char *s1=&quot;hello&quot;;//声明一个指针指向常量&quot;hello&quot;char s2[]=&quot;hello&quot;;//在栈中开辟一个数组字符&quot;hello&quot;;/** s2[]=&quot;hello&quot; 相当于* char s2[6];* s2[0]=&#x27;h&#x27;;* s2[1]=&#x27;e&#x27;;* s2[2]=&#x27;l&#x27;;* s2[3]=&#x27;l&#x27;;* s2[4]=&#x27;0&#x27;;* s2[5]=&#x27;\\0&#x27;;*说明：s1内容不能修改，因为他指向常量s2内容可以修改，因为他指代内存中的变量区s2其地址和容量在生命期里不能改变作为形参完全相同例：void function(char *s1);void function(char s1[]);*/ 这其中还有一种算法的改变就是再求next数组的时候用到next[0]。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void GetNext(int *next,const char *sub)&#123; next[0] = -1; next[1] = 0; int lensub = strlen(sub); int i = 2;//当前的i int k = 0;//前一项的K值 while(i &lt; lensub) &#123; if(k == -1 || sub[i-1] == sub[k]) &#123; next[i] = k+1; i++; k = k+1; &#125; else &#123; k = next[k]; &#125; &#125;&#125;int Kmp(const char *str,const char *sub,int pos)&#123; int i = pos; int j = 0; //此时j=0就是用next[0]这个值，上面那个是j=1就不用next[0]这个值啦 int lens = strlen(str); int lensub = strlen(sub); int *next = (int *)malloc(sizeof(int) * lensub); assert(next != NULL); GetNext(next,sub); while(j &lt; lensub &amp;&amp; i &lt; lens) &#123; if(j == -1 || str[i] == sub[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; &#125; &#125; if(j &gt;= lensub) &#123; return i-j; &#125; else &#123; return -1; &#125;&#125; https://blog.csdn.net/f_zyj/article/details/51694610","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"https://zouyunkai.github.io/myblog/tags/KMP/"},{"name":"CF","slug":"CF","permalink":"https://zouyunkai.github.io/myblog/tags/CF/"}],"author":"aoyuehan"},{"title":"Git使用","slug":"Git使用","date":"2019-08-08T12:02:00.000Z","updated":"2022-02-26T03:52:51.233Z","comments":true,"path":"2019/08/08/Git使用/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/08/08/Git%E4%BD%BF%E7%94%A8/","excerpt":"","text":"git命令使用1、什么是GitGit(读音为&#x2F;gɪt&#x2F;。)是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。有两种操作处理方式：一、先克隆到本地，修改删除文件之后，再push方法1、先将仓库clone到本地，修改后再push到码云的仓库仓库 1$ git clone https://gitee.com/用户个性地址/HelloGitee.git #将远程仓库克隆到本地 在克隆过程中，如果仓库是一个私有仓库，将会要求用户输入码云的账号和密码。按照提示输入即可。当然，用户也可以通过配置本地的git配置信息，执行git config命令预先配置好相关的用户信息，配置执行如下： 12$ git config --global user.name &quot;你的名字或昵称&quot;$ git config --global user.email &quot;你的邮箱&quot; 修改代码后，在仓库目录下执行下面命令 123$ git add . #将当前目录所有文件添加到git暂存区$ git commit -m &quot;my first commit&quot; #提交并备注提交信息$ git push origin master #将本地提交推送到远程仓库 二、初始化之后 因为远程仓库和自己的不一样，先pull之后再push 方法二：1、将文件添加到暂存区，再提交到本地仓库 ，再push（1）初始化一个本地版本库，执行一次即可，后面不用再执行 1git init (2)若为私有仓库的话就应该设置用户名和邮箱(全局，要和仓库中的用户名和邮箱一样) 12git config user.name &quot;用户名&quot; git config user.email &quot;xxxxxx@qq.com&quot; (3)创建文件，创建一个名为ai的txt文件 1touch ai.txt (4)查看状态（查看本地暂存区中 有的文件） 1git status 但是上面那样ai文件是在本地的，用git add ai.txt指令将其添加到暂存区，就可以通过git status指令看到了；另外可以使用git add . 命令刚才初始化文件夹下的所有文件都保存到本地暂存区中(5)暂存区（git add过的文件） 提交到本地版本库中1) -m后跟注释内容2) 可以 直接 在后面跟上文件，表示把该文件提交到本地版本库（不推荐）3) **不跟任何文件名称，表示把当前所有暂缓区中的内容都提交到 本地版本库 中 **下面两种写法都可以 12git commit -m &quot;只提交ai.txt文件试试，这是注释&quot; ai.txtgit commit -m &quot;这是注释，这样会把整个暂存区中的东西都提交到本地版本库中&quot; **出现nothing to commit, working tree clean表示成功将文件从暂存区提交到本地版本库 **3、修改文件先用vim命令对ai.txt文件进行修改，操作和在Liunx一模一样,修改完后在执行git status查看状态 这种红色的状态代表可提交，这种可提交状态说明他没有在暂存区中，只是在本地目录中再次执行 1git add ai.txt 这种绿色状态代表成功到达暂存区然后执行commit 到本地版本库中4、删除文件step1: 删除本地 1rm -rf ai.txt #删除本地目录中的ai.txt step2:删除暂存区 12git rm ai.txt #在暂存区中删除ai.txt文件git status #查看状态 step3:提交删除 1git commit -m &quot;注释&quot; 以上是从工作区到暂存区的操作，下面是操作远程仓库相关的 5、克隆操作（1）首先获得远程仓库地址（2）git config –list 查看设置过的参数（3）到一个文件夹下，bash命令执行 12345678# 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下$ git clone &lt;远程仓库的网址&gt;# 指定本地仓库的目录$ git clone &lt;远程仓库的网址&gt; &lt;本地目录&gt;# -b 指定要克隆的分支，默认是master分支$ git clone &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt; 整个repository(仓库的意思)就被下载下来了。 总结：touch xx.txt 创建文件git add xx.txt 添加到缓存区git commit -m “hahaha” 提交到本地仓库 （其中-m和后面的引号之间没有空格）git push 上传到远程仓库 6、上传一个文件到仓库的实例操作（1）通过以下命令会添加一个远程仓库 1234567891011121314git remote add origin https://github.com/aoyue# 列出已经存在的远程仓库$ git remote# 列出远程仓库的详细信息，在别名后面列出URL地址$ git remote -v$ git remote --verbose# 添加远程仓库$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;# 删除指定名称的远程仓库$ git remote remove &lt;远程仓库的别名&gt; git remote是管理远程仓库的命令，后面的add origin &lt;地址&gt; ，表示增加了一个origin远程仓库（origin就是一个远程主机的名字），origin是一个指针指向了后面的value。 （2）在将本地仓库与GitHub网站上的仓库进行关联后，便可进行推送了，但是在第一次进行推送时，需要注意的是，GitHub网站上的仓库并非是空的，在创建时创建了一个README文档，因此需要将两者进行合并才行。（rebase和merge都代表合并两者区别:rebase和bersge区别合并的时候，有可能会产生冲突。冲突的产生是因为在合并的时候，不同分支修改了相同的位置。所以在合并的时候git不知道那个到底是你想保留的，所以就提出疑问（冲突提醒）让你自己手动选择想要保留的内容，从而解决冲突。) 123git pull --rebase origin master #git pull只是修改#这个就是远程分支上有本地没有的文件，两者不相同，#所以存在冲突；这个冲突不是本地有远程分支没有，而是远程分支有，本地没有 上面这句话是关联的操作。最后，再进行推送即可。 1git push -u origin master 这个带有-u这个参数是指，将本地存储的master分支的所有内容都提交，第一次关联之后后边你再提交就可以不用这个参数了，之后你的每一次修改，你就可以只将你修改push就好了（即git push origin master）。上述命令中，origin代表远程仓库，master代表其分支。 1234567891011比如：git push A B:C 其中A和C是分别remote端的一个repository的名字和其branch的名字，B是本地端branch的名字它的意思是把本地的B推送到remotes/A/C下。当B=C时可以直接省略为：git push A B。比如：&quot;git push origin master:master&quot; 可以直接省略为&quot;git push origin master&quot;.再比如：git push origin master //把本地仓库提交到远程仓库的master分支中$ git push origin test:master // 提交本地test分支作为远程的master分支$ git push origin test:test // 提交本地test分支作为远程的test分支 (3)git branch -a 查看所有分支 上面的显示表示master 代表本地分支，origin&#x2F;master是远程分支 (origin指向仓库，master指向分支)第一行的master前面的星号是你所在的分支的标记第二行的红色是因为我后来对远程仓库master分支做了修改，本地和远程不同步。 (4)新增：删除github里的文件夹步骤：（以删除.idea文件夹为例） 123git rm -r --cached .idea #--cached不会把本地的.idea删除，但是写为git rm –rf .idea 就会把本地的也删除了git commit -m &#x27;delete .idea dir&#x27; git push -u origin master 理解git中的head和mastergit命令详解 错误累计1、有一次远程端有本地暂存库中没有的东西，但是自己在本地编写了文件，并且执行了add和commit命令了，再push的时候报错： 123456789$ git pushTo https://gitee.com/aoyuehan/liuxiaojing.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &#x27;https://gitee.com/aoyuehan/liuxiaojing.git&#x27;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#x27;git pull ...&#x27;) before pushing again.hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details. 报错的原因就是本地版本库和远程版本库不一致，有冲突解决办法：先git pull –rebase origin master然后不用再一次的向本地版本库中加入新编写的文件，直接push就会把新编写的文件上传上去git push -u origin master#-u这个参数是把本地的master分支全都提交上去，在提交一次之后就可以直接写git push或者git push origin master 2、还有就是自己要先pull下来远程的文件，然后在修改再add进去，commit ，再push；如果要是远程的文件a和本地版本库不一样，而且你也修改了本地版本库的文件a，然后add之后再pull，这样的就会有乱的现象，这个文件a中此时包含了你之前改的文件内容，也包含了远程的文件内容，是乱的，此时需要你手动去改这个文件。","categories":[{"name":"后端","slug":"后端","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"git","slug":"git","permalink":"https://zouyunkai.github.io/myblog/tags/git/"}],"author":"aoyuehan"},{"title":"动态规划_背包问题详解","slug":"动态规划-背包问题详解","date":"2019-08-05T02:33:00.000Z","updated":"2022-02-26T03:52:51.000Z","comments":true,"path":"2019/08/05/动态规划-背包问题详解/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/08/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"动态规划_背包问题详解最优装配给出 n 个物体，重量分别为 wi，使总重量不超过容量 C 的情况下选择尽量多的物体。这种背包问题很简单，只要求数量多就可以，因此我们对重量进行排序贪心选择就好。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int *stuff;// 最优装配int getResult(int n, int c)&#123; int cnt = 0; int sum = 0; for(int i = 0; i &lt; n; i++)&#123; sum += stuff[i];//从价值小的开始选 if(sum &lt;= c) cnt++; else break; &#125; return cnt;&#125;int main()&#123; int n, c; while(cin &gt;&gt; n &gt;&gt; c)&#123; stuff = new int[n]; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; stuff[i]; &#125; sort(stuff, stuff+n); int cnt = getResult(n, c); cout &lt;&lt; cnt &lt;&lt; endl; delete[] stuff; &#125; return 0;&#125; 部分背包问题有 n 个物体，重量分别为 wi，价值为 vi，在总重量不超过容量 C 的情况下让总价值最高，每个物体可以只取走一部分，若取走部分物体则价值也会等比例减少。这种背包问题也比较简单，可以定义一个变量 rate 表示各个物体的性价比，性价比最高的物体先拿走，如果可以整个物体都拿走则直接拿走，若不能整个拿走就拿走部分。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct STUFF &#123; int weight; int price; double rate; // 性价比 bool operator &lt; (STUFF other) const &#123; return rate &gt; other.rate; &#125;&#125;*stuffs;// 部分背包问题double getResult(int n, int c)&#123; double sum = 0; for(int i = 0; i &lt; n; i++)&#123; // 可以整个拿走就直接拿走 if(c &gt;= stuffs[i].weight)&#123; sum += stuffs[i].price; c -= stuffs[i].weight; &#125; else&#123;//因为只有一个物体，才这么写的 // 不能直接拿走就拿部分 sum += stuffs[i].price*1.0*c/stuffs[i].weight; break; &#125; &#125; return sum;&#125;int main()&#123; int n, c; while(cin &gt;&gt; n &gt;&gt; c)&#123; stuffs = new STUFF[n]; for(int i = 0; i &lt; n; i++)&#123; cin &gt;&gt; stuffs[i].weight &gt;&gt; stuffs[i].price; stuffs[i].rate = stuffs[i].price*1.0/stuffs[i].weight; &#125; sort(stuffs, stuffs+n); double result = getResult(n, c); cout &lt;&lt; result &lt;&lt; endl; delete[] stuffs; &#125; return 0;&#125; 01背包问题1、题目有N 件物品和一个容量为V 的背包。第i 件物品的费用是w[i]，价值是v[i]，求将哪些物品装入背包可使价值总和最大。2、基本思路这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。用子问题定义状态：即 f[i][j]表示前i 件物品恰放入一个容量为j 的背包可以获得的最大价值。则其状态转移方程便是： f[i][j]=max(f[i−1][j],f[i−1][j−w[i]]+v[i]) 这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所详细解释：“将前i 件物品放入容量为j的背包中”这个子问题，若只考虑第i 件物品的策略（放或不放），那么就可以转化为一个只牵扯前i−1 件物品的问题。如果不放第i件物品，那么问题就转化为“前i−1件物品放入容量为j的背包中”，价值为f[i−1][j] ；如果放第i 件物品，那么问题就转化为“前i−1件物品放入剩下的容量为j−c[i] 的背包中”，此时能获得的最大价值就是f[i−1][j−w[i]] 再加上通过放入第i ii件物品获得的价值v[i] 。3、优化空间复杂度以上方法的 **时间和空间复杂度均为O(VN) ** ，其中时间复杂度已经不能再优化了，但空间复杂度却可以优化到O(N) 。 123456789for (int i = 1; i &lt;= n; i++) for (int j = V; j &gt;= w[i]; j--) //这一步可以不用写为j&gt;=0,写成j=V...0 是为了在程序中体现每个状态都按照方程求解了，避免不必要的思维复杂度。 //而这里既然已经抽象成看作黑箱的过程了，就可以加入优化。费用为w[i]的物品不会影响状态f[0...j−1]，这是显然的，即不产生第二项。 f[j] = max(f[j], f[j - w[i]] + v[i]); //通过在主循环中以j=V...0的顺序递推f[j],这样就能保证推f[j] 时f[j−w[i]] 保存的是状态f[i−1][j−w[i]] 的值。 //即不会覆盖后面未求的元素。这样就能求一件商品了，和完全背包区别开 4、初始化的细节问题我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求”恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。这两种问法的区别是在初始化的时候有所不同。如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0] 为0其它f[1…V]均设为−∞ ，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0…V] 全部设为0 。为什么呢？可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0 的背包可能被价值为0 的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是−∞ 了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0 ，所以初始时状态的值也就全部为0 了。这个小技巧完全可以推广到其它类型的背包问题，后面也就不再对进行状态转移之前的初始化进行讲解。5、一个常数优化前面的代码中有for(j&#x3D;V…w[i]) ，还可以将这个循环的下限进行改进。由于只需要最后f[j] 的值，倒推前一个物品，其实只要知道f[j−w[n]] 即可。以此类推，对以第j 个背包，其实只需要知道到f[j−sumw[j…n]] 即可，即代码可以改成 12345for (int i = 1; i &lt;= n; i++) &#123; int bound = max(V - sum&#123;w[i]...w[n]&#125;, w[i]); for (int j = V; j &gt;= bound, j--) f[j] = max(f[j], f[j - w[i]] + v[i]);&#125; 对于求sum 可以用前缀和，这对于V 比较大时是有用的。 01背包的两种解法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;const int maxn=1000; /** * 解决背包问题的递归函数 * * @param w 物品的重量数组 * @param v 物品的价值数组 * @param index 当前待选择的物品索引 * @param capacity 当前背包有效容量 * @return 最大价值 */ int solveKS(int w[] , int v[] , int index, int capacity) &#123; //基准条件：如果索引无效或者容量不足，直接返回当前价值0 if (index &lt; 0 || capacity &lt;= 0) return 0; //不放第index个物品所得价值 int res = solveKS(w, v, index - 1, capacity); //放第index个物品所得价值（前提是：第index个物品可以放得下） if (w[index] &lt;= capacity) &#123; res = max(res, v[index] + solveKS(w, v, index - 1, capacity - w[index])); &#125; return res; &#125; int main()&#123; int size,C; int w[maxn] ; int v[maxn] ; cin&gt;&gt;size; for(int i=0;i&lt;size;i++)&#123; cin&gt;&gt;w[i]; &#125; for(int i=0;i&lt;size;i++)&#123; cin&gt;&gt;v[i]; &#125; cin&gt;&gt;C; cout&lt;&lt;solveKS(w, v, size - 1, C);&#125; #include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;const int maxn=1000; int knapSack(int w[], int v[] , int C,int size) &#123; if (size == 0) &#123; return 0; &#125; int dp[size][C + 1]; //初始化第一行 //仅考虑容量为C的背包放第0个物品的情况 for (int i = 0; i &lt;= C; i++) &#123; dp[0][i] = w[0] &lt;= i ? v[0] : 0; &#125; //填充其他行和列 for (int i = 1; i &lt; size; i++) &#123; for (int j = 0; j &lt;= C; j++) &#123; dp[i][j] = dp[i - 1][j]; if (w[i] &lt;= j) &#123; dp[i][j] = max(dp[i][j], v[i] + dp[i - 1][j - w[i]]); &#125; &#125; &#125; return dp[size - 1][C]; &#125; int main()&#123; int size,C; int w[maxn] ; int v[maxn] ; cin&gt;&gt;size; for(int i=0;i&lt;size;i++)&#123; cin&gt;&gt;w[i]; &#125; for(int i=0;i&lt;size;i++)&#123; cin&gt;&gt;v[i]; &#125; cin&gt;&gt;C; cout&lt;&lt;knapSack(w, v, C,size); &#125; 算法书上的一种方法 01背包拓展 完全背包问题1、题目有N 种物品和一个容量为V 的背包，每种物品都有无限件可用。第i 种物品的费用是w[i] ，价值是v[i] 。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。2、基本思路这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i][j] 表示前i 种物品恰放入一个容量为V的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样： f[i][j]=max(f[i−1][j−k∗w[i]]+k∗v[i])∣0&lt;=k∗w[i]&lt;=j 3、一个简单有效的优化（1）完全背包问题有一个很简单有效的优化，是这样的：若两件物品i 、j 满足 w[i]&lt;&#x3D;w[j]且v[i]&gt;&#x3D;v[j] 则将物品j 去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。这个优化可以简单的 O(N^2) )地实现，一般都可以承受。另外，针对背包问题而言，比较不错的一种方法是：首先将费用大于V的物品去掉，然后使用类似计数排序的做法，计算出费用相同的物品中价值最高的是哪个，可以O(V+N) 地完成这个优化。 （2）转化为01背包问题 4、O(VN)的算法这个算法使用一维数组，先看代码： 123for (int i = 1; i &lt;= n; i++) for (int j = w[i]; j &lt;= V; j++) f[j] = max(f[j], f[j - w[i]] + v[i]); 细心的读者会发现，这个代码与01背包的代码只有j 的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么01背包中要按照j&#x3D;V…0 的逆序来循环。这是因为要保证第i 次循环中的状态f[i][j] 是由状态f[i−1][j−w[i]] 递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i 件物品”这件策略时，依据的是一个绝无已经选入第i ii件物品的子结果f[i−1][j−w[i]] 。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i ii种物品”这种策略时，却正需要一个可能已选入第i ii种物品的子结果f[i][j−w[i]] ，所以就可以并且必须采用j&#x3D;0…V 的顺序循环。这就是这个简单的程序为何成立的道理。值得一提的是，上面的伪代码中两层for 循环的次序可以颠倒。这个结论有可能会带来算法时间常数上的优化。这个算法也可以以另外的思路得出。例如，将基本思路中求解f[i][j−w[i]] 的状态转移方程显式地写出来，代入原方程中，会发现该方程可以等价地变形成这种形式： f[i][j]=max(f[i−1][j],f[i][j−w[i]]+v[i]) 将这个方程用一维数组实现，便得到了上面的代码。 5、投资的最大效益 （lougu P1853）题目描述例如：有如下两种不同的债券：①投资额4000，年利息400；②投资额3000，年利息250。初始时，有10000的总资产，可以投资两份债券①债券，一年获得800的利息；而投资一份债券①和两份债券②，一年可获得900的利息，两年后，可获得1800的利息；而所有的资产达到11800，然后将卖掉一份债券②，换购债券①，年利息可达到1050；第三年后，总资产达到12850，可以购买三份债券①，年利息可达到1200，第四年后，总资产可达到$14050。现给定若干种债券、最初的总资产，帮助约翰先生计算，经过n年的投资，总资产的最大值。输入格式第一行为三个正整数s,n,d，分别表示最初的总资产、年数和债券的种类。接下来d行，每行表示一种债券，两个正整数a,b分别表示债券的投资额和年利息。输出格式仅一个整数，表示n年后的最大总资产。**输入 **10000 4 24000 4003000 250输出14050说明&#x2F;提示s≤10^6，n≤40，d≤10，a≤10^4,且a是1000的倍数，b不超过a的10%。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;struct o&#123;//结构体 int w,c;//w代表占用空间(所需钱数)，c代表价值&#125;p[51];int s,n,d,h[100000000]; int main()&#123; cin&gt;&gt;s&gt;&gt;n&gt;&gt;d;//输入不解释了 for(int i=1;i&lt;=d;i++)&#123; cin&gt;&gt;p[i].w&gt;&gt;p[i].c; &#125; for(int k=1;k&lt;=n;k++)&#123;//最外层是循环刷新s值的，否则s一直为本金 for(int i=1;i&lt;=d;i++)&#123;//完全背包从这里开始(i，j) for(int j=p[i].w;j&lt;=s;j++)&#123; h[j]=max(h[j],h[j-p[i].w]+p[i].c);//完全背包公式 &#125; &#125; s=s+h[s];//刷新s的值(就是本金加上这一年的利息) &#125; cout&lt;&lt;s;//输出最后空间(最后总钱数) return 0;&#125; 顺序枚举与倒序枚举详细解释 1、对于二维数组的背包来说，正序和逆序是无所谓的，因为你把状态都保存了下来，而一维数组的背包是会覆盖之前的状态的。 下面讲的就是原因 https://blog.csdn.net/yandaoqiusheng/article/details/84929357 多重背包问题 1、题目有N 种物品和一个容量为V 的背包。第i 种物品最多有p[i] 件可用，每件费用是w[i] ，价值是v[i] 。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。2、基本算法这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有p[i]+1 种策略：取0件，取1件……取p[i]件。令f[i][j]表示前i种物品恰放入一个容量为j的背包的最大权值，则有状态转移方程：f[i][j]&#x3D;max(f[i−1][j−k∗w[i]]+k∗v[i]) （0&lt;&#x3D;k&lt;&#x3D;p[i]） 复杂度是O(V∗Σp[i]) 。3、转化为01背包问题，把每个物品都为取或者不取。4、重点是转化成01背包的2进制优化，二进制优化就有那么一点点倍增的思想了（一点点而已），因为10进制的任何一个整数都是可以被二进制表达的，所以这个而二进制里的每一位都是2的几次方，所以只需要把物品的数量分成2的1~k次方就可以了，其中k为2的k次方小于n[i]的最大值，必须3就可以分解为2的一次方+2的0次方。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;int c[1001],w[1001],f[1001];int main()&#123; int n = 0,v,x; std::cin&gt;&gt;x&gt;&gt;v; for(int i = 0;i&lt;x;i++) &#123; int a,b,s,k = 1; std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;s; while(s-k&gt;=0) &#123; c[n++] = a*k;w[n-1] = b*k; s-=k;k*=2; &#125; c[n++] = s*a;//这个c数组存的就是分解之后可以取的数量 w[n-1] = s*b; &#125; for(int i = 0;i&lt;n;i++) for(int j = v;j&gt;=c[i];j--) f[j] = std::max(f[j],f[j-c[i]]+w[i]); std::cout&lt;&lt;f[v]; return 0;&#125; 例题 1234567891011121314151617181920212223242526272829303132333435363751nod 1086 背包问题 V2#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N = 50086;int dp[N];int main()&#123; int n, W; scanf(&quot;%d%d&quot;, &amp;n, &amp;W); int maxx = 0; for(int i = 1; i &lt;= n; i++) &#123; int w, p, c; cin&gt;&gt;w&gt;&gt;p&gt;&gt;c; for(int k = 1; k &lt;= c; c-=k, k&lt;&lt;=1) for(int j = W; j &gt;= w*k; j--) &#123; dp[j] = max(dp[j], dp[j-w*k]+p*k); &#125; if(C == 0) continue; for(int j = W; j&gt;= w*c; j--) dp[j] = max(dp[j], dp[j-w*c]+c*p); &#125; cout&lt;&lt;dp[W]&lt;&lt;endl; return 0;&#125; 背包九讲连接","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包问题","slug":"背包问题","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"}],"author":"aoyuehan"},{"title":"二分法","slug":"二分法","date":"2019-08-03T11:52:00.000Z","updated":"2022-02-26T03:52:52.341Z","comments":true,"path":"2019/08/03/二分法/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/08/03/%E4%BA%8C%E5%88%86%E6%B3%95/","excerpt":"","text":"二分法1、二分法查找，也称为折半法，是一种在有序数组中查找特定元素的搜索算法。2、二分法查找的思路如下： （1）首先，从数组的中间元素开始搜索，如果该元素正好是目标元素，则搜索过程结束，否则执行下一步。 （2）如果目标元素大于&#x2F;小于中间元素，则在数组大于&#x2F;小于中间元素的那一半区域查找，然后重复步骤（1）的操作。 （3）如果某一步数组为空，则表示找不到目标元素。二分法查找的时间复杂度O(logn)。 *3、 二分查找是有局限性的： （1）二分查找依赖的是顺序表结构，简单点说就是数组。 解释：主要原因是二分查找算法*需要按照下标随机访问元素。 （2）二分查找针对的是有序数据。 （3）数据量太小不适合二分查找。 （4）数据量太大也不适合二分查找。 解释：二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的空间要求比较苛刻。 3.5二分查找的递归解法 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;//二分查找的非递归形式 int binSearch(int nums[],int k)&#123; int i = 0; //j是数组最后一个下标的位置，如int a[5]，j最大为4（因为没有a[5]这个值 int j = sizeof(nums) / sizeof(nums[0])-1; int mid; while(i&lt;=j)&#123; mid = i+((j-i)&gt;&gt;1);//防止溢出,而且使用位运算更加高效//mid = ((i+j)&gt;&gt;&gt;1); if(nums[mid]==k)&#123; return mid; &#125;else if(nums[mid]&gt;k)&#123; j = mid-1; &#125;else&#123; i = mid+1; &#125; &#125; return -1;&#125;//二分查找的递归形式，其中k，i，j参数是必要的，不然的话怎么调用传值 int binSearch_1(int nums[],int k,int i,int j)&#123; //其中nums是有序数组，k为要查找的值，i为要查找的数组的起始下标，j为终点下标 if(i&gt;j) return -1; int mid =i+((j-i)&gt;&gt;1); if(nums[mid]==k)&#123; return mid; &#125;else if(nums[mid]&gt;k) &#123; return binSearch_1(nums,k,i,mid-1); &#125;else &#123; return binSearch_1(nums,k,mid+1,j); &#125;&#125; int main()&#123; int a[]=&#123;1,2,3,4,5&#125;; cout&lt;&lt;binSearch_1(a,5,0,4); //结果为4，即数组下表的最后一个，a[4] &#125; 4、实例：(1)求f(x)&#x3D;x^3-x-1在（1，1.5）内的一个实根，使误差不超过0.005。 1234567891011121314151617181920212223#include &lt;iostream&gt;#include&lt;math.h&gt;using namespace std;float Oper(float x)&#123; return x*x*x-x-1;&#125;int main()&#123; float a,b,c,x; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; while(fabs(b-a)&gt;=c)&#123; x=(a+b)/2; if(Oper(a)*Oper(x)&lt;0)&#123; b=x; &#125; else&#123; a=x; &#125; &#125; cout &lt;&lt; &quot;满足要求的值是：&quot; &lt;&lt;x&lt;&lt; endl; return 0;&#125; (2)求最小的i，使得a[i] &#x3D; key，若不存在，则返回-1(lowerbound函数)；求最大的i的下一个元素的下标(c++中的upperbound函数)，使得a[i] &#x3D; key，若不存在，则返回-1；求最大的i，使得a[i] &#x3D; key，若不存在，则返回-1；求最小的i，使得a[i] &gt; key，若不存在，则返回-1；求最大的i，使得a[i] &lt; key，若不存在，则返回-1； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100 + 10;int cmp(const void *a, const void *b) &#123; return *(int *) a - *(int *) b;&#125;//普通的二分查找int bs(int *arr,int L,int R,int target)&#123; while( L &lt;= R)&#123; int mid = (L) + (R-L)/2; if(arr[mid] == target) return mid; if(arr[mid] &gt; target) R = mid - 1; else L = mid + 1; &#125; return -1; // not find&#125;//求最小的i，使得a[i] = target，若不存在，则返回-1//返回 如果有重复的 下界(比如1,2,2,2,3,4)查找2,返回1int firstEqual(int arr[], int L, int R, int target) &#123; while (L &lt; R) &#123; int mid = L + (R - L) / 2; if (arr[mid] &lt; target) L = mid + 1; else R = mid; &#125; if (arr[L] == target) return L; return -1;&#125;//求最大的i的下一个元素的下标(c++中的upperbound函数)，使得a[i] = target，若不存在，则返回-1int lastEqualNext(int arr[], int L, int R, int target) &#123; while (L &lt; R) &#123; int m = L + (R - L) / 2; if (arr[m] &lt;= target) L = m + 1; else R = m; &#125; if (arr[L - 1] == target) return L; return -1;&#125;//求最大的i，使得a[i] = target，若不存在，则返回-1int lastEqual(int arr[], int L, int R, int target) &#123; while (L &lt; R) &#123; int mid = L + ((R + 1 - L) &gt;&gt; 1);//向上取整 if (arr[mid] &lt;= target) L = mid; else R = mid - 1; &#125; if (arr[L] == target) return L; return -1;&#125;//求最小的i，使得a[i] &gt; target，若不存在，则返回-1int firstLarge(int arr[], int L, int R, int target) &#123; while (L &lt; R) &#123; int m = L + ((R - L) &gt;&gt; 1);//向下取整 if (arr[m] &lt;= target) L = m + 1; else R = m; &#125; if (arr[R] &gt; target) return R; return -1;&#125;//求最大的i，使得a[i] &lt; target，若不存在，则返回-1int lastSmall(int arr[], int L, int R, int target) &#123; while (L &lt; R) &#123; int m = L + ((R + 1 - L) &gt;&gt; 1);//向上取整 if (arr[m] &lt; target) L = m; else R = m - 1; &#125; if (arr[L] &lt; target) return L; return -1;&#125;int main() &#123; //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); int n, a[maxn], v; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++)scanf(&quot;%d&quot;, &amp;a[i]); //1 3 2 9 4 1 3 7 2 2 scanf(&quot;%d&quot;, &amp;v); //input the number you need find qsort(a, n, sizeof(a[0]), cmp); // 1 1 2 2 2 3 3 4 7 9 printf(&quot;after sorted : \\n&quot;); for (int i = 0; i &lt; n; i++)printf(&quot;%d &quot;, a[i]); printf(&quot;\\n-------------test----------------&quot;); printf(&quot;\\n%d\\n&quot;, firstEqual(a, 0, n, v)); //output 2 第一个 printf(&quot;%d\\n&quot;, lastEqualNext(a, 0, n, v)); //output 4 + 1,最后一个的下一个 printf(&quot;%d\\n&quot;, lastEqual(a, 0, n, v)); //output 4 最后一个 printf(&quot;%d\\n&quot;, firstLarge(a, 0, n, v)); //output 5(第一个3大于2) printf(&quot;%d\\n&quot;, lastSmall(a, 0, n, v)); //output 1(不是0) return 0;&#125;/*测试数据:101 3 2 9 4 1 3 7 2 22*/ (5)二分套二分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* * 二分套二分 * 数组A同数组B组合乘积，二分查找第K大 */typedef long long ll;const int MAXN = 5e4 + 10;ll N, K;ll A[MAXN];ll B[MAXN];// 查找小于x的元素个数ll check(ll x)&#123; ll j = N, ans = 0; for (int i = 1; i &lt;= N; i++) &#123; for (; j &gt; 0;) &#123; if (A[i] * B[j] &gt; x) &#123; j--; &#125; else &#123; break; &#125; &#125; ans += j; &#125; return ans;&#125;int main(int argc, const char * argv[])&#123; cin &gt;&gt; N &gt;&gt; K; for (int i = 1; i &lt;= N; i++) &#123; scanf(&quot;%lld %lld&quot;, A + i, B + i); &#125; sort(A + 1, A + N + 1); sort(B + 1, B + N + 1); ll ans = 0; ll key = N * N - K + 1; ll low = A[1] * B[1]; // 初始最小值 ll high = A[N] * B[N]; // 初始最大值 while (high - low &gt; 1) &#123; ll mid = (low + high) &gt;&gt; 1; if (check(mid) &gt;= key) &#123; ans = mid; high = mid; &#125; else &#123; low = mid; &#125; &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"二分法","slug":"二分法","permalink":"https://zouyunkai.github.io/myblog/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"}],"author":"aoyuehan"},{"title":"动态规划","slug":"动态规划","date":"2019-08-02T08:19:00.000Z","updated":"2022-02-26T03:52:52.337Z","comments":true,"path":"2019/08/02/动态规划/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/08/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划1、动态规划（英语：Dynamic programming，DP）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。 动态规划背后的基本思想非常简单。**大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。 ** 2、动态规划问题满足三大重要性质 最优子结构性质：如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。 子问题重叠性质：子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。 无后效性：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。 3、求解的基本步骤（1）求解的基本步骤 动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。 动态规划的设计都有着一定的模式，一般要经历以下几个步骤。 初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 上面的流程就是动态规划决策过程示意图 (1)划分阶段，确定子问题：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。 (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。也就是说一个状态下的“值”通常会是一个或多个子问题的解。 (3)确定决策并写出状态转移方程（由已知推未知）：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。 (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。 一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。 （2）实际应用中可以按以下几个简化的步骤进行设计： （1）分析最优解的性质，并刻画其结构特征。 （2）递归的定义最优解。 （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值 （4）根据计算最优值时得到的信息，构造问题的最优解 （3）递归到动规的一般转化过程： 递归函数有n个参数，就定义一个n维数组，数组的下标是递归函数参数的取值范围，数组元素的值是递归函数的返回值，这样就可以从边界开始，逐步填充数组，相当于计算递归函数的逆过程。递推是递归的反向运算过程。 （4）动态规划性质浅谈首先，动态规划和递推有些相似（尤其是线性动规），但是不同于递推的是： 递推求出的是数据，所以只是针对数据进行操作；而动态规划求出的是最优状态，所以必然也是针对状态的操作，而状态自然可以出现在最优解中，也可以不出现——这便是决策的特性（布尔性）。 其次，由于每个状态均可以由之前的状态演变形成，所以动态规划有可推导性，但同时，动态规划也有无后效性，即每个当前状态会且仅会决策出下一状态，而不直接对未来的所有状态负责，可以浅显的理解为——现在决定未来，未来与过去无关。4、数字三角形（poj）问题描述：有一个由非负整数组成的三角形，第一行只有一个数，除了最下行之外每个数的左下方和右下方各有一个数，从第一行的数开始，每次可以往左下和右下走一格，直到走到最下行，把沿途经过的数全部加起来，如何才能使这个和最大？？ (1)状态转移方程由来的分析 需要用抽象的方法思考问题：把当前的位置（i,j）看成一个状态，然后定义状态（i,j）的指标函数maxSum(i,j)为从格子（i，j）出发时能得到的最大和（包括（i，j）本身的值）。在这个状态定义下，原问题的解为maxSum(1,1).从格子（i，j）出发有两种决策，往左下走或者往右下走，应选择maxSum(i+1,j),maxSum(i+1,j+1)中较大的那一个，即maxSum(i,j)&#x3D;maxSum(i,j)+max{maxSum(i+1,j),maxSum(i+1,j+1)}（如：三角形的这题中，状态就有n(n+1)&#x2F;2个，那么整个问题的时间复杂度就是状态数目乘以计算每个状态所需要的时间。）(2)记忆化搜索： 各个数都是非负的，只需把所有d初始化为-1，即可通过判断得知它是否已经被计算过。 另外就是注意边界的处理。 (3)如果不用记忆化搜索，用递归为什么会超时呐？原因如下： 改进：那么就可以算出来一个MaxSum(r,j)就存起来，用的时候直接去调用，因为三角形的数字总数是n(n+1)&#x2F;2，所以时间复杂度就是O（n^2）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253方法一：记忆化递归#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define MAX 101int D[MAX][MAX];int n;int maxSum[MAX][MAX];int MaxSum(int i,int j)&#123; if (maxSum[i][j]!=-1) return maxSum[i][j]; if(i==n) maxSum[i][j]=D[i][j]; else&#123; maxSum[i][j]=max( MaxSum(i+1,j),MaxSum(i+1,j+1) )+D[i][j]; &#125; return maxSum[i][j];&#125;int main()&#123; int i,j; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++)&#123; cin&gt;&gt;D[i][j]; maxSum[i][j]=-1; //给初始化一下，这样就能知道哪些值是已经算出来的，算出来的就可以直接用了 &#125; cout&lt;&lt;MaxSum(1,1)&lt;&lt;endl;&#125;方法二：递推（由已知推未知）#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define MAX 101int D[MAX][MAX];int n;int maxSum[MAX][MAX];int main()&#123; int i,j; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) cin&gt;&gt;D[i][j]; for(int i=1;i&lt;=n;++i) maxSum[n][i]=D[n][i]; for(int i=n-1;i&gt;=1;--i) for(int j=1;j&lt;=i;++j) maxSum[i][j]=max(maxSum[i+1][j],maxSum[i+1][j+1])+D[i][j]; //用一个maxSum这个数组存一下D中两个较大元素的和，然后算到顶端，就得到最大的maxSum[1][1] cout&lt;&lt;maxSum[1][1]&lt;&lt;endl; &#125; 其中在第二种递推方法中，可以用一个指针 指向D元素的第n行，然后用覆盖第n行的元素的方法来求得结果 1234567891011121314151617181920#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define MAX 101int D[MAX][MAX];int n;int* maxSum;int main()&#123; int i,j; cin&gt;&gt;n; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) cin&gt;&gt;D[i][j]; maxSum=D[n]; //maxSum指向了第n行 for(int i=n-1;i&gt;=1;--i) for(int j=1;j&lt;=i;++j) maxSum[j]=max(maxSum[j],maxSum[j+1])+D[i][j]; //现在就可以这样用，用maxSum[j]来指向第n行的第j个元素（始终是第n行，因为要覆盖第n行的相应元素） cout&lt;&lt;maxSum[1]&lt;&lt;endl; //因为j是从1开始记得，所以要输出maxSum[1]而不是maxSum[0]&#125; 5、最长上升子序列LCS（百练2757） 上述两图中下面这种有n个子问题，即n个状态，也满足无后效性（可以写出转移方程） 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int MAXN=1010;int a[MAXN];int maxlen[MAXN];int main()&#123; int N; cin&gt;&gt;N; for(int i=1;i&lt;=N;++i)&#123; cin&gt;&gt;a[i]; maxlen[i]=1; &#125; for(int i=2;i&lt;=N;++i)&#123; //每次求以第i个数为终点的最长上升子序列的长度 for(int j=1;j&lt;i;++j)&#123; //观察以第j个数为终点的最长上升子序列的长度 if(a[i]&gt;a[j]) maxlen[i]=max(maxlen[i],maxlen[j]+1); //因为maxlen[i]是时刻更新的，所以要求两者的较大的数 &#125; &#125; cout&lt;&lt; *max_element(maxlen+1,maxlen+N+1); max_element这个函数返回的是迭代器，所以要加*来输出其中的内容 return 0; //时间复杂度就是O(n^2) &#125; tips:在编写代码时，忘记把maxlen[i]=1与cin&gt;&gt;a[i];写在一行，而放进循环体内，报错（因为在函数内定义的变量的作用域都是本函数体内，所以会出现i未被定义的现象）[Error] name lookup of &#x27;i&#x27; changed for ISO &#x27;for&#x27; scoping [-fpermissive] 6、 最长公共子序列LIS （P1439）题目描述给出1-n的两个排列P1和P2，求它们的最长公共子序列。输入格式第一行是一个数n，接下来两行，每行为n个数，为自然数1-n的一个排列。输出格式一个数，即最长公共子序列的长度输入53 2 1 4 51 2 3 4 5**输出 **3 题解：看此题的数据范围，显然使用最长公共子序列的一般DP算法（时间复杂度为O(N^2)）肯定会超时，所以我们需要想别的方法。 考虑此题的另一个条件，两个序列都为1…n的一个排列，考虑特殊情况： 如果其中一个排列为(1,2,…,n)，另一个排列为(a1,a2,…,an)，那么对于两者的任意公共子序列(a[b1],a[b2],…,a[bk])，必有a[b1] &lt; a[b2] &lt; …&lt; a[bk]，则两序列的最长公共子序列为排列(a1,a2,…,an)的最长上升子序列。 那么，对于两个一般的排列(a1,a2,…,an)和(b1,b2,…,bn)的最长公共子序列怎么求？ 我们定义映射f(ai)&#x3D;i，那么两个排列可以转换为(f(a1),f(a2),…,f(an))&#x3D;(1,2,…,n)和(f(b1),f(b2),…,f(bn))，我们进行这样的转换之后，就把本题转换为求最长上升子序列的长度的题目了。之后便可以用LIS的nlogn算法计算了。总的时间复杂度为处理映射O(N)，求LIS长度为O(N log N)，总的时间复杂度为O(N log N) 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;int n,top;int a[100005],dp[100005],f[100005];int search(int x)&#123; int l=1,r=top,mid; while(l&lt;r)&#123; mid=(l+r)&gt;&gt;1; if(dp[mid]&lt;x) l=mid+1; else r=mid; &#125; return l;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); f[a[i]]=i; &#125; for(int i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); a[i]=f[a[i]]; &#125; for(int i=1;i&lt;=n;i++)&#123; if(dp[top]&lt;=a[i]) dp[++top]=a[i]; else dp[search(a[i])]=a[i]; &#125; printf(&quot;%d&quot;,top); return 0;&#125; 7、01背包问题(Charm Bracelet poj3624)：DescriptionBessie has gone to the mall’s jewelry store and spies a charm bracelet(镯子). Of course, she’d like to fill it with the best charms possible from the N (1 ≤ N ≤ 3,402) available charms. Each charm i in the supplied list has a weight Wi (1 ≤ Wi ≤ 400), a ‘desirability’ factor Di (1 ≤ Di ≤ 100), and can be used at most once. Bessie can only support a charm bracelet whose weight is no more than M (1 ≤ M ≤ 12,880). Given that weight limit as a constraint（n. 限制; 限定; 约束; 严管） and a list of the charms with their weights and desirability rating, deduce（推论; 推断; 演绎;） the maximum possible sum of ratings.Input Line 1: Two space-separated integers: N and M Lines 2..N+1: Line i+1 describes charm i with two space-separated integers: Wi and Di Output Line 1: A single integer that is the greatest sum of charm desirabilities that can be achieved given the weight constraints Sample Input4 61 42 63 122 7Sample Output23其中： 典型的动态规划题目，用一个数组记录背包各个重量的最优解，不断地更新直到穷尽所有可能性。 dp[j]&#x3D;max(dp[j] , dp[j-W[i]]+D[i]); 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int N ,M; cin&gt;&gt;N&gt;&gt;M; int *W = new int[N+1]; int *D = new int[N+1]; W[0]=0; D[0]=0; for(int i=1;i&lt;=N;i++) &#123; cin&gt;&gt;W[i]&gt;&gt;D[i]; &#125; int *dp = new int[M+1]; memset(*dp,0,M+1); //for(int i =0;i&lt;=M;i++)&#123; // dp[i]=0; //&#125; for(int i =1;i&lt;=N;i++) &#123; for(int j=M;j&gt;=W[i];j--)&#123; //只有j&gt;W[i]的时候才会有第二项 dp[j]=max(dp[j] , dp[j-W[i]]+D[i]); &#125; &#125; cout&lt;&lt;dp[M]&lt;&lt;endl; return 0;&#125; cankao : https://www.cnblogs.com/Archger/p/8451622.htmlhttps://blog.csdn.net/linxilinxilinxi/article/details/83998710 旅行商问题背包问题3.对于完全NP问题，目前并没有快速得到最优解的解决方案 面临NP完全问题，最佳的做法就是使用近似算法","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"author":"aoyuehan"},{"title":"贪心算法","slug":"贪心算法","date":"2019-08-02T08:18:00.000Z","updated":"2022-02-26T03:52:51.158Z","comments":true,"path":"2019/08/02/贪心算法/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/08/02/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","excerpt":"","text":"贪心算法1、贪心算法基础概念所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪婪算法可以寻找局部最优解，并尝试与这种方式获得全局最优解。 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，*选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。（即每一步行动都是按照某种指标选取最优的操作来进行，该指标只看眼前，并不考虑以后可能造成的影响。） ** 所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。 *（**而贪心算法需要证明其正确性，比如在圣诞老人礼物这题中，若糖果只能整箱拿，则贪心算法就是错误的；例如：三个箱子(8,6)(5,5)(5,5),雪橇总容量10，那么选价值比最大的第一个，其并不是最优解，可以拿后两个；背包问题用这种方法实现得到的结果并不是最优解）能用贪心解决的问题，也可以用动态规划解决。 2、 贪心算法的基本思路： 建立数学模型来描述问题。 把求解的问题分成若干个子问题。 对每一子问题求解，得到子问题的局部最优解。 把子问题的解局部最优解合成原来解问题的一个解。 贪心策略适用的前提是：局部最优策略能导致产生全局最优解。 ３、圣诞老人的礼物 描述圣诞节来临了，在城市A中圣诞老人准备分发糖果，现在有多箱不同的糖果，每箱糖果有自己的价值和重量，每箱糖果都可以拆分成任意散装组合带走。圣诞老人的驯鹿最多只能承受一定重量的糖果，请问圣诞老人最多能带走多大价值的糖果。输入第一行由两个部分组成，分别为糖果箱数正整数n(1 &lt;&#x3D; n &lt;&#x3D; 100)，驯鹿能承受的最大重量正整数w（0 &lt; w &lt; 10000），两个数用空格隔开。其余n行每行对应一箱糖果，由两部分组成，分别为一箱糖果的价值正整数v和重量正整数w，中间用空格隔开。输出输出圣诞老人能带走的糖果的最大总价值，保留1位小数。输出为一行，以换行符结束。样例输入4 15100 4412 8266 7591 2样例输出1193.0 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;algorithm&gt;#include &lt;iomanip&gt; //用setprecision这个的时候需要添加这个头文件，其中precision是精度的意思using namespace std;const double eps=1e-6; //表示1*10的-6次方，用来表示精度struct Candy&#123; int v; int w; bool operator&lt;(const Candy &amp;c)&#123; //重载了 &lt; 运算符 return double(v)/w-double(c.v)/c.w&gt;eps; //这一部分的意思是啥 &#125;&#125;candies[110];int main()&#123; int n,w; cin&gt;&gt;n&gt;&gt;w; for(int i=0;i&lt;n;++i)&#123; cin&gt;&gt;candies[i].v&gt;&gt;candies[i].w; &#125; sort(candies,candies+n); //所以时间复杂度为O(NLogN) int totalw=0; double totalv=0; for(int i=0;i&lt;n;++i)&#123; if(totalw+candies[i].w&lt;w)&#123; totalw+=candies[i].w; totalv+=candies[i].v; &#125; else&#123; totalv+=candies[i].v*double(w-totalw)/candies[i].w; break; &#125; &#125; cout&lt;&lt;setprecision(1)&lt;&lt;fixed&lt;&lt;totalv; return 0;&#125; 4、Go fishing（百练 1042 _贪心+枚举） 思路：枚举停止在的湖编号，用总时间减去到该湖的走的路程的时间即钓鱼的纯时间,在这段时间内，每次都找剩余鱼量最多的湖，而且当鱼量出现负数时，设置为0注意，假如所有湖剩余都为0，则跳出循环，将剩余时间加到第一个湖上解题：输入初始鱼量、每片减少的鱼量以及路程时间对每个湖假设停止并遍历，计算纯钓鱼的时间，在这段时间内，选择剩余鱼量最多的湖，该湖时间加一，并且更新鱼量，记得不能为负数，然后遍历湖假如此时湖剩余鱼量全为0，则跳出循环，并且记得将剩余时间全都给第一个湖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int n,h; //n指n个湖，h指钓鱼所用的总时间 cin&gt;&gt;n; while(n!=0)&#123; cin&gt;&gt;h; int result[n],tmp=-1; int fi[n],di[n],ti[n-1]; //fi指没每个鱼塘初始鱼的数量，di指每5分钟后鱼塘中鱼减少的速率，ti为从一个鱼塘走到另一个鱼塘所用的时间 for(int i=0;i&lt;n;i++)cin&gt;&gt;fi[i]; for(int i=0;i&lt;n;i++)cin&gt;&gt;di[i]; for(int i=0;i&lt;n-1;i++)cin&gt;&gt;ti[i]; int ft[n]; for(int i=0;i&lt;n;i++)ft[i]=fi[i]; for(int k=0;k&lt;n;k++)&#123; int result2[n]; for(int i=0;i&lt;n;i++)&#123; result2[i]=0; &#125; int ht=h*12; int test=0; for(int j=0;j&lt;k;j++)ht-=ti[j]; for(int i=0;i&lt;n;i++)ft[i]=fi[i]; int emp=0; while(ht--&amp;&amp;emp&lt;=k)&#123;//计算时间 int a=0; for(int j=0;j&lt;=k;j++)&#123;//计算最大的剩余的鱼 if(ft[a]&lt;ft[j])a=j; &#125; test+=ft[a]; result2[a]++; ft[a]-=di[a]; if(ft[a]&lt;=0)ft[a]=0; for(int j=emp; j&lt;=k; j++)//如果不进行统计就会超时 &#123; if(ft[j]==0) ++emp;//统计有几个湖已经没有鱼 else break; &#125; &#125; if(test&gt;tmp)&#123; for(int i=0;i&lt;n;i++)&#123; result[i]=result2[i]; &#125; if(ht&gt;0)//如果还有时间就加到第一个湖上 result[0]+=ht; tmp=test; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;result[i]*5; if(i!=n-1)cout&lt;&lt;&quot;, &quot;; &#125; cout&lt;&lt;endl; cout&lt;&lt;&quot;Number of fish expected: &quot;&lt;&lt;tmp&lt;&lt;endl; cout&lt;&lt;endl; cin&gt;&gt;n; &#125;&#125; 5、【题目描述】 有n堆纸牌，编号分别为 1，2，…, n。每堆上有若干张，但纸牌总数必为n的倍数。可以在任一堆上取若干张纸牌，然后移动。移牌规则为：在编号为1的堆上取的纸牌，只能移到编号为 2 的堆上；在编号为 n 的堆上取的纸牌，只能移到编号为n-1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。 现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。例如 n&#x3D;4，4堆纸牌数分别为： ① 9 ② 8 ③ 17 ④ 6移动3次可达到目的： 从 ③ 取4张牌放到④（9 8 13 10）-&gt;从③取3张牌放到 ②（9 11 10 10）-&gt; 从②取1张牌放到①（10 10 10 10）。【输入】 n（n 堆纸牌，1 ≤ n ≤ 100） a1 a2 … an （n 堆纸牌，每堆纸牌初始数，l≤ ai ≤10000）。【输出】 所有堆均达到相等时的最少移动次数。【输入样例】 4 9 8 17 6【输出样例】 3思路：求平均数，然后每个数减去平均数，然后不管是正数还是负数，都向下一个移动，最后会都等于0。至于这题是贪心，应该是每一步骤都是变为0，这种求解吧。 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int a[10000];int main()&#123; int n,sum=0,i,j,step=0; cin&gt;&gt;n;j=n;i=1; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; sum+=a[i]; &#125; for(int i=1;i&lt;=n;++i) &#123; a[i]-=sum/n; //记录比平均数多或少的那部分值就好了 &#125; while(a[i]==0&amp;&amp;i&lt;n)++i; while(a[j]==0&amp;&amp;j&gt;1)--j; while(i&lt;j) &#123; a[i+1]+=a[i]; ／／相当于把当前那个不是平均数的数用后面那个数来补上，理想这样是最优的 a[i]=0; // 把当前这个归位，不归也可以哈 step++; i++; while(a[i]==0&amp;&amp;i&lt;j)++i; //优化，只处理堆中不是平均数的就好了 &#125; cout&lt;&lt;step;&#125; 6、贪心算法之钱币找零问题 假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的。在程序中已经事先将Value按照从小到大的顺序排好 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=7; int Count[N]=&#123;3,0,2,1,0,3,5&#125;;int Value[N]=&#123;1,2,5,10,20,50,100&#125;; int solve(int money) &#123; int num=0; for(int i=N-1;i&gt;=0;i--) &#123; int c=min(money/Value[i],Count[i]); //这样的话就是可以取到的面值较大的张数的最小值，因为money/Value[i]的值可以是2，不只是1 money=money-c*Value[i]; num+=c; &#125; if(money&gt;0) num=-1; return num;&#125; int main() &#123; int money; cin&gt;&gt;money; int res=solve(money); if(res!=-1) cout&lt;&lt;res&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;&#125; 7、放置雷达（百练1328） 题目描述：假定海岸线是一条无限延伸的直线，陆地在海岸线的一边，大海在另一侧。海中有许多岛屿，每一个小岛我们可以认为是一个点。现在要在海岸线上安装雷达，雷达的覆盖范围是d，也就是说大海中一个小岛能被安装的雷达覆盖，那么它们之间的距离最大为d。我们使用平面直角坐标系，定义海岸线是x轴，大海在x轴上方，陆地在下方。给你海中每一个岛屿的坐标位置（x,y）和要安装的雷达所覆盖的范围d，你的任务是写一个程序计算出至少安装多少个雷达能将所有的岛屿覆盖。输入描述：第一行两个整数n（1≤n≤100000）和d，分别表示海中岛屿的数目和雷达覆盖的范围半径d。接下来n行，每行两个整数，表示每个岛屿的坐标位置（x,y）。输出描述：一行一个整数，即能将所有岛屿全部覆盖至少安装的雷达个数，如果无解则输出“-1”。样例输入3 21 2-3 12 1 1 20 2 0 0样例输出Case 1: 2Case 2: 1 贪心算法:如果求在x轴上有哪些点可以覆盖雷达，然后枚举，这样做很麻烦，所以转化到岛屿能被扫描到的区间的比较问题上。1 ) 将所有区间按照起点从小到大排序,并编号0 - (n-1)2 ) 依次考察每个区间的起点,看要不要在那里放雷达。开始,所有区间都没被覆盖,所以目前编号最小的未被覆盖的区间的编号 firstNoConverd &#x3D;03 ) 考察一个区间 i 的起点 xi的时候,要看从 firstNoCovered 到区间i-1 中是否存在某个区间 c ,没有被 xi 覆盖。如果没有,则先不急于在xi放雷达,接着往下看。如果有,那么 c 的终点肯定在xi的左边,因此不可能用同一个雷达覆盖 c 和i。即能覆盖c的点,已经不可能覆盖i和i后面的区间了。此时,为了覆盖c,必须放一个雷达了,放在区间 i-1 的起点即可覆盖所有从firstNoCovered到 i-1的区间。因为当初考察 i-1的起点 z时候,并没有发现 z 漏覆盖了从 firstNoCovered 到 i-2 之间的任何一个区间4 ) 放完雷达后,将 firstNoCovered改为i,再做下去。 证明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define NUM 1001using namespace std; //n代表小岛数，N代表小岛在island_x轴上的所有区间个数 struct QU_jian&#123; double l;//左边点 double r;//右边点 bool operator&lt;(const QU_jian&amp; t)const&#123; return this-&gt;l&lt;t.l; &#125;&#125;N[NUM]; int main()&#123; int n,d; double island_x,island_y;//每一个小岛的坐标 int k = 1;//案例数 while(cin&gt;&gt;n&gt;&gt;d&amp;&amp;n&amp;&amp;d)&#123; int radar_min_num = 1; for (int i = 0;i&lt;n;i++)&#123; cin&gt;&gt;island_x&gt;&gt;island_y; if(island_y&lt;=d &amp;&amp; d&gt;0 &amp;&amp; island_y&gt;=0)&#123; N[i].r=island_x+(double)sqrt(d*d - island_y*island_y); N[i].l=island_x-(double)sqrt(d*d - island_y*island_y); &#125; else&#123; radar_min_num = -1;//读错半径和island_y的坐标继续读 &#125; &#125; //用几何关系找到每一个小岛需要固定的半径的雷达在island_x轴上的最大和最小值范围 sort(N, N+n); //对左端的数据从小到大排序 double temp = N[0].r; for( int i = 1;(i&lt;n &amp;&amp; radar_min_num != -1);i++)&#123; if(temp&lt;N[i].l)&#123; temp = N[i].r; radar_min_num++; &#125; else&#123; if(N[i].r&lt;temp) temp = N[i].r; &#125; &#125; //利用贪心算法找到最优 cout &lt;&lt;&quot;Case &quot;&lt;&lt;k++&lt;&lt;&quot;: &quot;&lt;&lt;radar_min_num&lt;&lt;endl;//打印结果 &#125; return 0;&#125; https://blog.csdn.net/NNNNNNNNNNNNY/article/details/51721722????这种方法没看懂，二分与贪心","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://zouyunkai.github.io/myblog/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"贪心","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%B4%AA%E5%BF%83/"}],"author":"aoyuehan"},{"title":"C++语言零碎知识点汇总","slug":"C语言零碎知识点汇总","date":"2019-08-02T02:02:00.000Z","updated":"2022-02-26T03:52:52.122Z","comments":true,"path":"2019/08/02/C语言零碎知识点汇总/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/08/02/C%E8%AF%AD%E8%A8%80%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/","excerpt":"","text":"1，指针函数、函数指针、函数指针数组2 , 自定义比较函数, 结构体，sort函数中的less算子和greater算子，优先队列的重载运算符3 ，malloc4 ，C语言中位运算符&amp;和|是怎么运算的5 ,c语言数据类型的范围6,*p++ 和 ++*p7,strlen函数和sizeof操作符8，进制转换的方法 - 再谈C语言指针函数、函数指针、函数指针数组 1、 指针函数 指针函数就是返回指针值的函数，本质是一个函数。**所以指针函数等价于“返回值为指针的函数”。** 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int *GetNum(int x); //指针函数声明形式void main(void)&#123; cout &lt;&lt; &quot;===============start================&quot; &lt;&lt; endl; int num; cout &lt;&lt; &quot;Please enter the number between 0 and 6: &quot;; cin &gt;&gt; num; cout &lt;&lt; &quot;result is:&quot; &lt;&lt; *GetNum(num) &lt;&lt; endl; //输出返回地址块中的值 system(&quot;pause&quot;);&#125;int *GetNum(int x) &#123; static int num[] = &#123; 0,1,2,3,4,5,6 &#125;; //要声明为static类型的，不然函数内存释放的时候，该数组值也会是释放 return &amp;num[x]; //返回一个地址&#125; 2、函数指针 函数指针就是一个指向函数的指针。每个函数在编译时，会被分配一个入口地址，一般用函数名来表示，这个地址就是该函数的指针。语法：声明形式：type (*func)(参数列表 )从上面的定义形式可以看出，函数指针和指针函数的直观上区别在于指针符号*与函数名&#x2F;指针名有没有用括号（）包裹起来，从这一点来看是很容易区分两者的。 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int max(int a, int b) &#123; return a&gt;b ? a : b;&#125;void main(void)&#123; cout &lt;&lt; &quot;===========start===========&quot; &lt;&lt; endl; int(*func)(int, int); //定义一个指向该函数形式的指针变量 func = max; int a, b; cout &lt;&lt; &quot;Please enter two numbers:&quot;; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; &quot;max=&quot; &lt;&lt; (*func)(a, b) &lt;&lt; endl; //运用指针变量调用函数 cout &lt;&lt; &quot;max=&quot; &lt;&lt; max(a, b) &lt;&lt; endl; //使用原函数调用 cout &lt;&lt; &quot;max=&quot; &lt;&lt; func(a, b) &lt;&lt; endl; //使用函数指针名调用，func = max system(&quot;pause&quot;);&#125; 上例给出了函数指针的两种最普遍的调用形式，一个是直接用定义的指针变量( func)调用，一个是用指针名调用，后者看起来就像是将原函数使用了新名称去调用一样，可以看成函数的别名。*再次强调一下：指针变量名和指针符号 * 一定要用括号包裹起来。 3、函数指针数组就是每个元素都是函数指针的数组，直接在函数指针名后面加上数组符号[ ]即可。语法：声明形式：type (*func[ ])(参数列表 ) 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;void fun1()&#123; cout &lt;&lt; &quot;调用函数fun1&quot; &lt;&lt; endl;&#125;void fun2()&#123; cout &lt;&lt; &quot;调用函数fun2&quot; &lt;&lt; endl;&#125;void fun3()&#123; cout &lt;&lt; &quot;调用函数fun3&quot; &lt;&lt; endl;&#125;int main()&#123; //定义三个函数指针 void(*pfun)() = &amp;fun1; void(*pfun2)() = &amp;fun2; void(*pfun3)() = &amp;fun3; //接下来就是定义一个数组把他们三个装进去。 void(*pfunarr[3])(); void(*pfunarr[3])(); pfunarr[0] = pfun; pfunarr[1] = pfun2; pfunarr[2] = pfun3; /* 或者这样赋值 pfunarr[0] = &amp;fun1; pfunarr[1] = &amp;fun2; pfunarr[2] = &amp;fun3; */ //调用运行 pfunarr[0](); pfunarr[1](); pfunarr[2](); /* 或者这样调用 (*pfunarr[0])(); (*pfunarr[1])(); (*pfunarr[2])(); */ system(&quot;pause&quot;); return 0;&#125; 4、指向函数指针数组的指针语法：声明形式：type (* (*func )[ ])(参数列表 ) 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;void fun1()&#123; cout &lt;&lt; &quot;调用函数fun1&quot; &lt;&lt; endl;&#125;void fun2()&#123; cout &lt;&lt; &quot;调用函数fun2&quot; &lt;&lt; endl;&#125;void fun3()&#123; cout &lt;&lt; &quot;调用函数fun3&quot; &lt;&lt; endl;&#125;int main()&#123; //void(*pfun)() = &amp;fun1; //void(*pfun2)() = &amp;fun2; //void(*pfun3)() = &amp;fun3; //接下来就是定义一个数组把他们三个装进去。 void(*pfunarr[3])(); void(*(*pfunarr2)[3])(); //在这里呢看着个指针数组，他就是一个具有3个以函数指针为内容的元素的函数指针数组。 pfunarr[0] = &amp;fun1; pfunarr[1] = &amp;fun2; pfunarr[2] = &amp;fun3; pfunarr2 = &amp;pfunarr; (*pfunarr2)[0](); pfunarr[0](); system(&quot;pause&quot;); return 0;&#125;分析其定义形式：void(*(*pfunarr2)[3])()其中(* pfunarr2)[3]表示数组指针，而void(* )( )表示函数指针，两者结合起来就是指向函数指针数组的指针。 5、指针，地址，引用引用：引用是一个变量的另一个名字，又称别名。定义方式：int a=10； int &amp;b=a;**在这里，意思就是给a变量起了一个新名字b，因此b不可再次被重新定义。引用必须初始化，无空引用，并且引用不分等级。 **例如：交换函数swap（） 1234567891011121314151617181920212223242526272829303132void swap(int &amp;a,int &amp;b)&#123; int temp=a; a=b; b=temp;&#125;void main()&#123; int x=10,y=20; swap(x,y);&#125;等价指针为：void swap(int *const a,int *const b)&#123; int tmp=*a; *a=*b; *b=temp;&#125;void main()&#123;int x=10,y=20;swap(&amp;x,&amp;y);&#125;其中还有一个要注意的是int pos;char ch[10];int a[3];scanf(%d,&amp;pos); //一定要写&amp;，不然程序会崩的scanf(%s,ch);scanf(%d,&amp;a[1]); //注意a[3]包括a[0],a[1],a[2]这三个值，没有a[3]这个值 变量a 本质上代表一个存储单元。CPU通过该存储单元的地址访问该存储单元中的数据。所以a本来代表两个值：存储单元的地址和储单元中的数据。于是就有了二异性。为了消除这种二义性，*C语言规定a表示存储单元中的数据，&amp;a表示存储单元的地址。 **** 其中 要求a对应的存储单元中的数据一定是另一个存储单元的地址。定义int× b；int a&#x3D;5； b&#x3D;&amp;a；于是， ×b表示另一个存储单元中的数据。 而给指针赋值的时候b&#x3D;&amp;a；就b表示a对应的存储单元的地址中的数据。 &amp;a表示a对应的存储单元的地址。 ** 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main()&#123; int* b; int a=5; b=&amp;a; cout&lt;&lt;*b; //结果为5 return 0;&#125;其中在试验报告中看到自己当初写的：1. 指针就是地址，地址就是指针；指针变量是一个变量，它保存了基本类型变量的地址。如果指针变量p保存了变量a的地址，那么称作p指向了a，*p 就是变量a。如果p是一个指针变量，*p 表示了以 p 的内容为地址的变量，就是p指向的变量。2. *p++;等价于*(p++);因为++和*的优先级一样，故结合方向是从右向左。3. *(p++);和*(++p);二者是有区别的。前者是先取*p的值，然后p加1；后者是先p加1，再取p的值。即如果p指向的是数组a元素a[0]，则前者得到a[0]的值+1，后者得到a[1]的值。4. ++(*p);将p指向的元素的值加1。5. 如果p指向元素a[i]， *(p--);先得到p指向的地址的元素a[i]，然后p减1。 *(++p);执行结果得到a[i+1]，p加1。 *(–p);执行结果得到a[i-1]，p减1。6. 数组名作为函数实参时，向形参（数组名或指针变量）传递的是数组首元素地址。数组名做函数参数时并不是单纯的把数组内部的值传递给形参数组，而是把该数组首元素的地址传递给形参数组，也就是说将实参数组的地址分享给了形参数组，这样就实现了一个地址两方调用。 6、 方法改变数组元素 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;void xiu(int *a)&#123; a[0]=a[1];&#125;/*void xiu(int a[])&#123; a[0]=a[1];&#125;void xiu(int a[4])&#123; a[0]=a[1];&#125;这三种方法都可以实现改变s数组元素的内容，因为数组本身就是引用类型*/int main()&#123; int s[4]=&#123;1,2,3,4&#125;; xiu(s); for(int i=0;i&lt;4;i++) cout&lt;&lt;s[i];//cout&lt;&lt;s;的结果是打印出数组元素的首地址 &#125; 6、return语句return 语句的一般形式为：return 表达式;或者：return (表达式);有没有( )都是正确的，为了简明，一般也不写( )。例如： 123return max;return a+b;return (100+200); return 语句可以有多个，可以出现在函数体的任意位置，但是每次调用函数只能有一个 return 语句被执行，所以只有一个返回值（少数的编程语言支持多个返回值，例如Go语言） 函数一旦遇到 return 语句就立即返回，后面的所有语句都不会被执行到了。 return 语句是提前结束函数的唯一办法。return 后面可以跟一份数据，表示将这份数据返回到函数外面；return 后面也可以不跟任何数据，表示什么也不返回，仅仅用来结束函数。 - 自定义比较函数 1.1、定义 operator","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"c","slug":"c","permalink":"https://zouyunkai.github.io/myblog/tags/c/"},{"name":"c++","slug":"c","permalink":"https://zouyunkai.github.io/myblog/tags/c/"},{"name":"c语言小知识","slug":"c语言小知识","permalink":"https://zouyunkai.github.io/myblog/tags/c%E8%AF%AD%E8%A8%80%E5%B0%8F%E7%9F%A5%E8%AF%86/"}],"author":"aoyuehan"},{"title":"STL_总结","slug":"STL-总结","date":"2019-07-30T11:50:00.000Z","updated":"2022-02-26T03:52:51.873Z","comments":true,"path":"2019/07/30/STL-总结/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/30/STL-%E6%80%BB%E7%BB%93/","excerpt":"","text":"STL_总结STL pairSTL setSTL vectorSTL stringSTL stackSTL queueSTL mapSTL bitsetSTL iteratorSTL algorithm pair类模板：template＜class T1,class T2＞struct pair参数：T1是第一个值的数据类型，T2是第二个值的数据类型。作用：将两个元素（可以是不同类型的元素）整合为一种。用法： 怎么构造这样一个类型（定义方法）： 方法1： 1234pair&lt;int ,double&gt;p1; //两个参数的数据类型可以是不同的pair&lt;int ,int &gt;p2，p4;pair&lt;string ,string&gt;p3;pair&lt;string,double&gt;p2 (&quot;aa&quot;,5.0); //声明的时候直接赋值 方法2：通过typedef简化声明定义 123typedef pair&lt;string, string&gt;author; author pro(&quot;May&quot;, &quot;Lily&quot;); //这时就可以直接这样写，来给 pair对象赋值，而不是通过访问属性或者调用make_pair（）方法author joye(&quot;James&quot;, &quot;Joyce&quot;); 方法3： pair类数组的定义方法： 123456789101112#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; pair&lt;int ,int &gt;a[4]; for(int i=0;i&lt;=3;i++) &#123; scanf(&quot;%d%d&quot;,&amp;a[i].first,&amp;a[i].second); printf(&quot;first=%d second=%d\\n&quot;,a[i].first,a[i].second); &#125; return 0;&#125; 赋值方法： 方法1： 123pair&lt;int ,double &gt;p1;p1.first=1; //这是属性值，而不是调用方法p1.second=2.2; 方法2：利用make_pair(a1,a2) 12pair&lt;int, double&gt; p1;p1 = make_pair(1, 1.2); 方法3：这种是用于一个pair给另一个pair赋值： 12pair&lt;int, double&gt; p1(1, 1.2);//定义时赋值pair&lt;int, double&gt; p2 = p1;//类对类赋值 获取pair的值cout&lt;&lt;p1.first&lt;&lt;p1.second; &#x2F;&#x2F;获取pair对象的属性值 pair的运算方式：在中已经定义了pair上的六个比较运算符：&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D;其规则是先比较first，first相等时再比较second，这符合大多数应用的逻辑。当然，也可以通过重载这几个运算符来重新指定自⼰的比较逻辑。 pair的类型： pair 是 一种模版类型。每个pair 可以存储两个值。这两种值无限制。也可以将自己写的struct的对象放进去。如在返回值中的应用，在一个对象有多个属性的时候 ，一般自己写一个struct ，如果就是两个属性的话，就可以用pair 进行操作 。如果有三个属性的话，其实也是可以用的pair 的 ，极端的写法： 12pair &lt;int ,pair&lt;int ,int &gt; &gt; //（后边的两个 &gt; &gt; 要有空格，否则就会是 &gt;&gt; 位移运算符） pair实质上是一个结构体，其主要的两个成员变量是first和second，这两个变量可以直接使用。初始化一个pair可以使用构造函数，也可以使用std::make_pair函数，make_pair函数的定义如下： 1template pair make_pair(T1 a, T2 b) &#123; return pair(a, b); &#125; 小结: make_pair创建的是一个pair对象。使用都很方便，针对成对出现的数据，如书的ISBN对应一个书名。 pair是单个数据对的操作，pair是一struct类型，有两个成员变量，通过first,second来访问，用的是“.”访问。 map是一个关联容器，里面存放的是键值对，容器中每一元素都是pair类型，通过map的insert()方法来插入元素(pair类型)。 123456789101112131415161718192021222324252627282930313233pair和priority_queue连用：#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;typedef pair&lt;int, int&gt; P;struct cmp&#123; /*默认是less算子也就是返回a&lt;b，也就是小的优先级也小,即值大的优先级高，而greater算子返回a&gt;b，小的优先级高。*/ bool operator()(const P p1, const P p2) &#123; return p1 &gt; p2; //小值优先,当第一个元素相等时，比较第二个元素（同样是小者优先出队 //return p1 &lt; p2; 大值优先，即大值先出队 &#125;&#125;;int main(void)&#123; priority_queue&lt;P, vector&lt;P&gt;, cmp&gt; que; que.push(P(10,20)); que.push(P(15,30)); que.push(P(10,1)); P p; while(!que.empty()) &#123; p=que.top(); que.pop(); cout&lt;&lt;p.first&lt;&lt;&quot; &quot;&lt;&lt;p.second&lt;&lt;endl; &#125;&#125; set set是STL中一种标准关联容器。它底层使用平衡的搜索树——红黑树实现，插入删除操作时仅仅需要指针操作节点即可完成，不涉及到内存移动和拷贝，所以效率比较高。 set，顾名思义是“集合”的意思，在set中元素都是唯一的，而且默认情况下会对元素自动进行升序排列，支持集合的交(set_intersection),差(set_difference) 并(set_union)，对称差(set_symmetric_difference) 等一些集合上的操作，如果需要集合中的元素允许重复那么可以使用multiset。 Set容器的定义与创建：set模板原型： 1template &lt;class Key, class Compare=less&lt;Key&gt;, class Alloc=STL_DEFAULT_ALLOCATOR(Key) &gt; //Key为元素(键值)类型 set&lt;类型&gt; 对象名; 如：set＜int＞ s; set&lt;类型，比较结构体&gt; 对象名; 如：set＜int，myComp＞ s; Set容器在插入时，默认情况下按从小到大的顺序存储，可以通过自定义比较结构体，按从大到小的顺序存储或者按照多个关键字序列插入。 123456789101112131415#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;set&lt;int&gt; s;int main()&#123; set&lt;int &gt; seta; //默认是小于比较器less&lt;int&gt;的set set&lt;int, greater&lt;int&gt; &gt; setb; //创建一个大于比较器的set，需包含头文件functional int a[5] = &#123;1,2,3,4,5&#125;; set&lt;int &gt; setc(a,a+5); //数组a初始化一个set； set&lt;int &gt; setd(setc.begin(),setc.end()); //setc初始化一个set //上述两例均为区间初始化 set&lt;int &gt; sete(setd); //拷贝构造创建set return 0;&#125; set容器的增删改查 1234567891011121314151617181920212223242526272829303132333435363738set&lt;int &gt;s;int main()&#123;- 插入s.insert(2); //把2插入到集合中s.insert(2); //set只允许用一个值出现一次，要插入相同元素请用 multiset /* 定义multiset对象的示例代码如下：multiset&lt;int&gt; s;multiset&lt;double&gt; ss;multiset和set的基本操作相似，需要注意的是，集合的count()能返回0（无）或者 1（有），而多重集合是有多少个返回多少个。 */int a[4] = &#123;11,12,13,14&#125;;s.insert(a,a+4); //将区间[a, a+4]里的元素插入容器- 删除 s.erase(2) //删除2这个元素s.clear() //删除set容器中的所有的元素set&lt;int&gt;::iterator ita = s.begin();set&lt;int&gt;::iterator itb = s.begin();s.erase(ita); //删除迭代器指向位置的元素ita = s.begin(); itb = s.begin(); itb++; itb++; s.erase(ita,itb); //删除区间[ita,itb]的元素- 修改不能直接修改容器内数据，所以只能删除某元素再插入要修改的数值。- 查找s.find() 查找一个元素，如果容器中不存在该元素，返回值等于s.end()if(s.find(2) != s.end()) cout &lt;&lt; &quot;2 is existent&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;2 is non-existent&quot; &lt;&lt; endl;&#125; set的其他常用操作s.lower_bound() 返回第一个大于或等于给定关键值的元素s.upper_bound() 返回第一个大于给定关键值的元素s.equal_range() 返回一对定位器，分别表示 第一个大于或等于给定关键值的元素 和 第一个大于给定关键值的元素，**这个返回值是一个pair类型，如果这一对定位器中只要有一个返回失败，就会等于s.end() ** lower_bound()；upper_bound()的使用原则为，数组有序 1234567891011121314151617 cout &lt;&lt; &quot;equal_range test:&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第一个大于或等于2的元素: &quot; &lt;&lt; *s.equal_range(2).first &lt;&lt; endl; cout &lt;&lt; &quot;第一个大于2的元素: &quot; &lt;&lt; *s.equal_range(2).second &lt;&lt; endl; 其他方法：s.size() 返回当前set容器中的元素个数s.empty() 判断set容器是否为空 判断元素是否在set中 &amp; 判断set是否为空 if(s.empty()) cout &lt;&lt; &quot;容器为空&quot; &lt;&lt; endl; s.insert(1); if(!s.empty()) cout &lt;&lt; &quot;容器不为空&quot; &lt;&lt; endl; if(s.count(1)) cout &lt;&lt; &quot;1在容器中&quot; &lt;&lt; endl; if(!s.count(2)) cout &lt;&lt; &quot;2不在容器中&quot; &lt;&lt; endl; //集合的count()能返回0（无）或者1（有） 自定义比较函数 （1）当set中存储的数据，需要按自定义的规则进行比较大小时： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std; //定义比较函数，这地方还有点不懂？？？struct cmp&#123; bool operator () (const int &amp;a, const int &amp;b)&#123; return a &gt; b; &#125;&#125;;set&lt;int, cmp&gt;s; //自定义排序函数构造setvoid setprint(int cnt)&#123; cout &lt;&lt; &quot;Test output :&quot; &lt;&lt; cnt &lt;&lt; &quot;:&quot; &lt;&lt; endl; for(set&lt;int,cmp&gt;::iterator it = s.begin(); it!= s.end(); it++) cout &lt;&lt; *it &lt;&lt; &quot; &quot;; //这能够实现从大到小排列 return ;&#125;int main()&#123; s.insert(1); s.insert(2); s.insert(6); setprint(1); return 0;&#125; （2）当set中存储的是自定义数据时，如结构体，类等。 12345678 首先，在结构体中，增加“operator &lt;”函数 struct 结构体&#123; bool operator &lt; (const 结构体类型 &amp;a)&#123; ……return（…）; &#125; &#125;; 然后，定义setset&lt;类型&gt; s； 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;set&gt;#include&lt;string&gt;using namespace std;typedef struct non&#123; string name; float score; bool operator&lt; (const non &amp;a) const&#123; //运算符重载，来按结构体中的分数从高到低排列 return a.score&lt;score; &#125;&#125; STU; //要是不加typedef的话，STU应该是结构体的一个变量，否则STU为结构体的一个别名（要是不不用别名定义结构体的变量，应该struct non STU;即struct 结构体名 变量名这样声明 ，比较繁琐）。 int main()&#123; set&lt;STU&gt; v; STU s; //因为STU是non这个结构体的别名，所以可以这样定义 s.name=&quot;Jack&quot;; s.score=80.5; v.insert(s); s.name=&quot;Nacy&quot;; s.score=60.5; v.insert(s); s.name=&quot;Tomi&quot;; s.score=20; v.insert(s); set&lt;STU&gt;::iterator p; for(p=v.begin(); p!=v.end(); p++) &#123; cout&lt;&lt;(*p).name&lt;&lt;&quot; : &quot;&lt;&lt;(*p).score&lt;&lt;endl; &#125; return 0;&#125;输出结果：Jack : 80.5Nacy : 60.5Tomi : 20 实例：输入多个时间，对其排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;set&gt;using namespace std; struct time&#123; int hour; int minute; int second; bool operator &lt; (const time &amp;a)const &#123; if(hour!=a.hour) return(hour&lt;a.hour); else if(minute!=a.minute) return(minute&lt;a.minute); else return(second&lt;a.second); &#125;&#125;;int main()&#123; ifstream fin(&quot;input.txt&quot;); ofstream fout(&quot;output.txt&quot;); set&lt;struct time&gt; s; struct time t; int n; fin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; fin&gt;&gt;t.hour; fin.get(); //这句话的意思是什么,就是从文件流中获取到一个int类型的值 fin&gt;&gt;t.minute; fin.get(); fin&gt;&gt;t.second; s.insert(t); &#125; set&lt;struct time&gt;::iterator it; for(it=s.begin(); it!=s.end(); it++) fout&lt;&lt;(*it).hour&lt;&lt;&quot;:&quot;&lt;&lt;(*it).minute&lt;&lt;&quot;:&quot;&lt;&lt;(*it).second&lt;&lt;endl; fin.close(); fout.close(); return 0;&#125; ### vector 1、vector创建 vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。 123456vector&lt;int&gt; v;//定义一个空的动态数组,存储int类型元素vector&lt;int&gt; v(5);//定义一个初始大小为5的动态数组(默认初始值都为0)，存储int类型元素vector&lt;int&gt; v(5,1);//定义一个初始大小为5的动态数组,赋值都为1，存储int类型元素 2、基本操作 123456789101112131415161718 v[i]; // 以下标方式访问元素,很方便. v.push_back(x); //往尾部插入元素x (常用） v.insert(it, x); //向迭代器it指向的位置插入x,原位置后移 (蛮方便的，速度也快）。 //举例：v.insert(v.begin(),1); 比较神奇5w次这样的操作 大概0.5s，自己写的O(n)函数大概2.5s v.size();//返回表长,注意是unsigned类型,如果v.size()为1，减去2就是一个很大的正整数数,看情况转(int)v.size() v.begin(); // 返回指向首元素的迭代器 v.end(); // 返回指向尾元素 下一个位置的 迭代器. v.front(); //取首元素的值 v.back(); // 取尾元素的值 v.empty(); //表为空返回真，否则返回假 v.clear(); //清空表中所有元素 v.pop_back(); // 删除表尾元素 v.erase(it); //删除迭代器it指向的元素 v.erase(st, ed); //删除迭代器st和ed指定的元素[st,ed) (左闭右开） v.reserve(x); //预分配空间大小为x 3、排序方法sort（sort的第三个参数是一个函数指针或一个函数对象，不写就使用默认（自己定义的结构体要排序必须要写比较规则） ) （1）默认或使用标准库函数 123456789101112131415一个参数： vector&lt;int &gt;v; sort(v.begin(), v.end()); //默认，从小到大，升序排列 sort(v.begin(), v.end(), greater&lt;int&gt;()); //从大到小，降序排列 sort(v.begin(), v.end(), less&lt;int&gt;()); // 从小到大，升序排列 两个参数（不想写结构体的话可以用pair&lt;int,int&gt;) vector&lt;pair&lt;int,int&gt; &gt;v; //pair实质上是一个结构体，其主要的两个成员变量是first和second v.push_back(make_pair(3,4)); //用make_pair来构造我们需要的pair. v.push_back(make_pair(4,5)); sort(v.begin(), v.end()); //默认，按第一个数升序排列，若相同则按第二个数升序。 sort(v.begin(), v.end(), greater&lt;pair&lt;int,int&gt; &gt;()); //按第一个数降序排列，若相同按第二个数降序。 sort(v.begin(), v.end(), less&lt;pair&lt;int,int&gt; &gt;()); // 同默认，升序排列 cout &lt;&lt; v[0].first &lt;&lt; &quot; &quot; &lt;&lt; v[0].second; // 用v[i].first 和 v[i].second 取值 （2）自定义比较函数,多个参数的时候（常用） 123456789101112131415161718192021222324252627282930一般形式：vector&lt;int&gt; v; bool cmp(int a, int b) &#123; // 比较函数 return a &gt; b; // 降序 // return a &lt; b; 升序&#125;sort(v.begin(),v.end(), cmp);例如：#include &lt;bits/stdc++.h&gt;using namespace std;struct test &#123; int x,y; test(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125;&#125;;vector&lt;test&gt; v;bool cmp(test a, test b) &#123; return a.x &gt; b.x;&#125;int main(void ) &#123; v.push_back(test(1,2)); //写个构造函数方便很多. v.push_back(test(3,4)); sort(v.begin(), v.end(), cmp); cout &lt;&lt; v[0].x &lt;&lt; endl; // 结果为3 return 0;&#125; （3）重载结构体或类的比较运算符 12345678910111213141516171819202122232425262728293031323334353637383940414243//情况一：在结构体内部重载#include &lt;bits/stdc++.h&gt;using namespace std;struct test &#123; int x, y; test(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125; friend bool operator &lt; (test a, test b) &#123; return a.x &gt; b.x; //按x降序排序 &#125; /*或(也可以加上const &amp;更规范，比如在第三个参数写less&lt;test&gt;()时，必须按标准格式写） bool operator &lt; (const test &amp;a)const &#123; return x &gt; a.x; //按x降序排序 &#125; */&#125;;vector&lt;test&gt; v;int main(void ) &#123; v.push_back(test(1,2)); //写个构造函数pb时方便很多. v.push_back(test(3,4)); sort(v.begin(), v.end()); //不用写第三个参数 cout &lt;&lt; v[0].x &lt;&lt; endl; // 结果为3 return 0;&#125;//情况二：在外部重载#include &lt;bits/stdc++.h&gt;using namespace std;struct test &#123; int x, y; test(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125;&#125;;bool operator &lt; (test a,test b) &#123; //写在外面就不要friend了，参数要写全,更规范就写const &amp; return a.x &gt; b.x; //按x降序排序&#125;vector&lt;test&gt; v;int main(void ) &#123; v.push_back(test(1,2)); //写个构造函数pb时方便很多. v.push_back(test(3,4)); sort(v.begin(), v.end()); //不用写第三个参数 cout &lt;&lt; v[0].x &lt;&lt; endl; // 结果3 return 0;&#125; （4） 补充下重载pair，写在全局里无效，主要原因是不在一个namespace中，是先在同名字空间下里找，没找到才会外面找 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;#define pb push_back //少写点字的作用#define mp make_pairnamespace std &#123; bool operator &lt; (const pair&lt;int,int&gt; &amp;a, const pair&lt;int,int&gt; &amp;b) &#123; return a.first &gt; b.first; &#125; bool operator &gt; (const pair&lt;int,int&gt; &amp;a, const pair&lt;int,int&gt; &amp;b) &#123; return a.first &lt; b.first; &#125;&#125;vector&lt;pair&lt;int,int&gt; &gt; v;int main() &#123; v.pb(mp(1, 2)); v.pb(mp(3, 4)); sort(v.begin(),v.end()); cout &lt;&lt; v[0].first &lt;&lt; endl; // 结果为3 sort(v.begin(),v.end(), greater&lt;pair&lt;int,int&gt; &gt;()); cout &lt;&lt; v[0].first &lt;&lt; endl; // 结果为1&#125; （5）使用仿函数 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;struct test &#123; int x, y; test(int _x = 0, int _y = 0) : x(_x), y(_y) &#123;&#125;&#125;;vector&lt;test&gt; v;struct cmp &#123; //const 这里编译没有约束，但是对于明确的不可变参加上更严谨,上面的我有的没写，可以比较。 bool operator() (const test &amp;a, const test &amp;b) &#123; return a.x &gt; b.x; // 按x降序 &#125;&#125;;int main(void ) &#123; v.push_back(test(1,2)); //写个构造函数pb时方便很多.甚至可以 v.push_back(test(3,4)); //用的多了，手速狗可以 #define pb pusb_back sort(v.begin(), v.end(), cmp()); //传入函数对象. cout &lt;&lt; v[0].x &lt;&lt; endl; // 3 return 0;&#125; 4、 其他常用 （1） 123456789101112131415swap(v[1], v[2]); //交换元素.reverse(v.begin(), v.end()); //反转1234 -&gt; 4321*max_element(v.begin(), v.end()); //找表里最大的数（max_element返回的是迭代器，所以输出值的话要在前面加 *,即取指针的值）*min_element(v.begin(), v.end()); //找表里最小的数这两个函数还可以用于 vector&lt;int&gt; 或者 vector&lt;string&gt; ，也可以用于结构体vector或者结构体数组，他们 **默认** 是从小到大排列，所以要加上第三个参数cmp的话（比如从大到小排列，那么max_element返回的就是最小的那个）lower_bound(v.begin(), v.end(), x) - v.begin(); //二分法找第一个 大于等于x的下标upper_bound(v.begin(), v.end(), x) - v.begin(); //二分法找第一个 大于x的下标v.erase(unique(v.begin(), v.end()), v.end());//去重，1220330770.结果是1203070。一般是排序、去重、离散化时用到.vector &lt;pair&lt;int,int&gt; &gt;E[maxn]; // 一种建图思路.E[i][j] i为源点,E[i][j].first为第j条边终点， .second为距离 (2)max_element实例： 123456789101112131415161718192021222324252627282930313233343536373839404142struct node &#123; int x, y;&#125;;bool cmp1(node a, node b) &#123; return a.x &gt; b.x; //从大到小排列，即降序排列&#125;int main() &#123; vector&lt;int&gt; v(3); int arr[4]; int arr1[2][4]; vector&lt;node&gt; v1(3); cout &lt;&lt; *max_element(v.begin(), v.end()); cout &lt;&lt; *min_element(arr, arr + 4); cout &lt;&lt; *min_element(&amp;arr1[0][0], &amp;arr1[2][4]); //是求arr1[0][0],到arr1[2][4]这个区间内的最大值 cout &lt;&lt; (*max_element(v1.begin(), v1.end(), cmp1)).y; return 0;&#125;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std; struct node &#123; int x, y;&#125;;bool cmp1(node a, node b) &#123; return a.x &gt; b.x; //从大到小排列，即降序排列&#125;int main() &#123; vector&lt;node&gt; v1(3); for(int i=0;i&lt;3;i++)&#123; cin&gt;&gt;v1[i].x&gt;&gt;v1[i].y; &#125; cout &lt;&lt; (*max_element(v1.begin(), v1.end(), cmp1)).y; return 0; 这样的话会输出结构体中y值最小的那个结构体的y；因为max_element是相对于从小到大顺序排列的最下面的那个值，但是本题中加入了cmp1，就会输出最下面那个最小的值。&#125; stack1、定义： 堆栈是一个线性表，插入和删除只在表的一端进行。这一端称为栈顶，另一端称为栈底。堆栈的元素插入称为入栈，元素的删除则为出栈。 元素的入栈和出栈总在栈顶进行，因此，堆栈是一个后进先出(Last In First Out)表，即 LIFO 表。 C++ STL 的堆栈泛化是直接通过现有的序列容器来实现的，默认使用双端队列deque的数据结构，当然，可以采用其他线性结构（vector 或 list等），只要提供堆栈的入栈、出栈、栈顶元素访问和判断是否为空的操作即可。由于堆栈的底层使用的是其他容器，因此，堆栈可看做是一种适配器，将一种容器转换为另一种容器(堆栈容器)。 为了严格遵循堆栈的数据后进先出原则，stack 不提供元素的任何迭代器操作，因此，stack 容器也就不会向外部提供可用的前向或反向迭代器类型。2、常见用法：（1） 12默认构造函数，创建一个空的stack对象： stack&lt;int&gt; s; 复制构造函数，用一个 stack 堆栈创建一个新的堆栈。 stack(const stack&amp;) 例如，下面的代码利用 s1 ，创建一个以双向链表为底层容器的空堆栈对象 s2 。 12stack&lt;int, list&lt;int&gt; &gt; s1;stack&lt;int, list&lt;int&gt; &gt; s2(s1); （2） 元素入栈在栈顶添加元素 void push(const value_type&amp; x) 由于c++ STL的堆栈函数是不预设大小的。因此，入栈函数就不考虑堆栈空间是否为满，均将元素压入堆栈，从而函数没有标明入栈成功与否的返回值。(3) 移除栈顶元素 stack容器的元素出栈函数为 pop 函数，由于函数并没有判断堆栈是否为空，才进行元素的弹出，因此，需要自行判断堆栈是否为空，才可执行 pop 函数。 123456void pop() //这不会返回栈顶元素，只是移除栈顶元素 下面的示例代码，将堆栈的所有元素全部出栈 stack&lt;int&gt; s; while(!s.empty())&#123; // bool empty() 判断堆栈是否为空，返回 true 表示堆栈已空，false 表示堆栈非空。 s.pop(); // 出栈 &#125; ( 4 )计算栈对象元素个数 12345678910 size_type size() const; stack 堆栈是不设最大容量的，如果自己定义了栈的容量，可以用这种方法在栈未满之前压入元素： #define STACK_SIZE 100 // 堆栈最大容量 if (s.size() &lt; STACK_SIZE) s.push(68);~~~ (5)访问栈顶元素 ，** top（）是取栈顶元素，不会删掉栈里边的元素，pop（）是弹出栈顶元素，并且会删除栈顶元素。** value_type&amp; top(); //执行top不会弹出栈顶元素，只会读取 const value_type&amp; top() const; 1233、实例： #include #include #include #define STACK_SIZE 100 &#x2F;&#x2F; 堆栈最大容量 using namespace std; int main() { &#x2F;&#x2F; 用双向链表作堆栈的底层结构 stack&lt;int, list &gt; s; &#x2F;&#x2F; 堆栈未满，元素才能入栈 if (s.size() &lt; STACK_SIZE) s.push(68); if (s.size() &lt; STACK_SIZE) s.push(1); if (s.size() &lt; STACK_SIZE) s.push(17); &#x2F;&#x2F; 元素出栈 while (!s.empty()) { &#x2F;&#x2F; 打印 17 1 68 cout &lt;&lt; s.top() &lt;&lt; endl; &#x2F;&#x2F;这一句写成cout&lt;&lt;s.pop();是不可以的 s.pop(); &#x2F;&#x2F;只是移除栈顶元素，不会返回栈顶元素的值 } return 0; } 12345678 ---&lt;h3 id=&quot;queue&quot;&gt;&lt;h3&gt;#### queue1、 用法： queue表示的是队列的数据结构，是常用的数据结构之一。队列主要特点就是“先进先出”。 **在队尾添加元素，在队头删除元素。** **定义queue模板需要定义两个模版参数，一个是元素类型，一个是容器类型，元素类型是必要的，容器类型可选。** queue&lt;int&gt; q; queue&lt;double&gt; qq; 1232、基本函数 back() 返回一个引用，指向队列的最后一个元素。 empty() 函数返回真(true)如果队列为空，否则返回假(false)。 front() 返回队列第一个元素的引用。 pop() 函数删除队列头部的一个元素，但不返回其值，（清空队列没有clear方法，用这个就行） push() 在队列末尾加入一个元素 size() 返回队列中元素的个数 那么我们如何判断队列是空队列还是已满呢？ a、栈空： 队首标志=队尾标志时，表示栈空。 b、栈满 : 队尾+1 = 队首时，表示栈满。 1234563、 priority_queue (优先队列) 在＜queue＞ 头文件中，还定义了另一个非常有用的模版类priority_queue（优先队列）。**优先队列与队列的差别在于优先队列不是按照入队的顺序出队，而是按照队列中元素的优先权出队列（默认为大者优先，也可以通过指定算子来指定自己的优先顺序）。** priority_queue模版类有三个模版参数，第一个是元素类型，第二个是容器类型，第三个是比较算子。**其中后两者都可以忽略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队列时列尾元素先出队）。** (1)定义priority_queue对象的代码示例： priority_queue q; priority_queue&lt;pair&lt;int, int&gt; &gt; qq; &#x2F;&#x2F; 注意在两个尖括号之间一定要留空格，防止误判，默认为less算子，此时大值先出队列 priority_queue&lt;int, vector, greater &gt; qqq; &#x2F;&#x2F; greater算子，大值优先，但是队列从队尾出队，所以小值先出队列 1234 (2)priority_queue的基本操作与queue的略微不同。 priority_queue的基本操作： q.empty() &#x2F;&#x2F; 如果队列为空，则返回true，否则返回false q.size() &#x2F;&#x2F; 返回队列中元素的个数 q.pop() &#x2F;&#x2F; 删除队首元素，但不返回其值 q.top() &#x2F;&#x2F; 返回具有最高优先级的元素值，但不删除该元素 q.push(item) &#x2F;&#x2F; 在 基于优先级 的 适当位置 插入新元素 12345(3）如果是基本数据类型，或已定义了比较运算符的类，可以直接使用STL的less算子和greater算子——默认为使用less算子。如果要定义自己的比较算子，方法有多种。重载比较运算符方法。优先队列试图这两个元素x和y代入比较运算符（对于less算子（operator后面的&lt;，返回结果为真，就从小到大排列），调用x &lt; y，对于greater算子（operator后面的&gt;,返回结果为真就是从大到小），调用x &gt; y），若返回结果为真，则x排在y前面，y将先出队列，反之，则y排在x前面，x将先出队列（因为队尾先出队）。 如下算子示例： #include &lt;iostream&gt; #include &lt;queue&gt; using namespace std; class T &#123; public: int x, y, z; T(int a, int b, int c) : x(a), y(b), z(c) &#123;&#125; &#125;; bool operator &lt; (const T &amp;tOne, const T &amp;tTwo) &#123; return tOne.z &lt; tTwo.z; // 按照z的顺序来决定tOne和tTwo的顺序 &#125; int main() &#123; priority_queue&lt;T&gt; q; q.push(T(4, 4, 3)); q.push(T(2, 2, 5)); q.push(T(1, 5, 4)); q.push(T(3, 3, 6)); while (!q.empty()) &#123; T t = q.top(); q.pop(); cout &lt;&lt; t.x &lt;&lt; &quot; &quot; &lt;&lt; t.y &lt;&lt; &quot; &quot; &lt;&lt; t.z &lt;&lt; &#39;\\n&#39;; &#125; return 0; &#125; 输出结果为（注意是按照z的顺序从大到小出队列，因为less算子，然后队尾先出队）： 3 3 6 2 2 5 1 5 4 4 4 3 另外：如果想要按照z的顺序从小到大出队列，只需要改动比较运算符重载为： bool operator &gt; (const T &amp;tOne, const T &amp;tTwo) &#123; return tOne.z &gt; tTwo.z; // 按照z的顺序来决定tOne和tTwo的顺序 &#125; 对于自定义类型的数据进行排序： less算子，即默认算子为：大的往前排，小的往后排（出队时队列头的元素出队，即大者先出队）。（但是不放在优先队列里less算子从小到大排序） greater算子，即默认算子为：小的往前排，大的往后排（出队时队列头的元素出队，即小者先出队）。 #include #include using namespace std; &#x2F;&#x2F;方法1 struct tmp1 &#x2F;&#x2F;运算符重载&lt; { int x; tmp1(int a) {x &#x3D; a;} bool operator&lt;(const tmp1&amp; a) const {&#x2F;&#x2F;自定义less算子，x &lt; a.x返回true，从小到大，队尾出队，所以从大到小出队 return x &lt; a.x; &#x2F;&#x2F;从大到小出队 } }; &#x2F;&#x2F;方法2 struct tmp2 &#x2F;&#x2F;重写仿函数（必须放在结构体中） { bool operator() (tmp1 a, tmp1 b) { return a.x &lt; b.x; &#x2F;&#x2F;从大到小出队 } }; int main() { tmp1 a(1); tmp1 b(2); tmp1 c(3); priority_queue d; d.push(b); d.push(c); d.push(a); while (!d.empty()) { cout &lt;&lt; d.top().x &lt;&lt; ‘\\n’; d.pop(); } cout &lt;&lt; endl; priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f; f.push(c); f.push(b); f.push(a); while (!f.empty()) &#123; cout &lt;&lt; f.top().x &lt;&lt; &#39;\\n&#39;; f.pop(); &#125; } 1234567891011121314151617181920212223４、循环队列 **以数组作为底层数据结构时，一般讲队列实现为循环队列。**这是因为队列在顺序存储上的不足：每次从数组头部删除元素（出队）后，需要将头部以后的所有元素往前移动一个位置，这是一个时间复杂度为O（n）的操作。 **可能有人说，把队首标志往后移动不就不用移动元素了吗？的确，但那样会造成数组空间的“流失”。** 我们希望队列的插入与删除操作都是O(1)的时间复杂度，同时不会造成数组空间的浪费，我们应该使用循环队列。 **定义：** *所谓的循环队列，可以把数组看出一个首尾相连的圆环，删除元素时将队首标志往后移动，添加元素时若数组尾部已经没有空间，则考虑数组头部的空间是否空闲，如果是，则在数组头部进行插入。*![upload successful](\\aoyue\\images\\pasted-24.png) 那么我们如何判断队列是空队列还是已满呢？ 栈空： 队首标志=队尾标志时，表示栈空，即红绿两个标志在图中重叠时为栈空。栈满 : 队尾+1 = 队首时，表示栈满。图的最下面的队列即为一个满队列。尽管还有一个空位，我们不存储元素。(１)判断循环队列是“空”还是“ 满”，有以下两种处理方法： 1）设置状态标志位以区别空还是满 2）少用一个元素，约定“队头front在队尾rear的下一个位置（指的是环的下一个位置）”作为“满”的标志 C语言中，不能用动态分配的一维数组来实现循环队列，如果用户的应用程序中设有循环队列，则必须为它设定一个最大队列长度；**如果用户无法预估所用队列的最大长度，则宜采用链队列。** *定义front为队列头元素的位置，rear为队列尾元素的位置，MAXSIZE为循环队列的最大长度。*注意以下几点，循环队列迎刃而解： 1）求元素的个数：(rear - front + MAXSIZE) % MAXSIZE 2）rear指向逻辑的下一个空间; front =（front+1)%MAXSIZE ，rear = (rear+1)%MAXSIZE ？？对maxsize取余的意义何在？？ 3）判空：front == rear 4）判满：(rear+1+MAXSZIE) == front 5)循环队列中判断队空的方法是判断front==rear，队满的方法是判断front=（rear+1）%MAXSIZE。（为什么不用一个length表示队长，当length==maxSize时表示队满，原因就是，在频繁的队列操作中，多出一个变量会大量的增加执行时间，所以不如浪费一个数组空间来得划算。）(２)循环队列的c++实现： #include #include #include using namespace std; template class LoopQueue { public: LoopQueue(int c &#x3D; 10); ~LoopQueue(); bool isEmpty(); &#x2F;&#x2F;队列的判空 int size(); &#x2F;&#x2F;队列的大小 bool push(T t); &#x2F;&#x2F;入队列 bool pop(); &#x2F;&#x2F;出队列 T front(); &#x2F;&#x2F;队首元素 private: int capacity; int begin; int end; T* queue; }; template LoopQueue::LoopQueue(int c &#x3D; 10) :capacity(c), begin(0), end(0), queue(nullptr) { queue &#x3D; new T[capacity]; }; template LoopQueue::~LoopQueue() { delete[]queue; } template bool LoopQueue::isEmpty() &#x2F;&#x2F;判断循环队列是否为空 { if (begin &#x3D;&#x3D; end) return true; return false; }; template int LoopQueue::size() { return (end - begin + capacity) % capacity; &#x2F;&#x2F;计算循环队列的长度 }; template bool LoopQueue::push(T t) { if (end + 1 % capacity &#x3D;&#x3D; begin) &#x2F;&#x2F;判断队列是否已满 { return false; } queue[end] &#x3D; t; end &#x3D; (end + 1) % capacity; return true; }; template bool LoopQueue::pop() &#x2F;&#x2F;判断队列是否为空 { if (end &#x3D;&#x3D; begin) { return false; } begin &#x3D; (begin + 1) % capacity; return true; }; template T LoopQueue::front() { if (end &#x3D;&#x3D; begin) { return false; } return queue[begin]; }; int main() &#x2F;&#x2F;测试代码 { LoopQueue queue(6); queue.push(“one”); queue.push(“two”); queue.push(“three”); queue.push(“four”); queue.push(“five”); cout &lt;&lt; “队列长度” &lt;&lt; queue.size() &lt;&lt; endl; while (!queue.isEmpty()) { cout &lt;&lt; queue.front() &lt;&lt; endl; queue.pop(); } getchar(); &#x2F;&#x2F;system(“pause”); return 0; } 1234567891011125、链队列 **链队列是基于链表实现的队列，它不存在数组的O（n）的元素移动问题或空间浪费问题。**我们所要确定的就是链表哪头做队首，哪头做队尾。 (1)*显然我们应该以链表头部为队首，链表尾部为队尾。存储一个指向队尾的指针，方便**从链表尾插入元素**；使用带头节点的链表，方便**从链表头删除元素。** * ![upload successful](\\aoyue\\images\\pasted-25.png) 用单链表表示的链式队列特别适合于数据元素变动较大的情形，而且不存在溢出的情况。(2)代码实现： template struct Node { Node(T t) :value(t), next(nullptr){} Node() &#x3D; default; T value; &#x2F;&#x2F;vaule : 链表节点的值 Node * next; &#x2F;&#x2F;next : 指针，指向下一个节点 }; template class LinkQueue { public: LinkQueue(); ~LinkQueue(); bool isEmpty(); int size(); bool pop(); void push(T t); T front(); private: Node* phead; Node* pend; int count; }; template LinkQueue::LinkQueue() :phead(nullptr),pend(nullptr),count(0) { phead &#x3D; new Node(); pend &#x3D; phead; count &#x3D; 0; }; template LinkQueue::~LinkQueue() { while (phead-&gt;next !&#x3D; nullptr) { Node * pnode &#x3D; phead; phead &#x3D; phead-&gt;next; } }; template bool LinkQueue:: isEmpty() { return count&#x3D;&#x3D;0; }; template int LinkQueue::size() { return count; }; &#x2F;&#x2F;在队尾插入 template void LinkQueue::push(T t) { Node* pnode &#x3D; new Node(t); pend-&gt;next &#x3D; pnode; pend &#x3D; pnode; count++; }; &#x2F;&#x2F;在队首弹出 template bool LinkQueue::pop() { if (count &#x3D;&#x3D; 0) return false; Node* pnode &#x3D; phead-&gt;next; phead-&gt;next &#x3D; phead-&gt;next-&gt;next; delete pnode; count–; return true; }; &#x2F;&#x2F;获取队首元素 template T LinkQueue::front() { return phead-&gt;next-&gt;value; }; int _tmain(int argc, _TCHAR* argv[]) { LinkQueue lqueue; lqueue.push(“one”); lqueue.push(“two”); lqueue.push(“three”); lqueue.push(“four”); lqueue.push(“five”); cout &lt;&lt; “队列的大小” &lt;&lt; lqueue.size() &lt;&lt; endl; while (!lqueue.isEmpty()) { cout &lt;&lt; lqueue.front() &lt;&lt; endl; lqueue.pop(); } getchar(); return 0; } 运行结果： 队列的大小5 one two three four five 12345678---&lt;h3 id=&quot;map&quot;&gt;&lt;h3&gt;#### map1、 Map是c++的一个标准容器，它提供了很好的一对一的关系，在一些程序中建立一个map可以起到事半功倍的效果。 在STL的头文件中＜map＞中定义了模版类map和multimap，用有序二叉树表存储类型为pair&lt;const Key, T&gt;的元素对序列。 **序列中的元素以const Key部分作为标识，map中所有元素的Key值必须是唯一的，multimap则允许有重复的Key值。** 2、定义map对象 map&lt;int,string&gt;m; typedef map&lt;int,string&gt; MAP; // 这时候可以用MAP来声明一个 int，string类型的对象，例如：MAP m；这和map&lt;int,string&gt;m;等价 1233、map的基本操作： &#x2F;* 向map中插入元素 &#x2F; m[key] &#x3D; value; &#x2F;&#x2F; [key]操作是map很有特色的操作,如果在map中存在键值为key的元素对, 则返回该元素对的值域部分*,否则将会创建一个键值为key的元素对,值域为默认值。所以可以用该操作向map中插入元素对或修改已经存在的元素对的值域部分。 m.insert(make_pair(key, value)); &#x2F;&#x2F; 也可以直接调用insert方法插入元素对,insert操作会返回一个pair,当map中没有与key相匹配的键值时,其first是指向插入元素对的迭代器,其second为true;若map中已经存在与key相等的键值时,其first是指向该元素对的迭代器,second为false。 &#x2F;* 查找元素 *&#x2F; int i &#x3D; m[key]; &#x2F;&#x2F; 要注意的是,当与该键值相匹配的元素对不存在时,会创建键值为key（当另一个元素是整形时，m[key]&#x3D;0）的元素对。 map&lt;string, int&gt;::iterator it &#x3D; m.find(key); &#x2F;&#x2F; 如果map中存在与key相匹配的键值时,find操作将返回指向该元素对的迭代器,否则,返回的迭代器等于map的end()(参见vector中提到的begin()和end()操作)。 map.count(k); &#x2F;&#x2F;返回map中键k的出现次数(对于map而言，由于一个key对应一个value，因此返回只有0和1，因此可以用此函数判断k是否在map中) &#x2F;* 删除元素 *&#x2F; m.erase(key); &#x2F;&#x2F; 删除与指定key键值相匹配的元素对,并返回被删除的元素的个数。 m.erase(it); &#x2F;&#x2F; 删除由迭代器it所指定的元素对,并返回指向下一个元素对的迭代器。 &#x2F;* 其他操作 *&#x2F; m.size(); &#x2F;&#x2F; 返回元素个数 m.empty(); &#x2F;&#x2F; 判断是否为空 m.clear(); &#x2F;&#x2F; 清空所有元素 m1.swap(m2); &#x2F;&#x2F;m1,m2两个容器互换，Map中的swap不是一个容器中的元素交换，而是两个容器交换； Map中的元素是自动按key升序排序,所以不能对map用sort函数： 1234、实例： #include #include using namespace std; typedef map&lt;int, string, less &gt; M_TYPE typedef M_TYPE::iterator M_IT typedef M_TYPR::const_iterator M_CIT int main() { M_TYPR myTestMap; myTestMap[3] = &quot;No.3&quot;; myTestMap[5] = &quot;No.5&quot;; myTestMap[1] = &quot;No.1&quot;; myTestMap[2] = &quot;No.2&quot;; myTestMap[4] = &quot;No.4&quot;; M_IT itStop = myTestMap.find(2); cout &lt;&lt; &quot;myTestMap[2] = &quot; &lt;&lt; itStop-&gt;second &lt;&lt; endl; itStop-&gt;second = &quot;No.2 After modification&quot;; cout &lt;&lt; &quot;myTestMap[2] = &quot; &lt;&lt; itStop-&gt;second &lt;&lt; endl; cout &lt;&lt; &quot;Map contents:&quot; &lt;&lt; endl; for (M_CIT it = myTestMap.begin(); it != myTestMap.end(); it++) &#123; cout &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; return 0; } 程序执行的输出结果为： MyTestMap[2] &#x3D; No.2 MyTestMap[2] &#x3D; No.2 After modification Map contents : No.1 No.2 After modification No.3 No.4 No.5 123456789&lt;h3 id=&quot;bitset&quot;&gt;&lt;h3&gt;#### bitset1、在 STL 的头文件中＜bitset＞中定义了模版类 bitset，用来方便地管理一系列的 bit 位的类。bitset 除了可以访问指定下标的 bit 位以外，还可以把它们作为一个整数来进行某些统计。 2、定义bitset时，要明确bitset有多少位： bitset&lt;32&gt; bitvec // 32位二进制，初始化为0，0~31 **当用unsigned 值初始化bitset 对象时，该值将转化为二进制的位模式。**如果bitset类型长度大于 unsigned 值的二进制位数，则其余的高阶位将置为0；如果bitset 类型长度小于unsigned 值的二进制位数，则只使用unsigned值中的低阶位，超过bitset类型长度的高阶位将被丢弃。 例如： bitset&lt;16&gt; bit ( 0xFFFF ) &#x2F;&#x2F; 015位都置1 bitset&lt;32&gt; bit ( 0xFFFF ) &#x2F;&#x2F; 015位置1，16~31位置0 123456789101112131415161718192021222324252627282930313、https://blog.csdn.net/ACM_10000h/article/details/40951033https://blog.csdn.net/chaiwenjun000/article/details/71154235-------&lt;h3 id=&quot;iterator&quot;&gt;&lt;h3&gt;#### iterator1、iterator（迭代器）是用于访问容器中元素的指示器，从这个意义上说，iterator（迭代器）相当于数据结构中所说的“遍历指针”，也可以把iterator（迭代器）看作是一种泛化的指针。**每种STL容器都有自己的iterator（迭代器）子类** **定义：迭代器是一种检查容器内元素并遍历元素的数据类型。 迭代器提供对一个容器中的对象的访问方法，并且定义了容器中对象的范围。** - 迭代器和指针的区别： 容器和string有迭代器类型同时拥有返回迭代器的成员。如：容器有成员begin和end,其中begin成员复制返回指向第一个元素的迭代器，**而end成员返回指向容器尾元素的下一个位置的迭代器，也就是说end指示的是一个不存在的元素，所以end返回的是尾后迭代器。**2、简单的说，STL中有以下几类iterator（迭代器）： 输入iterator（迭代器），在容器的连续区内向前移动，可以读取容器内任意值； 输出iterator（迭代器），把值写进它所指向的容器中； 前向iterator（迭代器），读取队列中的值，并可以向前移动到下一个位置(++p, p++)； 双向iterator（迭代器），读取队列中的值，并可以向前后遍历容器；随机访问向iterator（迭代器），可以直接以下标方式对容器进行访问，vector的iterator（迭代器）就是这种iterator（迭代器）； *插入和删除所花费的时间是固定的，与位置无关。* 流iterator（迭代器），可以直接输入、输出流中的值； ![upload successful](\\aoyue\\images\\pasted-26.png)1）随机访问：提供了对数组元素进行快速随机访问以及在序列尾部进行快速插入和删除操作。 2）双向访问：插入和删除所花费的时间是固定的，与位置无关。 ![upload successful](\\aoyue\\images\\pasted-27.png)![upload successful](\\aoyue\\images\\pasted-28.png)3、**当用iterator删除容器中元素时，该迭代器会失效，或者当改变了容器的内存分配时，所有相关的迭代器都会失效。** 4、实例： #include #include using namespace std; int main() { vector s; for (int i &#x3D; 0; i &lt; 10; i++) { s.push_back(i); } for (vector::iterator it &#x3D; s.begin(); it !&#x3D; s.end(); it++) { cout &lt;&lt; *it &lt;&lt; “ “; } cout &lt;&lt; ‘\\n’; return 0; } &#x2F;&#x2F;vector的begin()和end()方法都会返回一个vector::iterator对象，分别指向vector的首元素位置和尾元素的下一个位置（我们可以称之为结束标志位）。 #include #include using namespace std; int main() { vector s; s.push_back(1); s.push_back(2); s.push_back(3); copy(s.begin(), s.end(), ostream_iterator (cout, “ “)); &#x2F;&#x2F;这段代码中的copy就是STL中定义的一个模版函数，copy(s.begin(), s.end(), ostream_iterator(cout, ” “));的意思是将由s.begin()至s.end()（不含s.end()）所指定的序列复制到标准输出流out中，用” “作为每个元素的间隔。也就是说，这句话的作用其实就是将表中的所有内容依次输出。 cout &lt;&lt; ‘\\n’; return 0; } 123456 ---&lt;h3 id=&quot;algorithm&quot;&gt;&lt;h3&gt;#### algorithm1、for_each遍历容器 #include #include #include using namespace std; int visit(int v) &#x2F;&#x2F; 遍历算子函数 { cout &lt;&lt; v &lt;&lt; “ “; return 1; } class multInt &#x2F;&#x2F; 定义遍历算子类 { private: int factor; public: multInt(int f) : factor(f) {} &#x2F;&#x2F;这是构造函数，给factor赋值的 void operator() (int &amp;elem) const &#123; elem *= factor; &#125; }; int main() { vector L; for (int i &#x3D; 0; i &lt; 10; i++) { L.push_back(i); } for_each(L.begin(), L.end(), visit); cout &lt;&lt; ‘\\n’; for_each(L.begin(), L.end(), multInt(2)); for_each(L.begin(), L.end(), visit); cout &lt;&lt; ‘\\n’; return 0; } 程序输出结果为： 0 1 2 3 4 5 6 7 8 9 0 2 4 6 8 10 12 14 16 18 1232、min_element/max_element找出容器中的最小/最大值 #include #include #include using namespace std; int main() { vector L; for (int i&#x3D;0; i&lt;10; i++) { L.push_back(i); } vector::iterator min_it &#x3D; min_element(L.begin(), L.end()); vector::iterator max_it &#x3D; max_element(L.begin(), L.end()); cout &lt;&lt; “Min is “ &lt;&lt; *min_it &lt;&lt; endl; cout &lt;&lt; “Max is “ &lt;&lt; *max_it &lt;&lt; endl; return 0; } 程序的输出结果： Min is 0 Max is 9 123 3、sort对容器进行排序 #include #include #include using namespace std; void Print(vector &amp;L) { for (vector::iterator it &#x3D; L.begin(); it !&#x3D; L.end(); it++) { cout &lt;&lt; *it &lt;&lt; “ “; } cout &lt;&lt; endl; return ; } int main() { vector L; for (int i &#x3D; 0; i &lt; 5; i++) { L.push_back(i); } for (int i &#x3D; 9; i &gt;&#x3D; 5; i–) { L.push_back(i); } Print(L); sort(L.begin(), L.end()); Print(L); sort(L.begin(), L.end(), greater ()); &#x2F;&#x2F; 按降序排序 Print(L); return 0; } 程序的输出结果： 0 1 2 3 4 9 8 7 6 5 0 1 2 3 4 5 6 7 8 9 9 8 7 6 5 4 3 2 1 0 1234、copy在容器间复制元素 #include #include #include using namespace std; int main() { &#x2F;&#x2F; 先初始化两个向量vOne和vTwo vector vOne, vTwo; for (int i &#x3D; 0; i &lt;&#x3D; 5; i++) { vOne.push_back(10 * i); } for (int i &#x3D; 0; i &lt;&#x3D; 10; i++) { vTwo.push_back(3 * i); } cout &lt;&lt; &quot;vOne = ( &quot;; for (vector&lt;int&gt;::iterator it = vOne.begin(); it != vOne.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;)&quot; &lt;&lt; &#39;\\n&#39;; cout &lt;&lt; &quot;vTwo = ( &quot;; for (vector&lt;int&gt;::iterator it = vTwo.begin(); it != vTwo.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;)&quot; &lt;&lt; &#39;\\n&#39;; // 将vOne的前三个元素复制到vTwo的中间（覆盖掉原来数据） copy(vOne.begin(), vOne.begin() + 3, vTwo.begin() + 4); cout &lt;&lt; &quot;vTwo with vOne insert = ( &quot; ; for (vector &lt;int&gt;::iterator it = vTwo.begin(); it != vTwo.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;)&quot; &lt;&lt; &#39;\\n&#39;; // 在vTwo内部进行复制，注意参数2表示结束位置，结束位置不参与复制 copy(vTwo.begin() + 4, vTwo.begin() + 7, vTwo.begin() + 2); cout &lt;&lt; &quot;vTwo with shifted insert = ( &quot; ; for (vector &lt;int&gt;::iterator it = vTwo.begin(); it != vTwo.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;)&quot; &lt;&lt; &#39;\\n&#39;; return 0; } 程序的输出结果： vOne &#x3D; ( 0 10 20 30 40 50 ) vTwo &#x3D; ( 0 3 6 9 12 15 18 21 24 27 30 ) vTwo with vOne insert &#x3D; ( 0 3 6 9 0 10 20 21 24 27 30 ) vTwo with shifted insert &#x3D; ( 0 3 0 10 20 10 20 21 24 27 30 ) 1234567891011121314151617##### queal函数 bool equal( InputIt1 first1, InputIt1 last1, InputIt2 first2); first1, last1-the first range of the elements to compare first2-the beginning element of the second range to compare 注解：它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回true，否则返回false。由于equal利用迭代器完成操作，因此可以通过equal比较两个不同类型容器中的元素。而且，元素的类型也不必一样，只要我们能用==来比较两个元素类型即可。equal基于一个非常重要的假设：它假设第二个序列至少与第一个序列一样长。 #include #include #include using namespace std; int main() { vector vi1,vi2; for(int i&#x3D;0;i&lt;10;i++) { vi1.push_back(i); vi2.push_back(i); } if(equal(vi1.begin(),vi1.end(),vi2.begin())) cout&lt;&lt;&quot;vi1 equal vi2\\n&quot;; else cout&lt;&lt;&quot;vi1 not equal vi2\\n&quot;; if(equal(vi1.begin()+5,vi1.end(),vi2.begin())) cout&lt;&lt;&quot;vi1 equal vi2\\n&quot;; else cout&lt;&lt;&quot;vi1 not equal vi2\\n&quot;; return 0; } 相应的，可以利用反向迭代器来实现判断回文 bool testHW(string str) { return equal(str.begin(), str.end(), str.rbegin()); } 1234567891011- G Jessica&#x27;s Reading Problem 题目大意： XXX要准备考试，书总共有P页，第i页恰好有一个知识点ai，书中的同一个知识点可能会被多次提到，所以他希望看其中连续的一些页的书来把所有的知识点都给看完。。 题目分析： 其实页数可以看作连续的序列，然后就是要求出一个子序列，子序列的要求的包涵所有知识点都有的页数，且子序列的长度要最短。 首先我们并不知道总共有多少个知识点，这是个先要记录的。 不断的把序列中的元素加入到子序列中，知识点的数目会不断的增加，当知识点是数目满了之后，把子序列前面的元素开始剔除，再看看现在的子序列还是否满足这个条件。满足继续删除子序列前面的元素，否则的话把后面的元素加入到子序列中。 注意中间过程知识点数的增加或减少的维护。 #include #include #include #include #include #include #include #include #include using namespace std; typedef long long LL; const int N&#x3D;100000+999; int n,m; int num[N]; &#x2F;&#x2F;尺取法 int main() { while(scanf(“%d”,&amp;n)!&#x3D;EOF) { memset(num,0,sizeof(num)); set all; &#x2F;&#x2F;利用集合元素的单一性 map&lt;int,int&gt; cot; for(int i&#x3D;0; i&lt;n; i++) { scanf(“%d”,&amp;num[i]); all.insert(num[i]); } int res&#x3D;n; m&#x3D;all.size(); &#x2F;&#x2F;算出种类 int s&#x3D;0,e&#x3D;0,sum&#x3D;0; while(1) { while(e&lt;n &amp;&amp; sum&lt;m) { if(cot[ num[e++] ]++ &#x3D;&#x3D; 0) &#x2F;&#x2F;如果这个种类未出现 则sum++ sum++; } if(sum&lt;m) break; res&#x3D;min(res,e-s); if(–cot[ num[s++] ] &#x3D;&#x3D; 0) &#x2F;&#x2F;如果这个种类-1后为0 则sum-1 sum–; } printf(“%d\\n”,res); } return 0; }","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://zouyunkai.github.io/myblog/tags/c/"},{"name":"stl","slug":"stl","permalink":"https://zouyunkai.github.io/myblog/tags/stl/"}],"author":"aoyuehan"},{"title":"web_sql注入","slug":"Untitled","date":"2019-07-29T10:07:00.000Z","updated":"2022-02-26T04:29:58.302Z","comments":true,"path":"2019/07/29/Untitled/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/29/Untitled/","excerpt":"","text":"SQL injection sqlwiki 基本概念 SQL 注入是一种将 SQL 代码插入或添加到应用（用户）的输入参数中，之后再将这些参数传递给后台的 SQL 服务器加以解析并执行的攻击。 攻击者能够修改 SQL 语句，该进程将与执行命令的组件（如数据库服务器、应用服务器或 WEB 服务器）拥有相同的权限。 如果 WEB 应用开发人员无法确保在将从 WEB 表单、cookie、输入参数等收到的值传递给 SQL 查询（该查询在数据库服务器上执行）之前已经对其进行过验证，通常就会出现 SQL 注入漏洞。 常用工具Burp Suite：Burp Suite 使用介绍Tamper Data (Firefox addon)HackBar (Firefox addon)sqlmap：sqlmap 用户手册","categories":[{"name":"CTF","slug":"CTF","permalink":"https://zouyunkai.github.io/myblog/categories/CTF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://zouyunkai.github.io/myblog/tags/web/"},{"name":"sql","slug":"sql","permalink":"https://zouyunkai.github.io/myblog/tags/sql/"}],"author":"aoyuehan"},{"title":"JS_HTML_DOM","slug":"js-html-DOM","date":"2019-07-29T09:21:00.000Z","updated":"2022-02-26T03:52:51.153Z","comments":true,"path":"2019/07/29/js-html-DOM/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/29/js-html-DOM/","excerpt":"","text":"JavaScript HTML DOM1、简介：a 、通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素b 、HTML DOM (文档对象模型)当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。HTML DOM 模型被构造为对象的树： 通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML。 JavaScript 能够改变页面中的所有 HTML 元素 JavaScript 能够改变页面中的所有 HTML 属性 JavaScript 能够改变页面中的所有 CSS 样式 JavaScript 能够对页面中的所有事件做出反应 c 、查找 HTML 元素 有三种方法来做这件事： 通过 id 找到 HTML 元素 通过标签名找到 HTML 元素 通过类名找到 HTML 元素 d 、通过 id 查找 HTML 元素var x=document.getElementById(&quot;intro&quot;); e 、通过标签名查找 HTML 元素 12var x=document.getElementById(&quot;main&quot;); var y=x.getElementsByTagName(&quot;p&quot;); f 、通过类名找到 HTML 元素 var x=document.getElementsByClassName(&quot;intro&quot;); 2 、JavaScript HTML DOM - 改变 HTMLa 、改变 HTML 输出流在 JavaScript 中，document.write() 可用于直接向 HTML 输出流写内容。 123&lt;script&gt;document.write(Date());&lt;/script&gt; b 、改变 HTML 内容修改 HTML 内容的最简单的方法是使用 innerHTML 属性。语法： document.getElementById(id).innerHTML &#x3D; 新的 HTML例如： 1234567891011&lt;p id=&quot;p1&quot;&gt;Hello World!&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;p1&quot;).innerHTML=&quot;新文本!&quot;;&lt;/script&gt;或者这样写：&lt;h1 id=&quot;header&quot;&gt;Old Header&lt;/h1&gt;&lt;script&gt;var element=document.getElementById(&quot;header&quot;);element.innerHTML=&quot;新标题&quot;;&lt;/script&gt; c 、改变 HTML 属性语法：document.getElementById(id).attribute&#x3D;新属性值例如： 1234&lt;img id=&quot;image&quot; src=&quot;smiley.gif&quot;&gt;&lt;script&gt;document.getElementById(&quot;image&quot;).src=&quot;landscape.jpg&quot;;&lt;/script&gt; 3、 JavaScript HTML DOM - 改变CSSa 、改变 HTML 样式语法：document.getElementById(id).style.property&#x3D;新样式例如： 1234567&lt;p id=&quot;p1&quot;&gt;Hello World!&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;Hello World!&lt;/p&gt;&lt;script&gt;document.getElementById(&quot;p2&quot;).style.color=&quot;blue&quot;;document.getElementById(&quot;p2&quot;).style.fontFamily=&quot;Arial&quot;;document.getElementById(&quot;p2&quot;).style.fontSize=&quot;larger&quot;;&lt;/script&gt; b 、使用事件HTML DOM 允许我们通过触发事件来执行代码。 比如以下事件： 元素被点击。 页面加载完成。 输入框被修改。 等等…… 例如： 1234&lt;h1 id=&quot;id1&quot;&gt;我的标题 1&lt;/h1&gt;&lt;button type=&quot;button&quot;onclick=&quot;document.getElementById(&#x27;id1&#x27;).style.color=&#x27;red&#x27;&quot;&gt;点我!&lt;/button&gt; 实例，隐藏元素： 123456&lt;p id=&quot;p1&quot;&gt;这是一个文本。 这是一个文本。 这是一个文本。 这是一个文本。这是一个文本。 这是一个文本。 这是一个文本。&lt;/p&gt;&lt;input type=&quot;button&quot; value=&quot;隐藏文本&quot;onclick=&quot;document.getElementById(&#x27;p1&#x27;).style.visibility=&#x27;hidden&#x27;&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;显示文本&quot;onclick=&quot;document.getElementById(&#x27;p1&#x27;).style.visibility=&#x27;visible&#x27;&quot; /&gt; ４、JavaScript HTML DOM 事件a 、对事件做出反应我们可以在事件发生时执行 JavaScript，比如当用户在 HTML 元素上点击时。如需在用户点击某个元素时执行代码，请向一个 HTML 事件属性添加 JavaScript 代码：语法： onclick&#x3D;JavaScript HTML 事件的例子： 当用户点击鼠标时 当网页已加载时 当图像已加载时 当鼠标移动到元素上时 当输入字段被改变时 当提交 HTML 表单时 当用户触发按键时 例如： 123456789101112131415161718&lt;body&gt;&lt;h1 onclick=&quot;this.innerHTML=&#x27;Ooops!&#x27;&quot;&gt;点击文本!&lt;/h1&gt;&lt;/body&gt;**或者从事件处理器中调用一个函数：**&lt;html&gt;&lt;head&gt;&lt;script&gt;function changetext(id)&#123;id.innerHTML=&quot;Ooops!&quot;;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 onclick=&quot;changetext(this)&quot;&gt;点击文本!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; b 、HTML 事件属性如需向 HTML 元素分配 事件，您可以使用事件属性。实例：向 button 元素分配 onclick 事件：&lt;button onclick=&quot;displayDate()&quot;&gt;点这里&lt;/button&gt;c 、使用 HTML DOM 来分配事件 HTML DOM 允许您使用 JavaScript 来向 HTML 元素分配事件：向 button 元素分配 onclick 事件： 1234&lt;script&gt;document.getElementById(&quot;myBtn&quot;).onclick=function()&#123;displayDate()&#125;;&lt;/script&gt;**名为 displayDate 的函数被分配给 id=&quot;myBtn&quot; 的 HTML 元素。** d 、onload 和 onunload 事件onload 和 onunload 事件会在用户进入或离开页面时被触发。onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。onload 和 onunload 事件可用于处理 cookie。e 、onchange 事件onchange 事件常结合对输入字段的验证来使用。下面是一个如何使用 onchange 的例子。当用户改变输入字段的内容时，会调用upperCase() 函数。&lt;input type=&quot;text&quot; id=&quot;fname&quot; onchange=&quot;upperCase()&quot;&gt; f 、onmouseover 和 onmouseout 事件onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML元素上方或移出元素时触发函数。g 、onmousedown、onmouseup 以及 onclick 事件onmousedown, onmouseup 以及 onclick构成了鼠标点击事件的所有部分。 首先当点击鼠标按钮时，会触发 onmousedown事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发onclick 事件。实例： 12345678910&lt;script&gt;function myFunction(x)&#123;x.style.background=&quot;yellow&quot;;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;输入你的名字: &lt;input type=&quot;text&quot; onfocus=&quot;myFunction(this)&quot;&gt;&lt;p&gt;**当输入框获取焦点时，修改背景色（background-color属性） 将被触发。**&lt;/p&gt;&lt;/body&gt; 5、 JavaScript HTML DOM EventListenera、addEventListener() 方法语法：element.addEventListener(event, function, useCapture); 第一个参数是事件的类型 (如 “click” 或 “mousedown”).第二个参数是事件触发后调用的函数。第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。注意：addEventListener() 方法用于向指定元素添加事件句柄。addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。你可以向一个元素添加多个事件句柄。你可以向同个元素添加多个同类型的事件句柄，如：两个 “click” 事件。你可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。当你使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。你可以使用 removeEventListener() 方法来移除事件的监听。b 、向原元素添加事件句柄实例：当用户点击元素时弹出 “Hello World!” :element.addEventListener(&quot;click&quot;, function()&#123; alert(&quot;Hello World!&quot;); &#125;);你可以使用函数名，来引用外部函数: 1234element.addEventListener(&quot;click&quot;, myFunction);function myFunction() &#123;alert (&quot;Hello World!&quot;);&#125; c 、向同一个元素中添加多个事件句柄addEventListener() 方法允许向同一个元素添加多个事件，且不会覆盖已存在的事件实例： 12element.addEventListener(&quot;click&quot;, myFunction);element.addEventListener(&quot;click&quot;, mySecondFunction); 你可以向同个元素添加不同类型的事件：实例： 123element.addEventListener(&quot;mouseover&quot;, myFunction);element.addEventListener(&quot;click&quot;, mySecondFunction);element.addEventListener(&quot;mouseout&quot;, myThirdFunction); d 、向 Window 对象添加事件句柄addEventListener() 方法允许你在 HTML DOM 对象添加事件监听， HTMLDOM对象 如： HTML 元素, HTML 文档, window 对象。或者其他支出的事件对象如:xmlHttpRequest 对象。 e 、传递参数当传递参数值时，使用”匿名函数”调用带参数的函数实例：element.addEventListener(&quot;click&quot;, function()&#123; myFunction(p1, p2); &#125;); f 、事件冒泡或事件捕获？事件传递有两种方式：冒泡与捕获。事件传递定义了元素事件触发的顺序。 如果你将 &lt;p&gt; 元素插入到 &lt;div&gt;元素中，用户点击 &lt;p&gt; 元素, 哪个元素的 “click” 事件先被触发呢？在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即： 元素的点击事件先触发，然后会触发 元素的点击事件。在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即：&lt;div&gt; 元素的点击事件先触发 ，然后再触发 &lt;p&gt; 元素的点击事件。addEventListener() 方法可以指定 “useCapture” 参数来设置传递类型：addEventListener(event, function, useCapture);默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。实例：document.getElementById(&quot;myDiv&quot;).addEventListener(&quot;click&quot;, myFunction, true);g 、removeEventListener() 方法removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄:实例：element.removeEventListener(&quot;mousemove&quot;, myFunction);h 、使用 addEventListener 的时候，又无法使用，是因为: 1234567x = document.getElementById(&quot;myBt&quot;);// x ---&gt; null可以这么写:window.onload = function () &#123;var x = document.getElementById(&quot;myBt&quot;);x.addEventListener(&quot;click&quot;, myFunction);&#125;; 6、JavaScript HTML DOM 元素 (节点)a、创建新的 HTML 元素 (节点) - appendChild()要创建新的 HTML 元素(节点)需要先创建一个元素，然后在已存在的元素中添加它，它用于添加新元素到尾部。实例： 1234567891011&lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;这是另外一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para = document.createElement(&quot;p&quot;); //创建p元素var node = document.createTextNode(&quot;这是一个新的段落。&quot;);para.appendChild(node);var element = document.getElementById(&quot;div1&quot;);element.appendChild(para);&lt;/script&gt; 123456789101112实例：在文档中添加一个p标签的方法function c()&#123; var elem=document.createElement(&quot;p&quot;); /*method1： var text=document.createTextNode(&quot;woshi p&quot;); elem.appendChild(text); */ elem.textContent=&quot;woshi p&quot;; //method2 var body=document.getElementsByTagName(&quot;body&quot;)[0]; //后面必须得写为[0]，有点疑惑 body.appendChild(elem); &#125; b、创建新的 HTML 元素 (节点) - insertBefore()如果我们需要将新元素添加到开始位置，可以使用 insertBefore() 方法:例子： 123456789101112&lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;这是另外一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para = document.createElement(&quot;p&quot;);var node = document.createTextNode(&quot;这是一个新的段落。&quot;);para.appendChild(node);var element = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);element.insertBefore(para, child);&lt;/script&gt; e 、移除已存在的元素要移除一个元素，你需要知道该元素的父元素。实例: 123456789&lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;这是另外一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var parent = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);parent.removeChild(child);&lt;/script&gt; 注意：如果能够在不引用父元素的情况下删除某个元素，就太好了。不过很遗憾。DOM 需要清楚您需要删除的元素，以及它的父元素。f 、替换 HTML 元素 - replaceChild()我们可以使用 replaceChild() 方法来替换 HTML DOM 中的元素。实例： 123456789101112&lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;这是一个段落。&lt;/p&gt;&lt;p id=&quot;p2&quot;&gt;这是另外一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para = document.createElement(&quot;p&quot;);var node = document.createTextNode(&quot;这是一个新的段落。&quot;);para.appendChild(node);var parent = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);parent.replaceChild(para, child);&lt;/script&gt; 7、JavaScript HTML DOM 集合(Collection)a 、HTMLCollection 对象getElementsByTagName() 方法返回 HTMLCollection 对象。HTMLCollection 对象类似包含 HTML 元素的一个数组。实例var x = document.getElementsByTagName(&quot;p&quot;);集合中的元素可以通过索引(以 0 为起始位置)来访问。访问第二个 元素可以是以下代码:y &#x3D; x[1];b 、HTMLCollection 对象 length 属性HTMLCollection 对象的 length 属性定义了集合中元素的数量。实例 12var myCollection = document.getElementsByTagName(&quot;p&quot;);document.getElementById(&quot;demo&quot;).innerHTML = myCollection.length; 注意HTMLCollection 不是一个数组！HTMLCollection 看起来可能是一个数组，但其实不是。你可以像数组一样，使用索引来获取元素。HTMLCollection 无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。8、JavaScript HTML DOM 节点列表a 、NodeList 对象是一个从文档中获取的节点列表 (集合) 。NodeList 对象类似 HTMLCollection 对象。所有浏览器的 childNodes 属性返回的是 NodeList 对象。大部分浏览器的 querySelectorAll() 返回 NodeList 对象。实例：var myNodeList = document.querySelectorAll(&quot;p&quot;);NodeList 中的元素可以通过索引(以 0 为起始位置)来访问。访问第二个 元素可以是以下代码:y &#x3D; myNodeList[1];b 、NodeList 对象 length 属性NodeList 对象 length 属性定义了节点列表中元素的数量。实例 12var myNodelist = document.querySelectorAll(&quot;p&quot;);document.getElementById(&quot;demo&quot;).innerHTML = myNodelist.length; 实例修改节点列表中所有 元素的背景颜色: 12345var myNodelist = document.querySelectorAll(&quot;p&quot;);var i;for (i = 0; i &lt; myNodelist.length; i++) &#123;myNodelist[i].style.backgroundColor = &quot;red&quot;;&#125; c 、注意节点列表不是一个数组！节点列表看起来可能是一个数组，但其实不是。你可以像数组一样，使用索引来获取元素。节点列表无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。f 、HTMLCollection 与 NodeList 的区别HTMLCollection 是 HTML 元素的集合。NodeList 是一个文档节点的集合。NodeList 与 HTMLCollection 有很多类似的地方。NodeList 与 HTMLCollection 都与数组对象有点类似，可以使用索引 (0, 1, 2, 3, 4,…) 来获取元素。NodeList 与 HTMLCollection 都有 length 属性。HTMLCollection 元素可以通过 name，id 或索引来获取。NodeList 只能通过索引来获取。只有 NodeList 对象有包含属性节点和文本节点。g 、另一个注意点 12pcoll=document.querySelectorAll(&quot;p&quot;) plist=document.getElementsByTagName(&quot;p&quot;) 以上 pcoll 返回的就是固定的值。而获取 plist 后, 若 html 页面有变化且刚好添加或移除了 p 标签,此时plist也会跟着变。 tips**document.body 的问题 **首先，先和你说一个标准的问题，请不要用document.body和document.all，否则除IE外的浏览器不认帐！ 123456789101112131415标准的元素获取方法只有以下三个：document.getElementById(元素的ID);document.getElemetsByName(元素的name);在IE下只能获取到&lt;input /&gt;document.getElemetsByTagName(元素的标签名);比如document.body最好是写成document.getElementsByTagName(&quot;body&quot;)[0];然后回答一下问题&lt;h1&gt;hello!&lt;/h1&gt;它的innerHTML和innerText都是hello!&lt;h1&gt;hello!&lt;b&gt;asdfasdf&lt;/b&gt;&lt;/h1&gt;它的innerHTML是hello!&lt;b&gt;asdfasdf&lt;/b&gt;它的innerText是hello!asdfasdf","categories":[{"name":"前端","slug":"前端","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"DOM","slug":"DOM","permalink":"https://zouyunkai.github.io/myblog/tags/DOM/"},{"name":"js","slug":"js","permalink":"https://zouyunkai.github.io/myblog/tags/js/"}],"author":"aoyuehan"},{"title":"八皇后问题","slug":"八皇后问题","date":"2019-07-29T05:17:37.000Z","updated":"2022-02-26T04:31:40.712Z","comments":true,"path":"2019/07/29/八皇后问题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/29/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/","excerpt":"","text":"https://blog.csdn.net/qq_41620518/article/details/81180081https://blog.csdn.net/summer_dew/article/details/83922473https://blog.csdn.net/a19990412/article/details/83304430","categories":[],"tags":[],"author":"aoyuehan"},{"title":"DFS and BFS","slug":"DFS-and-BFS","date":"2019-07-29T02:45:00.000Z","updated":"2022-02-26T03:52:51.259Z","comments":true,"path":"2019/07/29/DFS-and-BFS/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/29/DFS-and-BFS/","excerpt":"","text":"深度优先搜索算法深度优先搜索算法（英语：Depth-First-Search，简称DFS）是一种用于遍历或搜索树或图的算法。 * 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点，就像是走迷宫，有一个分叉路，走一条路发现不通，回去，再走另一条。整个进程反复进行直到所有节点都被访问为止。* 属于盲目搜索,最糟糕的情况算法时间复杂度为O(!n)。 基本模板： 1234567891011121314151617181920int check(参数)&#123; if(满足条件) return 1; return 0;&#125;void dfs(int step)&#123; 判断边界 &#123; 相应操作 &#125; 尝试每一种可能 &#123; 满足check条件 标记 继续下一步dfs(step+1) 恢复初始状态（用来回溯） &#125;&#125; DFS实现全排列 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//全排列问题#include&lt;stdio.h&gt;#include&lt;string.h&gt; int n;char a[15];char re[15];int vis[15];//假设有n个字符要排列，把他们依次放到n个箱子中//先要检查箱子是否为空，手中还有什么字符，把他们放进并标记。//放完一次要恢复初始状态，当到n+1个箱子时，一次排列已经结束void dfs(int step)&#123; int i; if(step==n+1)//判断边界,因为a[0]没有用，所以判断边界的条件是n+1 &#123; for(i=1;i&lt;=n;i++) printf(&quot;%c&quot;,re[i]); printf(&quot;\\n&quot;); return ; &#125; for(i=1;i&lt;=n;i++)//遍历每一种情况 &#123; if(vis[i]==0)//check满足 &#123; re[step]=a[i]; vis[i]=1;//标记 dfs(step+1);//继续搜索 vis[i]=0;//恢复初始状态，用来回溯 &#125; &#125; return ;&#125; int main(void)&#123; int T; scanf(&quot;%d&quot;,&amp;T); getchar(); //消去一个回车 while(T--) &#123; memset(a,0,sizeof(a)); memset(vis,0,sizeof(vis)); //对存数据的数组分别初始化 scanf(&quot;%s&quot;,a+1); //这样写就要让数组从下标为1的地方开始遍历 n=strlen(a+1); dfs(1); //从第一个箱子开始 &#125; return 0; &#125; P1036 洛谷新手村关卡6-2 选数 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;int n,k;int a[25];int vis[25];int ans;bool judge(int sum)&#123; if(sum==1)return 0; for(int i=2;i*i&lt;=sum;i++) if(sum%i==0)return 0; return 1;&#125;void dfs(int id,int sum,int cnt)&#123; if(cnt==k) &#123; if(judge(sum))ans++; return; &#125; for(int i=1;i&lt;=n;i++) &#123; if(vis[i])continue; //标记了就不要 往下走了 if(i&lt;=id)continue; //这样做是为了不让回溯到根节点外 sum+=a[i]; cnt++; vis[i]=1; dfs(i,sum,cnt); sum-=a[i]; //下面这三不就是用来回溯的 cnt--; vis[i]=0; &#125;&#125;int main()&#123; //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); //可以这样从文件中读取数据到控制台，没问题吧？？ scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); dfs(0,0,0); //从下标为0的地方开始遍历 printf(&quot;%d\\n&quot;,ans); return 0;&#125; 油田问题问题：GeoSurvComp地质调查公司负责探测地下石油储藏。 GeoSurvComp现在在一块矩形区域探测石油，并把这个大区域分成了很多小块。他们通过专业设备，来分析每个小块中是否蕴藏石油。如果这些蕴藏石油的小方格相邻，那么他们被认为是同一油藏的一部分。在这块矩形区域，可能有很多油藏。你的任务是确定有多少不同的油藏。input: 输入可能有多个矩形区域（即可能有多组测试）。每个矩形区域的起始行包含m和n，表示行和列的数量，1&lt;&#x3D;n,m&lt;&#x3D;100，如果m &#x3D;0表示输入的结束，接下来是n行，每行m个字符。每个字符对应一个小方格，并且要么是’*’，代表没有油，要么是’@’，表示有油。output: 对于每一个矩形区域，输出油藏的数量。两个小方格是相邻的，当且仅当他们水平或者垂直或者对角线相邻（即8个方向）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt; char a[105][105];int n,m,result;int dir[8][2]=&#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;,&#123;1,1&#125;,&#123;-1,-1&#125;,&#123;1,-1&#125;,&#123;-1,1&#125;&#125;;//表示8个方向 int check(int x,int y)//检查是否有油田&#123; if(x&gt;=0&amp;&amp;x&lt;m&amp;&amp;y&gt;=0&amp;&amp;y&lt;n&amp;&amp;a[x][y]==&#x27;@&#x27;) //还要判断x，y的边界，要不然的话x，y的值不符合要求这也能满足有油田，这样与题目不符，所以要想到这个问题，即认为所有的数据都是非法的 return 1; return 0;&#125; int dfs(int x, int y)&#123; int i,xx,yy; if(check(x,y)) &#123; a[x][y]=&#x27;.&#x27;; //统计之后就可以把该油田标记，且不用恢复（要不会重复）， //也可以用一个数组来存每个点的访问情况，但是感觉没必要，浪费空间 for(i=0;i&lt;8;i++) &#123; xx=x+dir[i][0]; yy=y+dir[i][1]; //比如第一次就是x=x+1，y=y；就是和这个点的右边进行比较 dfs(xx,yy);//依次检查8个方向 &#125; return 1; &#125; return 0;&#125; int main(void)&#123; int i,j; while(scanf(&quot;%d %d&quot;,&amp;m,&amp;n)==2) &#123; if(m==0&amp;&amp;n==0) break; result = 0; memset(a,0,sizeof(a)); for(i=0;i&lt;m;i++) //共有m行 scanf(&quot;%s&quot;,a[i]); //这样写的意思是给二维数组的每个一维数组赋值 for(i=0;i&lt;m;i++) //在每一个点都搜索一次 &#123; for(j=0;j&lt;n;j++) &#123; if(dfs(i,j))//找到油田就可以将结果加1 result++; &#125; &#125; printf(&quot;%d\\n&quot;,result); &#125; return 0;&#125; 棋盘问题 问题：在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。input： 输入含有多组测试数据。 每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个nn的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;&#x3D; 8 , k &lt;&#x3D; n 当为-1 -1时表示输入结束。 随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。output ：对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt; int n, k, ans;char str[10][10];int vis[100]; void dfs(int r, int k)&#123; if(k==0) //判断边界，此时棋子已经放完 &#123; ans++; return; &#125; for(int i=r; i&lt;n; i++) //每次都从放过棋子下一行开始搜索，保证不重复 &#123; for(int j=0; j&lt;n; j++) &#123; //循环保证行不重复，check保证列不重复 if(str[i][j]==&#x27;.&#x27; || vis[j]==1) continue; //不满足条件直接跳过 vis[j] = 1; //标记 dfs(i+1, k-1); //继续下一次标记 vis[j] = 0; //恢复初始状态 &#125; &#125;&#125; int main(void)&#123; while(1) &#123; scanf(&quot;%d %d&quot;, &amp;n, &amp;k); getchar(); if(n==-1 &amp;&amp; k==-1) break; memset(str, &#x27;\\0&#x27;, sizeof(str)); memset(vis, 0, sizeof(vis)); ans = 0; for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;n; j++) str[i][j] = getchar(); getchar(); &#125; dfs(0, k); //从第0行开始放，此时手中还剩k个棋子 printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125; DFS总结 总结一下，用递归法来实现DFS，比较好理解，就一直往下找，知道走不通后在回来尝试其它的地方。一个DFS一般要判断边界，check来判断是否符合相应条件，vis或者book来记录是否已经被用过，递归进行下一步操作。有的时候我们要将标记过的点恢复原来的状态，有时候则不必要恢复(油田问题)，要结合具体的问题来分析。 恢复标记相当于回溯的思想。 回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 优化问题：比如农夫和牛这个案例中，可以记录可以通过的路径的长度，如果在找到比这长度还长并且没有到终点的路径就不用向下走了。 广度优先算法 步骤：首先给节点分层，其次就是搜索过程（即节点的扩展过程，扩展时，不能扩展已经走过的节点，所以要判重），一层一层的往外扩展（走一步能到达的点，走两步能达到的点）。其可以确保找到最优解，但是因扩展出来结果比较多（深度优先搜索，只要保存一条路就可以了，用栈就好），且多数节点都需要保存，因此需要的存储空间较大。用队列存节点 1、Catch That Cow （poj3278）DescriptionFarmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting. Walking: FJ can move from any point X to the points X - 1 or X + 1 in a single minute Teleporting: FJ can move from any point X to the point 2 × X in a single minute.If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it?InputLine 1: Two space-separated integers: N and KOutputLine 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow.Sample Input5 17Sample Output4 算法实现流程图： 1234567891011121314151617181920212223242526272829303132333435363738394041424344方法一：#include &lt;iostream&gt;#include &lt;cstring&gt;#include&lt;queue&gt;using namespace std;int N,K;const int MAXN=100000;int visited[MAXN+10];//判重标记，当其值为1的时候就说明已经扩展过了 struct Step&#123; int x; //农夫的位置 int steps; //农夫走过的步数 Step(int xx,int s):x(xx),steps(s)&#123;&#125;//这一步要是这么写，接下来就可以Step(N,0)这样赋值，否则就要Step.x=N;Step.steps=0;这样来赋值，比较麻烦&#125;;queue&lt;Step&gt; q; //基于结构体的队列，这个就是open表int main()&#123; cin&gt;&gt;N&gt;&gt;K; memset(visited,0,sizeof(visited)); q.push(Step(N,0)); visited[N]=1; while(!q.empty())&#123; Step s=q.front(); if(s.x==K)&#123; //找到目标 cout&lt;&lt;s.steps&lt;&lt;endl; return 0; &#125; else&#123; if(s.x-1&gt;=0&amp;&amp;!visited[s.x-1])&#123; q.push(Step(s.x-1,s.steps+1)); visited[s.x-1]=1; &#125; if(s.x+1&lt;=MAXN&amp;&amp;!visited[s.x+1])&#123; q.push(Step(s.x+1,s.steps+1)); visited[s.x+1]=1; &#125; if(s.x*2&lt;=MAXN&amp;&amp;!visited[s.x*2])&#123; q.push(Step(s.x*2,s.steps+1)); visited[s.x*2]=1; &#125; q.pop(); &#125; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839方法二：c++STL、BFS#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define N 100010int step[N],vis[N];queue&lt;int&gt;q;int bfs(int n,int k)&#123; int now,next; step[n]=0; vis[n]=1; //vis数组值为1则为走过了 q.push(n); while(!q.empty())&#123; now=q.front(); for(int i=0;i&lt;3;i++)&#123; if(i==0) next=now-1; else if(i==1) next=now+1; else if(i==2) next=now*2; if(next&lt;0||next&gt;N) continue; if(!vis[next])&#123; vis[next]=1; q.push(next); step[next]=step[now]+1; //这一句是什么意思 &#125; if(next==k) return step[next]; &#125; q.pop(); //扩展过了就让他出队 &#125;&#125;int main()&#123; int n,k; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); if(n&gt;=k) printf(&quot;%d\\n&quot;,n-k); else printf(&quot;%d\\n&quot;,bfs(n,k)); return 0;&#125; 2、迷宫问题 （poj3984） 另外要注意状态的变化： 初始状态，目标状态 比如：求钥匙的鸣人一题中，他的状态就有三个要素：（r,c,keys）即鸣人的行，列，已经拥有的钥匙种数 目标状态（x，y，K）（x，y）是佐助呆的地方 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 这一题不能用queue来做，因为必须pop（）在队列头部删除元素，但我们还必须要得到路径，所以要模拟一个基于结构体类型的数组的队列头和尾，如果front=rear就说明队列为空了#include&lt;iostream&gt;using namespace std;#define QSize 50int a[5][5];//把迷宫想象成x轴，y轴//int dx[4]=&#123;-1,1,0,0&#125;; //x轴方向上的变化//int dy[4]=&#123;0,0,-1,1&#125;; //y轴方向上的变化int dis[4][2]=&#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;; //定义4个方向struct Node&#123; int x,y,pre;&#125;queue[QSize]; //设置一个50个格子的队列int front=0;int rear=0; //设置队头和队尾，头指针指向头元素,尾指针指向队尾的下一个位置int visit[5][5]; //记录是否访问过的数组 //广度优先遍历void bfs(int beginX,int beginY,int endX,int endY)&#123; queue[0].x=beginX,queue[0].y=beginY,queue[0].pre=-1; //将初始结点[0,0]压入队列 rear=rear+1; visit[beginX][beginY]=1; while(front&lt;rear)&#123; //如果队列不为空 for(int i=0;i&lt;4;i++)&#123; //4个方向搜索可达的方向 int newx=queue[front].x+dis[i][0]; int newy=queue[front].y+dis[i][1]; if(newx&lt;0||newx&gt;5||newy&lt;0||newy&gt;5||a[newx][newy]==1||visit[newx][newy]==1) //是否在迷宫内，是否撞墙，是否已走过 continue; //进队 queue[rear].x=newx; queue[rear].y=newy; queue[rear].pre=front; rear++; visit[newx][newy]=1; //给走过的位置做标记 if(newx==endX&amp;&amp;newy==endY)&#123; return; &#125; &#125; front++; //出队 &#125;&#125; void print(Node now)&#123; if(now.pre==-1) cout&lt;&lt;&quot;(&quot;&lt;&lt;now.x&lt;&lt;&quot;, &quot;&lt;&lt;now.y&lt;&lt;&quot;)&quot;&lt;&lt;endl; else&#123; print(queue[now.pre]); cout&lt;&lt;&quot;(&quot;&lt;&lt;now.x&lt;&lt;&quot;, &quot;&lt;&lt;now.y&lt;&lt;&quot;)&quot;&lt;&lt;endl; &#125;&#125; int main()&#123; //初始化迷宫 for(int i=0;i&lt;5;i++)&#123; for(int j=0;j&lt;5;j++)&#123; cin&gt;&gt;a[i][j]; &#125; &#125; bfs(0,0,4,4); print(queue[rear-1]); return 0;&#125; 两者的区别和联系 DFS容易TLE（运行超时），BFS容易MLE（运行内存超空间），有时DFS还面临着递归层数过多爆栈的风险","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"https://zouyunkai.github.io/myblog/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://zouyunkai.github.io/myblog/tags/BFS/"},{"name":"图","slug":"图","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%9B%BE/"},{"name":"算法","slug":"算法","permalink":"https://zouyunkai.github.io/myblog/tags/%E7%AE%97%E6%B3%95/"}],"author":"aoyuehan"},{"title":"洛谷递归和boos（新手村）","slug":"洛谷递归和boos（新手村）","date":"2019-07-28T23:49:00.000Z","updated":"2022-02-26T03:52:51.782Z","comments":true,"path":"2019/07/29/洛谷递归和boos（新手村）/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/29/%E6%B4%9B%E8%B0%B7%E9%80%92%E5%BD%92%E5%92%8Cboos%EF%BC%88%E6%96%B0%E6%89%8B%E6%9D%91%EF%BC%89/","excerpt":"","text":"关卡6-1先输入一个自然数n(n≤1000),然后对此自然数按照如下方法进行处理:在它的左边加上一个自然数,但该自然数不能超过原数的一半;加上数后,继续按此规则进行处理,直到不能再加自然数为止.输出这样的数有几个 递归的方式求本问题 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;int n;int digui[1001];int main() &#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= i / 2; j++) &#123; digui[i] += digui[j]; &#125; digui[i]++; &#125; printf(&quot;%d&quot;, digui[n]); return 0;&#125;方法二：#include&lt;iostream&gt;using namespace std;int s=1;void function(int &amp;a)&#123; if(a!=0) &#123; for(int i=1;i&lt;=a;i++) &#123; s++; int b=i/2; function(b); &#125; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; n=n/2; function(n); cout&lt;&lt;s; return 0;&#125; 关卡6-2P1036 选数 1 BOSS战-入门综合练习1 关卡7_1P1478 陶陶摘苹果（升级版） 题目描述又是一年秋季时，陶陶家的苹果树结了n个果子。陶陶又跑去摘苹果，这次她有一个a公分的椅子。当他手够不着时，他会站到椅子上再试试。这次与NOIp2005普及组第一题不同的是：陶陶之前搬凳子，力气只剩下s了。当然，每次摘苹果时都要用一定的力气。陶陶想知道在s&lt;0之前最多能摘到多少个苹果。现在已知n个苹果到达地上的高度xi，椅子的高度a，陶陶手伸直的最大长度b，陶陶所剩的力气s，陶陶摘一个苹果需要的力气yi，求陶陶最多能摘到多少个苹果。**输入格式 **第1行：两个数 苹果数n，力气s。第2行：两个数 椅子的高度a，陶陶手伸直的最大长度b。第3行~第3+n-1行：每行两个数 苹果高度xi，摘这个苹果需要的力气yi。输出格式只有一个整数，表示陶陶最多能摘到的苹果数。**输入输出样例 **输入8 1520 130120 3150 2110 7180 150 8200 0140 3120 2输出4 解答： 1.搜索的基本思路就是枚举，枚举可能出现的各种情况，然后从中找到满足条件的结果。对于这个题，朴素的搜索方法就是DFS搜索每个苹果，每个苹果可分支出两个搜索子树：摘这个苹果或者不摘这个苹果。比如这样的一棵搜索树：我们使用递归函数，从第一个苹果开始递归访问，如果这个苹果可以取（高度够得到或者当前剩下的体力还够用），则递归搜索取这个苹果的子树。然后无论能不能取都递归搜索不取这个苹果的子树。 **当搜索到叶子节点也就是第n+1个苹果（这个苹果并不存在）的时候，返回0。对于其他苹果节点，返回两个搜索子树返回值中的较大值（只有一个则返回那个值）。** 那么函数的返回值是什么意思呢？返回值表示这个苹果的搜索子树里的最大能取的苹果数量。 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int n,s,a,b,ans;int xi[5005],yi[5005];int dfs(int num,int rest)&#123; if(num&gt;n) return 0;//如果到了第n+1个苹果,就说明DFS递归到底了 int maxn=0; if(xi[num]&lt;=a+b&amp;&amp;rest&gt;=yi[num])&#123; maxn=dfs(num+1,rest-yi[num])+1&gt;dfs(num+1,rest)?dfs(num+1,rest-yi[num])+1:dfs(num+1,rest);//dfs()+1表示取当前搜索到的苹果，因此摘到苹果的总数+1 &#125;//返回两个搜索子树里最大值的较大值 return maxn;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;xi[i]&gt;&gt;yi[i]; &#125; cout&lt;&lt;dfs(1,s);//从第一个苹果开始递归求解 return 0;&#125; 但是这个代码如果你提交的话，就会完美的TLE掉。我们看一下这个题的数据范围，n最大有5000个，每个苹果有取或不取两个选择，那么搜索完所有的子树差不多就是2^5000次运算。而计算机一秒只能运算大约10^7次左右，当然会TLE了。这种最朴素的搜索算法时间复杂度差不多是O(2^n)的……几乎绝大部分的题目的较大的数据都过不去……那么我们有什么好办法吗？确实存在方法——剪枝和记忆化搜索。 1_1 **所谓剪枝，就是将对答案没有贡献的搜索子树剪去，从而减少搜索次数，提高运行速度的一种搜索优化方法。剪枝对于DFS的优化效果比较明显**，上面一版代码的运行时间跑到了3500多毫秒，但是优化后113毫秒就跑完了（虽然这样还不是最快）。那这90%左右的时间是怎么优化掉的呢？ ``maxn=dfs(num+1,rest-yi[num])+1&gt;dfs(num+1,rest)?dfs(num+1,rest-yi[num])+1:dfs(num+1,rest);`` 我们要知道，如果想得到一个函数的返回值，首先就要运行一遍这个函数。复杂度如此高的函数在比较和调用值的时候分别运算了一次，就相当于给搜索树凭空加了好多无用的搜索子树。那么我们能不能用两个个变量来存储dfs(num+1,rest−yi[num])和dfs(num+1,rest)的值呢？这样经过测试可以节省大约30%的时间。代码如下： 123456789101112131415161718192021 #include&lt;iostream&gt;using namespace std;int n,s,a,b,ans;int xi[5005],yi[5005];int dfs(int num,int rest)&#123; if(num&gt;n) return 0; int maxn=dfs(num+1,rest); if(xi[num]&lt;=a+b&amp;&amp;rest&gt;=yi[num])&#123; int t=dfs(num+1,rest-yi[num])+1; maxn=t&gt;maxn?t:maxn; &#125; return maxn;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;xi[i]&gt;&gt;yi[i]; &#125; cout&lt;&lt;dfs(1,s); return 0;&#125; 1_2 **所谓记忆化搜索，就是将每个不同参量的函数的返回值存在一个数组里，当再次调用这个函数的时候，就不用再次费时间计算这个函数的返回值了。**这里我们还是结合代码讲一下： 12345678910111213141516171819202122232425 #include&lt;iostream&gt;using namespace std;int n,s,a,b,ans;int xi[5005],yi[5005];bool visit[5005][1001];//存储是否访问过调用这两个参量的函数int mem[5005][1001];//存储调用这两个参量的函数的返回值int dfs(int num,int rest)&#123; if(num&gt;n) return 0; if(visit[num][rest]) return mem[num][rest];//如果调用这两个参量的函数已经被访问过，那么直接返回之前存储的值即可 visit[num][rest]=true; int maxn=dfs(num+1,rest); if(xi[num]&lt;=a+b&amp;&amp;rest&gt;=yi[num])&#123; int t=dfs(num+1,rest-yi[num])+1; maxn=t&gt;maxn?t:maxn; &#125; return mem[num][rest]=maxn;//返回值的同时存储这次运算的返回值&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;xi[i]&gt;&gt;yi[i]; &#125; cout&lt;&lt;dfs(1,s); return 0;&#125; 1_3 我们不难发现，对于那些不能够采到的苹果，我们搜索它们只会白白浪费时间，那我们就可以将这些苹果排除掉，这样就使得搜索子树被缩小了。这就是剪枝。 我们怎么才能避免搜索到这些苹果被搜索到呢？我们可以将所有的苹果按照高度从矮到高排序（排序的知识在第一弹里讲过，不会的同学可以去看一下）。在这种情况下当我们搜索到一个够不到的苹果时，无论我们再往下搜索多久，我们都不会再搜索到可以够得到的苹果了。这时候我们就可以 return 0 了。代码如下： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;int n,s,a,b,ans;bool visit[5005][1001];int mem[5005][1001];struct apple&#123; int xi,yi;&#125;ap[5005];int dfs(int num,int rest)&#123; if(num&gt;n||ap[num].xi&gt;a+b) return 0;//当搜索到够不到的苹果后，就不再继续向下搜索了 if(visit[num][rest]) return mem[num][rest]; visit[num][rest]=true; int maxn=dfs(num+1,rest); if(ap[num].xi&lt;=a+b&amp;&amp;rest&gt;=ap[num].yi)&#123; int t=dfs(num+1,rest-ap[num].yi)+1; maxn=t&gt;maxn?t:maxn; &#125; return mem[num][rest]=maxn;&#125;int cmp(apple x,apple y)&#123; return x.xi&lt;y.xi;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;ap[i].xi&gt;&gt;ap[i].yi; &#125; sort(ap+1,ap+n+1,cmp);//按照高度从矮到高排序 cout&lt;&lt;dfs(1,s); return 0;&#125; //这种方法比起剪枝前，又快了大约15%。 1_4 动态规划——背包我们做题不能只靠搜索，世界上解决这类问题也不是只有搜索这一种算法，要不然还要OI干吗？ 于是，有一些特殊的搜索问题就被优化了，并且形成了一类新的算法：动态规划。动态规划的种类很多：有线性动态规划、多维动态规划、区间动态规划等。我们这里先只讲一类特殊的多维动态规划：背包问题。 动态规划最核心的思想就是状态转移。即任何状态的解都可以建立在已知状态的基础上快速求出。这是不是和记忆化搜索有些类似呢？事实上动态规划和记忆化搜索真的差不多，记忆化搜索需要一个数组来存储不同参量的递归函数的返回值，动态规划需要一个状态转移数组来存储已求解的状态的解。而动态规划相比搜索的高明之处就在于，动态规划可以将搜索有向化，而不是漫无目的地遍历搜索每一个可能的状态，相当于自动剪枝。 我们前面讲过，动态规划实质上是对搜索的优化，之前我们搜索，是从前向后递归搜索，根据之后状态返回的值来决定向前返回什么值。而动态规划用的方法恰恰相反，是从前向后递推搜索，根据之前状态传递来的值决定向后传递什么值。这就是动态规划省时的主要原因。 那么接下来我们来讲背包问题。背包问题解决的一类问题是：对于空间有限的背包，和一些有着已知体积与价值的物品，优化取物品策略使得背包里物品的价值总和最大。对于这个题，总力气就是背包的空间，摘每个苹果所需要的力气就是苹果占背包的空间，每个苹果的价值都是1，我们只需让背包里的苹果价值和最大即可。 上面讲到，动态规划的核心是状态的转移，与此相对应的，每类动态规划问题也都有它的状态转移方程，比如背包问题，它的状态转移方程就是：dp[i][j]&#x3D;max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]) 。这之中，dp[i][j] 表示对于空间大小为j的背包考虑前i个物品所能得到的最大总价值， v[i]表示第i个物品的占空间大小， w[i]表示第i个物品的价值。 不过讲了这么多，大家估计也听烦了，我们先上代码，然后再根据代码讲一下背包问题的解法。代码如下： 123456789101112131415161718#include&lt;iostream&gt; using namespace std;int dp[5005][1001];int xi[5005],yi[5005],n,s,a,b;int main()&#123; cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;xi[i]&gt;&gt;yi[i]; &#125; for(int i=1;i&lt;=n;i++)//枚举考虑每一个苹果 for(int j=0;j&lt;=s;j++)&#123;//枚举背包大小 dp[i][j]=dp[i-1][j];//不能取就直接转移考虑之前苹果的最大值 if(xi[i]&lt;=a+b&amp;&amp;j&gt;=yi[i])//如果能够取 dp[i][j]=dp[i-1][j-yi[i]]+1&gt;dp[i][j]?dp[i-1][j-yi[i]]+1:dp[i][j];//这个就是动态转移方程。max函数运行太慢，我们这里选择三目运算符取较大值 &#125; cout&lt;&lt;dp[n][s];//因为是从前向后递推，因此接收最终答案的位置也从最前面转到了最后面 return 0;&#125; 为什么背包问题的状态转移方程是dp[i][j]&#x3D;max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]) 呢？我们还是回到之前讲过的知识点：动态规划实质上是对搜索的优化。回想一下我们当时是怎么搜索的？对于搜索到的每个苹果，都有两种选择：取或者不取。不取则对应返回不取这个苹果后剩下的苹果最多能取的个数，取则对应返回取这个苹果后剩下的苹果最多能够取的个数加1。那么我们该如何将这个转化为递推关系呢？ 首先我们考虑，当我们取了一个苹果，就相当于把背包里容纳这个苹果的空间分给了这个苹果，剩下的空间再由这个苹果之前（为什么是之前等一下会讲到）的苹果来分。那么不就相当于把背包缩小后再考虑前面的苹果了吗？那么不取就是背包大小不变，由之前的苹果来分这个背包的空间。基于这样的思想，我们就可以比较在当前背包大小下，是取这个苹果更值还是不取这个苹果更值。而缩小背包考虑之前的苹果的工作，在考虑上一个苹果时就已经求解过了。这样就可以不断地考虑一个又一个的苹果，不断地递推下去，最终得到最终的结果。 那么实现思路就是这样的：首先用一个循环枚举每个苹果，然后在考虑每个苹果时，再用一个循环枚举背包大小（为什么要枚举背包大小？——比较最大值时不是要缩小背包吗？这里就是为下一步递推比较做准备），对于每个大小的背包，如果能够取这个苹果（够得着而且当前背包大小装得下这个苹果），就比较取这个苹果和不取这个苹果哪个更值；如果不能取（够不到或者当前背包大小装不下这个苹果），就将这个大小的背包装之前的苹果的最大值传递给这个dp值。这样就得到了上面的代码。现在再回去看看之前的代码，是不是就明白了呢？ 1_5 贪心算法有的同学可能会注意到，我们给的状态转移方程里有一个变量w[i] ，但是在这个题里我们没有用w[i] ，而是直接用1表示，让人对照起来看难免有些别扭。如果你觉得别扭的话，那我要夸奖你，因为一眼就看出了这个问题其实动态规划并不是最优解。 我们最开始用无优化搜索跑了3500多毫秒才跑完，之后记忆化搜索直接提升到130多毫秒，然后剪枝又优化到110多毫秒，之后动态规划直接60多毫秒解决问题。那你以为这就是这个题的极限通过时间了吗？接下来介绍的贪心算法15毫秒就通过了这个题。 贪心算法其实比动态规划算法要低级不少，因为它适用面实在是有点窄。但是对于某些问题，贪心法却能跑出比动态规划快不少的成绩。 那么为什么这个题可以用贪心算法解决呢？我们看一下，在这个题里，所有苹果费力气也就是占背包空间不同，但是价值都是1。背包问题主要是为了解决拿得多却不一定价值最大，拿价值大的却可能装不下其他有价值的东西而使人陷入两难才被发明的算法。对于价值相同体积却不同的物品，我们每次只取体积最小的，不就能在取得当前价值的情况下，最大化剩余空间，从而拿更多苹果了吗？ 讲到这里，大家可能就有点明白贪心算法的适用范围了。我之所以先引例，就是因为下面这段话实在有点晦涩难懂： 百度百科定义：贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 我语言功底有限，就不再用我贫瘠的语言来给大家详细解释这段话了。总之，这个题，用贪心确实是最优解。这点从时间复杂度上就能看出来： 搜索的基础复杂度（不加优化）是O(k^n) （k指每个节点的选择分支的个数）的，动态规划的基础复杂度是O(nm) （n,m分别指的是物品数量和背包大小），而贪心却只有O(n) 。搜索适用范围最广，同样地时间复杂度也最高；动态规划适用范围有所缩小，但是时间复杂度也相应地提高了；贪心算法适用范围极窄，但却拥有极优的时间复杂度。万事万物都是这样，既有长处，又有短处，长短互补，向来如此。 咳咳……扯远了。下面放上贪心算法的代码。这里就不加注释了，大家借此机会锻炼一下自己的读代码能力吧。 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;int n,s,a,b,x_,y_,can,rest,ans;struct apple&#123; int xi,yi;&#125;ap[50005];int cmp(apple x,apple y)&#123; return x.yi&lt;y.yi;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;s&gt;&gt;a&gt;&gt;b; for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;x_&gt;&gt;y_; if(x_&lt;=a+b)&#123; can++; ap[can].xi=x_; ap[can].yi=y_; &#125; &#125; sort(ap+1,ap+can+1,cmp); rest=s; ans=0; for(int i=1;rest&gt;=ap[i].yi&amp;&amp;i&lt;=can;i++)&#123; ans++; rest-=ap[i].yi; &#125; cout&lt;&lt;ans; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"递归","slug":"递归","permalink":"https://zouyunkai.github.io/myblog/tags/%E9%80%92%E5%BD%92/"},{"name":"boos","slug":"boos","permalink":"https://zouyunkai.github.io/myblog/tags/boos/"}],"author":"aoyuehan"},{"title":"mysql笔记重点","slug":"mysql笔记","date":"2019-07-27T12:29:00.000Z","updated":"2022-02-26T04:29:56.914Z","comments":true,"path":"2019/07/27/mysql笔记/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/27/mysql%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"https://zouyunkai.github.io/myblog/tags/mysql/"}],"author":"aoyuehan"},{"title":"快速幂 矩阵快速幂 快速幂求逆元","slug":"快速幂问题","date":"2019-07-27T08:57:00.000Z","updated":"2022-02-26T03:51:21.555Z","comments":true,"path":"2019/07/27/快速幂问题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/27/%E5%BF%AB%E9%80%9F%E5%B9%82%E9%97%AE%E9%A2%98/","excerpt":"","text":"求幂方法-pow函数也就是平常使用pow函数，最简单的实现就是一直累乘，可以得到这样的代码： 1234567int Pow(int a,int n)&#123; //求a^n int ans = 1; for(int i = 0;i &lt; n;i++)&#123; //i从0开始，到n-1，即执行n次 ans *= a; &#125; return ans;&#125; 上面这种算法的时间复杂度是O(n)。为了降低时间复杂度，我们可以使用快速幂算法，将时间复杂度降低到O(logn)，n是幂。 快速幂： 假设我们要求a^b，那么其实b是可以拆成二进制的，**该二进制数第i位的权为2^(i-1)**， 例如当b&#x3D;&#x3D;11时 a^11&#x3D;a^(2^0+2^1+2^3)11的二进制是1011，11 &#x3D; 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 a2^0×a2^1×a2^3，看出来快的多了吧原来算11次，现在算三次。 那么在关于位运算的部分，我们可以逐位获取b的位，碰到0，就累乘，碰到1，就将base累乘的值和ans相乘从而得到答案。 1234567891011int poww(int a, int n) &#123; int ans = 1, base = a; while (n != 0) &#123; if(n &amp; 1 != 0)&#123; ans *= base; //这就是碰到1的时候 &#125; base *= base; //碰到0就底数相乘 n &gt;&gt;= 1; &#125; return ans;&#125; 以b&#x3D;&#x3D;11为例，b&#x3D;&gt;1011,二进制从右向左算，但乘出来的顺序是 a^(2^0)*a^(2^1)a^(2^3)，是从左向右的。我们不断的让base&#x3D;base目的即是累乘，以便随时对ans做出贡献。 其中要理解base*&#x3D;base这一步：因为 basebase&#x3D;&#x3D;base^2，下一步再乘，就是base2 base2&#x3D;&#x3D;base4，然后同理 base4base4&#x3D;base8，由此可以做到base–&gt;base2–&gt;base4–&gt;base8–&gt;base16–&gt;base32…….指数正是 2^i ，再看上面的例子，a¹¹&#x3D; a1a2*a8，这三项就可以完美解决了，快速幂就是这样。 快速幂取模根据同余定理，我们知道（ab）%m &#x3D; （（a%m）（b%m））%m；其实快速幂取模也是用到这个定理，那么根据上面的定理可以推导出另一个定理：(a^b) mod c &#x3D; (a * a * a……..)%c &#x3D; ((a%c)(a%c)(a%c)*………)%c &#x3D; (a%c)^b %c;这就是快速幂取模 123456789101112typedef long long LL; // 视数据大小的情况而定LL powerMod(LL x, LL n, LL m) ////计算a^n % m&#123; LL res = 1; while (n &gt; 0)&#123; //这地方可以写while（n）吗，可以的 if (n &amp; 1) // 判断是否为奇数，若是则true res = (res * x) % m; x = (x * x) % m; n &gt;&gt;= 1; // 相当于n /= 2,舍去n的最后一位 &#125; return res;&#125; 1234567891011另一种写法：ll binaryPow(ll a, ll b, ll m)&#123; if(b == 0) return 1; else if(b % 2 == 1) return a * binaryPow(a, b - 1, m) % m; else&#123; ll num = binaryPow(a, b/2, m) % m; //优化 return num * num % m;// 不直接写成return binaryPow(a, b/2, m) * binaryPow(a, b/2, m) &#125;&#125; 矩阵快速幂 需要进行幂运算的不仅仅只有整数，比如，在POJ3070 Fibonacci中，就需要我们快速地完成方阵的幂运算。知道了如何做快速幂，我们还可以将同样的思想运用在其他地方。除了乘法的规则与普通快速幂不同之外不同，其他的细节并没有什么差别。 实现矩阵快速幂的一种方法如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct matrix//定义一个结构体，方便传递值&#123; int m[maxn][maxn];&#125;;/*maxn和mod由全局定义，其中mod根据需要可以省去*/matrix mat_multi(matrix a, matrix b)//矩阵求积&#123; matrix ans; for(int i = 0;i &lt; maxn;i++) &#123; for(int j = 0;j &lt; maxn;j++) &#123; ans.m[i][j] = 0; for(int k = 0;k &lt; maxn;k++) &#123; ans.m[i][j] += (a.m[i][k] % mod * b.m[k][j] % mod) % mod; ans.m[i][j] %= mod; &#125; &#125; &#125; return ans;&#125;matrix mat_quickpow(matrix a, int n)//矩阵快速幂&#123; matrix ans; for(int i = 0;i &lt; maxn;i++) &#123; for(int j = 0;j &lt; maxn;j++) &#123; if(i == j) ans.m[i][j] = 1; else ans.m[i][j] = 0; //这里要初始化为单位矩阵，类比普通快速幂这里初始化为1 &#125; &#125; while(n != 0)//方法与普通快速幂相同，只有乘法的实现不同 &#123; if(n &amp; 1) ans = mat_multi(a, ans); a = mat_multi(a, a); n &gt;&gt;= 1; &#125; return ans;&#125; 快速幂求逆元在模为素数p的情况下，有费马小定理a^(p-1)&#x3D;1（mod p）那么a^(p-2)&#x3D;a^-1(mod p)也就是说a的逆元为a^(p-2)而在模不为素数p的情况下，有欧拉定理a^phi(m)&#x3D;1（mod m） (a⊥m)同理a^-1&#x3D;a^(phi(m)-1)因此逆元x便可以套用快速幂求得了x&#x3D;a^(phi(m)-1)但是似乎还有个问题？如何判断a是否有逆元呢?检验逆元的性质，看求出的幂值x与a相乘是否为1即可PS:这种算法复杂度为O（log2N）在几次测试中，常数似乎较上种方法大当p比较大的时候需要用快速幂求解tips：模运算 模运算有一些很好的性质，以下列举四条： 1234 (a + b) % p = (a % p + b % p) % p (a - b) % p = (a % p - b % p + p) % p (a * b) % p = (a % p * b % p) % p (a^b) % p = ((a % p)^b) % p 乘法逆元乘法逆元的定义 若整数b，m互质，并且b|a，则存在一个整数x，使得a&#x2F;b≡a∗x(mod m)，则称x为b的模m乘法逆元，记为b^(−1)(mod m)。 b存在乘法逆元的充要条件是b与模数m互质。当模数m为质数时，b^(m−2)即为b的乘法逆元。 因为在模运算中，并没有除法的性质，即没有(a&#x2F;b)%p≠((a%p)&#x2F;(b%p))%p，而乘法逆元便可以帮助我们将其转化成乘法形式：a&#x2F;b % m&#x3D;a∗x % m。(其中x为b的逆元) 由乘法逆元的定义我们可以推出如下结论： 12∵ a/b mod p = a * b^(-1) mod p = a/b * b * b^(-1) mod p ∴ b * b^(-1) ≡ 1（mod p） 有了乘法逆元，我们在计数类问题中遇到(a&#x2F;b)%p时，便可以转化成((a % p) * (b^(-1) % p)) % p来计算了，这样便防止了爆int的情况出现，当然，转化的前提是必须保证b与p互质。当p是质数时，则可以进一步转化为((a % p) * (b ^(p-2) % p)) % p。","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"快速幂","slug":"快速幂","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"}],"author":"aoyuehan"},{"title":"算法模板","slug":"算法模板","date":"2019-07-27T08:19:00.000Z","updated":"2022-02-26T04:29:58.281Z","comments":true,"path":"2019/07/27/算法模板/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/27/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"算法模板头文件万能头文件：#include&lt;bits/stdc++.h&gt;控制输出流的格式。#include&lt;iomanip&gt; 特点： 将操纵运算子写在输出流中。 每个数向前寻找最近的操纵运算子，若有连续多个同类算子，**仅最后一个有效。 ** 四舍六入五找数（若5后有数，进位，反之舍弃）。 当算子无效时，程序一般可以正常运行。 常用算子： stew(n)：设定域宽，默认右对齐，对本身超过域宽的数字无效。 setfill(‘char’)：设定填充字符。 注意：以上两个算子都仅对紧接着的一个数字有效。 setbase(n)：调整进制，仅对整形有效，n可取8，10，16，取其他值无效。 setprecision(n)：设置有效数字，对整形无效，若 n 多于实数的位数也无效（不补零）。 cout&lt;&lt;fixed&lt;&lt;setprecision(n)：整数部分不变（仍以十进制形式输出），小数部分保留 n 位。 cout&lt;&lt;left：左对齐（与 cout&lt;&lt;setiosflags(ios::left) 效果相同）。 补充： 有效数字默认为六位，如： 1.234567 会输出 1.23457。 1111111.234567 会输出 1.11111e+006。 #define _CRT_SBCURE_NO_DEPRECATE#include &#x2F;&#x2F;STL 集合容器#include &#x2F;&#x2F;STL线性列表容器#include &#x2F;&#x2F;STL 映射容器#include &#x2F;&#x2F;定义数学函数#include &#x2F;&#x2F;STL队列容器#include &#x2F;&#x2F;STL堆栈容器 #include &#x2F;&#x2F;STL动态数组容器#include &#x2F;&#x2F;字符串类#include &#x2F;&#x2F;定义输入／输出函数#include &#x2F;&#x2F;定义杂项函数及内存分配函数#include &#x2F;&#x2F;字符串处理#include &#x2F;&#x2F;数据流输入／输出#include &#x2F;&#x2F;STL通用算法#include &#x2F;&#x2F;STL定义运算函数（代替运算符） using namespace std;const int maxn &#x3D; 110;const int INF &#x3D; 0x3f3f3f3f;更多介绍：https://blog.csdn.net/qq_34625397/article/details/81233870 经典算法1.埃拉托斯特尼筛法 123456789101112131415161718192021/* |埃式筛法| |快速筛选素数| |16/11/05ztx|*/int prime[maxn]; bool is_prime[maxn];int sieve(int n)&#123; int p = 0; memset(is_prime, true, sizeof(is_prime)); is_prime[0] = is_prime[1] = false; for (int i = 2; i &lt;= n; ++i)&#123; // 注意数组大小是n if(is_prime[i])&#123; prime[p++] = i; for(int j = i + i; j &lt;= n; j += i) // 轻剪枝，j必定是i的倍数 is_prime[j] = false; &#125; &#125; return p; // 返回素数个数&#125; 2.快速幂 ???? 12345678910111213141516/* |这是快速幂还是快速幂取模|*/typedef long long LL; // 视数据大小的情况而定LL powerMod(LL x, LL n, LL m)&#123; LL res = 1; while (n &gt; 0)&#123; if (n &amp; 1) // 判断是否为奇数，若是则true res = (res * x) % m; x = (x * x) % m; n &gt;&gt;= 1; // 相当于n /= 2; &#125; return res;&#125; 3.大数模拟 123456789101112131415161718192021222324252627string add1(string s1, string s2)&#123; if (s1 == &quot;&quot; &amp;&amp; s2 == &quot;&quot;) return &quot;0&quot;; if (s1 == &quot;&quot;) return s2; if (s2 == &quot;&quot;) return s1; string maxx = s1, minn = s2; if (s1.length() &lt; s2.length())&#123; maxx = s2; minn = s1; &#125; int a = maxx.length() - 1, b = minn.length() - 1; for (int i = b; i &gt;= 0; --i)&#123; maxx[a--] += minn[i] - &#x27;0&#x27;; // a一直在减 ， 额外还要减个&#x27;0&#x27; &#125; for (int i = maxx.length()-1; i &gt; 0;--i)&#123; if (maxx[i] &gt; &#x27;9&#x27;)&#123; maxx[i] -= 10; //注意这个是减10 maxx[i - 1]++; &#125; &#125; if (maxx[0] &gt; &#x27;9&#x27;)&#123; //注意字符串的下标是从左往右增大的，所以maxx[0]是权最高的那个数 maxx[0] -= 10; maxx = &#x27;1&#x27; + maxx; &#125; return maxx;&#125; Number 数论 GCD最大公约数 123456789101112131415161718192021222324252627282930311.int gcd(int a,int b) ///基础 辗转 &#123; int r; while(b&gt;0) &#123; r=a%b; a=b; b=r; &#125; return a; &#125; 2.int gcd(int a,int b)///位运算&#123; while(b^=a^=b^=a%=b); return a; &#125; 3.int gcd(int a,int b)///递归调用&#123; if(b==0) &#123; return a; &#125; gcd(b,a%b);&#125;4.#include&lt;algorithm&gt;///直接使用c++的内置函数using namespace std;__gcd(int a,int b) //这个用法gcd前面必须得要两条小横线","categories":[{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"模板","slug":"模板","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%A8%A1%E6%9D%BF/"}],"author":"aoyuehan"},{"title":"数论","slug":"c-素数问题","date":"2019-07-27T03:18:00.000Z","updated":"2022-02-26T03:52:52.347Z","comments":true,"path":"2019/07/27/c-素数问题/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/27/c-%E7%B4%A0%E6%95%B0%E9%97%AE%E9%A2%98/","excerpt":"","text":"数论素数问题 对于寻找素数，第一时间想到的便是二重循环暴力查找，其复杂度O(n)，通过循环中只判断到根号n可以优化一些，不过复杂度也达不到预期。 埃氏筛法 O(nloglogn)的算法，而在一些数据范围达到1e7这样的题目中，也很难让人满意 欧拉筛法，也即 O(n)的线性筛法。 暴力求素数1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; for(int i=2; i&lt;n; i++)&#123; //**可以改为i&lt;=sqrt(n)** if(n%i == 0)&#123; cout &lt;&lt; n &lt;&lt; &quot; isn&#x27;t a prime&quot; &lt;&lt; endl; return 1; &#125; &#125; cout &lt;&lt; n &lt;&lt; &quot; is a prime&quot; &lt;&lt; endl; return 0;&#125; 埃氏筛法* 埃氏筛法的基本思想 ：从2开始，将每个质数的倍数都标记成合数，以达到筛选素数的目的。 12345678910111213141516171819202122232425262728293031323334int prime[maxn]; bool is_prime[maxn];int sieve(int n)&#123; int num = 0; //num从0开始，这样下面prime数组从1开始存放num个素数，但总的个数是num个 memset(is_prime, true, sizeof(is_prime)); is_prime[0] = is_prime[1] = false; for (int i = 2; i &lt;= n; ++i)&#123; // 注意数组大小是n if(is_prime[i])&#123; prime[num++] = i; for(int j = 2; j*i &lt;= n; j++ ) // 轻剪枝，j必定是i的倍数 is_prime[j*i] = false; &#125; &#125; return num; // 返回素数个数&#125;int main()&#123; cout&lt;&lt;sieve(4)&lt;&lt;endl; for(int i=0;i&lt;=4;i++) &#123; cout&lt;&lt;prime[i]&lt;&lt;&quot; &quot;&lt;&lt;isPrime[i]&lt;&lt;endl; &#125;&#125; 运行结果：2 //两个素数2 0 //前面一列是num个素数的表，就是prime数组，下标从0开始3 0 //后面一列是is_prime数组的真假值，下标从0开始0 10 10 0 * 埃氏筛法的缺陷 ：对于一个合数，有可能被筛多次。例如 30 = 2 * 15 = 3* 10 = 5*6……那么如何确保每个合数只被筛选一次呢？我们只要用它的 最小质因子 来筛选即可，这便是欧拉筛法。 欧拉筛法* 欧拉筛法的基本思想 ：在埃氏筛法的基础上，让每个合数只被它的**最小质因子**筛选一次，以达到不重复的目的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100;int prime[maxn];bool isPrime[maxn];bool noPrime[maxn];int sieve(int n)&#123; int num=0; memset(isPrime,true,sizeof(isPrime)); isPrime[0]=isPrime[1]=false; for(int i=2;i&lt;=n;i++)&#123; if(isPrime[i])&#123; prime[num++]=i; for(int j=2;j*i&lt;=n;j++)&#123; isPrime[j*i]=false; &#125; &#125; &#125; return num;&#125; int eulerSieve_3(int n)&#123; int num=0; memset(prime,0,sizeof(prime)); memset(noPrime,false,sizeof(noPrime)); noPrime[0]=noPrime[1]=true; for(int i=2;i&lt;=n;++i)&#123; if(noPrime[i]==false)prime[++num]=i; //从1开始存素数 for(int j=1;j&lt;=num&amp;&amp;i*prime[j]&lt;=n;++j)&#123; noPrime[i*prime[j]]=true; if(i%prime[j] ==0)break; &#125; &#125; return num;&#125;//下面这个方法最好int eulerSieve_1(int n)&#123; int num=0; memset(isPrime,true,sizeof(isPrime)); isPrime[0]=isPrime[1]=false; for(int i=2;i&lt;=n;i++)&#123; //这个从prime的0下标开始存素数 if(isPrime[i])prime[num++]=i; //第一次执行num++，prime[0]存入i，之后num为1，那么下面这个for中num为1 for(int j=0;j&lt;num&amp;&amp;i*prime[j]&lt;=n;j++)&#123; //这个从j开始到num，遍历一遍prime数组，所以遍历的次数为数组个数 isPrime[i*prime[j]]=false; if(i%prime[j]==0)break; &#125; &#125; return num;&#125;int main()&#123; cout&lt;&lt;eulerSieve_1 (4)&lt;&lt;endl; for(int i=0;i&lt;=4;i++) &#123; cout&lt;&lt;prime[i]&lt;&lt;&quot; &quot;&lt;&lt;isPrime[i]&lt;&lt;endl; &#125;&#125; 如果i%prime[j]&#x3D;&#x3D;0，那么i就可以看成prime[i]乘以一个数（记为n）；因为我们存的prime是从小到大存的，所以prime[j+1]&gt;prime[j]；那么iprime[j+1]就可以看成prime[j]nprime[j+1];那么iprime[j+1]的最小质因子是prime[j]。加上if(i%prime[j]&#x3D;&#x3D;0) break后我们就可以保证每一个数只被它的最小质因子给筛去,那么每一个数只会被筛一次，那么时间复杂度为O(n)。**举个例子 **：i &#x3D; 8 ，j &#x3D; 1，prime[j] &#x3D; 2，如果不跳出循环，prime[j+1] &#x3D; 3，8 * 3 &#x3D; 2 * 4 * 3 &#x3D; 2 * 12，在i &#x3D; 12时会计算。因为欧拉筛法的原理便是通过最小素因子来消除。 下图是n&#x3D;20的模拟。（p[j]是代码中的prime[j]，tot是cnt） 约数个数，欧拉函数等https://blog.csdn.net/weixin_43896346/article/details/88396182 下一个","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://zouyunkai.github.io/myblog/tags/c/"},{"name":"素数","slug":"素数","permalink":"https://zouyunkai.github.io/myblog/tags/%E7%B4%A0%E6%95%B0/"}],"author":"aoyuehan"},{"title":"java-@param注解","slug":"java-param注解","date":"2019-07-26T07:00:00.000Z","updated":"2022-02-26T03:52:51.577Z","comments":true,"path":"2019/07/26/java-param注解/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/26/java-param%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"实例一 @Param注解单一属性 dao层示例 1Public User selectUser(@param(“userName”) String name,@param(“userpassword”) String password); xml映射对应示例 1234&lt;select id=&quot; selectUser&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from user_user_t where user_name = #&#123;userName，jdbcType=VARCHAR&#125; and user_password=#&#123;userPassword,jdbcType=VARCHAR&#125; &lt;/select&gt; 注意：采用#{}的方式把@Param注解括号内的参数进行引用（括号内参数对应的是形参如 userName对应的是name）； 实例二 @Param注解JavaBean对象 dao层示例 1public List&lt;user&gt; getUserInformation(@Param(&quot;user&quot;) User user); xml映射对应示例 123456789&lt;select id=&quot;getUserInformation&quot; parameterType=&quot;com.github.demo.vo.User&quot; resultMap=&quot;userMapper&quot;&gt; select &lt;include refid=&quot;User_Base_Column_List&quot; /&gt; from mo_user t where 1=1 &lt;!-- 因为传进来的是对象所以这样写是取不到值得 &lt;if test=&quot;user.userName!=null and user.userName!=&#x27;&#x27;&quot;&gt; and t.user_name = #&#123;user.userName&#125; &lt;/if&gt; &lt;if test=&quot;user.userAge!=null and user.userAge!=&#x27;&#x27;&quot;&gt; and t.user_age = #&#123;user.userAge&#125; &lt;/if&gt; &lt;/select&gt; 1，使用@Param注解 当以下面的方式进行写SQL语句时： 12@Select(&quot;select column from table where userid = #&#123;userid&#125; &quot;)public int selectColumn(int userid); 当你使用了使用@Param注解来声明参数时，如果使用 #{} 或 ${} 的方式都可以。 12@Select(&quot;select column from table where userid = $&#123;userid&#125; &quot;)public int selectColumn(@Param(&quot;userid&quot;) int userid); 当你不使用@Param注解来声明参数时，必须使用使用 #{}方式。如果使用 ${} 的方式，会报错。 @Select(&quot;select column from table where userid = $&#123;userid&#125; &quot;) public int selectColumn(@Param(&quot;userid&quot;) int userid); 2，不使用@Param注解 不使用@Param注解时，参数只能有一个，并且是Javabean。在SQL语句里可以引用JavaBean的属性，而且只能引用JavaBean的属性。 1234// 这里id是user的属性@Select(&quot;SELECT * from Table where id = $&#123;id&#125;&quot;)Enchashment selectUserById(User user);","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://zouyunkai.github.io/myblog/categories/JAVA/"}],"tags":[{"name":"param","slug":"param","permalink":"https://zouyunkai.github.io/myblog/tags/param/"},{"name":"java","slug":"java","permalink":"https://zouyunkai.github.io/myblog/tags/java/"}],"author":"aoyuehan"},{"title":"递归  recursive functions","slug":"递归","date":"2019-07-26T00:59:00.000Z","updated":"2022-02-26T03:52:51.031Z","comments":true,"path":"2019/07/26/递归/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/26/%E9%80%92%E5%BD%92/","excerpt":"","text":"递归函数 递归介绍 递归就是一个函数在它的函数体内调用它自身。执行递归函数将反复调用其自身，每调用一次就进入新的一层。递归函数必须有结束条件。当函数在一直递推，直到遇到墙后返回，这个墙就是结束条件。所以递归要有两个要素，结束条件与递推关系 注:递归的时候，每次调用一个函数，计算机都会为这个函数分配新的空间，这就是说，当被调函数返回的时候，调用函数中的变量依然会保持原先的值，否则也不可能实现反向输出。 例如： 1234567891011121314151617181920212223242526272829303132333435计算n的阶乘#include &lt;stdio.h&gt; int factorial(int n)&#123; int result; if (n&lt;0) // 判断例外 &#123; printf(&quot;输入错误!\\n&quot;); return 0; &#125; else if (n==0 || n==1) &#123; result = 1; //回推墙 ，就是结束条件 &#125; else &#123; result = factorial(n-1) * n; //递推关系，这个数与上一个数之间的关系。 &#125; return result; &#125; int main()&#123; int n = 5; //输入数字5，计算5的阶乘 printf(&quot;%d的阶乘=%d&quot;,n,factorial(n)); return 0;&#125;其中阶乘用循环来实现：int factorial(int n)&#123; int product = 1; while(n&gt;0)&#123; product *= n; n--; &#125; return product;&#125; 123456789101112131415161718192021斐波那契数列斐波那契数列指的是这样一个数列:0, 1, 1, 2, 3, 5, 8, 13, 21, ···这个数列从第三项开始,每一项都等于前两项之和.#include &lt;stdio.h&gt;long fibonacci( long num )&#123; if ( num == 0 || num == 1 )&#123; return num; //这就是结束条件 &#125; else&#123; return fibonacci( num -1 ) + fibonacci( num -2 ); //这是循环条件 &#125;&#125;void mian()&#123; long number; puts(&quot;请输入一个正整数: &quot;); scanf(&quot;%ld&quot;, &amp;number); printf(&quot;斐波那契数列第%ld项为: %ld\\n&quot;, number, fibonacci( number ) );&#125; 其中这个树的调用顺序是先纵后横，fib5的下一级的fib4的调用顺序为fib5-&gt;fib4-&gt;fib3-&gt;fib2-&gt;fib1-&gt;返回1-&gt;fib0-&gt;返回-&gt;fib1(与左侧fib2同级的fib1)-&gt;fib2(与左侧fib3同级的fib2)-&gt;返回到fib5。 123如果只有 1 个盘子，则不需要利用B塔，直接将盘子从A移动到C。如果有 2 个盘子，可以先将盘子1上的盘子2移动到B；将盘子1移动到C；将盘子2移动到C。这说明了：可以借助B将2个盘子从A移动到C，当然，也可以借助C将2个盘子从A移动到B。如果有3个盘子，那么根据2个盘子的结论，可以借助c将盘子1上的两个盘子从A移动到B；将盘子1从A移动到C，A变成空座；借助A座，将B上的两个盘子移动到C。 其中这个就相当于在1~n和第n个之间切了一刀，这样比那个在第一个和第二个到第n-1个之间切一刀好，前者是等价的，并且减小了问题的规模。这三个柱子的角色再变，首先是C协助，后来B协助，再后来A协助、 123456789101112 ***以此类推，上述的思路可以一直扩展到 n 个盘子的情况，将将较小的 n-1个盘子看做一个整体，也就是我们要求的子问题***，以借助B塔为例，可以借助空塔B将盘子A上面的 n-1 个盘子从A移动到B；将A最大的盘子移动到C，A变成空塔；借助空塔A，将B塔上的 n-2 个盘子移动到A，将C最大的盘子移动到C，B变成空塔… 根据以上的分析，不难写出程序： void Hanoi (int n, char A, char B, char C)&#123; if (n==1)&#123; //end condition move(A,B);//‘move’ can be defined to be a print function &#125; else&#123; Hanoi(n-1,A,C,B);//move sub [n-1] pans from A to B move(A,C);//move the bottom(max) pan to C Hanoi(n-1,B,A,C);//move sub [n-1] pans from B to C &#125;&#125; 递归的特点 每一级函数调用时都有自己的变量，但是函数代码并不会得到复制，如计算5的阶乘时每递推一次变量都不同； 每次调用都会有一次返回，如计算5的阶乘时每递推一次都返回进行下一次； 递归函数中，位于递归调用前的语句和各级被调用函数具有相同的执行顺序；就是在递归函数前后的语句的执行顺序 递归函数中，位于递归调用后的语句的执行顺序和各个被调用函数的顺序相反； 递归函数中必须有终止语句。 效率 系统栈（也叫核心栈、内核栈） 是内存中属于操作系统空间的一块区域，其主要用途为： (1)保存中断现场，对于嵌套中断，被中断程序的现场信息依次压入系统栈，中断返回时逆序弹出； (2)保存操作系统子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。 用户栈 是用户进程空间中的一块区域，用于保存用户进程的子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量。 我们编写的递归程序属于用户程序，因此使用的是用户栈。 * **栈溢出 ** 函数调用的参数是通过栈空间来传递的，在调用过程中会占用线程的栈资源。**而递归调用，只有走到最后的 结束点后函数才能依次退出，而未到达最后的结束点之前，占用的栈空间一直没有释放，如果递归调用次数过多，就可能导致占用的栈资源超过线程的最大值，从而导致栈溢出，导致程序的异常退出。** 每一个递归程序都遵循相同的基本步骤： (1) 初始化算法。递归程序通常需要一个开始时使用的种子值（seed value）。要完成此任务，可以向函数传递参数，或者提供一个入口函数， 这个函数是非递归的，但可以为递归计算设置种子值。 (2) 检查要处理的当前值是否已经与基线条件相匹配。如果匹配，则进行处理并返回值。 (3) 使用更小的或更简单的子问题（或多个子问题（多个子问题就是斐波那锲那种的形式，这样与切蛋糕有些区别）(子问题就是重复的那部分，不过就是规模变小了)）来重新定义答案。 (4) 对子问题运行算法。 (5) 将结果合并入答案的表达式。 (6) 返回结果。 例如： 12345678910/*f1(n):求n的阶乘*找重复：n*(n-1)的阶乘，求n-1的阶乘是原问题的重复(规模更小)，即子问题*找变化：找重复中的变化量，作为参数*找边界：通过参数变化的趋势找出口 */int f1(int n)&#123; if(n==1)return 1; return n*f1(n-1);&#125; 函数所做的最后一件事情是一个函数调用（递归的或者非递归的），这被称为 尾部调用（tail-call）。使用尾部调用的递归称为 尾部递归。当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。**通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。 ** 在尾部调用之后除去栈结构的方法称为 尾部调用优化 。 (1) 函数在尾部被调用之后，还需要使用哪个本地变量？哪个也不需要。 (2) 会对返回的值进行什么处理？什么处理也没有。 (3) 传递到函数的哪个参数将会被使用？哪个都没有。 好像一旦控制权传递给了尾部调用的函数，栈中就再也没有有用的内容了。虽然还占据着空间，但函数的栈结构此时实际上已经没有用了，因此，尾部调用优化就是要在尾部进行函数调用时使用下一个栈结构 覆盖 当前的栈结构，同时保持原来的返回地址。 123456789101112131415161718192021222324252627 int test1()&#123; int a = 3; test1(); /* recursive, but not a tail call. We continue */ /* processing in the function after it returns. */ a = a + 4; return a;&#125;int test2()&#123; int q = 4; q = q + 5; return q + test1(); /* test1() is not in tail position. * There is still more work to be * done after test1() returns (like * adding q to the result*/&#125;int test3()&#123; int b = 5; b = b + 2; return test1(); /* This is a tail-call. The return value * of test1() is used as the return value * for this function.*/ &#125;int test4()&#123; test3(); /* not in tail position */ test3(); /* not in tail position */ return test3(); /* in tail position */&#125; 递归实现全排列 输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则输出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。 递归思想： 假如针对abc的排列，可以分成 (1)以a开头，加上bc的排列 (2)以b开头，加上ac的排列 (3)以c开头，加上ab的排列 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt; using namespace std;//产生排列组合的递归写法 void pai(char t[],int k,int n)&#123; if(k==n-1)&#123; //输出这个排列，k=n-1就是 递归出口 for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;t[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;else&#123; for(int i=k;i&lt;n;i++)&#123; //一次挑选n个元素中的一个,和前位置替换 int tmp=t[i];t[i]=t[k];t[k]=tmp; //再对其余的n-1个字母一次挑选 pai(t,k+1,n); //在换回到原来的状态 tmp=t[i];t[i]=t[k];t[k]=tmp; &#125; &#125; &#125;int main ()&#123; char t[3]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;; //t为数组 int k=0; //k为起始排列值 int n=3; //n为数组长度，是数组声明的时候的下标 cout&lt;&lt;&quot;第一种方法：&quot;&lt;&lt;endl; pai(t,0,n); cout&lt;&lt;&quot;第二种方法：&quot;&lt;&lt;endl; do&#123; cout&lt;&lt;t[0]&lt;&lt;&quot; &quot;&lt;&lt;t[1]&lt;&lt;&quot; &quot;&lt;&lt;t[2]&lt;&lt;endl; &#125;while(next_permutation(t,t+3));//参数3指的是要进行排列的长度 //如果存在t之后的排列，就返回true。如果a是最后一个排列没有后继，返回false，每执行一次，t就变成它的后继；若排列本来就是最大的了没有后继，则next_permutation执行后，会对排列进行字典升序排序,相当于循环&#125; 下面这道题就是知道最后n&#x3D;7时的结果，来推最初的那个结果 的题目？？？ 一个人赶着鸭子去每个村庄卖，每经过一个村子卖去所赶鸭子的一半又一只。这样他经过了七个村子后还剩两只鸭子，问他出发时共赶多少只鸭子？经过每个村子卖出多少只鸭子 题目分析:递归终止的条件是当达到第7个村庄时递归停止，设经过的村庄数为n则有剩余的鸭子为总数为每次剩余的鸭子数位sum &#x3D; sum-(sum&#x2F;2+1) 算法构造：当 n&#x3D;7 时 sum &#x3D; 2;当 0&lt;n&lt;7 时 sum &#x3D;2*sum+2;，结束条件是n&lt;&#x3D;0 1234567891011121314151617181920212223#include &lt;iostream.h&gt;class Questionone&#123;public: int answer(int n, int sum)&#123; if(n&gt;0)&#123; sum = 2*sum+2; if(n-1&gt;0)&#123; cout&lt;&lt;&quot;第&quot;&lt;&lt;n-1&lt;&lt;&quot;个村庄&quot;&lt;&lt;&quot;卖出&quot;&lt;&lt;2*sum+2-sum&lt;&lt;endl; &#125; n--; return answer(n,sum); &#125;else&#123; return sum; &#125; &#125; &#125;;void main()&#123; int SUM = 2; int N = 7; Questionone question; cout&lt;&lt;&quot;总数：&quot;&lt;&lt;question.answer(N,SUM)&lt;&lt;endl; &#125; 日本著名数学游戏专家中村义作教授提出这样一个问题：父亲将2520个桔子分给六个儿子。分完 后父亲说：“老大将分给你的桔子的1&#x2F;8给老二；老二拿到后连同原先的桔子分1&#x2F;7给老三；老三拿到后连同原先的桔子分1&#x2F;6给老四；老四拿到后连同原先的桔子分1&#x2F;5给老五；老五拿到后连同原先的桔子分1&#x2F;4给老六；老六拿到后连同原先的桔子分1&#x2F;3给老大”。结果大家手中的桔子正好一 样多。问六兄弟原来手中各有多少桔子？ 题目分析：解决此问题主要使用递归运算。由题目可以看出原来手中的加上得到的满足关系式：StartNum &#x3D; 420 * (n -2)&#x2F;(n - 1) 分给下一个人的橘子数：GiveNum &#x3D; AfterGetNum &#x2F; n; 下一个人的橘子数：nextStartNum &#x3D; 420*(n-1)&#x2F;(n-2) - GiveNum; 下一个人加上之前得到的橘子的总数：afterGetNum &#x3D; nextStartNum + GiveNum; 以此使用递归算法可以算出各个孩子原来手中的橘子数。 1234567891011121314151617181920212223242526272829public class questionfour &#123;/** * * @param n 表示第几个儿子 * @param befor 表示为分配之前就的桔子数 * @param After 表示分配之后的桔子数 * @param m 分配的比例 * @return */ ？？？？？？？public int answer(int n,int befornum, int afternum,int m )&#123; if(n&gt;6)&#123; return 0; &#125;else&#123; System.out.println(&quot;老&quot;+n+&quot;原有的桔子数&quot;+befornum); //分给下一个人的桔子数 int givenum = afternum/m; //下一个人的桔子数 int nextBeforenum = 420*(m-1)/(m-2)-givenum; //下一人加上之前的桔子数的总数 int afterGetnum = nextBeforenum+givenum; return answer(n+1,nextBeforenum,afterGetnum,m-1); &#125;&#125;public static void main(String[] args)&#123; questionfour question4 = new questionfour(); question4.answer(1, 240, 240, 8);&#125; 八皇后问题 ????? 问题描述：经典的八皇后问题，即在一个8*8的棋盘上放8个皇后，使得这8个皇后无法互相攻击( 任意2个皇后不能处于同一行，同一列或是对角线上)，输出所有可能的摆放情况。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;int c[20],n=8,cnt=0;void print()&#123; //打印 for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;n;++j)&#123; if(j==c[i])cout&lt;&lt;&quot;1 &quot;; else cout&lt;&lt;&quot;0 &quot;; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl;&#125;void search(int r)&#123; if(r==n)&#123; //当已经排到最后一个皇后的时候位置一定固定。【条件2】 print(); ++cnt; return; &#125; for(int i=0;i&lt;n;++i)&#123; //r表示第几行 标号1 c[r]=i; //c[r]=i，表示第r行第i列 int ok=1; for(int j=0;j&lt;r;++j) if(c[r]==c[j]||r-j==c[r]-c[j]||r-j==c[j]-c[r])&#123; //判断是否在同一列，是否在主对角线或副对角线上【条件1】 ok=0; break; //这会跳出离这个最近的for循环，所以本题中会执行标号1的语句 &#125; if(ok)search(r+1); //r+1必定不在同一行，故不用判断是否在一行 &#125;&#125;int main()&#123; search(0); cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[{"name":"递归","slug":"递归","permalink":"https://zouyunkai.github.io/myblog/tags/%E9%80%92%E5%BD%92/"}],"author":"aoyuehan"},{"title":"acm学习计划","slug":"acm","date":"2019-07-26T00:50:21.000Z","updated":"2022-02-26T04:31:40.722Z","comments":true,"path":"2019/07/26/acm/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/26/acm/","excerpt":"","text":"ACM大量习题题库 ACM大量习题题库现在网上有许多题库，大多是可以在线评测，所以叫做Online Judge。除了USACO是为IOI准备外，其余几乎全部是大学的ACM竞赛题库。 USACO http://ace.delos.com/usacogate 美国著名在线题库，专门为信息学竞赛选手准备 TJU http://acm.tongji.edu.cn/ 同济大学在线题库，唯一的中文题库，适合NOIP选手 ZJU http://acm.zju.edu.cn/ 浙江大学在线题库 JLU http://acm.jlu.edu.cn/ 吉林大学在线题库（一直上不去） PKU http://acm.pku.edu.cn 北京大学在线题库 URAL http://acm.timus.ru 俄罗斯乌拉尔大学在线题库 SGU http://acm.sgu.ru/ 俄罗斯圣萨拉托夫州大学在线题库 ELJ http://acm.mipt.ru/judge/bin/problems.pl?lang=en 俄罗斯莫斯科物理技术学院 SPOJ https://spoj.sphere.pl/ 波兰格但斯克理工大学 UVA http://acm.uva.es/ 西班牙的Universidad de Valladolid在线题 ACM联系建议 一位高手对我的建议： 一般要做到50行以内的程序不用调试、100行以内的二分钟内调试成功.acm主要是考算法的，主要时间是花在思考算法上，不是花在写程序与debug上。下面给个计划你练练： 第一阶段：练经典常用算法，下面的每个算法给我打上十到二十遍，同时自己精简代码，因为太常用，所以要练到写时不用想，10-15分钟内打完，甚至关掉显示器都可以把程序打出来.1.最短路(Floyd、Dijstra,BellmanFord)2.最小生成树(先写个prim,kruscal要用并查集，不好写)3.大数（高精度）加减乘除4.二分查找. (代码可在五行以内)5.叉乘、判线段相交、然后写个凸包.6.BFS、DFS,同时熟练hash表(要熟，要灵活,代码要简)7.数学上的有：辗转相除（两行内），线段交点、多角形面积公式.8. 调用系统的qsort, 技巧很多，慢慢掌握.9. 任意进制间的转换 第二阶段：练习复杂一点，但也较常用的算法。如： 二分图匹配（匈牙利），最小路径覆盖 网络流，最小费用流。 线段树. 并查集。 熟悉动态规划的各个典型：LCS、最长递增子串、三角剖分、记忆化dp 6.博弈类算法。博弈树，二进制法等。7.最大团，最大独立集。8.判断点在多边形内。9. 差分约束系统.10. 双向广度搜索、A*算法，最小耗散优先. 第三阶段：前两个阶段是打基础，第三阶段是锻炼在比赛中可以快速建立模型、想新算法。这就要平时多做做综合的题型了。 把oibh上的论文看看（大概几百篇的，我只看了一点点，呵呵）。 平时扫扫zoj上的难题啦，别老做那些不用想的题.(中大acm的版主经常说我挑简单的来做:-P ) 多参加网上的比赛，感受一下比赛的气氛，评估自己的实力. 一道题不要过了就算，问一下人，有更好的算法也打一下。 做过的题要记好 :-) ACM ICPC学习计划 大牛给的计划——一般要做到50行以内的程序不用调试、100行以内的二分钟内调试成功.acm主要是考算法的,主要时间是花在思考算法上，不是花在写程序与debug上。下面给个计划你练练：第一阶段：练经典常用算法，下面的每个算法给我打上十到二十遍，同时自己精简代码，因为太常用，所以要练到写时不用想，10-15分钟内打完，甚至关掉显示器都可以把程序打出来.1.最短路(Floyd、Dijstra,BellmanFord)2.最小生成树(先写个prim,kruscal要用并查集，不好写)3.大数（高精度）加减乘除4.二分查找. (代码可在五行以内)5.叉乘、判线段相交、然后写个凸包.6.BFS、DFS,同时熟练hash表(要熟，要灵活,代码要简)7.数学上的有：辗转相除（两行内），线段交点、多角形面积公式.8. 调用系统的qsort, 技巧很多，慢慢掌握.9. 任意进制间的转换第二阶段：练习复杂一点，但也较常用的算法。如： 二分图匹配（匈牙利），最小路径覆盖 网络流，最小费用流。 线段树. 并查集。 熟悉动态规划的各个典型：LCS、最长递增子串、三角剖分、记忆化dp 6.博弈类算法。博弈树，二进制法等。7.最大团，最大独立集。8.判断点在多边形内。9. 差分约束系统.10. 双向广度搜索、A*算法，最小耗散优先.&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;ACMer必备知识（这么多呀，慢慢学了…… 图论 路径问题 0&#x2F;1边权最短路径 BFS 非负边权最短路径（Dijkstra） 可以用Dijkstra解决问题的特征 负边权最短路径 Bellman-Ford Bellman-Ford的Yen-氏优化 差分约束系统 Floyd 广义路径问题 传递闭包 极小极大距离 &#x2F; 极大极小距离 Euler Path &#x2F; Tour 圈套圈算法 混合图的 Euler Path &#x2F; Tour Hamilton Path &#x2F; Tour 特殊图的Hamilton Path &#x2F; Tour 构造 生成树问题 最小生成树 第k小生成树 最优比率生成树 0&#x2F;1分数规划 度限制生成树 连通性问题 强大的DFS算法 无向图连通性 割点 割边 二连通分支 有向图连通性 强连通分支 2-SAT 最小点基 有向无环图 拓扑排序 有向无环图与动态规划的关系 二分图匹配问题 一般图问题与二分图问题的转换思路 最大匹配 有向图的最小路径覆盖 0 &#x2F; 1矩阵的最小覆盖 完备匹配 最优匹配 稳定婚姻 网络流问题 网络流模型的简单特征和与线性规划的关系 最大流最小割定理 最大流问题 有上下界的最大流问题 循环流 最小费用最大流 &#x2F; 最大费用最大流 弦图的性质和判定 组合数学 解决组合数学问题时常用的思想 逼近 递推 &#x2F; 动态规划 概率问题 Polya定理 计算几何 &#x2F; 解析几何 计算几何的核心：叉积 &#x2F; 面积 解析几何的主力：复数 基本形 点 直线，线段 多边形 凸多边形 &#x2F; 凸包 凸包算法的引进，卷包裹法 Graham扫描法 水平序的引进，共线凸包的补丁 完美凸包算法 相关判定 两直线相交 两线段相交 点在任意多边形内的判定 点在凸多边形内的判定 经典问题 最小外接圆 近似O(n)的最小外接圆算法 点集直径 旋转卡壳，对踵点 多边形的三角剖分 数学 &#x2F; 数论 最大公约数 Euclid算法 扩展的Euclid算法 同余方程 &#x2F; 二元一次不定方程 同余方程组 线性方程组 高斯消元法 解mod 2域上的线性方程组 整系数方程组的精确解法 矩阵 行列式的计算 利用矩阵乘法快速计算递推关系 分数 分数树 连分数逼近 数论计算 求N的约数个数 求phi(N) 求约数和 快速数论变换 …… 素数问题 概率判素算法 概率因子分解 数据结构 组织结构 二叉堆 左偏树 二项树 胜者树 跳跃表 样式图标 斜堆 reap 统计结构 树状数组 虚二叉树 线段树 矩形面积并 圆形面积并 关系结构 Hash表 并查集 路径压缩思想的应用 STL中的数据结构 vector deque set &#x2F; map 动态规划 &#x2F; 记忆化搜索 动态规划和记忆化搜索在思考方式上的区别 最长子序列系列问题 最长不下降子序列 最长公共子序列 最长公共不下降子序列 一类NP问题的动态规划解法 树型动态规划 背包问题 动态规划的优化 四边形不等式 函数的凸凹性 状态设计 规划方向 线性规划 常用思想 二分 最小表示法 串 KMP Trie结构 后缀树&#x2F;后缀数组 LCA&#x2F;RMQ 有限状态自动机理论 排序 选择&#x2F;冒泡 快速排序 堆排序 归并排序 基数排序 拓扑排序 排序网络 熟练掌握数据结构、常用算法汇聚 （一） 不可能都完全记住那么多的算法.常用算法,拿过来就可以写出来不常用的,拿起书来,看10分钟,就能理解算法(因为以前记过).对以前没有记过的算法,就不好说了,难的可能要研究好几天.这样就可以了. 应该熟练掌握的常用的算法应该有:各种排序算法（插入排序、冒泡排序、选择排序，快速排序，堆排序，归并排序）线性表(一般的线性表,栈,队列)的插入和删除二叉树的遍历（前序，中序，后序）图的遍历（深度优先，广度优先）二分法查找，排序二叉树，Hash查找（处理冲突的方法）。 （二） 分析一个东西,你可以用不同的眼光去看待,有很多时候,就跟自己生活一样,觉得小时候看待问题很幼稚,现在看问题全面了,而且方式不一样了,为什么,就是成长吧,就跟这个一样的,你对算法,比如写一个程序,可能直接写很简单,可是可以有一些有趣的方式,比如通过什么样来表达,怎么样更高效..等等吧 （三） 于大学里把基本的专业课学扎实就ok，如：数据结构，离散，操作系统等。碰到一些基本的数据结构和算法，如查找排序要根据原理马上能写出相应的代码就行了，我个人是这样理解的，对于更深层次的东西，也是建立在自己熟练的基础之上的吧 （四） 算法与数据结构考验试题精析》第2版 机械工业出版社如果你想练习的话，这里有N多的题可以来练习，但实际中能用到的比较少，除非搞一些高端的玩意，不过平时也可以在自己的项目中结合使用 （五） 数据结构在平时可能用不上，但数据结构可以培养你程序时如果注意效率的意识，一个学过数据结构的人和一个没有学过数结构的人写出来的程序可能在效率上有差别。 （六） 搞ACM需要的掌握的算法.要注意,ACM的竞赛性强,因此自己应该和自己的实际应用联系起来.适合自己的才是好的,有的人不适合搞算法,喜欢系统架构,因此不要看到别人什么就眼红,发挥自己的长处,这才是重要的. 第一阶段：练经典常用算法，下面的每个算法给我打上十到二十遍，同时自己精简代码，因为太常用，所以要练到写时不用想，10-15分钟内打完，甚至关掉显示器都可以把程序打出来.1.最短路(Floyd、Dijstra,BellmanFord)2.最小生成树(先写个prim,kruscal要用并查集，不好写)3.大数（高精度）加减乘除4.二分查找. (代码可在五行以内)5.叉乘、判线段相交、然后写个凸包.6.BFS、DFS,同时熟练hash表(要熟，要灵活,代码要简)7.数学上的有：辗转相除（两行内），线段交点、多角形面积公式.8. 调用系统的qsort, 技巧很多，慢慢掌握.9. 任意进制间的转换 第二阶段：练习复杂一点，但也较常用的算法。如： 二分图匹配（匈牙利），最小路径覆盖 网络流，最小费用流。 线段树. 并查集。 熟悉动态规划的各个典型：LCS、最长递增子串、三角剖分、记忆化dp 6.博弈类算法。博弈树，二进制法等。7.最大团，最大独立集。8.判断点在多边形内。9. 差分约束系统.10. 双向广度搜索、A*算法，最小耗散优先. 相关的知识 图论 路径问题0&#x2F;1边权最短路径BFS非负边权最短路径（Dijkstra）可以用Dijkstra解决问题的特征负边权最短路径Bellman-FordBellman-Ford的Yen-氏优化差分约束系统Floyd广义路径问题传递闭包极小极大距离 &#x2F; 极大极小距离Euler Path &#x2F; Tour圈套圈算法混合图的 Euler Path &#x2F; TourHamilton Path &#x2F; Tour特殊图的Hamilton Path &#x2F; Tour 构造 生成树问题最小生成树第k小生成树最优比率生成树0&#x2F;1分数规划度限制生成树 连通性问题强大的DFS算法无向图连通性割点割边二连通分支有向图连通性强连通分支2-SAT最小点基 有向无环图拓扑排序有向无环图与动态规划的关系 二分图匹配问题一般图问题与二分图问题的转换思路最大匹配有向图的最小路径覆盖0 &#x2F; 1矩阵的最小覆盖完备匹配最优匹配稳定婚姻 网络流问题网络流模型的简单特征和与线性规划的关系最大流最小割定理最大流问题有上下界的最大流问题循环流最小费用最大流 &#x2F; 最大费用最大流 弦图的性质和判定 组合数学 解决组合数学问题时常用的思想逼近递推 &#x2F; 动态规划概率问题Polya定理 计算几何 &#x2F; 解析几何 计算几何的核心：叉积 &#x2F; 面积解析几何的主力：复数 基本形点直线，线段多边形 凸多边形 &#x2F; 凸包凸包算法的引进，卷包裹法 Graham扫描法水平序的引进，共线凸包的补丁 完美凸包算法 相关判定两直线相交两线段相交点在任意多边形内的判定点在凸多边形内的判定 经典问题最小外接圆近似O(n)的最小外接圆算法点集直径旋转卡壳，对踵点多边形的三角剖分 数学 &#x2F; 数论 最大公约数Euclid算法扩展的Euclid算法同余方程 &#x2F; 二元一次不定方程同余方程组 线性方程组高斯消元法解mod 2域上的线性方程组整系数方程组的精确解法 矩阵行列式的计算利用矩阵乘法快速计算递推关系 分数分数树连分数逼近 数论计算求N的约数个数求phi(N)求约数和快速数论变换…… 素数问题概率判素算法概率因子分解 数据结构 组织结构二叉堆左偏树二项树胜者树跳跃表样式图标斜堆reap 统计结构树状数组虚二叉树线段树矩形面积并圆形面积并 关系结构Hash表并查集路径压缩思想的应用 STL中的数据结构vectordequeset &#x2F; map 动态规划 &#x2F; 记忆化搜索 动态规划和记忆化搜索在思考方式上的区别 最长子序列系列问题最长不下降子序列最长公共子序列最长公共不下降子序列 一类NP问题的动态规划解法 树型动态规划 背包问题 动态规划的优化四边形不等式函数的凸凹性状态设计规划方向 线性规划 常用思想 二分 最小表示法 串 KMP Trie结构后缀树&#x2F;后缀数组 LCA&#x2F;RMQ有限状态自动机理论 排序选择&#x2F;冒泡 快速排序 堆排序 归并排序基数排序 拓扑排序 排序网络 中级:一.基本算法:(1)C++的标准模版库的应用. (poj3096,poj3007)(2)较为复杂的模拟题的训练(poj3393,poj1472,poj3371,poj1027,poj2706)二.图算法:(1)差分约束系统的建立和求解. (poj1201,poj2983)(2)最小费用最大流(poj2516,poj2516,poj2195)(3)双连通分量(poj2942)(4)强连通分支及其缩点.(poj2186)(5)图的割边和割点(poj3352)(6)最小割模型、网络流规约(poj3308, )三.数据结构.(1)线段树. (poj2528,poj2828,poj2777,poj2886,poj2750)(2)静态二叉检索树. (poj2482,poj2352)(3)树状树组(poj1195,poj3321)(4)RMQ. (poj3264,poj3368)(5)并查集的高级应用. (poj1703,2492)(6)KMP算法. (poj1961,poj2406)四.搜索(1)最优化剪枝和可行性剪枝(2)搜索的技巧和优化 (poj3411,poj1724)(3)记忆化搜索(poj3373,poj1691) 五.动态规划(1)较为复杂的动态规划(如动态规划解特别的施行商问题等)(poj1191,poj1054,poj3280,poj2029,poj2948,poj1925,poj3034)(2)记录状态的动态规划. (POJ3254,poj2411,poj1185)(3)树型动态规划(poj2057,poj1947,poj2486,poj3140)六.数学(1)组合数学:1.容斥原理.2.抽屉原理.3.置换群与Polya定理(poj1286,poj2409,poj3270,poj1026).4.递推关系和母函数. (2)数学.1.高斯消元法(poj2947,poj1487, poj2065,poj1166,poj1222)2.概率问题. (poj3071,poj3440)3.GCD、扩展的欧几里德(中国剩余定理) (poj3101)(3)计算方法.1.0&#x2F;1分数规划. (poj2976)2.三分法求解单峰(单谷)的极值.3.矩阵法(poj3150,poj3422,poj3070)4.迭代逼近(poj3301)(4)随机化算法(poj3318,poj2454)(5)杂题.(poj1870,poj3296,poj3286,poj1095)七.计算几何学.(1)坐标离散化.(2)扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).(poj1765,poj1177,poj1151,poj3277,poj2280,poj3004)(3)多边形的内核(半平面交)(poj3130,poj3335)(4)几何工具的综合应用.(poj1819,poj1066,poj2043,poj3227,poj2165,poj3429) 高级:一.基本算法要求:(1)代码快速写成,精简但不失风格(poj2525,poj1684,poj1421,poj1048,poj2050,poj3306)(2)保证正确性和高效性. poj3434二.图算法:(1)度限制最小生成树和第K最短路. (poj1639)(2)最短路,最小生成树,二分图,最大流问题的相关理论(主要是模型建立和求解)(poj3155, poj2112,poj1966,poj3281,poj1087,poj2289,poj3216,poj2446(3)最优比率生成树. (poj2728)(4)最小树形图(poj3164)(5)次小生成树.(6)无向图、有向图的最小环三.数据结构.(1)trie图的建立和应用. (poj2778)(2)LCA和RMQ问题(LCA(最近公共祖先问题) 有离线算法(并查集+dfs) 和 在线算法(RMQ+dfs)).(poj1330)(3)双端队列和它的应用(维护一个单调的队列,常常在动态规划中起到优化状态转移的目的). (poj2823)(4)左偏树(可合并堆).(5)后缀树(非常有用的数据结构,也是赛区考题的热点).(poj3415,poj3294)四.搜索(1)较麻烦的搜索题目训练(poj1069,poj3322,poj1475,poj1924,poj2049,poj3426)(2)广搜的状态优化:利用M进制数存储状态、转化为串用hash表判重、按位压缩存储状态、双向广搜、A算法. (poj1768,poj1184,poj1872,poj1324,poj2046,poj1482)(3)深搜的优化:尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大、可以考虑双向搜索或者是轮换搜索、IDA算法. (poj3131,poj2870,poj2286)五.动态规划(1)需要用数据结构优化的动态规划.(poj2754,poj3378,poj3017)(2)四边形不等式理论.(3)较难的状态DP(poj3133)六.数学(1)组合数学.1.MoBius反演(poj2888,poj2154)2.偏序关系理论.(2)博奕论.1.极大极小过程(poj3317,poj1085)2.Nim问题.七.计算几何学.(1)半平面求交(poj3384,poj2540)(2)可视图的建立(poj2966)(3)点集最小圆覆盖.(4)对踵点(poj2079)八.综合题.(poj3109,poj1478,poj1462,poj2729,poj2048,poj3336,poj3315,poj2148,poj1263) 初期:一.基本算法:(1)枚举. (poj1753,poj2965) (2)贪心(poj1328,poj2109,poj2586)(3)递归和分治法. (4)递推.(5)构造法.(poj3295) (6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996)二.图算法:(1)图的深度优先遍历和广度优先遍历.(2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra)(poj1860,poj3259,poj1062,poj2253,poj1125,poj2240)(3)最小生成树算法(prim,kruskal)(poj1789,poj2485,poj1258,poj3026)(4)拓扑排序 (poj1094)(5)二分图的最大匹配 (匈牙利算法) (poj3041,poj3020)(6)最大流的增广路算法(KM算法). (poj1459,poj3436)三.数据结构.(1)串 (poj1035,poj3080,poj1936)(2)排序(快排、归并排(与逆序数有关)、堆排) (poj2388,poj2299)(3)简单并查集的应用.(4)哈希表和二分查找等高效查找法(数的Hash,串的Hash)(poj3349,poj3274,POJ2151,poj1840,poj2002,poj2503)(5)哈夫曼树(poj3253)(6)堆(7)trie树(静态建树、动态建树) (poj2513)四.简单搜索(1)深度优先搜索 (poj2488,poj3083,poj3009,poj1321,poj2251)(2)广度优先搜索(poj3278,poj1426,poj3126,poj3087.poj3414)(3)简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129)五.动态规划(1)背包问题. (poj1837,poj1276)(2)型如下表的简单DP(可参考lrj的书 page149):1.E[j]&#x3D;opt{D+w(i,j)} (poj3267,poj1836,poj1260,poj2533)2.E[i,j]&#x3D;opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (最长公共子序列)(poj3176,poj1080,poj1159)3.C[i,j]&#x3D;w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)六.数学(1)组合数学:1.加法原理和乘法原理.2.排列组合.3.递推关系.(POJ3252,poj1850,poj1019,poj1942)(2)数论.1.素数与整除问题2.进制位.3.同余模运算.(poj2635, poj3292,poj1845,poj2115)(3)计算方法.1.二分法求解单调函数相关知识.(poj3273,poj3258,poj1905,poj3122)七.计算几何学.(1)几何公式.(2)叉积和点积的运用(如线段相交的判定,点到线段的距离等). (poj2031,poj1039)(3)多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)(poj1408,poj1584)(4)凸包. (poj2187,poj1113) （七） 第一阶段：练经典常用算法，下面的每个算法给我打上十到二十遍，同时自己精简代码，因为太常用，所以要练到写时不用想，10-15分钟内打完，甚至关掉显示器都可以把程序打出来.1.最短路(Floyd、Dijstra,BellmanFord)2.最小生成树(先写个prim,kruscal要用并查集，不好写)3.大数（高精度）加减乘除4.二分查找. (代码可在五行以内)5.叉乘、判线段相交、然后写个凸包.6.BFS、DFS,同时熟练hash表(要熟，要灵活,代码要简)7.数学上的有：辗转相除（两行内），线段交点、多角形面积公式.8. 调用系统的qsort, 技巧很多，慢慢掌握.9. 任意进制间的转换 第二阶段：练习复杂一点，但也较常用的算法。如： 二分图匹配（匈牙利），最小路径覆盖 网络流，最小费用流。 线段树. 并查集。 熟悉动态规划的各个典型：LCS、最长递增子串、三角剖分、记忆化dp 6.博弈类算法。博弈树，二进制法等。7.最大团，最大独立集。8.判断点在多边形内。9. 差分约束系统.10. 双向广度搜索、A*算法，最小耗散优先. （八） 搞实际项目的话基本用不着多少。lss说的那点都已经多了。当然，偶个人觉得，判断一个问题是否NPC&#x2F;NPH还是比较有用的，判是以后就不会把自己的经历浪费在寻找多项式算法上了。这点acm要用，实际项目偶觉得也有用。 acm的话上面贴的那一长串还不够用。所谓不够用，第一，指这些就算都会都不会写错，不会建立dp模型不会建立图论模型的话一样能挂得很惨，这种活的东西不是死做题就能会的。第二，这表还不全。既然图可以扯到最优比率生成树，那博弈的话至少也得扯SG定理，串的话至少也得扯AC自动机（吐槽：不是自动AC机）， （九）补充中。。。。 浙江大学 http://acm.zju.edu.cn 北京大学 http://acm.pku.edu.cn/JudgeOnline天津大学 http://acm.tju.edu.cn 厦门大学 http://acm.xmu.edu.cn/JudgeOnline福州大学 http://acm.fzu.edu.cn 华中科技 http://acm.hust.edu.cn/JudgeOnline宁波理工 http://acm.nit.net.cn 合肥工大 http://acm.tdzl.net:83/JudgeOnline汕头大学 http://acm.stu.edu.cn 北大内部 http://ai.pku.cn/JudgeOnline中国科大 http://acm.ustc.edu.cn 暨南大学 http://202.116.24.78/JudgeOnline浙江工业 http://acm.zjut.edu.cn 中山大学 http://202.116.77.69/sicily福建师范 http://acm.fjnu.edu.cn 哈工业大 http://acm.hit.edu.cn/ojs/ojs.php杭电科大 http://acm.hziee.edu.cn 四川大学 http://acm.scu.edu.cn/soj哈工程大 http://acm.hrbeu.edu.cn 武汉大学 http://acm.whu.edu.cn/noah同济大学 http://acm.tongji.edu.cn 湖南大学 http://acm.hnu.cn:8080/online/?上海大学 http://pc.shu.edu.cn/openjudge/problemlist.php兰州大学 http://acm.sundayclub.cn/JudgeOnline/problemlist OJ上的一些水题(可用来练手和增加自信)(poj3299,poj2159,poj2739,poj1083,poj2262,poj1503,poj3006,poj2255,poj3094)初期:一.基本算法:(1)枚举. (poj1753,poj2965)(2)贪心(poj1328,poj2109,poj2586)(3)递归和分治法.(4)递推.(5)构造法.(poj3295)(6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996)二.图算法:(1)图的深度优先遍历和广度优先遍历.(2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra)(poj1860,poj3259,poj1062,poj2253,poj1125,poj2240)(3)最小生成树算法(prim,kruskal)(poj1789,poj2485,poj1258,poj3026)(4)拓扑排序 (poj1094)(5)二分图的最大匹配 (匈牙利算法) (poj3041,poj3020)(6)最大流的增广路算法(KM算法). (poj1459,poj3436)三.数据结构.(1)串 (poj1035,poj3080,poj1936)(2)排序(快排、归并排(与逆序数有关)、堆排) (poj2388,poj2299)(3)简单并查集的应用.(4)哈希表和二分查找等高效查找法(数的Hash,串的Hash)(poj3349,poj3274,POJ2151,poj1840,poj2002,poj2503)(5)哈夫曼树(poj3253)(6)堆(7)trie树(静态建树、动态建树) (poj2513)四.简单搜索(1)深度优先搜索 (poj2488,poj3083,poj3009,poj1321,poj2251)(2)广度优先搜索(poj3278,poj1426,poj3126,poj3087.poj3414)(3)简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129)五.动态规划(1)背包问题. (poj1837,poj1276)(2)型如下表的简单DP(可参考lrj的书 page149):1.E[j]&#x3D;opt{D[i]+w(i,j)} (poj3267,poj1836,poj1260,poj2533)2.E[i,j]&#x3D;opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (最长公共子序列)(poj3176,poj1080,poj1159)3.C[i,j]&#x3D;w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)六.数学(1)组合数学:1.加法原理和乘法原理.2.排列组合.3.递推关系.(POJ3252,poj1850,poj1019,poj1942)(2)数论.1.素数与整除问题2.进制位.3.同余模运算.(poj2635, poj3292,poj1845,poj2115)(3)计算方法.1.二分法求解单调函数相关知识.(poj3273,poj3258,poj1905,poj3122)七.计算几何学.(1)几何公式.(2)叉积和点积的运用(如线段相交的判定,点到线段的距离等). (poj2031,poj1039)(3)多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)(poj1408,poj1584)(4)凸包. (poj2187,poj1113)中级:一.基本算法:(1)C++的标准模版库的应用. (poj3096,poj3007)(2)较为复杂的模拟题的训练(poj3393,poj1472,poj3371,poj1027,poj2706)二.图算法:(1)差分约束系统的建立和求解. (poj1201,poj2983)(2)最小费用最大流(poj2516,poj2516,poj2195)(3)双连通分量(poj2942)(4)强连通分支及其缩点.(poj2186)(5)图的割边和割点(poj3352)(6)最小割模型、网络流规约(poj3308, )三.数据结构.(1)线段树. (poj2528,poj2828,poj2777,poj2886,poj2750)(2)静态二叉检索树. (poj2482,poj2352)(3)树状树组(poj1195,poj3321)(4)RMQ. (poj3264,poj3368)(5)并查集的高级应用. (poj1703,2492)(6)KMP算法. (poj1961,poj2406)四.搜索(1)最优化剪枝和可行性剪枝(2)搜索的技巧和优化 (poj3411,poj1724)(3)记忆化搜索(poj3373,poj1691) 五.动态规划(1)较为复杂的动态规划(如动态规划解特别的施行商问题等)(poj1191,poj1054,poj3280,poj2029,poj2948,poj1925,poj3034)(2)记录状态的动态规划. (POJ3254,poj2411,poj1185)(3)树型动态规划(poj2057,poj1947,poj2486,poj3140)六.数学(1)组合数学:1.容斥原理.2.抽屉原理.3.置换群与Polya定理(poj1286,poj2409,poj3270,poj1026).4.递推关系和母函数. (2)数学.1.高斯消元法(poj2947,poj1487, poj2065,poj1166,poj1222)2.概率问题. (poj3071,poj3440)3.GCD、扩展的欧几里德(中国剩余定理) (poj3101)(3)计算方法.1.0&#x2F;1分数规划. (poj2976)2.三分法求解单峰(单谷)的极值.3.矩阵法(poj3150,poj3422,poj3070)4.迭代逼近(poj3301)(4)随机化算法(poj3318,poj2454)(5)杂题.(poj1870,poj3296,poj3286,poj1095)七.计算几何学.(1)坐标离散化.(2)扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).(poj1765,poj1177,poj1151,poj3277,poj2280,poj3004)(3)多边形的内核(半平面交)(poj3130,poj3335)(4)几何工具的综合应用.(poj1819,poj1066,poj2043,poj3227,poj2165,poj3429)高级:一.基本算法要求:(1)代码快速写成,精简但不失风格(poj2525,poj1684,poj1421,poj1048,poj2050,poj3306)(2)保证正确性和高效性. poj3434二.图算法:(1)度限制最小生成树和第K最短路. (poj1639)(2)最短路,最小生成树,二分图,最大流问题的相关理论(主要是模型建立和求解)(poj3155, poj2112,poj1966,poj3281,poj1087,poj2289,poj3216,poj2446(3)最优比率生成树. (poj2728)(4)最小树形图(poj3164)(5)次小生成树.(6)无向图、有向图的最小环三.数据结构.(1)trie图的建立和应用. (poj2778)(2)LCA和RMQ问题(LCA(最近公共祖先问题) 有离线算法(并查集+dfs) 和 在线算法(RMQ+dfs)).(poj1330)(3)双端队列和它的应用(维护一个单调的队列,常常在动态规划中起到优化状态转移的目的). (poj2823)(4)左偏树(可合并堆).(5)后缀树(非常有用的数据结构,也是赛区考题的热点).(poj3415,poj3294)四.搜索(1)较麻烦的搜索题目训练(poj1069,poj3322,poj1475,poj1924,poj2049,poj3426)(2)广搜的状态优化:利用M进制数存储状态、转化为串用hash表判重、按位压缩存储状态、双向广搜、A算法. (poj1768,poj1184,poj1872,poj1324,poj2046,poj1482)(3)深搜的优化:尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大、可以考虑双向搜索或者是轮换搜索、IDA算法. (poj3131,poj2870,poj2286)五.动态规划(1)需要用数据结构优化的动态规划.(poj2754,poj3378,poj3017)(2)四边形不等式理论.(3)较难的状态DP(poj3133)六.数学(1)组合数学.1.MoBius反演(poj2888,poj2154)2.偏序关系理论.(2)博奕论.1.极大极小过程(poj3317,poj1085)2.Nim问题.七.计算几何学.(1)半平面求交(poj3384,poj2540)(2)可视图的建立(poj2966)(3)点集最小圆覆盖.(4)对踵点(poj2079)八.综合题.(poj3109,poj1478,poj1462,poj2729,poj2048,poj3336,poj3315,poj2148,poj1263) 同时由于个人练习的时候可能有些偏向性,可能上面的总结不是很全,还请大家提出和指正,而且由于ACM的题目中专门针对某个算法的题目可能比较少出现,所以上面的分类中的题有可能有多种解法或者是一些算法的综合,这都不会影响大家做题,希望练习的同学能够认真,扎实地训练,做到真正的理解算法,掌握算法.同时在论坛上还有许多前辈的分类,总结,大家也可以按自己的情况采用.注意FTP上有很多的资料,希望大家好好地利用. 如果同学能在明年暑假前能掌握上面大部分算法,那你也基本上达到了训练的目的,到暑假的时候你就可以选择自己比较喜欢的方面进行加深和强化,而且同学们不要觉得看算法的证明是很麻烦的事,这可以加强你的思维能力,这在ACM中也很重要.同时也希望老队员能帮助我整理习题和题目分类.同时ACM的题目是没有范围的,只能在平时中多积累多练习,多比别人多努力一点,你就会比别人多一线希望. 我补充些动态规划、搜索方面的资料吧。 Dp状态设计与方程总结 1.不完全状态记录&lt;1&gt;青蛙过河问题&lt;2&gt;利用区间dp2.背包类问题&lt;1&gt; 0-1背包，经典问题&lt;2&gt;无限背包，经典问题&lt;3&gt;判定性背包问题&lt;4&gt;带附属关系的背包问题&lt;5&gt; + -1背包问题&lt;6&gt;双背包求最优值&lt;7&gt;构造三角形问题&lt;8&gt;带上下界限制的背包问题(012背包)3.线性的动态规划问题&lt;1&gt;积木游戏问题&lt;2&gt;决斗（判定性问题）&lt;3&gt;圆的最大多边形问题&lt;4&gt;统计单词个数问题&lt;5&gt;棋盘分割&lt;6&gt;日程安排问题&lt;7&gt;最小逼近问题(求出两数之比最接近某数&#x2F;两数之和等于某数等等)&lt;8&gt;方块消除游戏(某区间可以连续消去求最大效益)&lt;9&gt;资源分配问题&lt;10&gt;数字三角形问题&lt;11&gt;漂亮的打印&lt;12&gt;邮局问题与构造答案&lt;13&gt;最高积木问题&lt;14&gt;两段连续和最大&lt;15&gt;2次幂和问题&lt;16&gt;N个数的最大M段子段和&lt;17&gt;交叉最大数问题4.判定性问题的dp(如判定整除、判定可达性等)&lt;1&gt;模K问题的dp&lt;2&gt;特殊的模K问题，求最大(最小)模K的数&lt;3&gt;变换数问题5.单调性优化的动态规划&lt;1&gt;1-SUM问题&lt;2&gt;2-SUM问题&lt;3&gt;序列划分问题(单调队列优化)6.剖分问题(多边形剖分&#x2F;石子合并&#x2F;圆的剖分&#x2F;乘积最大)&lt;1&gt;凸多边形的三角剖分问题&lt;2&gt;乘积最大问题&lt;3&gt;多边形游戏(多边形边上是操作符,顶点有权值)&lt;4&gt;石子合并(N^3&#x2F;N^2&#x2F;NLogN各种优化)7.贪心的动态规划&lt;1&gt;最优装载问题&lt;2&gt;部分背包问题&lt;3&gt;乘船问题&lt;4&gt;贪心策略&lt;5&gt;双机调度问题Johnson算法8.状态dp&lt;1&gt;牛仔射击问题(博弈类)&lt;2&gt;哈密顿路径的状态dp&lt;3&gt;两支点天平平衡问题&lt;4&gt;一个有向图的最接近二部图9.树型dp&lt;1&gt;完美服务器问题(每个节点有3种状态)&lt;2&gt;小胖守皇宫问题&lt;3&gt;网络收费问题&lt;4&gt;树中漫游问题&lt;5&gt;树上的博弈&lt;6&gt;树的最大独立集问题&lt;7&gt;树的最大平衡值问题&lt;8&gt;构造树的最小环 先掌握搜索，动态规划，贪心这些思想方法然后学习各种技巧 ACM基本算法分类 ACM基本算法分类、推荐学习资料和配套pku习题一.动态规划 参考资料： 刘汝佳《算法艺术与信息学竞赛》《算法导论》 推荐题目： http://acm.pku.edu.cn/JudgeOnline/problem?id=1141 简单 http://acm.pku.edu.cn/JudgeOnline/problem?id=2288 中等，经典TSP问题 http://acm.pku.edu.cn/JudgeOnline/problem?id=2411 中等，状态压缩DP http://acm.pku.edu.cn/JudgeOnline/problem?id=1112 中等 http://acm.pku.edu.cn/JudgeOnline/problem?id=1848 中等，树形DP。可参考《算法艺术与信息学竞赛》动态规划一节的树状模型 http://acm.zju.edu.cn/show_problem.php?pid=1234 中等，《算法艺术与信息学竞赛》中的习题 http://acm.pku.edu.cn/JudgeOnline/problem?id=1947 中等，《算法艺术与信息学竞赛》中的习题 http://acm.pku.edu.cn/JudgeOnline/problem?id=1946 中等，《算法艺术与信息学竞赛》中的习题 http://acm.pku.edu.cn/JudgeOnline/problem?id=1737 中等，递推 http://acm.pku.edu.cn/JudgeOnline/problem?id=1821 中等，需要减少冗余计算 http://acm.zju.edu.cn/show_problem.php?pid=2561 中等，四边形不等式的简单应用 http://acm.pku.edu.cn/JudgeOnline/problem?id=1038 较难，状态压缩DP，《算法艺术与信息学竞赛》中有解答 http://acm.pku.edu.cn/JudgeOnline/problem?id=1390 较难，《算法艺术与信息学竞赛》中有解答 http://acm.pku.edu.cn/JudgeOnline/problem?id=3017 较难，需要配合数据结构优化（我的题目^_^） http://acm.pku.edu.cn/JudgeOnline/problem?id=1682 较难，写起来比较麻烦 http://acm.pku.edu.cn/JudgeOnline/problem?id=2047 较难 http://acm.pku.edu.cn/JudgeOnline/problem?id=2152 难，树形DP http://acm.pku.edu.cn/JudgeOnline/problem?id=3028 难，状态压缩DP，题目很有意思 http://acm.pku.edu.cn/JudgeOnline/problem?id=3124 难 http://acm.pku.edu.cn/JudgeOnline/problem?id=2915 非常难 二.搜索 参考资料： 刘汝佳《算法艺术与信息学竞赛》 推荐题目： http://acm.pku.edu.cn/JudgeOnline/problem?id=1011 简单，深搜入门题 http://acm.pku.edu.cn/JudgeOnline/problem?id=1324 中等，广搜 http://acm.pku.edu.cn/JudgeOnline/problem?id=2044 中等，广搜 http://acm.pku.edu.cn/JudgeOnline/problem?id=2286 较难，广搜 http://acm.pku.edu.cn/JudgeOnline/problem?id=1945 难，IDA*，迭代加深搜索，需要较好的启发函数 http://acm.pku.edu.cn/JudgeOnline/problem?id=2449 难，可重复K最短路，A*。可参考解题报告: http://acm.pku.edu.cn/JudgeOnline/showcontest?contest_id=1144 http://acm.pku.edu.cn/JudgeOnline/problem?id=1190 难，深搜剪枝，《算法艺术与信息学竞赛》中有解答 http://acm.pku.edu.cn/JudgeOnline/problem?id=1084 难，《算法艺术与信息学竞赛》习题 http://acm.pku.edu.cn/JudgeOnline/problem?id=2989 难，深搜 http://acm.pku.edu.cn/JudgeOnline/problem?id=1167 较难，《算法艺术与信息学竞赛》中有解答 http://acm.pku.edu.cn/JudgeOnline/problem?id=1069 很难 三. 常用数据结构 参考资料： 刘汝佳《算法艺术与信息学竞赛》 《算法导论》 线段树资料： http://home.ustc.edu.cn/~zhuhcheng/ACM/segment_tree.pdf 树状数组资料 http://home.ustc.edu.cn/~zhuhcheng/ACM/tree.ppt 关于线段树和树状数组更多相关内容可在网上搜到 后缀数组资料 http://home.ustc.edu.cn/~zhuhcheng/ACM/suffix_array.pdf http://home.ustc.edu.cn/~zhuhcheng/ACM/linear_suffix.pdf 推荐题目 http://acm.pku.edu.cn/JudgeOnline/problem?id=2482 较难，线段树应用，《算法艺术与信息学竞赛》中有解答 http://acm.pku.edu.cn/JudgeOnline/problem?id=1151 简单，线段树应用矩形面积并，《算法艺术与信息学竞赛》中有解答 http://acm.pku.edu.cn/JudgeOnline/problem?id=3225 较难，线段树应用，可参考解题报告 http://acm.pku.edu.cn/JudgeOnline/showcontest?contest_id=1233 http://acm.pku.edu.cn/JudgeOnline/problem?id=2155 难，二维树状数组。 http://acm.pku.edu.cn/JudgeOnline/problem?id=2777 中等，线段树应用。 http://acm.pku.edu.cn/JudgeOnline/problem?id=2274 难，堆的应用，《算法艺术与信息学竞赛》中有解答 http://acm.zju.edu.cn/show_problem.php?pid=2334 中等，左偏树，二项式堆或其他可合并堆的应用。 左偏树参考 http://www.nist.gov/dads/HTML/leftisttree.html 二项式堆参见《算法导论》相关章节 http://acm.pku.edu.cn/JudgeOnline/problem?id=1182 中等，并查集 http://acm.pku.edu.cn/JudgeOnline/problem?id=1816 中等，字典树 http://acm.pku.edu.cn/JudgeOnline/problem?id=2778 较难，多串匹配树 参考： http://home.ustc.edu.cn/~zhuhcheng/ACM/zzy2004.pdf http://acm.pku.edu.cn/JudgeOnline/problem?id=1743 难，后缀数组 http://acm.pku.edu.cn/JudgeOnline/problem?id=2774 较难，最长公共子串，经典问题，后缀数组 http://acm.pku.edu.cn/JudgeOnline/problem?id=2758 很难，后缀数组 可参考解题报告 http://acm.pku.edu.cn/JudgeOnline/showcontest?contest_id=1178 http://acm.pku.edu.cn/JudgeOnline/problem?id=2448 很难，数据结构综合运用 四.图论基础 参考资料： 刘汝佳《算法艺术与信息学竞赛》《算法导论》《网络算法与复杂性理论》谢政 推荐题目: http://acm.pku.edu.cn/JudgeOnline/problem?id=2337 简单，欧拉路 http://acm.pku.edu.cn/JudgeOnline/problem?id=3177 中等，无向图割边 http://acm.pku.edu.cn/JudgeOnline/problem?id=2942 较难，无向图双连通分支 http://acm.pku.edu.cn/JudgeOnline/problem?id=1639 中等，最小度限制生成树，《算法艺术与信息学竞赛》中有解答 http://acm.pku.edu.cn/JudgeOnline/problem?id=2728 中等，最小比率生成树，《算法艺术与信息学竞赛》中有解答 http://acm.pku.edu.cn/JudgeOnline/problem?id=3013 简单，最短路问题 http://acm.pku.edu.cn/JudgeOnline/problem?id=1275 中等，差分约束系统，Bellman-Ford求解，《算法艺术与信息学竞赛》中有解答 http://acm.pku.edu.cn/JudgeOnline/problem?id=1252 简单，Bellman-Ford http://acm.pku.edu.cn/JudgeOnline/problem?id=1459 中等，网络流 http://acm.pku.edu.cn/JudgeOnline/problem?id=2391 较难，网络流 http://acm.pku.edu.cn/JudgeOnline/problem?id=1325 中等，二部图最大匹配 http://acm.pku.edu.cn/JudgeOnline/problem?id=2226 较难，二部图最大匹配 http://acm.pku.edu.cn/JudgeOnline/problem?id=2195 中等，二部图最大权匹配 KM算法参考《网络算法与复杂性理论》 http://acm.pku.edu.cn/JudgeOnline/problem?id=2516 较难，二部图最大权匹配 http://acm.pku.edu.cn/JudgeOnline/problem?id=1986 中等，LCA（最近公共祖先）问题 参考Tarjan’s LCA algorithm 《算法导论》第21章习题 http://acm.pku.edu.cn/JudgeOnline/problem?id=2723 较难，2-SAT问题 参考：http://home.ustc.edu.cn/~zhuhcheng/ACM/2-SAT.PPT http://acm.pku.edu.cn/JudgeOnline/problem?id=2749 较难，2-SAT问题 http://acm.pku.edu.cn/JudgeOnline/problem?id=3164 较难，最小树形图 参考《网络算法与复杂性理论》中朱-刘算法 五.数论及组合计数基础 http://acm.pku.edu.cn/JudgeOnline/problem?id=1811 简单，素数判定，大数分解 参考算法导论相关章节 http://acm.pku.edu.cn/JudgeOnline/problem?id=2888 较难，Burnside引理 http://acm.pku.edu.cn/JudgeOnline/problem?id=2891 中等，解模方程组 http://acm.pku.edu.cn/JudgeOnline/problem?id=2154 中等，经典问题，波利亚定理 http://cs.scu.edu.cn/soj/problem.action?id=2703 难，极好的题目，Burnside引理+模线性方程组 http://acm.pku.edu.cn/JudgeOnline/problem?id=2764 较难，需要数学方法，该方法在《具体数学》第七章有讲 http://acm.pku.edu.cn/JudgeOnline/problem?id=1977 简单，矩阵快速乘法 第01篇 ACM&#x2F;ICPC竞赛之基础篇一、ACM&#x2F;ICPC竞赛的特点 ACM&#x2F;ICPC（国际大学生程序设计竞赛）是以算法设计为主的程序设计竞赛，并不涉及具体的应用技术。 ACM&#x2F;ICPC竞赛以组队形式参赛，每个参赛队由三名队员组成，共同使用一台计算机解题。通常每场比赛的试题为6至10题，根据各队的完成题数和罚时进行排名。题目提交通过称为完成，从比赛开始到提交成功所用的时间为题目的基础罚时，另外，一道题目每提交失败一次，将增加20分钟罚时。也就是说，参赛队要尽可能用最快的速度、最少的失败次数，解决最多的题目。 二、输入和输出处理试题一般采用标准输入和输出方式读取输入和产生输出，在题目中会详细描述输入和输出的格式和值域范围，所写的程序一定要严格遵守题目指定的输入输出格式。 在比赛试题的输入和输出处理上，针对一些常见的情形，有一些常用的方法。 1、多测试用例的输入和输出 有些试题在一次输入中只包含一个测试用例，也就是说，程序每运行一次，只算一道题。也有些试题在一次输入中包含多个测试用例，也就是说，程序每运行一次，要计算多道题。 对多用例输入，通常会先输入要计算的用例的个数，然后依次输入每个测试用例的输入数据，但程序并不需要等到所有的测试用例都计算完后再输出所有测试用例的计算结果，而是可以读入一个测试用例，输出一个结果，再读入一个测试用例，再输出一个结果。因此对多用例输入的试题，可以用这样的输入模式： 以C++为例： int n; cin &gt;&gt; n; for (int i&#x3D;0; i&lt;n; i++) { 读入测试用例数据 计算 输出计算结果 } 2、单测试用例输入的结束判断对单用例输入，最主要的问题是如何知道输入什么时候结束。 有些试题会指定某种特殊的输入值作为输入的结束标志，这种情况比较容易处理，只须在读入后，判断一下读入的内容是否为约定结束值即可。 有些试题并不指定特殊的输入值，而是以EOF（文件结束标志）作为结束标志。如果从文件流读入，当读到文件尾时，输入返回EOF。如果从键盘读入时，在Windows的终端中，是以Ctrl+Z表示EOF。对于这种情况，可以用这样的输入模式： 以C++为例： int m, n; &#x2F;&#x2F; 假设要连续输入一组整数对 while (cin&gt;&gt;m&gt;&gt;n) { 处理整数对(m, n) } 以C语言为例： int m, n; while (scanf(“%d%d”, &amp;m, &amp;n)&#x3D;&#x3D;2) { 处理整数对(m, n) } 三、数据结构的设计很多试题中已经给出了数据量的上限，因此可以很方便地以数组的方式定义数据结构。但也要注意到有些题目中没有明确指出数据上限时，切不可盲目定义数组大小。 例如在题1070（多项式求和）中，并未说明输入多项式的项数，对这种情况就不宜用数组方式来表示多项式了——除非你的运气足够好，所开辟的数组大小能够经受所有的测试用例的考验。 除了使用一般的数组或链表结构外，对使用C++的选手来说，STL也是一大利器，充分运用可以有效提高编程的效率和正确性。 四、测试用例的考虑在试题中通常会给出测试用例的样例，这通常会被我们用来测试自己的程序，而且很多选手往往在正确计算出测试用例样例时，会认为自己的程序是正确的。 其实测试用例的样例只是测试用例的个例，实际用于测试的测试用例往往会涵盖各种极限情况和边界情况，而且有时测试用例的数量还会比较大，甚至会重复测试同一个测试用例。因此我们的程序能够通过样例测试，未必能够通过所有的测试用例的测试，一方面要全面考虑所有可能的极限情况和边界情况，一方面程序要有足够的效率。 2008-7-17 01:29 回复 狂晕的迷战士14位粉丝2楼第03篇 ACM&#x2F;ICPC竞赛之STL–pairSTL的头文件中描述了一个看上去非常简单的模板类pair，用来表示一个二元组或元素对，并提供了按照字典序对元素对进行大小比较的比较运算符模板函数。 例如，想要定义一个对象表示一个平面坐标点，则可以： pair&lt;double, double&gt; p1;cin &gt;&gt; p1.first &gt;&gt; p1.second; pair模板类需要两个参数：首元素的数据类型和尾元素的数据类型。pair模板类对象有两个成员：first和second，分别表示首元素和尾元素。 在中已经定义了pair上的六个比较运算符：&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;、&#x3D;&#x3D;、!&#x3D;，其规则是先比较first，first相等时再比较second，这符合大多数应用的逻辑。当然，也可以通过重载这几个运算符来重新指定自己的比较逻辑。 除了直接定义一个pair对象外，如果需要即时生成一个pair对象，也可以调用在中定义的一个模板函数：make_pair。make_pair需要两个参数，分别为元素对的首元素和尾元素。 在题1067–Ugly Numbers中，就可以用pair来表示推演树上的结点，用first表示结点的值，用second表示结点是由父结点乘以哪一个因子得到的。 #include #include using namespace std;typedef pair&lt;unsigned long, int&gt; node_type;main(){ unsigned long result[1500];priority_queue&lt; node_type, vector, greater &gt; Q;Q.push( make_pair(1, 2) );for (int i&#x3D;0; i&lt;1500; i++){node_type node &#x3D; Q.top();Q.pop();switch(node.second){ case 2: Q.push( make_pair(node.first*2, 2) );case 3: Q.push( make_pair(node.first*3, 3) );case 5: Q.push( make_pair(node.first*5, 5) );}result[i] &#x3D; node.first;}int n; cin &gt;&gt; n;while (n&gt;0){cout &lt;&lt; result[n-1] &lt;&lt; endl;cin &gt;&gt; n;}return 1;}看上去是很简单的一个头文件，但是的设计中却浓缩反映了STL设计的基本思想。有意深入了解和研究STL的同学，仔细阅读和体会这个简单的头文件，不失为一种入门的途径。2008-7-17 01:31 回复 狂晕的迷战士14位粉丝3楼第04篇 ACM&#x2F;ICPC竞赛之STL–vector在STL的头文件中定义了vector（向量容器模板类），vector容器以连续数组的方式存储元素序列，可以将vector看作是以顺序结构实现的线性表。当我们在程序中需要使用动态数组时，vector将会是理想的选择，vector可以在使用过程中动态地增长存储空间。 vector模板类需要两个模板参数，第一个参数是存储元素的数据类型，第二个参数是存储分配器的类型，其中第二个参数是可选的，如果不给出第二个参数，将使用默认的分配器。 下面给出几个常用的定义vector向量对象的方法示例： vector s;定义一个空的vector对象，存储的是int类型的元素。 vector s(n);定义一个含有n个int元素的vector对象。 vector s(first, last);定义一个vector对象，并从由迭代器first和last定义的序列[first, last)中复制初值。 vector的基本操作有： s[i]直接以下标方式访问容器中的元素。 s.front()返回首元素。 s.back()返回尾元素。 s.push_back(x)向表尾插入元素x。 s.size()返回表长。 s.empty()当表空时，返回真，否则返回假。 s.pop_back()删除表尾元素。 s.begin()返回指向首元素的随机存取迭代器。 s.end()返回指向尾元素的下一个位置的随机存取迭代器。 s.insert(it, x)向迭代器it指向的元素前插入新元素val。 s.insert(it, n, x)向迭代器it指向的元素前插入n个x。 s.insert(it, first, last)将由迭代器first和last所指定的序列[first, last)插入到迭代器it指向的元素前面。 s.erase(it)删除由迭代器it所指向的元素。 s.erase(first, last)删除由迭代器first和last所指定的序列[first, last)。 s.reserve(n)预分配缓冲空间，使存储空间至少可容纳n个元素。 s.resize(n)改变序列的长度，超出的元素将会被删除，如果序列需要扩展（原空间小于n），元素默认值将填满扩展出的空间。 s.resize(n, val)改变序列的长度，超出的元素将会被删除，如果序列需要扩展（原空间小于n），将用val填满扩展出的空间。 s.clear()删除容器中的所有的元素。 s.swap(v)将s与另一个vector对象v进行交换。 s.assign(first, last)将序列替换成由迭代器first和last所指定的序列[first, last)。[first, last)不能是原序列中的一部分。 要注意的是，resize操作和clear操作都是对表的有效元素进行的操作，但并不一定会改变缓冲空间的大小。 另外，vector还有其他一些操作如反转、取反等，不再一下列举。 vector上还定义了序列之间的比较操作运算符(&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;, &#x3D;&#x3D;, !&#x3D;)，可以按照字典序比较两个序列。 还是来看一些示例代码。输入个数不定的一组整数，再将这组整数按倒序输出，如下所示： #include #include using namespace std;main(){vector L;int x;while (cin&gt;&gt;x) L.push_back(x);for (int i&#x3D;L.size()-1; i&gt;&#x3D;0; i–) cout &lt;&lt; L[i] &lt;&lt; “ “;cout &lt;&lt; endl;return 1;}2008-7-17 01:31 回复 狂晕的迷战士14位粉丝4楼第04篇 ACM&#x2F;ICPC竞赛之STL–vector在STL的头文件中定义了vector（向量容器模板类），vector容器以连续数组的方式存储元素序列，可以将vector看作是以顺序结构实现的线性表。当我们在程序中需要使用动态数组时，vector将会是理想的选择，vector可以在使用过程中动态地增长存储空间。 vector模板类需要两个模板参数，第一个参数是存储元素的数据类型，第二个参数是存储分配器的类型，其中第二个参数是可选的，如果不给出第二个参数，将使用默认的分配器。 下面给出几个常用的定义vector向量对象的方法示例： vector s;定义一个空的vector对象，存储的是int类型的元素。 vector s(n);定义一个含有n个int元素的vector对象。 vector s(first, last);定义一个vector对象，并从由迭代器first和last定义的序列[first, last)中复制初值。 vector的基本操作有： s[i]直接以下标方式访问容器中的元素。 s.front()返回首元素。 s.back()返回尾元素。 s.push_back(x)向表尾插入元素x。 s.size()返回表长。 s.empty()当表空时，返回真，否则返回假。 s.pop_back()删除表尾元素。 s.begin()返回指向首元素的随机存取迭代器。 s.end()返回指向尾元素的下一个位置的随机存取迭代器。 s.insert(it, x)向迭代器it指向的元素前插入新元素val。 s.insert(it, n, x)向迭代器it指向的元素前插入n个x。 s.insert(it, first, last)将由迭代器first和last所指定的序列[first, last)插入到迭代器it指向的元素前面。 s.erase(it)删除由迭代器it所指向的元素。 s.erase(first, last)删除由迭代器first和last所指定的序列[first, last)。 s.reserve(n)预分配缓冲空间，使存储空间至少可容纳n个元素。 s.resize(n)改变序列的长度，超出的元素将会被删除，如果序列需要扩展（原空间小于n），元素默认值将填满扩展出的空间。 s.resize(n, val)改变序列的长度，超出的元素将会被删除，如果序列需要扩展（原空间小于n），将用val填满扩展出的空间。 s.clear()删除容器中的所有的元素。 s.swap(v)将s与另一个vector对象v进行交换。 s.assign(first, last)将序列替换成由迭代器first和last所指定的序列[first, last)。[first, last)不能是原序列中的一部分。 要注意的是，resize操作和clear操作都是对表的有效元素进行的操作，但并不一定会改变缓冲空间的大小。 另外，vector还有其他一些操作如反转、取反等，不再一下列举。 vector上还定义了序列之间的比较操作运算符(&gt;, &lt;, &gt;&#x3D;, &lt;&#x3D;, &#x3D;&#x3D;, !&#x3D;)，可以按照字典序比较两个序列。 还是来看一些示例代码。输入个数不定的一组整数，再将这组整数按倒序输出，如下所示： #include #include using namespace std;main(){vector L;int x;while (cin&gt;&gt;x) L.push_back(x);for (int i&#x3D;L.size()-1; i&gt;&#x3D;0; i–) cout &lt;&lt; L[i] &lt;&lt; “ “;cout &lt;&lt; endl;return 1;}2008-7-17 01:32 回复 狂晕的迷战士14位粉丝5楼第05篇 ACM&#x2F;ICPC竞赛之STL–iterator简介iterator(迭代器)是用于访问容器中元素的指示器，从这个意义上说，iterator(迭代器)相当于数据结构中所说的“遍历指针”，也可以把iterator(迭代器)看作是一种泛化的指针。 STL中关于iterator(迭代器)的实现是相当复杂的，这里我们暂时不去详细讨论关于iterator(迭代器)的实现和使用，而只对iterator(迭代器)做一点简单的介绍。 简单地说，STL中有以下几类iterator(迭代器)： 输入iterator(迭代器)，在容器的连续区间内向前移动，可以读取容器内任意值；输出iterator(迭代器)，把值写进它所指向的容器中；前向iterator(迭代器)，读取队列中的值，并可以向前移动到下一位置(++p,p++)；双向iterator(迭代器)，读取队列中的值，并可以向前向后遍历容器；随机访问iterator(迭代器), 可以直接以下标方式对容器进行访问，vector的iterator(迭代器)就是这种iterator(迭代器)；流iterator(迭代器)，可以直接输出、输入流中的值；每种STL容器都有自己的iterator(迭代器)子类，下面先来看一段简单的示例代码： #include #include using namespace std;main(){vector s;for (int i&#x3D;0; i&lt;10; i++) s.push_back(i);for (vector::iterator it&#x3D;s.begin(); it!&#x3D;s.end(); it++)cout &lt;&lt; *it &lt;&lt; “ “;cout &lt;&lt; endl;return 1;} vector的begin()和end()方法都会返回一个vector::iterator对象，分别指向vector的首元素位置和尾元素的下一个位置（我们可以称之为结束标志位置）。 对一个iterator(迭代器)对象的使用与一个指针变量的使用极为相似，或者可以这样说，指针就是一个非常标准的iterator(迭代器)。 再来看一段稍微特别一点的代码： #include #include using namespace std;main(){vector s;s.push_back(1);s.push_back(2);s.push_back(3);copy(s.begin(), s.end(), ostream_iterator(cout, “ “));cout &lt;&lt;endl;return 1;} 这段代码中的copy就是STL中定义的一个模板函数，copy(s.begin(), s.end(), ostream_iterator(cout, “ “));的意思是将由s.begin()至s.end()(不含s.end())所指定的序列复制到标准输出流cout中，用” “作为每个元素的间隔。也就是说，这句话的作用其实就是将表中的所有内容依次输出。 iterator(迭代器)是STL容器和算法之间的“胶合剂”，几乎所有的STL算法都是通过容器的iterator(迭代器)来访问容器内容的。只有通过有效地运用iterator(迭代器)，才能够有效地运用STL强大的算法功能。2008-7-17 01:32 回复 狂晕的迷战士14位粉丝6楼第05篇 ACM&#x2F;ICPC竞赛之STL–iterator简介iterator(迭代器)是用于访问容器中元素的指示器，从这个意义上说，iterator(迭代器)相当于数据结构中所说的“遍历指针”，也可以把iterator(迭代器)看作是一种泛化的指针。 STL中关于iterator(迭代器)的实现是相当复杂的，这里我们暂时不去详细讨论关于iterator(迭代器)的实现和使用，而只对iterator(迭代器)做一点简单的介绍。 简单地说，STL中有以下几类iterator(迭代器)： 输入iterator(迭代器)，在容器的连续区间内向前移动，可以读取容器内任意值；输出iterator(迭代器)，把值写进它所指向的容器中；前向iterator(迭代器)，读取队列中的值，并可以向前移动到下一位置(++p,p++)；双向iterator(迭代器)，读取队列中的值，并可以向前向后遍历容器；随机访问iterator(迭代器), 可以直接以下标方式对容器进行访问，vector的iterator(迭代器)就是这种iterator(迭代器)；流iterator(迭代器)，可以直接输出、输入流中的值；每种STL容器都有自己的iterator(迭代器)子类，下面先来看一段简单的示例代码： #include #include using namespace std;main(){vector s;for (int i&#x3D;0; i&lt;10; i++) s.push_back(i);for (vector::iterator it&#x3D;s.begin(); it!&#x3D;s.end(); it++)cout &lt;&lt; *it &lt;&lt; “ “;cout &lt;&lt; endl;return 1;} vector的begin()和end()方法都会返回一个vector::iterator对象，分别指向vector的首元素位置和尾元素的下一个位置（我们可以称之为结束标志位置）。 对一个iterator(迭代器)对象的使用与一个指针变量的使用极为相似，或者可以这样说，指针就是一个非常标准的iterator(迭代器)。 再来看一段稍微特别一点的代码： #include #include using namespace std;main(){vector s;s.push_back(1);s.push_back(2);s.push_back(3);copy(s.begin(), s.end(), ostream_iterator(cout, “ “));cout &lt;&lt;endl;return 1;} 这段代码中的copy就是STL中定义的一个模板函数，copy(s.begin(), s.end(), ostream_iterator(cout, “ “));的意思是将由s.begin()至s.end()(不含s.end())所指定的序列复制到标准输出流cout中，用” “作为每个元素的间隔。也就是说，这句话的作用其实就是将表中的所有内容依次输出。 iterator(迭代器)是STL容器和算法之间的“胶合剂”，几乎所有的STL算法都是通过容器的iterator(迭代器)来访问容器内容的。只有通过有效地运用iterator(迭代器)，才能够有效地运用STL强大的算法功能。2008-7-17 01:33 回复 狂晕的迷战士14位粉丝7楼第06篇 ACM&#x2F;ICPC竞赛之STL–string字符串是程序中经常要表达和处理的数据，我们通常是采用字符数组或字符指针来表示字符串。STL为我们提供了另一种使用起来更为便捷的字符串的表达方式：string。string类的定义在头文件中。 string类其实可以看作是一个字符的vector，vector上的各种操作都可以适用于string，另外，string类对象还支持字符串的拼合、转换等操作。 下面先来看一个简单的例子： #include #include using namespace std;main(){string s &#x3D; “Hello! “, name;cin &gt;&gt; name;s +&#x3D; name;s +&#x3D; ‘!’;cout &lt;&lt; s &lt;&lt; endl;return 1;} 再以题1064–Parencoding为例，看一段用string作为容器，实现由P代码还原括号字符串的示例代码片段： int m;cin &gt;&gt; m; &#x2F;&#x2F; P编码的长度string str; &#x2F;&#x2F; 用来存放还原出来的括号字符串int leftpa &#x3D; 0; &#x2F;&#x2F; 记录已出现的左括号的总数for (int j&#x3D;0; j&lt;m; j++){int p;cin &gt;&gt; p;for (int k&#x3D;0; k&lt;p-leftpa; k++) str +&#x3D; ‘(‘;str +&#x3D; ‘)’;leftpa &#x3D; p;}2008-7-17 01:33 回复 狂晕的迷战士14位粉丝9楼 看下面这个简单的示例： #include #include using namespace std;class T{public:int x, y, z;T(int a, int b, int c):x(a), y(b), z?{}};bool operator &lt; (const T &amp;t1, const T &amp;t2){return t1.z &lt; t2.z; &#x2F;&#x2F; 按照z的顺序来决定t1和t2的顺序}main(){priority_queue q;q.push(T(4,4,3));q.push(T(2,2,5));q.push(T(1,5,4));q.push(T(3,3,6)); while (!q.empty()){T t &#x3D; q.top(); q.pop();cout &lt;&lt; t.x &lt;&lt; “ “ &lt;&lt; t.y &lt;&lt; “ “ &lt;&lt; t.z &lt;&lt; endl;}return 1;} 输出结果为(注意是按照z的顺序从大到小出队的)： 3 3 62 2 51 5 44 4 3 再看一个按照z的顺序从小到大出队的例子： #include #include using namespace std;class T{public:int x, y, z;T(int a, int b, int c):x(a), y(b), z?{}};bool operator &gt; (const T &amp;t1, const T &amp;t2){return t1.z &gt; t2.z;}main(){priority_queue&lt;T, vector, greater &gt; q;q.push(T(4,4,3));q.push(T(2,2,5));q.push(T(1,5,4));q.push(T(3,3,6)); while (!q.empty()){T t &#x3D; q.top(); q.pop();cout &lt;&lt; t.x &lt;&lt; “ “ &lt;&lt; t.y &lt;&lt; “ “ &lt;&lt; t.z &lt;&lt; endl;}return 1;} 输出结果为： 4 4 31 5 42 2 53 3 6 如果我们把第一个例子中的比较运算符重载为： bool operator &lt; (const T &amp;t1, const T &amp;t2){return t1.z &gt; t2.z; &#x2F;&#x2F; 按照z的顺序来决定t1和t2的顺序} 则第一个例子的程序会得到和第二个例子的程序相同的输出结果。 再回顾一下用优先队列实现的题1067–Ugly Numbers的代码： #include #include using namespace std;typedef pair&lt;unsigned long int, int&gt; node_type;main( int argc, char *argv[] ){unsigned long int result[1500];priority_queue&lt; node_type, vector, greater &gt; Q;Q.push( make_pair(1, 3) );for (int i&#x3D;0; i&lt;1500; i++){node_type node &#x3D; Q.top();Q.pop();switch(node.second){case 3: Q.push( make_pair(node.first*2, 3) );case 2: Q.push( make_pair(node.first*3, 2) );case 1: Q.push( make_pair(node.first*5, 1) );}result[i] &#x3D; node.first;}int n;cin &gt;&gt; n;while (n&gt;0){cout &lt;&lt; result[n-1] &lt;&lt; endl;cin &gt;&gt; n;}return 1;}2008-7-17 01:34 回复 狂晕的迷战士14位粉丝10楼第09篇 ACM&#x2F;ICPC竞赛之STL–algorithm无疑是STL中最大的一个头文件，它是由一大堆模板函数组成的。 下面列举出中的模板函数： adjacent_find &#x2F; binary_search &#x2F; copy &#x2F; copy_backward &#x2F; count &#x2F; count_if &#x2F; equal &#x2F; equal_range &#x2F; fill &#x2F; fill_n &#x2F; find &#x2F; find_end &#x2F; find_first_of &#x2F; find_if &#x2F; for_each &#x2F; generate &#x2F; generate_n &#x2F; includes &#x2F; inplace_merge &#x2F; iter_swap &#x2F; lexicographical_compare &#x2F; lower_bound &#x2F; make_heap &#x2F; max &#x2F; max_element &#x2F; merge &#x2F; min &#x2F; min_element &#x2F; mismatch &#x2F; next_permutation &#x2F; nth_element &#x2F; partial_sort &#x2F; partial_sort_copy &#x2F; partition &#x2F; pop_heap &#x2F; prev_permutation &#x2F; push_heap &#x2F; random_shuffle &#x2F; remove &#x2F; remove_copy &#x2F; remove_copy_if &#x2F; remove_if &#x2F; replace &#x2F; replace_copy &#x2F; replace_copy_if &#x2F; replace_if &#x2F; reverse &#x2F; reverse_copy &#x2F; rotate &#x2F; rotate_copy &#x2F; search &#x2F; search_n &#x2F; set_difference &#x2F; set_intersection &#x2F; set_symmetric_difference &#x2F; set_union &#x2F; sort &#x2F; sort_heap &#x2F; stable_partition &#x2F; stable_sort &#x2F; swap &#x2F; swap_ranges &#x2F; transform &#x2F; unique &#x2F; unique_copy &#x2F; upper_bound 如果详细叙述每一个模板函数的使用，足够写一本书的了。还是来看几个简单的示例程序吧。 示例程序之一，for_each遍历容器： #include #include #include using namespace std; int Visit(int v) &#x2F;&#x2F; 遍历算子函数{cout &lt;&lt; v &lt;&lt; “ “;return 1;} class MultInt &#x2F;&#x2F; 定义遍历算子类{private:int factor;public:MultInt(int f) : factor(f){}void operator()(int &amp;elem) const{elem *&#x3D; factor;}}; main(){vector L;for (int i&#x3D;0; i&lt;10; i++) L.push_back(i);for_each(L.begin(), L.end(), Visit);cout &lt;&lt; endl;for_each(L.begin(), L.end(), MultInt(2));for_each(L.begin(), L.end(), Visit);cout &lt;&lt; endl;return 1;} 程序的输出结果为： 0 1 2 3 4 5 6 7 8 90 2 4 6 8 10 12 14 16 18 示例程序之二，min_element&#x2F;max_element，找出容器中的最小&#x2F;最大值： #include #include #include using namespace std; main(){vector L;for (int i&#x3D;0; i&lt;10; i++) L.push_back(i);vector::iterator min_it &#x3D; min_element(L.begin(), L.end());vector::iterator max_it &#x3D; max_element(L.begin(), L.end());cout &lt;&lt; “Min is “ &lt;&lt; *min_it &lt;&lt; endl;cout &lt;&lt; “Max is “ &lt;&lt; *max_it &lt;&lt; endl;return 1;} 程序的输出结果为： Min is 0Max is 9 示例程序之三，sort对容器进行排序： #include #include #include using namespace std;void Print(vector &amp;L){for (vector::iterator it&#x3D;L.begin(); it!&#x3D;L.end(); it++)cout &lt;&lt; *it &lt;&lt; “ “;cout &lt;&lt; endl;}main(){vector L;for (int i&#x3D;0; i&lt;5; i++) L.push_back(i);for (int i&#x3D;9; i&gt;&#x3D;5; i–) L.push_back(i);Print(L);sort(L.begin(), L.end());Print(L);sort(L.begin(), L.end(), greater()); &#x2F;&#x2F; 按降序排序Print(L);return 1;} 程序的输出结果为： 0 1 2 3 4 9 8 7 6 50 1 2 3 4 5 6 7 8 99 8 7 6 5 4 3 2 1 0 示例程序之四，copy在容器间复制元素： #include #include #include using namespace std;main( ){&#x2F;&#x2F; 先初始化两个向量v1和v2vector v1, v2;for (int i&#x3D;0; i&lt;&#x3D;5; i++) v1.push_back(10i);for (int i&#x3D;0; i&lt;&#x3D;10; i++) v2.push_back(3i); cout &lt;&lt; “v1 &#x3D; ( “ ;for (vector ::iterator it&#x3D;v1.begin(); it!&#x3D;v1.end(); it++)cout &lt;&lt; *it &lt;&lt; “ “;cout &lt;&lt; “)” &lt;&lt; endl; cout &lt;&lt; “v2 &#x3D; ( “ ;for (vector ::iterator it&#x3D;v2.begin(); it!&#x3D;v2.end(); it++)cout &lt;&lt; *it &lt;&lt; “ “;cout &lt;&lt; “)” &lt;&lt; endl; &#x2F;&#x2F; 将v1的前三个元素复制到v2的中间copy(v1.begin(), v1.begin()+3, v2.begin()+4); cout &lt;&lt; “v2 with v1 insert &#x3D; ( “ ;for (vector ::iterator it&#x3D;v2.begin(); it!&#x3D;v2.end(); it++)cout &lt;&lt; *it &lt;&lt; “ “;cout &lt;&lt; “)” &lt;&lt; endl; &#x2F;&#x2F; 在v2内部进行复制，注意参数2表示结束位置，结束位置不参与复制copy(v2.begin()+4, v2.begin()+7, v2.begin()+2); cout &lt;&lt; “v2 with shifted insert &#x3D; ( “ ;for (vector ::iterator it&#x3D;v2.begin(); it!&#x3D;v2.end(); it++)cout &lt;&lt; *it &lt;&lt; “ “;cout &lt;&lt; “)” &lt;&lt; endl;return 1;} 程序的输出结果为： v1 &#x3D; ( 0 10 20 30 40 50 )v2 &#x3D; ( 0 3 6 9 12 15 18 21 24 27 30 )v2 with v1 insert &#x3D; ( 0 3 6 9 0 10 20 21 24 27 30 )v2 with shifted insert &#x3D; ( 0 3 0 10 20 10 20 21 24 27 30 )2008-7-17 01:37 回复 狂晕的迷战士14位粉丝11楼第10篇 ACM&#x2F;ICPC竞赛之算法策略ACM&#x2F;ICPC竞赛其实就是算法设计和编码的竞赛，熟悉各种常用算法和算法设计策略并能灵活运用是非常必要的。 这里对几种在竞赛中经常用到的算法设计策略做一简单的介绍。 1、穷举法穷举法是最基本的算法设计策略，其思想是列举出问题所有的可能解，逐一进行判别，找出满足条件的解。 穷举法的运用关键在于解决两个问题： 如何列举所有的可能解； 如何判别可能解是否满足条件； 在运用穷举法时，容易出现的问题是可能解过多，导致算法效率很低，这就需要对列举可能解的方法进行优化。 以题1041–纯素数问题为例，从1000到9999都可以看作是可能解，可以通过对所有这些可能解逐一进行判别，找出其中的纯素数，但只要稍作分析，就会发现其实可以大幅度地降低可能解的范围。根据题意易知，个位只可能是3、5、7，再根据题意可知，可以在3、5、7的基础上，先找出所有的二位纯素数，再在二位纯素数基础上找出三位纯素数，最后在三位纯素数的基础上找出所有的四位纯素数。 2、分治法分治法也是应用非常广泛的一种算法设计策略，其思想是将问题分解为若干子问题，从而可以递归地求解各子问题，再综合出问题的解。 分治法的运用关键在于解决三个问题： 确定分治规则，即如何分解问题。 确定终结条件，即问题分解到什么状态时可以直接求解。 确定归纳方法，即如何由子问题的解得到原问题的解。这一步并不总是需要的，因为对某些问题来说，并不需要对子问题的解进行复杂的归纳。 我们熟知的如汉诺塔问题、折半查找算法、快速排序算法等都是分治法运用的典型案例。 以题1045–Square Coins为例，先对题意进行分析，可设一个函数f(m, n)等于用面值不超过n2的货币构成总值为m的方案数，则容易推导出： f(m, n) &#x3D; f(m-0nn, n-1)+f(m-1nn, n-1)+f(m-2nn, n-1)+…+f(m-knn, n-1)这里的k是币值为n2的货币最多可以用多少枚，即k&#x3D;m&#x2F;(n*n)。 也很容易分析出，f(m, 1) &#x3D; f(1, n) &#x3D; 1 对于这样的题目，一旦分析出了递推公式，程序就非常好写了。所以在动手开始写程序之前，分析工作做得越彻底，逻辑描述越准确、简洁，写起程序来就会越容易。 3、动态规划法动态规划法多用来计算最优问题，动态规划法与分治法的基本思想是一致的，但处理的手法不同。动态规划法在运用时，要先对问题的分治规律进行分析，找出终结子问题，以及子问题向父问题归纳的规则，而算法则直接从终结子问题开始求解，逐层向上归纳，直到归纳出原问题的解。 动态规划法多用于在分治过程中，子问题可能重复出现的情况，在这种情况下，如果按照常规的分治法，自上向下分治求解，则重复出现的子问题就会被重复地求解，从而增大了冗余计算量，降低了求解效率。而采用动态规划法，自底向上求解，每个子问题只计算一次，就可以避免这种重复的求解了。 动态规划法还有另外一种实现形式，即备忘录法。备忘录的基本思想是设立一个称为备忘录的容器，记录已经求得解的子问题及其解。仍然采用与分治法相同的自上向下分治求解的策略，只是对每一个分解出的子问题，先在备忘录中查找该子问题，如果备忘录中已经存在该子问题，则不须再求解，可以从备忘录中直接得到解，否则，对子问题递归求解，且每求得一个子问题的解，都将子问题及解存入备忘录中。 例如，在题1045–Square Coins中，可以采用分治法求解，也可以采用动态规划法求解，即从f(m, 1)和f(1, n)出发，逐层向上计算，直到求得f(m, n)。 在竞赛中，动态规划和备忘录的思想还可以有另一种用法。有些题目中的可能问题数是有限的，而在一次运行中可能需要计算多个测试用例，可以采用备忘录的方法，预先将所有的问题的解记录下来，然后输入一个测试用例，就查备忘录，直接找到答案输出。这在各问题之间存在父子关系的情况下，会更有效。例如，在题1045–Square Coins中，题目中已经指出了最大的目标币值不超过300，也就是说问题数只有300个，而且各问题的计算中存在重叠的子问题，可以采用动态规划法，将所有问题的解先全部计算出来，再依次输入测试用例数据，并直接输出答案。 4、回溯法回溯法是基于问题状态树搜索的求解法，其可适用范围很广。从某种角度上说，可以把回溯法看作是优化了的穷举法。回溯法的基本思想是逐步构造问题的可能解，一边构造，一边用约束条件进行判别，一旦发现已经不可能构造出满足条件的解了，则退回上一步构造过程，重新进行构造。这个退回的过程，就称之为“回溯”。 回溯法在运用时，要解决的关键问题在于： 如何描述局部解。 如何扩展局部解和回溯局部解。 如何判别局部解。 回溯法的经典案例也很多，例如全排列问题、N后问题等。 5、贪心法贪心法也是求解最优问题的常用算法策略，利用贪心法策略所设计的算法，通常效率较高，算法简单。贪心法的基本思想是对问题做出目前看来最好的选择，即贪心选择，并使问题转化为规模更小的子问题。如此迭代，直到子问题可以直接求解。 基于贪心法的经典算法例如：哈夫曼算法、最小生成树算法、最短路径算法等。 但是，贪心法的运用是有条件的，必须能够证明贪心选择能够导出最优解，且转化出的子问题与原问题是同性质的问题，才能使用贪心法求解。 一个比较经典的贪心法求解的问题就是找硬币问题：有1、2、5、10、20、50、100七种面值的硬币，要支付指定的金额，问怎么支付所用的硬币个数最少。这是一个非常日常化的问题，凭直觉我们会想到，尽可能先用大面值的硬币，这就是“贪心选择”，而在这个问题上，这个贪心选择也是正确的。 6、限界剪枝法限界剪枝法是求解较复杂最优问题的一种算法策略，与回溯法类似的是，限界剪枝法也是在问题状态空间树上进行搜索，但回溯法是搜索一般解，而限界剪枝法则是搜索最优解。限界剪枝法的基本思想是通过找出权值函数的上下界函数，以下界函数来指导搜索的方向，以上界函数来帮助剪除一些不可能含有最优解的分枝。 关于算法和算法策略的讨论是一个非常庞大的话题，几乎每个问题点都能扩展出一大堆可讨论的内容和案例。我实在不知道该怎样用简短的几篇文字就能够把这个话题说透，这里只能蜻蜓点水地对竞赛中经常用到的几种策略做一极为简略的介绍。 也许我们可以在以后的文章中，针对具体的题目进行算法和策略的分析，效果可能会更好。2008-7-17 01:37 回复 狂晕的迷战士14位粉丝12楼第11篇 ACM&#x2F;ICPC竞赛之调试在写程序时，调试程序也是一个重要的环节。怎样才能够更有效地调试程序，发现并修正错误呢？ 1、调试中的输入输出为了调试程序，我们可能需要反复执行程序，也就需要反复输入相同或不相同的测试数据。如果每次调试运行时都是以手工的方式输入测试数据，相信很多人都会觉得不胜其烦。其实我们可以用一些辅助的手段来简化这个过程。 方法一：使用剪贴板 可以将输入数据预先写好（用记事本、开发环境的编辑器或随便什么能够录入的东西），再将输入数据复制到剪贴板上（也就是说我们通常所说的复制操作）。在调试运行时，就可以直接将输入数据粘贴上去，不需要手工输入，这对于反复调试同一组测试数据尤其方便。 方法二：使用重定向 使用剪贴板对于多组测试数据或者比较长的测试数据就会显得不那么好用了。而使用输入输出的重定向则会更方便。 输入输出重定向是在终端窗口下的一种命令行功能，在命令行上可以用“&lt;”表示输入重定向，在“&lt;”后跟随输入文件名，则程序将从指定的输入文件中获取输入数据，而不再从键盘读入数据。也可以用“&gt;”表示输出重定向。在“&gt;”后跟输出文件名，则程序产生的标准输出将写入指定的输出文件中，而不是显示在屏幕上。 我们可以预先将输入数据存到文本文件中（如果有多组测试数据，可以存成多个文件），用重定向指定准备使用的输入数据。 例如，程序名为myprog，输入数据已经存到文件test.txt中，则在命令行下可以这样执行： C:&gt;myprog &lt; test.txt 则程序会直接从test.txt中读取输入。如果想把输出结果也存到文件中（这在输出结果比较多的时候尤其有用，因为直接输出到屏幕上可能会来不及看到输出，或看不全所有的输出），例如，可以这样执行： C:&gt;myprog &gt; test.out 这样我们就可以在执行后，用一个文本编辑器打开输出文件，慢慢阅读和分析输出结果。 如果把输入和输出的重定向结合起来，也可以这样执行： C:&gt;myprog &lt; test.txt &gt; test.out 2、输出调试信息在调试时，很多同学往往首先想到的是使用开发环境所提供的调试功能：设置断点、单步执行、查看和修改变量，甚至改变程序的流程。不可否认，使用开发环境所提供的调试功能的确很方便，但当你过分依赖于这些集成工具时，你可能忽略了很多更有效的手段：仔细地分析、充分的信息。 当我们发现程序没有按照自己预期得那样工作时，不要急于跟踪甚至修改程序，而是应该首先仔细对程序的逻辑、语句、表达式进行检查和分析，尽可能使程序在表达上更简洁、更干净。如果实在难以发现问题所在，也不必急于借助于集成工具去跟踪程序的运行。早期的程序员在调试程序时经常会在程序中加入输出调试信息的语句或过程，用以观察程序的运行过程，分析程序的运行逻辑，这种调试手段即使在今天也仍然是非常有效的。 输出的调试信息要尽量容易阅读，格式清楚，在必要的时候，可以借助工具程序或自己编写的程序对输出信息进行处理，以帮助分析问题。 3、发现线索调试的目的就是要分析错误发生的原因，寻找线索。盲目的调试只会浪费时间。 调试中的技巧很多，这里提出几条基本原则： 首先是要使错误可重现，要设法保证能够使错误按照自己的意愿重复出现。对于不知道什么时候会冒出来的错误，分析起来会困难得多！ 缩小导致错误的输入，设法构造出最小的又能保证错误出现的输入，这样可以减少变化的可能性，使分析范围更集中。经常可以采用二分选择的方法来选择输入，就是舍掉一半输入，看看错误是否会出现，如果不出现，则选择另一半输入，如此反复，并不断缩小导致错误的输入。 4、构造测试数据和测试程序在题目中所给出的测试样例只是一小组测试数据，这虽然通常是我们用来测试程序的第一组数据，但却是远远不够的。我们应该根据题意自行构造更多的测试数据，尤其是一些边界状态的测试数据（数据极大、数据极小、数据量极多、数据量极少、预期出现极端结果等情况）。 边界测试数据可以用于检查程序中是否存在边界错误，设计有缺陷的程序，在处理边界测试数据时往往容易暴露出错误。但如果没有发生明显的运行错误，就需要对结果的正确性进行验证。 有些测试数据可以通过手工计算求出结果，再与程序的计算结果相对比，而也有些问题，可以通过构造测试程序来进行验证。 测试程序通常是用确定可靠的算法编写的解题程序，但不须考虑时间和空间的消耗，用测试程序对测试数据进行求解，用计算结果与待测试程序的计算结果进行对比。 以题1041–纯素数问题为例，我们可以用最简单的穷举法进行求解，也许这样的解法是不被接受的，因为效率太低，但这个解法却可以用作我们的测试程序，甚至——有同学索性在本地先用这个程序把结果算出来，再写一个程序直接输出结果——居然也被接受了！ 写得有点疲了，脑子也有点麻木了~~~~先这样吧，等缓一缓再说吧。2008-7-17 01:40 回复 狂晕的迷战士14位粉丝13楼第02篇 ACM&#x2F;ICPC竞赛之STL简介一、关于STL STL(Standard Template Library，标准模板库）是C++语言标准中的重要组成部分。STL以模板类和模板函数的形式为程序员提供了各种数据结构和算法的精巧实现，程序员如果能够充分地利用STL，可以在代码空间、执行时间和编码效率上获得极大的好处。 STL大致可以分为三大类：算法(algorithm)、容器(container)、迭代器(iterator)。 STL容器是一些模板类，提供了多种组织数据的常用方法，例如vector(向量，类似于数组)、list(列表，类似于链表)、deque(双向队列)、set(集合)、map(映象)、stack(栈)、queue(队列)、priority_queue(优先队列)等，通过模板的参数我们可以指定容器中的元素类型。 STL算法是一些模板函数，提供了相当多的有用算法和操作，从简单如for_each（遍历）到复杂如stable_sort（稳定排序）。 STL迭代器是对C中的指针的一般化，用来将算法和容器联系起来。几乎所有的STL算法都是通过迭代器来存取元素序列进行工作的，而STL中的每一个容器也都定义了其本身所专有的迭代器，用以存取容器中的元素。有趣的是，普通的指针也可以像迭代器一样工作。 熟悉了STL后，你会发现，很多功能只需要用短短的几行就可以实现了。通过STL，我们可以构造出优雅而且高效的代码，甚至比你自己手工实现的代码效果还要好。 STL的另外一个特点是，它是以源码方式免费提供的，程序员不仅可以自由地使用这些代码，也可以学习其源码，甚至按照自己的需要去修改它。 下面是用STL写的题1067–Ugly Numbers的代码： #include #include using namespace std;typedef pair&lt;unsigned long, int&gt; node_type;main(){ unsigned long result[1500]; priority_queue&lt; node_type, vector, greater &gt; Q; Q.push( make_pair(1, 2) ); for (int i&#x3D;0; i&lt;1500; i++) { node_type node &#x3D; Q.top(); Q.pop(); switch(node.second) { case 2: Q.push( make_pair(node.first*2, 2) ); case 3: Q.push( make_pair(node.first*3, 3) ); case 5: Q.push( make_pair(node.first*5, 5) ); } result[i] &#x3D; node.first; } int n; cin &gt;&gt; n; while (n&gt;0) { cout &lt;&lt; result[n-1] &lt;&lt; endl; cin &gt;&gt; n; } return 1;} 在ACM竞赛中，熟练掌握和运用STL对快速编写实现代码会有极大的帮助。二、使用STL在C++标准中，STL被组织为以下的一组头文件（注意，是没有.h后缀的！）： algorithm &#x2F; deque &#x2F; functional &#x2F; iterator &#x2F; list &#x2F; map memory &#x2F; numeric &#x2F; queue &#x2F; set &#x2F; stack &#x2F; utility &#x2F; vector 当我们需要使用STL的某个功能时，需要嵌入相应的头文件。但要注意的是，在C++标准中，STL是被定义在std命名空间中的。如下例所示： #include main() { std::stack s; s.push(0); … return 1; } 如果希望在程序中直接引用STL，也可以在嵌入头文件后，用using namespace语句将std命名空间导入。如下例所示： #include using namespace std; main() { stack s; s.push(0); … return 1; } STL是C++语言机制运用的一个典范，通过学习STL可以更深刻地理解C++语言的思想和方法。在本系列的文章中不打算对STL做深入的剖析，而只是想介绍一些STL的基本应用。 有兴趣的同学，建议可以在有了一些STL的使用经验后，认真阅读一下《C++ STL》这本书（电力出版社有该书的中文版）。2008-7-17 01:54 回复 狂晕的迷战士14位粉丝14楼第08篇 ACM&#x2F;ICPC竞赛之STL–map在STL的头文件中定义了模板类map和multimap，用有序二叉树来存贮类型为pair&lt;const Key, T&gt;的元素对序列。序列中的元素以const Key部分作为标识，map中所有元素的Key值都必须是唯一的，multimap则允许有重复的Key值。 可以将map看作是由Key标识元素的元素集合，这类容器也被称为“关联容器”，可以通过一个Key值来快速确定一个元素，因此非常适合于需要按照Key值查找元素的容器。 map模板类需要四个模板参数，第一个是键值类型，第二个是元素类型，第三个是比较算子，第四个是分配器类型。其中键值类型和元素类型是必要的。 map的基本操作有： 1、定义map对象，例如： map&lt;string, int&gt; m; 2、向map中插入元素对，有多种方法，例如： m[key] &#x3D; value;[key]操作是map很有特色的操作，如果在map中存在键值为key的元素对，则返回该元素对的值域部分，否则将会创建一个键值为key的元素对，值域为默认值。所以可以用该操作向map中插入元素对或修改已经存在的元素对的值域部分。 m.insert( make_pair(key, value) );也可以直接调用insert方法插入元素对，insert操作会返回一个pair，当map中没有与key相匹配的键值时，其first是指向插入元素对的迭代器，其second为true；若map中已经存在与key相等的键值时，其first是指向该元素对的迭代器，second为false。 3、查找元素对，例如： int i &#x3D; m[key];要注意的是，当与该键值相匹配的元素对不存在时，会创建键值为key的元素对。 map&lt;string, int&gt;::iterator it &#x3D; m.find(key);如果map中存在与key相匹配的键值时，find操作将返回指向该元素对的迭代器，否则，返回的迭代器等于map的end()（参见vector中提到的begin和end操作）。 4、删除元素对，例如： m.erase(key);删除与指定key键值相匹配的元素对，并返回被删除的元素的个数。 m.erase(it);删除由迭代器it所指定的元素对，并返回指向下一个元素对的迭代器。 看一段简单的示例代码： #include#include using namespace std; typedef map&lt;int, string, less &gt; M_TYPE;typedef M_TYPE::iterator M_IT;typedef M_TYPE::const_iterator M_CIT; int main(){ M_TYPE MyTestMap; MyTestMap[3] &#x3D; “No.3”; MyTestMap[5] &#x3D; “No.5”; MyTestMap[1] &#x3D; “No.1”; MyTestMap[2] &#x3D; “No.2”; MyTestMap[4] &#x3D; “No.4”; M_IT it_stop &#x3D; MyTestMap.find(2); cout &lt;&lt; “MyTestMap[2] &#x3D; “ &lt;&lt; it_stop-&gt;second &lt;&lt; endl; it_stop-&gt;second &#x3D; “No.2 After modification”; cout &lt;&lt; “MyTestMap[2] &#x3D; “ &lt;&lt; it_stop-&gt;second &lt;&lt; endl; cout &lt;&lt; “Map contents : “ &lt;&lt; endl; for(M_CIT it &#x3D; MyTestMap.begin(); it !&#x3D; MyTestMap.end(); it++) { cout &lt;&lt; it-&gt;second &lt;&lt; endl; } return 0;}程序执行的输出结果为： MyTestMap[2] &#x3D; No.2MyTestMap[2] &#x3D; No.2 After modificationMap contents :No.1No.2 After modificationNo.3No.4No.5 再看一段简单的示例代码： #include #include using namespace std;main(){map&lt;string, int&gt; m;m[“one”] &#x3D; 1;m[“two”] &#x3D; 2;&#x2F;&#x2F; 几种不同的insert调用方法m.insert(make_pair(“three”, 3));m.insert(map&lt;string, int&gt;::value_type(“four”, 4));m.insert(pair&lt;string, int&gt;(“five”, 5)); string key;while (cin&gt;&gt;key){map&lt;string, int&gt;::iterator it &#x3D; m.find(key);if (it&#x3D;&#x3D;m.end()){cout &lt;&lt; “No such key!” &lt;&lt; endl;}else{cout &lt;&lt; key &lt;&lt; “ is “ &lt;&lt; it-&gt;second &lt;&lt; endl;cout &lt;&lt; “Erased “ &lt;&lt; m.erase(key) &lt;&lt; endl;}}return 1;} 主流算法： 1.搜索 &#x2F;&#x2F;回溯 2.DP（动态规划） 3.贪心 4.图论 &#x2F;&#x2F;Dijkstra、最小生成树、网络流 5.数论 &#x2F;&#x2F;解模线性方程 6.计算几何 &#x2F;&#x2F;凸壳、同等安置矩形的并的面积与周长 7.组合数学 &#x2F;&#x2F;Polya定理 8.模拟 9.数据结构 &#x2F;&#x2F;并查集、堆 10.博弈论 1、 排序 1423, 1694, 1723, 1727, 1763, 1788, 1828, 1838, 1840, 2201, 2376, 2377, 2380, 1318, 1877, 1928, 1971, 1974, 1990, 2001, 2002, 2092, 2379, 1002（需要字符处理，排序用快排即可） 1007（稳定的排序） 2159（题意较难懂） 2231 2371（简单排 序） 2388（顺序统计算法） 2418（二叉排序树） 2、 搜索、回溯、遍历 1022 1111 1118 1129 1190 1562 1564 1573 1655 2184 2225 2243 2312 2362 2378 2386 1010,1011,1018,1020,1054,1062,1256,1321,1363,1501， 1650,1659,1664,1753,2078,2083,2303,2310,2329 简单：1128, 1166, 1176, 1231, 1256, 1270, 1321, 1543, 1606, 1664, 1731, 1742, 1745, 1847, 1915, 1950, 2038, 2157, 2182, 2183, 2381, 2386, 2426,不易：1024, 1054, 1117, 1167, 1708, 1746, 1775, 1878, 1903, 1966, 2046, 2197, 2349,推荐：1011, 1190, 1191, 1416, 1579, 1632, 1639, 1659, 1680, 1683, 1691, 1709, 1714, 1753, 1771, 1826, 1855, 1856, 1890, 1924, 1935, 1948, 1979, 1980, 2170, 2288, 2331, 2339, 2340,1979（和迷宫类似） 1980（对剪枝要求较高） 3、 历法 1008 2080 （这种题要小心） 4、 枚举 1012，1046， 1387， 1411， 2245， 2326， 2363， 2381，1054（剪枝要求较高），1650 （小数的精 度问题） 5、 数据结构的典型算法 容易：1182, 1656, 2021, 2023, 2051, 2153, 2227, 2236, 2247, 2352, 2395,不易：1145, 1177, 1195, 1227, 1661, 1834,推荐：1330, 1338, 1451, 1470, 1634, 1689, 1693, 1703, 1724, 1988, 2004, 2010, 2119, 2274, 1125(弗洛伊德算法) ，2421（图的最小生成树） 6、 动态规划 1037 A decorative fence、 1050 To the Max、 1088 滑雪、 1125 Stockbroker Grapevine、 1141 Brackets Sequence、 1159 Palindrome、 1160 Post Office、 1163 The Triangle、 1458 Common Subsequence、 1579 Function Run Fun、 1887 Testing the CATCHER、 1953 World Cup Noise、 2386 Lake Counting 7、 贪心 1042, 1065, 1230, 1323, 1477, 1716, 1784,1328 1755（或用单纯形方法），2054，1017， 1328， 1862， 1922 ，2054， 2209， 2313， 2325， 2370。 8、 模拟 容易：1006, 1008, 1013, 1016, 1017, 1169, 1298, 1326, 1350, 1363, 1676, 1786, 1791, 1835, 1970, 2317, 2325, 2390, 不易：1012, 1082, 1099, 1114, 1642, 1677, 1684, 1886,1281 1928 2083 2141 2015 9、 递归 1664 10、字符串处理 1488, 1598, 1686, 1706, 1747, 1748, 1750, 1760, 1782, 1790, 1866, 1888, 1896, 1951, 2003, 2121, 2141, 2145, 2159, 2337, 2359, 2372, 2406, 2408, 1016 1051 1126 1318 1572 1917 1936 2039 2083 2136 2271 2317 2330，2121 2403 11、数论 1006,1014,1023,1061,1152,1183,1730,2262 12、几何有关的题目 凸包：1113, 1228, 1794, 2007, 2187,1113 wall，2187 beauty contest 容易：1319, 1654, 1673, 1675, 1836, 2074, 2137, 2318,不易：1685, 1687, 1696, 1873, 1901, 2172, 2333, 13、任意精度运算、数字游戏、高精度计算 1001 1023 1047 1060 1079 1131 1140 1142 1207 1220 1284 1289 1306 1316 1338 1405 1454 1503 1504 1519 1565 1650 1969 2000 2006 2081 2247 2262 2305 2316 23891001, 1220, 1405, 1503,1001（高精度乘法） 2413(高精度加法，还有二分查找) 14、概率统计 1037,1050 15、小费用最大流、最大流 2195 going home，2400 supervisor, supervisee，1087 a plug for UNIX，1149 PIGS，1273 drainage ditches，1274 the perfect stall，1325 machine schedule，1459 power network，2239 selecting courses 16、压缩存储的DP 1038 bugs integrated inc，1185 炮兵阵地，2430 lazy cow 17、最长公共子串（LCS） 1080 human gene functions，1159 palindrome，1458 common subsequence，2192 zipper 18、图论及组合数学 2421 Constructing Roads、 2369 Permutations、 2234 Matches Game、 2243 Knight Moves、 2249 Binomial Showdown、 2255 Tree Recovery、 2084 Game of Connections、 1906 Three powers、 1833 排列、 1850 Code、 1562 Oil Deposits、 1496 Word Index、 1306 Combinations、 1125 Stockbroker Grapevine、 1129 Channel Allocation、 1146 ID Codes、 1095 Trees Made to Order、找规律 2247 Humble Numbers、 2309 BST、 2346 Lucky tickets、 2370 Democracy in danger、 2365 Rope、 2101 Honey and Milk Land2028 When Can We Meet?、 2084 Game of Connections、 1915 Knight Moves、 1922 Ride to School、 1941 The Sierpinski Fractal、 1953 World Cup Noise、 1958 Strange Towers of Hanoi、 1969 Count on Canton、 1806 Manhattan 2025、 1809 Regetni、 1844 Sum、 1870 Bee Breeding、 1702 Eva&#39;s Balance、 1728 A flea on a chessboard、 1604 Just the Facts、 1642 Stacking Cubes、 1656 Counting Black、 1657 Distance on Chessboard、 1662 CoIns、 1663 Number Steps、 1313 Booklet Printing、 1316 Self Numbers、 1320 Street Numbers、 1323 Game Prediction、 1338 Ugly Numbers、 1244 Slots of Fun、 1250 Tanning Salon、 1102 LC-Display、 1147 Binary codes、 1013 Counterfeit Dollar、 19、博弈类 1067 取石子游戏、 1740 A New Stone Game、 2234 Matches Game、 1082 Calendar Game 、 2348 Euclid&#39;s Game、 2413 How many Fibs?、 2419 Forest 20、简单、模拟题1001 Exponentiation 、 1002 487-3279、 1003 Hangover 、 1701 Dissatisfying Lift、 2301 Beat the Spread!、 2304 Combination Lock、 2328 Guessing Game、 2403 Hay Points 、 2406 Power Strings、 2339 Rock, Scissors, Paper、 2350 Above Average、 2218 Does This Make Me Look Fat?、 2260 Error Correction、 2262 Goldbach&#39;s Conjecture、 2272 Bullseye、 2136 Vertical Histogram、 2174 Decoding Task、 2183 Bovine Math Geniuses、 2000 Gold Coins、 2014 Flow Layout、 2051 Argus、 2081 Calendar、 1918 Ranking List、 1922 Ride to School、 1970 The Game、 1972 Dice Stacking、 1974 The Happy Worm、 1978 Hanafuda Shuffle、 1979 Red and Black、 1617 Crypto Columns、 1666 Candy Sharing Game、 1674 Sorting by Swapping、 1503 Integer Inquiry、 1504 Adding Reversed Numbers、 1528 Perfection、 1546 Basically Speaking、 1547 Clay Bully、 1573 Robot Motion、 1575 Easier Done Than Said?、 1581 A Contesting Decision、 1590 Palindromes、 1454 Factorial Frequencies、 1363 Rails、 1218 THE DRUNK JAILER、 1281 MANAGER、 1132 Border、 1028 Web Navigation、 21、初等数学 1003 Hangover、 1045 Bode Plot、 1254 Hansel and Grethel、 1269 Intersecting Lines、 1401 Factorial、 1410 Intersection、 2363 Blocks 、 2365 Rope、 2242 The Circumference of the Circle、 2291 Rotten Ropes、 2295 A DP Problem、 2126 Factoring a Polynomial、 2191 Mersenne Composite Numbers、 2196 Specialized Four-Digit Numbers、 1914 Cramer&#39;s Rule、 1835 宇航员、 1799 Yeehaa!、 1607 Deck、 1244 Slots of Fun、 1269 Intersecting Lines、 1299 Polar Explorer、 1183 反正切函数的应用、 22、匹配 1274, 1422, 1469, 1719, 2060, 2239,经典1011（搜索好题）1012（学会打表）10131019（它体现了很多此类问题的特点）1050（绝对经典的dp）1088（dp好题）1157（花店，经典的dp）1163（怎么经典的dp那么多呀？？？）1328（贪心）1458（最长公共子序列）1647（很好的真题，考临场分析准确和下手迅速）1654（学会多边形面积的三角形求法）1655（一类无根树的dp问题）1804（逆序对）2084（经典组合数学问题）2187（用凸包求最远点对，求出凸包后应该有O(N)的求法，可我就是调不出来）2195（二分图的最佳匹配）2242（计算几何经典）2295（等式处理）2353（dp，但要记录最佳路径）2354（立体解析几何）2362（搜索好题）2410（读懂题是关键）2411（经典dp） 趣味1067（很难的数学，但仔细研究，是一片广阔的领域）1147（有O(n)的算法，需要思考）1240（直到一棵树的先序和后序遍历，那么有几种中序遍历呢？dp）1426（是数论吗？错，是图论！）1648（别用计算几何，用整点这个特点绕过精度的障碍吧）1833（找规律）1844（貌似dp或是搜索，其实是道有趣的数学题）1922（贪心，哈哈）22312305（不需要高精度噢）2328（要仔细噢）2356（数论知识）2359（约瑟夫问题变种）2392（有趣的问题） 很繁的题100110081087（构图很烦，还有二分图的最大匹配）1128（USACO）124513291550（考的是读题和理解能力）1649（dp）2200（字符串处理+枚举）2358（枚举和避免重复都很烦）2361（仔细仔细再仔细） 难题1014（数学证明比较难，但有那种想法更重要）1037（比较难的dp）1405（高精度算法也分有等级之分，不断改进吧）2002（不知道有没有比O(n^2*logn)更有的算法？）2054（极难，很强的思考能力）2085（组合数学）2414（dp，但要剪枝）2415（搜索）2423（计算几何+统计） 多解题1002（可以用排序，也可以用统计的方法）1338（搜索和dp都可以）1664（搜索和dp都练一练吧）2082（这可是我讲的题噢）2352（桶排和二叉树都行）Note:1011: 很经典的剪支1014: 难在数学上1017: 严格的数学证明貌似不容易1021: 有点繁,考察对图形进行各种旋转的处理1083: 巧妙的思考角度1150: 分奇偶讨论,lg(n)算法1218: 三行就够了,虽然简单,但也有优劣之别1505: 二分加贪心1654: 做法也许很多吧,本人用有向面积做的1674: 计算圈的个数(算是graph 吧)1700: 数学证明不容易1742: O(m*n)的算法1863: 要耐心地慢慢写…^_^1988: 并查集2051: 堆2078: 不难，但剪支可以做到很好2082::O(n),你想到了吗？2084: 卡特兰数2182: 线段树2195: 最小费用最大流2234: 经典博弈算法2236: 并查集2299: 二分思想2395: Kruskal 最小生成树的拓展2406: KMP2411: 用二进制串来表示状态 1、 排序 1423, 1694, 1723, 1727, 1763, 1788, 1828, 1838, 1840, 2201, 2376, 2377, 2380, 1318, 1877, 1928, 1971, 1974, 1990, 2001, 2002, 2092, 2379, 1002（需要字符处理，排序用快排即可） 1007（稳定的排序） 2159（题意较难懂） 22312371（简单排序） 2388（顺序统计算法） 2418（二*排序树） 2、 搜索、回溯、遍历 1022,1111,1118,1129,1190,1562,1564,1573,1655,2184,2225,2243,2312,2362,2378,2386,1010,1011,1018,1020,1054,1062,1256,1321,1363,1501,1650,1659,1664,1753,2078,2083,2303,2310,2329 简单：1128, 1166, 1176, 1231, 1256, 1270, 1321, 1543, 1606, 1664, 1731, 1742, 1745, 1847, 1915, 1950, 2038, 2157, 2182, 2183, 2381, 2386, 2426,不易：1024, 1054, 1117, 1167, 1708, 1746, 1775, 1878, 1903, 1966, 2046, 2197, 2349,推荐：1011, 1190, 1191, 1416, 1579, 1632, 1639, 1659, 1680, 1683, 1691, 1709, 1714, 1753, 1771, 1826, 1855, 1856, 1890, 1924, 1935, 1948, 1979, 1980, 2170, 2288, 2331, 2339, 2340,1979（和迷宫类似） 1980（对剪枝要求较高） 3、 历法 1008 2080 （这种题要小心） 4、 枚举 1012，1046， 1387， 1411， 2245， 2326， 2363， 2381，1054（剪枝要求较高），1650(小数的精度问题） 5、 数据结构的典型算法 容易：1182, 1656, 2021, 2023, 2051, 2153, 2227, 2236, 2247, 2352, 2395,不易：1145, 1177, 1195, 1227, 1661, 1834,推荐：1330, 1338, 1451, 1470, 1634, 1689, 1693, 1703, 1724, 1988, 2004, 2010, 2119, 2274, 1125(弗洛伊德算法) ，2421（图的最小生成树） 6、 动态规划 1037 A decorative fence、1050 To the Max、1088 滑雪、1125 Stockbroker Grapevine、1141 Brackets Sequence、1159 Palindrome、1160 Post Office、1163 The Triangle、1458 Common Subsequence、1579 Function Run Fun、1887 Testing the CATCHER、1953 World Cup Noise、2386 Lake Counting 动态规划容易：1018, 1050, 1083, 1088, 1125, 1143, 1157, 1163, 1178, 1179, 1189, 1208, 1276, 1322, 1414, 1456, 1458, 1609, 1644, 1664, 1690, 1699, 1740, 1742, 1887, 1926, 1936, 1952, 1953, 1958, 1959, 1962, 1975, 1989, 2018, 2029, 2033, 2063, 2081, 2082, 2181, 2184, 2192, 2231, 2279, 2329, 2336, 2346, 2353, 2355, 2356, 2385, 2392, 2424,不易：1019, 1037, 1080, 1112, 1141, 1170, 1192, 1239, 1655, 1695, 1707, 1733, 1737, 1837, 1850, 1920, 1934, 1937, 1964, 2039, 2138, 2151, 2161, 2178,推荐：1015, 1635, 1636, 1671, 1682, 1692, 1704, 1717, 1722, 1726, 1732, 1770, 1821, 1853, 1949, 2019, 2127, 2176, 2228, 2287, 2342, 2374, 2378, 2384, 2411, 7、 贪心 1042, 1065, 1230, 1784,1328 1755（或用单纯形方法），2054，1017， 1328，1862， 1922 ，2054， 2209， 2313， 2325， 2370。 8、 模拟 容易：1006, 1008, 1013, 1016, 1017, 1169, 1298, 1326, 1350, 1363, 1676, 1786, 1791, 1835, 1970, 2317, 2325, 2390,不易：1012, 1082, 1099, 1114, 1642, 1677, 1684, 1886,1281 1928 2083 2141 2015 9、 递归 1664 10、字符串处理 1488, 1598, 1686, 1706, 1747, 1748, 1750, 1760, 1782, 1790, 1866, 1888, 1896, 1951, 2003, 2121, 2141, 2145, 2159, 2337, 2359, 2372, 2406, 2408, 1016 1051 1126 1318 1572 1917 1936 2039 2083 2136 2271 2317 2330，2121 2403 11、数论 1006,1014,1023,1061,1152,1183,1730,2262 12、几何有关的题目 凸包：1113, 1228, 1794, 2007, 2187,1113 wall，2187 beauty contest容易：1319, 1654, 1673, 1675, 1836, 2074, 2137, 2318,不易：1685, 1687, 1696, 1873, 1901, 2172, 2333, 13、任意精度运算、数字游戏、高精度计算 1001 1023 1047 1060 1079 1131 1140 1142 1207 1220 1284 1289 1306 1316 1338 1405 14541503 1504 1519 1565 1650 1969 2000 2006 2081 2247 2262 2305 2316 23891001, 1220, 1405, 1503,1001（高精度乘法） 2413(高精度加法，还有二分查找) 14、概率统计 1037,1050 15、小费用最大流、最大流 2195 going home，2400 supervisor, supervisee，1087 a plug for UNIX，1149 PIGS，1273 drainage ditches，1274 the perfect stall，1325 machine schedule，1459 power network，2239 selecting courses 16、压缩存储的DP 1038 bugs integrated inc，1185 炮兵阵地，2430 lazy cow 17、最长公共子串（LCS） 1080 human gene functions，1159 palindrome，1458 common subsequence，2192 zipper 18、图论及组合数学 2421 Constructing Roads、2369 Permutations、2234 Matches Game、2243 Knight Moves、2249 Binomial Showdown、2255 Tree Recovery、2084 Game of Connections、1906 Three powers、1833 排列、1850 Code、1562 Oil Deposits、1496 Word Index、1306 Combinations、1125 Stockbroker Grapevine、1129 Channel Allocation、1146 ID Codes、1095 Trees Made to Order、找规律2247 Humble Numbers、2309 BST、2346 Lucky tickets、2370 Democracy in danger、2365 Rope、2101 Honey and Milk Land2028 When Can We Meet?、2084 Game of Connections、1915 Knight Moves、1922 Ride to School、1941 The Sierpinski Fractal、1953 World Cup Noise、1958 Strange Towers of Hanoi、1969 Count on Canton、1806 Manhattan 2025、1809 Regetni、1844 Sum、1870 Bee Breeding、1702 Eva&#39;s Balance、1728 A flea on a chessboard、1604 Just the Facts、1642 Stacking Cubes、1656 Counting Black、1657 Distance on Chessboard、1662 CoIns、1663 Number Steps、1313 Booklet Printing、1316 Self Numbers、1320 Street Numbers、1323 Game Prediction、1338 Ugly Numbers、1244 Slots of Fun、1250 Tanning Salon、1102 LC-Display、1147 Binary codes、1013 Counterfeit Dollar、 19、博弈类 1067 取石子游戏、1740 A New Stone Game、2234 Matches Game、1082 Calendar Game 、2348 Euclid&#39;s Game、2413 How many Fibs?、2419 Forest 20、简单、模拟题1001 Exponentiation 、1002 487-3279、1003 Hangover 、1701 Dissatisfying Lift、2301 Beat the Spread!、2304 Combination Lock、2328 Guessing Game、2403 Hay Points 、2406 Power Strings、2339 Rock, Scissors, Paper、2350 Above Average、2218 Does This Make Me Look Fat?、2260 Error Correction、2262 Goldbach&#39;s Conjecture、2272 Bullseye、2136 Vertical Histogram、2174 Decoding Task、2183 Bovine Math Geniuses、2000 Gold Coins、2014 Flow Layout、2051 Argus、2081 Calendar、1918 Ranking List、1922 Ride to School、1970 The Game、1972 Dice Stacking、1974 The Happy Worm、1978 Hanafuda Shuffle、1979 Red and Black、1617 Crypto Columns、1666 Candy Sharing Game、1674 Sorting by Swapping、1503 Integer Inquiry、1504 Adding Reversed Numbers、1528 Perfection、1546 Basically Speaking、1547 Clay Bully、1573 Robot Motion、1575 Easier Done Than Said?、1581 A Contesting Decision、1590 Palindromes、1454 Factorial Frequencies、1363 Rails、1218 THE DRUNK JAILER、1281 MANAGER、1132 Border、1028 Web Navigation、 21、初等数学 1003 Hangover、1045 Bode Plot、1254 Hansel and Grethel、1269 Intersecting Lines、1401 Factorial、1410 Intersection、2363 Blocks 、2365 Rope、2242 The Circumference of the Circle、2291 Rotten Ropes、2295 A DP Problem、2126 Factoring a Polynomial、2191 Mersenne Composite Numbers、2196 Specialized Four-Digit Numbers、1914 Cramer&#39;s Rule、1835 宇航员、1799 Yeehaa!、1607 Deck、1244 Slots of Fun、1269 Intersecting Lines、1299 Polar Explorer、1183 反正切函数的应用、 22、匹配 1274, 1422, 1469, 1719, 2060, 2239 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 经典1011（搜索好题）1012（学会打表）10131019（它体现了很多此类问题的特点）1050（绝对经典的dp）1088（dp好题）1157（花店，经典的dp）1163（怎么经典的dp那么多呀？？？）1328（贪心）1458（最长公共子序列）1647（很好的真题，考临场分析准确和下手迅速）1654（学会多边形面积的三角形求法）1655（一类无根树的dp问题）1804（逆序对）2084（经典组合数学问题）2187（用凸包求最远点对，求出凸包后应该有O(N)的求法，可我就是调不出来）2195（二分图的最佳匹配）2242（计算几何经典）2295（等式处理）2353（dp，但要记录最佳路径）2354（立体解析几何）2362（搜索好题）2410（读懂题是关键）2411（经典dp） 趣味1067（很难的数学，但仔细研究，是一片广阔的领域）1147（有O(n)的算法，需要思考）1240（直到一棵树的先序和后序遍历，那么有几种中序遍历呢？dp）1426（是数论吗？错，是图论！）1648（别用计算几何，用整点这个特点绕过精度的障碍吧）1833（找规律）1844（貌似dp或是搜索，其实是道有趣的数学题）1922（贪心，哈哈）22312305（不需要高精度噢）2328（要仔细噢）2356（数论知识）2359（约瑟夫问题变种）2392（有趣的问题） 很繁的题100110081087（构图很烦，还有二分图的最大匹配）1128（USACO）124513291550（考的是读题和理解能力）1649（dp）2200（字符串处理+枚举）2358（枚举和避免重复都很烦）2361（仔细仔细再仔细） 难题 1014（数学证明比较难，但有那种想法更重要）1037（比较难的dp）1405（高精度算法也分有等级之分，不断改进吧）2002（不知道有没有比O(n^2*logn)更有的算法？）2054（极难，很强的思考能力）2085（组合数学）2414（dp，但要剪枝）2415（搜索）2423（计算几何+统计） 多解题1002（可以用排序，也可以用统计的方法）1338（搜索和dp都可以）1664（搜索和dp都练一练吧）2082（这可是我讲的题噢）2352（桶排和二*树都行） Note:1011: 很经典的剪支1014: 难在数学上1017: 严格的数学证明貌似不容易1021: 有点繁,考察对图形进行各种旋转的处理1083: 巧妙的思考角度1150: 分奇偶讨论,lg(n)算法1218: 三行就够了,虽然简单,但也有优劣之别1505: 二分加贪心1654: 做法也许很多吧,本人用有向面积做的1674: 计算圈的个数(算是graph 吧)1700: 数学证明不容易1742: O(m*n)的算法1863: 要耐心地慢慢写…^_^1988: 并查集2051: 堆2078: 不难，但剪支可以做到很好2082::O(n),你想到了吗？2084: 卡特兰数2182: 线段树2195: 最小费用最大流2234: 经典博弈算法2236: 并查集2299: 二分思想2395: Kruskal 最小生成树的拓展2406: KMP2411: 用二进制串来表示状态 主流算法：1.搜索 &#x2F;&#x2F;回溯2.DP（动态规划） 3.贪心 4.图论 &#x2F;&#x2F;Dijkstra、最小生成树、网络流5.数论 &#x2F;&#x2F;解模线性方程6.计算几何 &#x2F;&#x2F;凸壳、同等安置矩形的并的面积与周长7.组合数学 &#x2F;&#x2F;Polya定理8.模拟 9.数据结构 &#x2F;&#x2F;并查集、堆10.博弈论 1、 排序1423, 1694, 1723, 1727, 1763, 1788, 1828, 1838, 1840, 2201, 2376, 2377, 2380, 1318, 1877,1928, 1971, 1974, 1990, 2001, 2002, 2092, 2379,1002（需要字符处理，排序用快排即可） 1007（稳定的排序） 2159（题意较难懂）2231 2371（简单排序） 2388（顺序统计算法） 2418（二叉排序树） 2、 搜索、回溯、遍历1022 1111 1118 1129 1190 1562 1564 1573 1655 2184 2225 2243 2312 2362 2378 23861010,1011,1018,1020,1054,1062,1256,1321,1363,1501,1650,1659,1664,1753,2078,2083,2303,2310,2329 简单：1128, 1166, 1176, 1231, 1256, 1270, 1321, 1543, 1606, 1664, 1731, 1742, 1745, 1847,1915, 1950, 2038, 2157, 2182, 2183, 2381, 2386, 2426,不易：1024, 1054, 1117, 1167, 1708, 1746, 1775, 1878, 1903, 1966, 2046, 2197, 2349,推荐：1011, 1190, 1191, 1416, 1579, 1632, 1639, 1659, 1680, 1683, 1691, 1709, 1714, 1753,1771, 1826, 1855, 1856, 1890, 1924, 1935, 1948, 1979, 1980, 2170, 2288, 2331, 2339,2340,1979（和迷宫类似） 1980（对剪枝要求较高） 3、 历法1008 2080 （这种题要小心） 4、 枚举1012，1046， 1387， 1411， 2245， 2326， 2363， 2381，1054（剪枝要求较高），1650 （小数的精度问题） 5、 数据结构的典型算法容易：1182, 1656, 2021, 2023, 2051, 2153, 2227, 2236, 2247, 2352, 2395,不易：1145, 1177, 1195, 1227, 1661, 1834,推荐：1330, 1338, 1451, 1470, 1634, 1689, 1693, 1703, 1724, 1988, 2004, 2010, 2119, 2274,1125(弗洛伊德算法) ，2421（图的最小生成树） 6、 动态规划1037 A decorative fence、1050 To the Max、1088 滑雪、1125 Stockbroker Grapevine、1141 Brackets Sequence、1159 Palindrome、1160 Post Office、1163 The Triangle、1458 Common Subsequence、1579 Function Run Fun、1887 Testing the CATCHER、1953 World Cup Noise、2386 Lake Counting 7、 贪心 1042, 1065, 1230, 1323, 1477, 1716, 1784,1328 1755（或用单纯形方法），2054，1017， 1328，1862， 1922 ，2054， 2209， 2313， 2325， 2370。 8、 模拟容易：1006, 1008, 1013, 1016, 1017, 1169, 1298, 1326, 1350, 1363, 1676, 1786, 1791, 1835,1970, 2317, 2325, 2390不易：1012, 1082, 1099, 1114, 1642, 1677, 1684, 1886,1281 1928 2083 2141 2015 9、 递归1664 10、字符串处理1488, 1598, 1686, 1706, 1747, 1748, 1750, 1760, 1782, 1790, 1866, 1888, 1896, 1951, 2003,2121, 2141, 2145, 2159, 2337, 2359, 2372, 2406, 2408, 1016 1051 1126 1318 1572 1917 19362039 2083 2136 2271 2317 2330，2121 2403 11、数论1006,1014,1023,1061,1152,1183,1730,2262 12、几何有关的题目凸包：1113, 1228, 1794, 2007, 2187,1113 wall，2187 beauty contest容易：1319, 1654, 1673, 1675, 1836, 2074, 2137, 2318,不易：1685, 1687, 1696, 1873, 1901, 2172, 2333, 13、任意精度运算、数字游戏、高精度计算1001 1023 1047 1060 1079 1131 1140 1142 1207 1220 1284 1289 1306 1316 1338 1405 1454 15031504 1519 1565 1650 1969 2000 2006 2081 2247 2262 2305 2316 23891001, 1220, 1405, 1503,1001（高精度乘法） 2413(高精度加法，还有二分查找) 14、概率统计1037,1050 15、小费用最大流、最大流2195 going home，2400 supervisor, supervisee，1087 a plug for UNIX，1149 PIGS，1273 drainage ditches，1274 the perfect stall，1325 machine schedule，1459 power network，2239 selecting courses 16、压缩存储的DP1038 bugs integrated inc，1185 炮兵阵地，2430 lazy cow 17、最长公共子串（LCS）1080 human gene functions，1159 palindrome，1458 common subsequence，2192 zipper 18、图论及组合数学 2421 Constructing Roads、 2369 Permutations、 2234 Matches Game、 2243 Knight Moves、 2249 Binomial Showdown、 2255 Tree Recovery、 2084 Game of Connections、 1906 Three powers、 1833 排列、 1850 Code、 1562 Oil Deposits、 1496 Word Index、 1306 Combinations、 1125 Stockbroker Grapevine、 1129 Channel Allocation、 1146 ID Codes、 1095 Trees Made to Order、找规律 2247 Humble Numbers、 2309 BST、 2346 Lucky tickets、 2370 Democracy in danger、 2365 Rope、 2101 Honey and Milk Land2028 When Can We Meet?、 2084 Game of Connections、 1915 Knight Moves、 1922 Ride to School、 1941 The Sierpinski Fractal、 1953 World Cup Noise、 1958 Strange Towers of Hanoi、 1969 Count on Canton、 1806 Manhattan 2025、 1809 Regetni、 1844 Sum、 1870 Bee Breeding、 1702 Eva&#39;s Balance、 1728 A flea on a chessboard、 1604 Just the Facts、 1642 Stacking Cubes、 1656 Counting Black、 1657 Distance on Chessboard、 1662 CoIns、 1663 Number Steps、 1313 Booklet Printing、 1316 Self Numbers、 1320 Street Numbers、 1323 Game Prediction、 1338 Ugly Numbers、 1244 Slots of Fun、 1250 Tanning Salon、 1102 LC-Display、 1147 Binary codes、 1013 Counterfeit Dollar、 19、博弈类 1067 取石子游戏、 1740 A New Stone Game、 2234 Matches Game、 1082 Calendar Game 、 2348 Euclid&#39;s Game、 2413 How many Fibs?、 2419 Forest 20、简单、模拟题1001 Exponentiation 、 1002 487-3279、 1003 Hangover 、 1701 Dissatisfying Lift、 2301 Beat the Spread!、 2304 Combination Lock、 2328 Guessing Game、 2403 Hay Points 、 2406 Power Strings、 2339 Rock, Scissors, Paper、 2350 Above Average、 2218 Does This Make Me Look Fat?、 2260 Error Correction、 2262 Goldbach&#39;s Conjecture、 2272 Bullseye、 2136 Vertical Histogram、 2174 Decoding Task、 2183 Bovine Math Geniuses、 2000 Gold Coins、 2014 Flow Layout、 2051 Argus、 2081 Calendar、 1918 Ranking List、 1922 Ride to School、 1970 The Game、 1972 Dice Stacking、 1974 The Happy Worm、 1978 Hanafuda Shuffle、 1979 Red and Black、 1617 Crypto Columns、 1666 Candy Sharing Game、 1674 Sorting by Swapping、 1503 Integer Inquiry、 1504 Adding Reversed Numbers、 1528 Perfection、 1546 Basically Speaking、 1547 Clay Bully、 1573 Robot Motion、 1575 Easier Done Than Said?、 1581 A Contesting Decision、 1590 Palindromes、 1454 Factorial Frequencies、 1363 Rails、 1218 THE DRUNK JAILER、 1281 MANAGER、 1132 Border、 1028 Web Navigation、 21、初等数学 1003 Hangover、 1045 Bode Plot、 1254 Hansel and Grethel、 1269 Intersecting Lines、 1401 Factorial、 1410 Intersection、 2363 Blocks 、 2365 Rope、 2242 The Circumference of the Circle、 2291 Rotten Ropes、 2295 A DP Problem、 2126 Factoring a Polynomial、 2191 Mersenne Composite Numbers、 2196 Specialized Four-Digit Numbers、 1914 Cramer&#39;s Rule、 1835 宇航员、 1799 Yeehaa!、 1607 Deck、 1244 Slots of Fun、 1269 Intersecting Lines、 1299 Polar Explorer、 1183 反正切函数的应用、 22、匹配 1274, 1422, 1469, 1719, 2060, 2239,经典1011（搜索好题）1012（学会打表）10131019（它体现了很多此类问题的特点）1050（绝对经典的dp）1088（dp好题）1157（花店，经典的dp）1163（怎么经典的dp那么多呀？？？）1328（贪心）1458（最长公共子序列）1647（很好的真题，考临场分析准确和下手迅速）1654（学会多边形面积的三角形求法）1655（一类无根树的dp问题）1804（逆序对）2084（经典组合数学问题）2187（用凸包求最远点对，求出凸包后应该有O(N)的求法，可我就是调不出来）2195（二分图的最佳匹配）2242（计算几何经典）2295（等式处理）2353（dp，但要记录最佳路径）2354（立体解析几何）2362（搜索好题）2410（读懂题是关键）2411（经典dp） 趣味1067（很难的数学，但仔细研究，是一片广阔的领域）1147（有O(n)的算法，需要思考）1240（直到一棵树的先序和后序遍历，那么有几种中序遍历呢？dp）1426（是数论吗？错，是图论！）1648（别用计算几何，用整点这个特点绕过精度的障碍吧）1833（找规律）1844（貌似dp或是搜索，其实是道有趣的数学题）1922（贪心，哈哈）22312305（不需要高精度噢）2328（要仔细噢）2356（数论知识）2359（约瑟夫问题变种）2392（有趣的问题） 很繁的题100110081087（构图很烦，还有二分图的最大匹配）1128（USACO）124513291550（考的是读题和理解能力）1649（dp）2200（字符串处理+枚举）2358（枚举和避免重复都很烦）2361（仔细仔细再仔细） 难题1014（数学证明比较难，但有那种想法更重要）1037（比较难的dp）1405（高精度算法也分有等级之分，不断改进吧）2002（不知道有没有比O(n^2*logn)更有的算法？）2054（极难，很强的思考能力）2085（组合数学）2414（dp，但要剪枝）2415（搜索）2423（计算几何+统计） 多解题1002（可以用排序，也可以用统计的方法）1338（搜索和dp都可以）1664（搜索和dp都练一练吧）2082（这可是我讲的题噢）2352（桶排和二叉树都行） Note:1011: 很经典的剪支1014: 难在数学上1017: 严格的数学证明貌似不容易1021: 有点繁,考察对图形进行各种旋转的处理1083: 巧妙的思考角度1150: 分奇偶讨论,lg(n)算法1218: 三行就够了,虽然简单,但也有优劣之别1505: 二分加贪心1654: 做法也许很多吧,本人用有向面积做的1674: 计算圈的个数(算是graph 吧)1700: 数学证明不容易1742: O(m*n)的算法1863: 要耐心地慢慢写…^_^1988: 并查集2051: 堆2078: 不难，但剪支可以做到很好2082::O(n),你想到了吗？2084: 卡特兰数2182: 线段树2195: 最小费用最大流2234: 经典博弈算法2236: 并查集2299: 二分思想2395: Kruskal 最小生成树的拓展2406: KMP2411: 用二进制串来表示状态","categories":[],"tags":[],"author":"aoyuehan"},{"title":"java网络编程-聊天室","slug":"java网络编程-聊天室","date":"2019-07-24T12:27:00.000Z","updated":"2022-02-26T03:51:21.510Z","comments":true,"path":"2019/07/24/java网络编程-聊天室/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/24/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E8%81%8A%E5%A4%A9%E5%AE%A4/","excerpt":"","text":"package com.ruide.chats; import java.awt.BorderLayout;import java.awt.EventQueue; import javax.swing.JFrame;import javax.swing.JPanel;import javax.swing.border.EmptyBorder;import javax.swing.JTextArea;import javax.swing.JButton;import javax.swing.JTextField;import java.awt.event.ActionListener;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;import java.net.UnknownHostException;import java.awt.event.ActionEvent; public class Chat extends JFrame { private JPanel contentPane; private JTextField textField; /** * Launch the application. */ public static void main(String[] args) &#123; EventQueue.invokeLater(new Runnable() &#123; public void run() &#123; try &#123; Chat frame = new Chat(); frame.setVisible(true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; /** * Create the frame. */ public Chat() &#123; setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setBounds(100, 100, 450, 300); contentPane = new JPanel(); contentPane.setBorder(new EmptyBorder(5, 5, 5, 5)); setContentPane(contentPane); contentPane.setLayout(null); JTextArea textArea = new JTextArea(); textArea.setBounds(10, 10, 414, 172); contentPane.add(textArea); textField = new JTextField(); textField.setBounds(10, 202, 291, 40); contentPane.add(textField); textField.setColumns(10); JButton button = new JButton(&quot;\\u53D1\\u9001&quot;); button.addActionListener(new ActionListener() &#123; //发送的监听事件 public void actionPerformed(ActionEvent e) &#123; //获取本机的IP地址 InetAddress ip=null; int port=8888; try &#123; ip=InetAddress.getByName(&quot;localhost&quot;); //获取Socket Socket s=new Socket(ip, port); //获取网络输出流 OutputStream out=s.getOutputStream(); //获取文本域的信息 String messages=textArea.getText(); //获取需要发送的信息 String str=textField.getText(); //信息 String message=messages+&quot;\\n&quot;+str; //将字符串转化成字节数组 byte by[]=message.getBytes(); //传输信息 out.write(by); &#125; catch (IOException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; &#125; &#125;); button.setBounds(331, 205, 72, 32); contentPane.add(button); new Thread() &#123; public void run() &#123; //服务器端 int port=8888; try &#123; //创建服务器套接字 ServerSocket ss=new ServerSocket(port); while(true) &#123; //创建字符数组接收信息 byte bs[]=new byte[1024*64]; Socket s=ss.accept(); //获取输入流 InputStream in=s.getInputStream(); //读取缓冲区信息 in.read(bs); 这地方还有点问题？？？课本while //输出到控制台是中文 String str=new String(bs); //添加客户端信息到会话展示框 textArea.setText(str.trim()); &#125; &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; &#125; &#125;.start(); &#125; }","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://zouyunkai.github.io/myblog/categories/JAVA/"}],"tags":[{"name":"java网络编程","slug":"java网络编程","permalink":"https://zouyunkai.github.io/myblog/tags/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"聊天室","slug":"聊天室","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/"}],"author":"aoyuehan"},{"title":"java小游戏-五子棋","slug":"java小游戏-五子棋","date":"2019-07-22T07:44:00.000Z","updated":"2022-02-26T03:52:51.171Z","comments":true,"path":"2019/07/22/java小游戏-五子棋/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/22/java%E5%B0%8F%E6%B8%B8%E6%88%8F-%E4%BA%94%E5%AD%90%E6%A3%8B/","excerpt":"","text":"1、设计蓝图 首先是黑棋白棋这两个对象，用vector集合以 x-y 的形式在集合中存入棋子的坐标。 给界面添加鼠标点击事件，因为首先下的是白子，所以可以用v.size()%2&#x3D;&#x3D;0来决定是否画黑子还是白子；还有处理棋子没有下在网格中间的处理方法，即：x&#x3D;(x-x%w)+(x%w&gt;w&#x2F;2?w:0); 还有右键点击悔棋的功能，判断一下上一次下的是黑棋还是白棋，判断一下是否超过三步，如果否，执行vector中的move方法来除去集合中上一步下的棋子。 效果：2、 源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226import java.awt.BorderLayout;import java.awt.*;import java.awt.Graphics;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.util.Vector;import javax.swing.JFrame;import javax.swing.JOptionPane;public class Wuziqi extends JFrame implements MouseListener &#123; int px=100,py=100; //棋盘黑线的坐标原点即（0,0）位置 int w=25; //一个小格是长宽为25的小格 int vline=px+16*w;//横线长度 vline=500 int hline=py+16*w;//纵线长度 16个空，17条线 boolean b; //用来判断白旗还是黑棋 int whiteCount, blackCount; //计算悔棋步数 Vector v=new Vector(); Vector white = new Vector(); Vector black = new Vector(); public static void main(String args[]) &#123; new Wuziqi(); &#125; //构造方法 public Wuziqi() &#123; this.setVisible(true); this.setTitle(&quot;小志版五子棋&quot;); this.setLocationRelativeTo(null); //在屏幕上居中显示 Container container =this.getContentPane(); container.setLayout(new BorderLayout()); this.setSize(600,600); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); this.setBackground(Color.orange); //添加监听器 this.addMouseListener(this); &#125; public void paint(Graphics g) &#123; //清除画板，重新画画 g.clearRect(0,0,600,600); g.drawRect(px, py, 16*w, 16*w); //注意不是px+16*w g.setColor(Color.black); for(int i=0;i&lt;16;i++) g.drawLine(px, py+w*i,vline, py+w*i); for(int i=0;i&lt;16;i++) g.drawLine(px+w*i, py,px+w*i, hline); //画棋子 for(int i=0;i&lt;v.size();i++) &#123; //获取棋子的坐标 String string=(String)v.get(i); String[] cha =string.split(&quot;-&quot;); //获取x，y的坐标，此时是（2,2）这种形式 int x=Integer.parseInt(cha[0]); int y=Integer.parseInt(cha[1]); //x y坐标转化棋盘中的像素位置 x=x*w+px; y=y*w+py; if(i%2==0)&#123; //一定要是i%2才行；不然的话会画错棋子 g.setColor(Color.WHITE); &#125;else &#123; g.setColor(Color.BLACK); //g.setColor(Color.white); &#125; //设置好画笔的颜色，画棋子 g.fillArc(x-w/2,y-w/2,w,w,0,360); &#125; &#125; //鼠标事件 public void mouseClicked(MouseEvent e) &#123; if(e.getButton()==e.BUTTON1) &#123; int x=e.getX(); int y=e.getY(); //棋子的坐标若在一个格的1/2边的时候就划到这一边 x=(x-x%w)+(x%w&gt;w/2?w:0); y=(y-y%w)+(y%w&gt;w/2?w:0); //把棋子的坐标变化成表格中的坐标 x=(x-px)/w; y=(y-py)/w; //打印下的棋子的坐标 System.out.println(x+&quot; &quot;+y ); //先判断一下，因为不能在棋盘外面画棋子 if(x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;x&lt;=16&amp;&amp;y&lt;=16) &#123; if(v.contains(x+&quot;-&quot;+y))&#123;&#125; //如果vector中有了这个点了就不能在这个地方画棋子了 else &#123; //先把棋子添加到v中，在判断一下添加到黑白棋的vector中 v.add(x+&quot;-&quot;+y); //System.out.println(&quot;v&quot;+v); //存完之后 要重画一边 才能显示 this.repaint(); if(v.size()%2==0) &#123; //因为首先画的是白子，vecyor从0开始存的，所以当v中有奇数个棋子的时候，再画就应该画白子了 black.add(x+&quot;-&quot;+y); this.vectory(x,y,black); //System.out.println(&quot;black&quot;+black ); &#125;else &#123; white.add(x+&quot;-&quot;+y); this.vectory(x,y,white); //System.out.println(&quot;white:&quot;+white ); &#125; &#125; &#125; &#125; if (e.getButton() == e.BUTTON3) &#123; //右击悔棋的方法 //System.out.println(&quot;鼠标右击--悔棋&quot;); if (v.isEmpty()) &#123; JOptionPane.showMessageDialog(this, &quot;没有棋可悔&quot;); &#125; else &#123; if (v.size() % 2 == 0) &#123; //判断是白棋悔棋，还是黑棋悔棋 blackCount++; if (blackCount &gt; 3) &#123; JOptionPane.showMessageDialog(this, &quot;黑棋已经悔了3步&quot;); &#125; else &#123; v.remove(v.lastElement()); //一定要加上下面这句话，不然的话悔棋之后那个坐标还是存在black的集合中 black.remove(v.lastElement()); this.repaint(); &#125; &#125; else &#123; whiteCount++; if (whiteCount &gt; 3) &#123; JOptionPane.showMessageDialog(this, &quot;白棋已经悔了3步&quot;); &#125; else &#123; v.remove(v.lastElement()); white.remove(v.lastElement()); this.repaint(); &#125; &#125; &#125; &#125; &#125; public void vectory(int x, int y, Vector ve) &#123; int cv=0;//垂直方向 int ch=0;//水平方向 int ci1=0; int ci2=0; //判断是否能连成五个字的线，垂直方向向右 for(int i=1;i&lt;5;i++) &#123; if(ve.contains((x+i)+&quot;-&quot;+y)) &#123; cv++; &#125;else &#123; break; &#125; &#125; //垂直方向向左 for(int i=1;i&lt;5;i++) &#123; if(ve.contains((x-i)+&quot;-&quot;+y)) &#123; cv++; &#125;else &#123; break; &#125; &#125; //水平方向 for(int i=1;i&lt;5;i++) &#123; if(ve.contains(x+&quot;-&quot;+(y+i))) &#123; ch++; &#125;else &#123; break; &#125; &#125; for(int i=1;i&lt;5;i++) &#123; if(ve.contains(x+&quot;-&quot;+(y-i))) &#123; ch++; &#125;else &#123; break; &#125; &#125; //45du方向 for(int i=1;i&lt;5;i++) &#123; if(ve.contains((x+i)+&quot;-&quot;+(y+i))) &#123; ci1++; &#125;else &#123; break; &#125; &#125; for(int i=1;i&lt;5;i++) &#123; if(ve.contains((x-i)+&quot;-&quot;+(y-i))) &#123; ci1++; &#125;else &#123; break; &#125; &#125; //145du方向向右 for(int i=1;i&lt;5;i++) &#123; if(ve.contains((x+i)+&quot;-&quot;+(y-i))) &#123; ci2++; &#125;else &#123; break; &#125; &#125; for(int i=1;i&lt;5;i++) &#123; if(ve.contains((x-i)+&quot;-&quot;+(y+i))) &#123; ci2++; &#125;else &#123; break; &#125; &#125; //判断一下，只需要判断与4的关系就好了，因为上面的判断都是从1开始判断到5，只是判断了4次 if(ch&gt;=4||cv&gt;=4||ci1&gt;=4||ci2&gt;=4) &#123; if(v.size()%2==0) &#123; //通过vector中的棋子数目来判断是谁赢了，白棋如果赢了，那么vector中是奇数个 JOptionPane.showMessageDialog(null,&quot;黑棋赢了&quot;); &#125;else &#123; JOptionPane.showMessageDialog(null, &quot;白棋赢了&quot;); &#125; this.v.clear(); this.black.clear(); this.white.clear(); this.repaint(); &#125; &#125; public void mouseEntered(MouseEvent e) &#123; &#125; public void mouseExited(MouseEvent e) &#123; &#125; public void mousePressed(MouseEvent e) &#123; &#125; public void mouseReleased(MouseEvent e) &#123; &#125;&#125; 3、 总结：学会了vector集合的使用方法，鼠标点击事件的处理。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://zouyunkai.github.io/myblog/categories/JAVA/"}],"tags":[{"name":"小游戏","slug":"小游戏","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"},{"name":"五子棋","slug":"五子棋","permalink":"https://zouyunkai.github.io/myblog/tags/%E4%BA%94%E5%AD%90%E6%A3%8B/"}],"author":"aoyuehan"},{"title":"java小游戏-贪吃蛇","slug":"java小游戏-贪吃蛇","date":"2019-07-22T07:18:00.000Z","updated":"2022-02-26T03:52:51.669Z","comments":true,"path":"2019/07/22/java小游戏-贪吃蛇/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/22/java%E5%B0%8F%E6%B8%B8%E6%88%8F-%E8%B4%AA%E5%90%83%E8%9B%87/","excerpt":"","text":"java小游戏-贪吃蛇1、 设计蓝图 首先是设计三个类，分别为Food,She,Game。 有两个对象，分别为蛇和食物；其中蛇有依照键盘按键走不同方向，吃食物的行为；食物有消失和产生的行为。 Food类存入食物的坐标 ；She类存入蛇头位置，蛇的长度，蛇头的方向等蛇的基本属性和蛇移动、吃食物的方法；Game产生界面，并且实现键盘监听，判断游戏是否结束，实现蛇的自动移动的功能； 效果： 2、源代码： Food类： 1234 public class Food &#123; public int[] foodx= &#123;500,50,125,600,800&#125;; public int[] foody= &#123;500,75,800,125,800&#125;;&#125;She类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class She &#123; // 线程内部类实现面板重画功能 String direction=&quot;R&quot;; //蛇头的方向，R L U D int length=1; //除了蛇头的身体的长度 int x=400; //she头的坐标 int y=400; int[] bodyx=new int[100]; int[] bodyy=new int[100]; int speed=25; //蛇的速度，一小格 是 25 //蛇头的图片 public String imageUrl=&quot;/image/s_mario_stand_R.png&quot;; public void move() &#123; //一个蛇身体的块 是由上一个块来决定的 //蛇头的方向是由键盘方向来控制的 //for循环倒着遍历 for(int i=length;i&gt;0;i--) &#123; if(i==1) &#123; //数组 下标头部的下一节为0，然后依次推，靠头的那部分，就是i==1的时候，变为头的坐标 //否则就，从蛇尾开始，后一节的变为前一节（因为这样不会出现空节的现象） bodyx[i-1]=x; bodyy[i-1]=y; &#125;else &#123; bodyx[i-1]=bodyx[i-2]; bodyy[i-1]=bodyy[i-2]; &#125; &#125; //要先遍历在判断蛇头向哪走，加多少 if(direction==&quot;R&quot;) &#123; x+=speed; &#125;else if(direction==&quot;L&quot;) &#123; x-=speed; &#125;else if(direction==&quot;D&quot;) &#123; y+=speed; &#125;else if(direction==&quot;U&quot;) &#123; y-=speed; &#125; &#125; public void eat() &#123; //先加上一节，虽然不知道在那里加 length++; move(); &#125;&#125; Game类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188import java.awt.BorderLayout;import java.awt.Color;import java.awt.Container;import java.awt.Graphics;import java.awt.Image;import java.awt.Panel;import java.awt.Toolkit;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import javax.swing.JFrame;import javax.swing.JOptionPane;import javax.swing.Timer;public class Game extends JFrame implements KeyListener&#123; //创建一个蛇和食物的全局对象 She snake=new She(); Food food=new Food(); boolean iseat=false; boolean isdie=false; int j; //记录消失的食物的代号，因为要产生的食物覆盖消食的食物的位置 public Game() &#123; this.setTitle(&quot;贪贪吃蛇&quot;); Container container =this.getContentPane(); container.setLayout(new BorderLayout()); this.setSize(1016,1038); this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //添加监听器 this.addKeyListener(this); this.setVisible(true); tim.start(); &#125; //重新游戏 public void regame() &#123; this.dispose(); new Game(); &#125; //开一个计时器 让蛇自己动 Timer tim=new Timer(300,new ActionListener() &#123; public void actionPerformed(ActionEvent arg0) &#123; if(isdie)&#123; tim.stop(); return; &#125; if(snake.direction==&quot;L&quot;) &#123; //如果头朝向左 for(int i=0;i&lt;5;i++) &#123; if((snake.x-25)==food.foodx[i]&amp;&amp;snake.y==food.foody[i]) &#123; iseat=true; //记录消失的食物的数组下标 j=i; &#125; &#125; if(iseat) &#123; snake.eat(); snake.move(); createfood(); iseat=false; &#125;else &#123; snake.move(); &#125; repaint(); &#125; if(snake.direction==&quot;U&quot;) &#123; //如果头朝向上 for(int i=0;i&lt;5;i++) &#123; if(snake.x==food.foodx[i]&amp;&amp;(snake.y-25)==food.foody[i]) &#123; iseat=true; j=i; &#125; &#125; if(iseat) &#123; snake.eat(); snake.move(); createfood(); iseat=false; &#125;else &#123; snake.move(); &#125; repaint(); &#125; if(snake.direction==&quot;R&quot;) &#123; //如果头朝向右 for(int i=0;i&lt;5;i++) &#123; if((snake.x+25)==food.foodx[i]&amp;&amp;snake.y==food.foody[i]) &#123; iseat=true; j=i; &#125; &#125; if(iseat) &#123; snake.eat(); snake.move(); createfood(); iseat=false; &#125;else &#123; snake.move(); &#125; repaint(); &#125; if(snake.direction==&quot;D&quot;) &#123; //如果头朝向下 for(int i=0;i&lt;5;i++) &#123; if(snake.x==food.foodx[i]&amp;&amp;(snake.y+25)==food.foody[i]) &#123; iseat=true; j=i; &#125; &#125; if(iseat) &#123; snake.eat(); snake.move(); createfood(); iseat=false; &#125;else &#123; snake.move(); &#125; repaint(); &#125; &#125; &#125;); public void paint(Graphics g) &#123;// g.clearRect(0,0,600,600); 这一行可以用下面这句话来代替，重画一下面板，才能继续画 super.paint(g); // 这个是paint空方法，用来初始化一下面板 //判断蛇撞到身子时，这时候最后一个身子上前移的时候，覆盖头，就是和头的坐标一致，所以会直接结束游戏，不判断最后一节的方法是什么 for(int i=1;i&lt;snake.length;i++) &#123; if(snake.x==snake.bodyx[i]&amp;&amp;snake.y==snake.bodyy[i]) &#123; isdie=true; JOptionPane.showMessageDialog(null, &quot;GameOver&quot;); regame(); &#125; &#125; //初始化面板 g.setColor(Color.WHITE); g.fillRect(0, 0, 1000, 1000); //实心矩形 g.setColor(Color.BLUE); Image headimg=Toolkit.getDefaultToolkit().getImage( Panel.class.getResource(snake.imageUrl)); //画蛇头和蛇身子，蛇头用图片，蛇身子用蓝色实心圆画 for(int i=0;i&lt;=snake.length;i++) &#123; g.drawImage(headimg,snake.x, snake.y,25,25,this); g.fillArc(snake.bodyx[i], snake.bodyy[i], 25, 25,0,360); &#125; //先换一下黄色颜色，画食物 g.setColor(Color.YELLOW); for(int i=0;i&lt;5;i++) &#123; g.fillRect(food.foodx[i], food.foody[i], 25, 25); &#125; &#125; //食物产生的方法 public void createfood() &#123; int x=((int)(Math.random()*40)*25); int y=((int)(Math.random()*40)*25); food.foodx[j]=x; food.foody[j]=y; &#125; //键盘监听 public void keyPressed(KeyEvent e) &#123; if(e.getKeyCode()==KeyEvent.VK_LEFT) &#123; //左键 if(snake.direction==&quot;R&quot;) &#123; //添加if-else这样做的原因是不让蛇头与正在走的方向相反的方向走，否则就会死亡 &#125; else&#123;snake.direction=&quot;L&quot;;&#125; &#125; if(e.getKeyCode()==KeyEvent.VK_UP) &#123; //上键 if(snake.direction==&quot;D&quot;) &#123; &#125; else&#123;snake.direction=&quot;U&quot;;&#125; &#125; if(e.getKeyCode()==39) &#123; //右键 if(snake.direction==&quot;L&quot;) &#123; &#125; else&#123;snake.direction=&quot;R&quot;;&#125; &#125; if(e.getKeyCode()==40) &#123; //下键 if(snake.direction==&quot;U&quot;) &#123; &#125; else&#123;snake.direction=&quot;D&quot;;&#125; &#125; &#125; public void keyReleased(KeyEvent e) &#123; &#125; public void keyTyped(KeyEvent e) &#123; &#125; public static void main(String[] args) &#123; new Game(); &#125;&#125; 3、 总结：复习了一下关于java窗口设计的知识，懂的了计时器是怎么用的，为键盘添加监听器的方法，Toolkit画图片的方法，关键之处是如何把蛇的运动这个行为抽象成一个move方法，对象的属性抽象成几个变量。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://zouyunkai.github.io/myblog/categories/JAVA/"}],"tags":[{"name":"小游戏","slug":"小游戏","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"},{"name":"贪吃蛇","slug":"贪吃蛇","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%B4%AA%E5%90%83%E8%9B%87/"}],"author":"aoyuehan"},{"title":"STL_string","slug":"C-字符串处理","date":"2019-07-22T00:15:00.000Z","updated":"2022-02-26T03:52:52.589Z","comments":true,"path":"2019/07/22/C-字符串处理/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/22/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/","excerpt":"","text":"C++中的字符串类型 常用的C++的字符串类型主要是std::string。它是模板std::basic_string的一个实例化。 std::string中的很多操作都是基于迭代器的——这样的话，很多操作，我们都需要先调用find或者直接遍历字符串拿到操作区间的迭代器，然后再进行实际的操作。成员函数中：insert、erase、replace都是基于迭代器的操作。 1、 string类是一个模板类，位于名字空间std中，通常为方便使用还需要增加：using namespace std; 声明一个字符串变量很简单：string str; 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main ( )&#123; string str; //定义了一个空字符串str str = &quot;Hello world&quot;; // 给str赋值为&quot;Hello world&quot; char cstr[] = &quot;abcde&quot;; //定义了一个C字符串 string s1(str); //调用复制构造函数生成s1，s1为str的复制品 cout&lt;&lt;s1&lt;&lt;endl; string s2(str,6); //将str内，开始于位置6的部分当作s2的初值 cout&lt;&lt;s2&lt;&lt;endl; string s3(str,6,3); //将str内，开始于6且长度顶多为3的部分作为s3的初值 cout&lt;&lt;s3&lt;&lt;endl; string s4(cstr); //将C字符串作为s4的初值 cout&lt;&lt;s4&lt;&lt;endl; string s5(cstr,3); //将C字符串前3个字符作为字符串s5的初值。 cout&lt;&lt;s5&lt;&lt;endl; string s6(5,&#x27;A&#x27;); //生成一个字符串，包含5个&#x27;A&#x27;字符 cout&lt;&lt;s6&lt;&lt;endl; string s7(str.begin(),str.begin()+5); //区间str.begin()和str.begin()+5内的字符作为初值 cout&lt;&lt;s7&lt;&lt;endl; return 0;&#125;程序执行结果为：Hello worldworldworabcdeabcAAAAAHello 2、 string的比较等操作你可以用 &#x3D;&#x3D;、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;、和!&#x3D;比较字符串，可以用+或者+&#x3D;操作符连接两个字符串，并且可以用[ ]获取特定的字符。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str; cout &lt;&lt; &quot;Please input your name:&quot;&lt;&lt;endl; cin &gt;&gt; str; if( str == &quot;Li&quot; ) // 字符串相等比较 cout &lt;&lt; &quot;you are Li!&quot;&lt;&lt;endl; else if( str != &quot;Wang&quot; ) // 字符串不等比较 cout &lt;&lt; &quot;you are not Wang!&quot;&lt;&lt;endl; else if( str &lt; &quot;Li&quot;) // 字符串小于比较，&gt;、&gt;=、&lt;=类似 cout &lt;&lt; &quot;your name should be ahead of Li&quot;&lt;&lt;endl; else cout &lt;&lt; &quot;your name should be after of Li&quot;&lt;&lt;endl; str += &quot;, Welcome!&quot;; // 字符串+= cout &lt;&lt; str&lt;&lt;endl; for(int i = 0 ; i &lt; str.size(); i ++) cout&lt;&lt;str[i]; // 类似数组，通过[]获取特定的字符 //cout&lt;&lt; str[i]; 可换为： cout&lt;&lt; str.at(i); return 0;&#125;程序执行结果为：Please input your name:Zhang↙you are not Wang!Zhang, Welcome!Zhang, Welcome! 3、 string特性描述 123456789101112131415161718192021222324252627282930313233343536373839int capacity()const; //返回当前容量（即string中不必增加内存即可存放的元素个数）int max_size()const; //返回string对象中可存放的最大字符串的长度int size()const; //返回当前字符串的大小int length()const; //返回当前字符串的长度bool empty()const; //当前字符串是否为空void resize(int len,char c); //把字符串当前大小置为len，多去少补，多出的字符c填充不足的部分#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str; if (str.empty()) cout&lt;&lt;&quot;str is NULL.&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;str is not NULL.&quot;&lt;&lt;endl; str = str + &quot;abcdefg&quot;; cout&lt;&lt;&quot;str is &quot;&lt;&lt;str&lt;&lt;endl; cout&lt;&lt;&quot;str&#x27;s size is &quot;&lt;&lt;str.size()&lt;&lt;endl; cout&lt;&lt;&quot;str&#x27;s capacity is &quot;&lt;&lt;str.capacity()&lt;&lt;endl; cout&lt;&lt;&quot;str&#x27;s max size is &quot;&lt;&lt;str.max_size()&lt;&lt;endl; cout&lt;&lt;&quot;str&#x27;s length is &quot;&lt;&lt;str.length()&lt;&lt;endl; str.resize(20,&#x27;c&#x27;); cout&lt;&lt;&quot;str is &quot;&lt;&lt;str&lt;&lt;endl; str.resize(5); cout&lt;&lt;&quot;str is &quot;&lt;&lt;str&lt;&lt;endl; return 0;&#125;程序执行结果为：str is NULL.str is abcdefgstr&#x27;s size is 7str&#x27;s capacity is 15str&#x27;s max size is 4294967294str&#x27;s length is 7str is abcdefgcccstr is abcde 5、string的查找；rfind() 类似，只是从反向查找 12345678910111213141516171819202122232425262728293031323334size_type find( const basic_string &amp;str, size_type index ); //返回str在字符串中第一次出现的位置（从index开始查找），如果没找到则返回string::npossize_type find( const char *str, size_type index ); // 同上size_type find( const char *str, size_type index, size_type length ); //返回str在字符串中第一次出现的位置（从index开始查找，长度为length），如果没找到就返回string::npossize_type find( char ch, size_type index ); // 返回字符ch在字符串中第一次出现的位置（从index开始查找），如果没找到就返回string::npos注意：查找字符串a是否包含子串b,不是用 strA.find(strB) &gt; 0 而是 strA.find(strB) != string:nposstrchr(s1,ch) : 返回一个指针，指向字符串s1中字符ch第一次出现的位置strrchr(p, c) : 在字符串中反向查找strstr(s1,s2) : 返回一个指针，指向字符串s1中字符串s2的第一次出现位置关于查找的另一些用法：#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int loc; string s=&quot;study hard and make progress everyday! every day!!&quot;; loc=s.rfind(&quot;make&quot;,10); cout&lt;&lt;&quot;the word make is at index&quot;&lt;&lt;loc&lt;&lt;endl;//-1表示没找到 loc=s.rfind(&quot;make&quot;);//缺省状态下，从最后一个往前找 cout&lt;&lt;&quot;the word make is at index&quot;&lt;&lt;loc&lt;&lt;endl; loc=s.find_first_of(&quot;day&quot;); //在一个字符串中进行查找，返回值是第一个与指定字符串中任何字符匹配的字符位置；如果没有找到匹配的内容，就返回 string::npos 。本例中就在字符串中查找第一次出现‘d’或‘a’或‘y’的位置。 cout&lt;&lt;&quot;the word day(first) is at index &quot;&lt;&lt;loc&lt;&lt;endl; loc=s.find_first_not_of(&quot;study&quot;); cout&lt;&lt;&quot;the first word not of study is at index&quot;&lt;&lt;loc&lt;&lt;endl; loc=s.find_last_of(&quot;day&quot;); cout&lt;&lt;&quot;the last word of day is at index&quot;&lt;&lt;loc&lt;&lt;endl; loc=s.find(&quot;day&quot;);//缺陷状态下从第一个往后找 cout&lt;&lt;loc; return 0;&#125; 上述结果为： 6、 其他常用函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748string &amp;insert(int p,const string &amp;s); //在p位置插入字符串sstring &amp;replace(int p, int n,const char *s); //删除从p开始的n个字符，然后在p处插入串sstring &amp;replace(int p, int n,const char *s，int q) //删除从p开始的n个字符，然后在p处插入串s的前q个字符string &amp;erase(int p, int n); //删除p开始的n个字符，返回修改后的字符串string substr(int pos = 0,int n = npos) const; //返回pos开始的n个字符组成的字符串void swap(string &amp;s2); //交换当前字符串与s2的值string &amp;append(const char *s); //把字符串s连接到当前字符串结尾，其中这个*s不能是字符型的数据，否则会报错“invalid conversion from &#x27;char&#x27; to &#x27;const char*&#x27;“void push_back(char c) //当前字符串尾部加一个字符cconst char *data()const; //返回一个非null终止的c字符数组，data():与c_str()类似，用于string转const char*其中它返回的数组是不以空字符终止,const char *c_str()const; //返回一个以null终止的c字符串，即c_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同,用于string转const char*int strcmp (const char *s1, const char *s2);比较字符串s1和字符串s2。返回值是s1与s2第一个不同的字符差值。两个字符串自左向右逐个字符相比（按ASCII值大小相比较，注意他们的顺序），直到出现不同的字符或遇&#x27;\\0&#x27;为止。int stricmp (const char *s1, const char *s2);比较字符串s1和字符串s2，忽略大小写。返回值是s1与s2第一个不同的字符差值。char *strcpy (char *dest, const char *src);复制字符串src到dest中。返回指针为dest的值。char *strcat (char *dest, const char *src);将字符串src添加到dest尾部。返回指针为dest的值。void *memcpy (void *dest, const void *src, size_t n);从src所指向的对象复制 前 n个字符到dest所指向的对象中。返回指针为dest的值。void *memchr (const void *s, int c, size_t n);在s所指向的对象的 前 n个字符中搜索字符c。如果搜索到，返回指针指向字符c第一次出现的位置；否则返回NULL。 ret = (char*)memchr(str, ch, strlen(str));因为是void类型memset(void*s ,int ch,size_t n);函数解释：将s的前n个字节用ch替换并返回s。其中若把memset（str ，0,5）这种形式调用函数，就会把0转换为／０就会截断字符串，应写为ｍemset(str,&#x27;0&#x27;,5)；例如：memset(prime, 0, sizeof(prime));memmove(void* dest,const void* src,size_t count);函数解释：由src所指的内存区域复制count个字节到dest所指的内存区域。当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确，但是它们的作用是一样的。另外，源和目的的内存区域不能重叠。测试代码;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str1 = &quot;abc123defg&quot;; string str2 = &quot;swap!&quot;; cout&lt;&lt;str1&lt;&lt;endl; cout&lt;&lt;str1.erase(3,3)&lt;&lt;endl; //从索引3开始的3个字符,即删除掉了&quot;123&quot; cout&lt;&lt;str1.insert(0,&quot;123&quot;)&lt;&lt;endl; //在头部插入 cout&lt;&lt;str1.append(&quot;123&quot;)&lt;&lt;endl; //append()方法可以添加字符串 str1.push_back(&#x27;A&#x27;); //push_back()方法只能添加一个字符 cout&lt;&lt;str1&lt;&lt;endl; cout&lt;&lt;str1.replace(0,3,&quot;hello&quot;)&lt;&lt;endl; //即将索引0开始的3个字符替换成&quot;hello&quot; cout&lt;&lt;str1.substr(5,7)&lt;&lt;endl; //返回一个从索引5开始7个字节字符串 str1.swap(str2); cout&lt;&lt;str1&lt;&lt;endl; const char* p = str1.c_str(); printf(&quot;%s\\n&quot;,p); //可以直接打印数组 return 0;&#125; 字符检查 1234567891011isalpha() 检查是否为字母字符 isupper() 检查是否为大写字母字符 islower() 检查是否为小写字母字符 isdigit() 检查是否为数字 isxdigit() 检查是否为十六进制数字表示的有效字符 isspace() 检查是否为空格类型字符 iscntrl() 检查是否为控制字符 ispunct() 检查是否为标点符号 isalnum() 检查是否为字母和数字 isprint() 检查是否是可打印字符 isgraph() 检查是否是图形字符，等效于 isalnum() | ispunct() 字符串到数值类型的转换 1234567891011121314strtod(p, ppend) 从字符串 p 中转换 double 类型数值，并将后续的字符串指针存储到 ppend 指向的 char* 类型存储。strtol(p, ppend, base) 从字符串 p 中转换 long 类型整型数值，base 显式设置转换的整型进制，设置为 0 以根据特定格式判断所用进制，0x, 0X 前缀以解释为十六进制格式整型，0 前缀以解释为八进制格式整型atoi(p) 字符串转换到 int 整型atof(p) 字符串转换到 double 符点数atol(p) 字符串转换到 long 整型 itoa()函数（可以将一个10进制数转换为任意的2-36进制字符串）itoa(num, str, 2); num是一个int型的，是要转化的10进制数，str是转化结果，后面的值为目标进制。strtol()函数函数原型：long int strtol(const char *nptr, char **endptr, int base) base是要转化的数的进制，非法字符会赋值给endptr，nptr是要转化的字符例如：char buffer[20]=&quot; 10549stend# #12&quot;; char *stop; int ans=strtol(buffer, &amp;stop, 8); //将八进制数1054转成十进制，后面均为非法字符 memset函数详细说明 123456789101112 1)void *memset(void *s,int c,size_t n) 总的作用：将已开辟内存空间 s 的首 n 个字节的值设为值 c。 2)memset() 函数常用于内存空间初始化。如： char str[100]; memset(str,0,100); 3)memset可以方便的清空一个结构类型的变量或数组。 4)memset()的深刻内涵：用来对一段内存空间全部设置为某个字符，一般用在对定义的字符串进行初始化为‘ ’或‘/0’；例:char a[100];memset(a, ‘/0’, sizeof(a)); memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度；例：char a[100],b[50]; memcpy(b, a, sizeof(b));注意如用sizeof(a)，会造成b的内存地址溢出。strcpy就只能拷贝字符串了，它遇到’/0’就结束拷贝；例：char a[100],b[50];strcpy(a,b);如用strcpy(b,a)，要注意a中的字符串长度（第一个‘/0’之前）是否超过50位，如超过，则会造成b的内存地址溢出。 memset主要应用是初始化某个内存空间。memcpy是用于copy源空间的数据到目的空间中。strcpy用于字符串copy,遇到‘/0’，将结束。 字符串处理的常用函数：https://blog.csdn.net/wu694128/article/details/79666501https://www.cnblogs.com/findumars/p/6353621.html 小技巧 getline(cin,s1); &#x2F;&#x2F;整行输入 ，可以把cin流放进去 关于 if-else if-else 的问题： 12345678910if( str == &quot;Li&quot; ) // 字符串相等比较 cout &lt;&lt; &quot;you are Li!&quot;&lt;&lt;endl; else if( str != &quot;Wang&quot; ) // 字符串不等比较 cout &lt;&lt; &quot;you are not Wang!&quot;&lt;&lt;endl; else if( str &lt; &quot;Li&quot;) // 字符串小于比较，&gt;、&gt;=、&lt;=类似 cout &lt;&lt; &quot;your name should be ahead of Li&quot;&lt;&lt;endl; else cout &lt;&lt; &quot;your name should be after of Li&quot;&lt;&lt;endl; 输出结果是：you are not Wang! 只会执行4条语句中的一条语句，如果条件1不对，判断条件二，条件二满足条件，执行条件二的语句；如果前三个条件都不满足，就会执行else的语句；如果有多个if语句为真，谁在前面就执行谁。 *stringstream的使用 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200000+10;string b[maxn];int main()&#123; string s; getline(cin,s); stringstream ss; ss&lt;&lt;s; //此时ss中就是由空格分开的 字符串 数组 int k=0; while(ss) &#123; ss&gt;&gt;b[k++]; //从ss中取出来一个字符串 放到字符串数组b中 &#125; for(int i=0;i&lt;k;i++) cout&lt;&lt;b[i]&lt;&lt;&quot;\\n&quot;;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"C++字符串处理","slug":"C-字符串处理","permalink":"https://zouyunkai.github.io/myblog/tags/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"}],"author":"aoyuehan"},{"title":"java算法练习","slug":"java练习","date":"2019-07-18T00:33:00.000Z","updated":"2022-02-26T03:52:52.610Z","comments":true,"path":"2019/07/18/java练习/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/18/java%E7%BB%83%E4%B9%A0/","excerpt":"","text":"例题 java求空心菱形 12345678910111213141516171819202122232425262728293031323334// 空心菱形 for (int i = 1; i &lt;= 5; i++) &#123; // 打印上半部分空格 for (int j = 1; j &lt;= 5 - i; j++) &#123; System.out.print(&quot; &quot;); &#125; // 打印原本实心的*部分 for (int j = 1; j &lt;= 2 * i - 1; j++) &#123; // 仅在一行的开头和末尾打印* if (j == 1 || j == 2 * i - 1) &#123; System.out.print(&quot;*&quot;); &#125; else &#123; System.out.print(&quot; &quot;); &#125; &#125; System.out.println(&quot; &quot;); &#125; for (int i = 4; i &gt;= 1; i--) &#123; // 打印下半部分空格 for (int j = 1; j &lt;= 5 - i; j++) &#123; System.out.print(&quot; &quot;); &#125; // 打印原本实心的*部分 for (int j = 1; j &lt;= 2 * i - 1; j++) &#123; // 仅在一行的开头和末尾打印* if (j == 1 || j == 2 * i - 1) &#123; System.out.print(&quot;*&quot;); &#125; else &#123; System.out.print(&quot; &quot;); &#125; &#125; System.out.println(&quot; &quot;); &#125; java实现矩阵的运算 输入第一个矩阵的行数列数输入第一个矩阵输入第二个矩阵的行数列数输入第二个矩阵输出两个矩阵的jia，cheng，和转置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package juzhen_jia_zhuanzhi;import java.util.Scanner;public class Mar &#123; private static Scanner sin; public static void main(String [] args) &#123; sin=new Scanner(System.in); int n1=sin.nextInt(); int m1=sin.nextInt(); int s1[][]; //第一个空 s1=new int[100][100]; for(int i=0;i&lt;n1;i++) &#123; for(int j=0;j&lt;m1;j++) &#123; s1[i][j]=sin.nextInt(); &#125; &#125; Matr matr1=new Matr(n1, m1, s1); int n2=sin.nextInt(); int m2=sin.nextInt(); int s2[][]; //第二个空 s2=new int[100][100]; for(int i=0;i&lt;n2;i++) &#123; for(int j=0;j&lt;m2;j++) &#123; s2[i][j]=sin.nextInt(); &#125; &#125; Matr matr2=new Matr(n2, m2, s2); System.out.println(&quot;matr1 zhuan zhi hou:&quot;); print(matr1.transpose()); System.out.println(&quot;xiang jia hou:&quot;); print(matr1.jia(matr2)); System.out.println(&quot;xiang cheng hou:&quot;); print(matr1.cheng(matr2)); &#125; //第三个空 public static void print(Matr a) &#123; int s3[][]=new int[100][100]; s3=a.getShuju(); for(int i=0;i&lt;a.getN();i++) &#123; for(int j=0;j&lt;a.getM();j++) &#123; System.out.print(s3[i][j]+&quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125;class Matr&#123; private int n; private int m; private int[][] shuju; public int getN() &#123; return n; &#125; public int getM() &#123; return m; &#125; public void setN(int n) &#123; this.n=n; &#125; public void setM(int m) &#123; this.m=m; &#125; public void setShuju(int [][] shuju) &#123; this.shuju=shuju; &#125; public int[][] getShuju() &#123; return shuju; &#125; public Matr(int n, int m, int[][] shuju) &#123; super(); this.n=n; this.m=m; this.shuju=shuju; &#125; //第四个空 public Matr jia(Matr b) &#123; int s5[][]=new int[100][100]; Matr matr5=new Matr(b.getN(), b.getM(), s5); for(int i=0;i&lt;b.getN();i++) &#123;for(int j=0;j&lt;b.getM();j++) &#123; s5[i][j]=shuju[i][j]+b.shuju[i][j]; &#125; &#125; matr5.setShuju(s5); return matr5; &#125; //第五个空 public Matr cheng(Matr b) &#123; int s5[][]=new int[100][100]; Matr matr5=new Matr(b.getN(), b.getM(), s5); for(int i=0;i&lt;b.getN();i++) &#123; //枚举矩阵a的行 for(int j=0;j&lt;b.getM();j++) &#123;//枚举矩阵b的列，三个for循环的第二三个for循环可以颠倒 s5[i][j]=0; for(int k=0;k&lt;b.getM();k++) &#123;//枚举矩阵a的列，从而实现矩阵a*矩阵b s5[i][j]+=shuju[i][k]*b.shuju[k][j]; //这句话写为shuju[i][j]*=b.shuju[i][j]; 是不对的 &#125; &#125; &#125; matr5.setShuju(s5); return matr5; &#125; //第六个空 public Matr transpose() &#123; int s5[][]=new int[100][100]; Matr matr5=new Matr(this.getN(), this.getM(), s5); for(int i=0;i&lt;=n/2;i++) &#123; for(int j=0;j&lt;=m/2;j++) &#123; s5[i][j]=shuju[j][i]; s5[j][i]=shuju[i][j]; &#125; &#125; matr5.setShuju(s5); return matr5; &#125; /* * 首先这一题中给出的测试数据都是在原来1 3 4 5的基础上进行的 * 而不是在转置，jia之后的那个矩阵进行的矩阵的乘法。 * 正确答案应该 * 在jia，转置，cheng之中新建一个matr对象 * 把对数据的操作都放到行的对象中，不能修改员数据 * * */ &#125; 字符三角形 123456789101112131415161718192021222324252627import java.util.Scanner; public class Main &#123; public static void main(String args[]) &#123; Scanner scanner = new Scanner(System.in); String N = scanner.nextLine();//StringBuilder就是一个字符串类，他生成一个可以改变的字符串 StringBuilder b = new StringBuilder(&quot; &quot;); //39个空格 String c = &quot; &quot;; int k = 1; for (char i = &#x27;A&#x27;; i &lt; N.charAt(0); i++) &#123; System.out.print(b); if (i == &#x27;A&#x27;)&#123; System.out.println(i); &#125;else &#123; System.out.print(i); System.out.print(c); System.out.println(i); c += &quot; &quot;;//c这个代表两字母之间的空格，每次+2 &#125; b.delete(0,1);//每次删掉第0位的空格 k++;//计数，求最后打印多少个最底行的字母 &#125; System.out.print(b); for (int i = 0; i &lt; 2*k -1; i++) &#123; System.out.print(N); &#125; &#125; &#125; java依照输入的大小，输出相应类型1234567891011121314151617181920212223242526272829import java.math.BigInteger;import java.util.Scanner;public class Main&#123; public static void main(String [] args)&#123; BigInteger a;//java的大数可以存无限位数 BigInteger bigInteger1= new BigInteger(&quot;127&quot;); BigInteger bigInteger2= new BigInteger(&quot;32767&quot;); BigInteger bigInteger3= new BigInteger(&quot;2147483647&quot;); BigInteger bigInteger4= new BigInteger(&quot;9223372036854775807&quot;); Scanner sc=new Scanner(System.in); a=sc.nextBigInteger(); if(a.abs().compareTo(bigInteger1)&lt;=0) &#123; System.out.println(&quot;byte&quot;); &#125;else if (a.abs().compareTo(bigInteger2)&lt;=0) &#123; System.out.println(&quot;short&quot;); &#125;else if (a.abs().compareTo(bigInteger3)&lt;=0) &#123; System.out.println(&quot;int&quot;); &#125;else if (a.abs().compareTo(bigInteger4)&lt;=0) &#123; System.out.println(&quot;long&quot;); &#125;else &#123; System.out.println(&quot;BigInteger&quot;); &#125; sc.close(); &#125;&#125; 复杂情况下统计数字和，若有字母则输出attention123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Scanner;public class Main &#123; public static void main(String args[]) &#123; Scanner scanner = new Scanner(System.in); String s = scanner.nextLine(); String[] strings = s.split(&quot; &quot;);//把输入的s按照空格分开成子字符串 int sum = 0; boolean f = false; for (int i = 0; i &lt; strings.length; i++) &#123; if (strings[i].charAt(0)==&#x27;-&#x27;)&#123;//如果子字符串的第一个字符为- ，则为负数 sum += Integer.parseInt(strings[i]);//因为是-，所以一定能转换为数字 &#125;else if (strings[i].charAt(0)&gt;=&#x27;0&#x27; &amp;&amp; strings[i].charAt(0) &lt;= &#x27;9&#x27;)&#123;//如果开头不是-，而是数字 try &#123; sum += Integer.parseInt(strings[i]);//将这个子字符串转换成int类型， &#125;catch (Exception a)&#123;//如果这个子字符串中不全都是数字,就会出错，出错了就执行这一语句块 f = true;//记录一下，过会输出attention continue;//这一句要不要都可 &#125; &#125;else &#123; f = true;//如果开头的第一个就是字母，那么直接记录一下 &#125; &#125; System.out.println(sum); if (f)&#123;//f为true，则输出attention System.out.println(&quot;attention&quot;); &#125; &#125;&#125;方法二：import java.util.Scanner;import java.util.regex.Pattern;public class Main&#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String s = sc.nextLine(); sc.close(); String[] sArr = s.split(&quot; &quot;); boolean hasStr = false; Pattern pattern = Pattern.compile(&quot;[-+]*[0-9]+&quot;); int total = 0; for(int i=0;i&lt;sArr.length;i++) &#123; if (pattern.matcher(sArr[i]).matches()) &#123; total += Integer.parseInt( sArr[i] ); &#125;else &#123; hasStr = true; &#125; &#125; System.out.println(total); if(hasStr) &#123; System.out.println(&quot;attention&quot;); &#125; &#125;&#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://zouyunkai.github.io/myblog/categories/JAVA/"}],"tags":[{"name":"java算法","slug":"java算法","permalink":"https://zouyunkai.github.io/myblog/tags/java%E7%AE%97%E6%B3%95/"}],"author":"aoyuehan"},{"title":"数学知识汇总","slug":"数学知识汇总","date":"2019-07-15T09:50:44.000Z","updated":"2022-02-26T03:52:52.389Z","comments":true,"path":"2019/07/15/数学知识汇总/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/15/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/","excerpt":"","text":"1，排列组合的算法2，gcd算法 1. 组合排列 ![upload successful](\\aoyue\\images\\pasted-12.png) ![upload successful](\\aoyue\\images\\pasted-13.png) 公式中A(n,m)为排列数公式，C(n,m)为组合数公式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175方法一：DFS实现全排列方法如下：//全排列问题#include&lt;stdio.h&gt;#include&lt;string.h&gt;int n;char a[15];char re[15];int vis[15];//假设有n个字符要排列，把他们依次放到n个箱子中//先要检查箱子是否为空，手中还有什么字符，把他们放进并标记。//放完一次要恢复初始状态，当到n+1个箱子时，一次排列已经结束void dfs(int step)&#123; int i; if(step==n+1)//判断边界 &#123; for(i=1;i&lt;=n;i++) printf(&quot;%c&quot;,re[i]); printf(&quot;\\n&quot;); return ; &#125; for(i=1;i&lt;=n;i++)//遍历每一种情况 &#123; if(vis[i]==0)//check满足 &#123; re[step]=a[i]; vis[i]=1;//标记 dfs(step+1);//继续搜索 vis[i]=0;//恢复初始状态 &#125; &#125; return ;&#125; int main(void)&#123; int T; scanf(&quot;%d&quot;,&amp;T); getchar(); while(T--) &#123; memset(a,0,sizeof(a)); memset(vis,0,sizeof(vis));//对存数据的数组分别初始化 scanf(&quot;%s&quot;,a+1); n=strlen(a+1); dfs(1);//从第一个箱子开始 &#125; return 0;&#125;方法二：* 递归实现全排列 输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，则输出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。 **递归思想：** 假如针对abc的排列，可以分成 (1)以a开头，加上bc的排列 (2)以b开头，加上ac的排列 (3)以c开头，加上ab的排列 #include&lt;bits/stdc++.h&gt; using namespace std;//产生排列组合的递归写法 void pai(char t[],int k,int n)&#123; if(k==n-1)&#123; //输出这个排列，k=n-1就是 递归出口 for(int i=0;i&lt;n;i++)&#123; cout&lt;&lt;t[i]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;else&#123; for(int i=k;i&lt;n;i++)&#123; //一次挑选n个元素中的一个,和前位置替换 int tmp=t[i];t[i]=t[k];t[k]=tmp; //再对其余的n-1个字母一次挑选 pai(t,k+1,n); //在换回到原来的状态 tmp=t[i];t[i]=t[k];t[k]=tmp; &#125; &#125; &#125;int main ()&#123; char t[3]=&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;; //t为数组 int k=0; //k为起始排列值 int n=3; //n为数组长度，是数组声明的时候的下标 cout&lt;&lt;&quot;第一种方法：&quot;&lt;&lt;endl; pai(t,0,n); cout&lt;&lt;&quot;第二种方法：&quot;&lt;&lt;endl; do&#123; cout&lt;&lt;t[0]&lt;&lt;&quot; &quot;&lt;&lt;t[1]&lt;&lt;&quot; &quot;&lt;&lt;t[2]&lt;&lt;endl; &#125;while(next_permutation(t,t+3));//参数3指的是要进行排列的长度 /* 如果存在t之后的排列，就返回true。如果a是最后一个排列没有后继，返回false，每执行一次，t就变成它的后继；若排列本来就是最大的了没有后继，则next_permutation执行后，会对排列进行字典升序排序,相当于循环 */&#125;其中STL之next_permutation函数详解(1) int 类型的next_permutation int main()&#123; int a[3]; a[0]=1;a[1]=2;a[2]=3; do&#123; cout&lt;&lt;a[0]&lt;&lt;&quot; &quot;&lt;&lt;a[1]&lt;&lt;&quot; &quot;&lt;&lt;a[2]&lt;&lt;endl; &#125; while (next_permutation(a,a+3)); //参数3指的是要进行排列的长度 //如果存在a之后的排列，就返回true。如果a是最后一个排列没有后继，返回false，每执行一次，a就变成它的后继&#125;/*如果改成 while(next_permutation(a,a+2));只对前两个元素进行字典排序*/(2) char 类型的next_permutation int main()&#123; char ch[205]; cin &gt;&gt; ch; sort(ch, ch + strlen(ch) ); //该语句对输入的数组进行字典升序排序。如输入9874563102 cout&lt;&lt;ch; 将输出0123456789,这样就能输出全排列了 char *first = ch; char *last = ch + strlen(ch); do &#123; cout&lt;&lt; ch &lt;&lt; endl; &#125;while(next_permutation(first, last)); return 0;&#125; //这样就不必事先知道ch的大小了，是把整个ch字符串全都进行排序//若采用 while(next_permutation(ch,ch+5)); 如果只输入1562，就会产生错误，因为ch中第五个元素指向未知//若要整个字符串进行排序，参数5指的是数组的长度，不含结束符(3) string 类型的next_permutation int main()&#123; string line; while(cin&gt;&gt;line&amp;&amp;line!=&quot;#&quot;) &#123; if(next_permutation(line.begin(),line.end())) //从当前输入位置开始 cout&lt;&lt;line&lt;&lt;endl; else cout&lt;&lt;&quot;Nosuccesor\\n&quot;; &#125;&#125;(4)next_permutation 自定义比较函数 #include&lt;iostream&gt; //poj 1256 Anagram#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int cmp(char a,char b) //&#x27;A&#x27;&lt;&#x27;a&#x27;&lt;&#x27;B&#x27;&lt;&#x27;b&#x27;&lt;...&lt;&#x27;Z&#x27;&lt;&#x27;z&#x27;.&#123; if(tolower(a)!=tolower(b)) return tolower(a)&lt;tolower(b); else return a&lt;b;&#125;int main()&#123; char ch[20]; int n; cin&gt;&gt;n; while(n--) &#123; scanf(&quot;%s&quot;,ch); sort(ch,ch+strlen(ch),cmp); do &#123; printf(&quot;%s\\n&quot;,ch); &#125;while(next_permutation(ch,ch+strlen(ch),cmp)); &#125; return 0;&#125; 2.1、gcd算法 GCD（Great Common Divisor）算法，即所谓最大公约数算法，也称为HCF（Highest Common Factor）算法。而所谓的最大公约数，指的是几个整数中共有约数中最大的一个。如果数A可被M整除，则M就是A的约数（因数），那么如果数A、 B、 C都可被M整除，且M是可以整除这些数种最大的整数，则M就成为A B C的最大公约数，记为(A、 B、 C)，如（12、15、18）&#x3D;3。 辗转相除法 即两个整数的最大公约数等于其中较小的数和两数的差的最大公约数。即一步步的降低两个数的值，直到其中一个变成零，这时所剩下的还没有变成零的数就是两个数的最大公约数。例如：252（2112）和105（215）的最大公约数就是21，则147（252-105）和105的最大公约数也是21，然后42（147-105）和105的最大公约数也是21………… 定理：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。最大公约数（Greatest Common Divisor）缩写为GCD。gcd(a,b) &#x3D; gcd(b,a mod b) (不妨设a&gt;b 且r&#x3D;a mod b ,r不为0)证明 ：a可以表示成a &#x3D; kb + r（a，b，k，r皆为正整数，且r&lt;b），则r &#x3D; a mod b假设d是a,b的一个公约数，记作d|a,d|b，即a和b都可以被d整除。而r &#x3D; a - kb，两边同时除以d，r&#x2F;d&#x3D;a&#x2F;d-kb&#x2F;d&#x3D;m，由等式右边可知m为整数，因此d|r因此d也是b,a mod b的公约数假设d是b,a mod b的公约数, 则d|b,d|(a-k*b),k是一个整数。进而d|a.因此d也是a,b的公约数因此(a,b)和(b,a mod b)的公约数是一样的，其最大公约数也必然相等，得证。可以发现，辗转相除法就是一种递归算法，每一步计算的输出值就是下一步计算的输入值。设k表示步骤数（从零开始计数），则计算过程如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* 递归方法实现： */int gcd(int a,int b)&#123; if(b==0) return a; return gcd(b,a%b);&#125;/* 迭代法（递推法，即非递归方法）：欧几里得算法，计算最大公约数 */int gcd(int m, int n)&#123; while(m&gt;0) &#123; int c = n % m; n = m; m = c; &#125; return n;&#125;/* 快速GCD算法，其原理是：更相减损法，当传入的参数a和b均为偶数时，我们吧a和b全部右移（&gt;&gt;），然后在结尾乘2（&lt;&lt;），如果一个奇数，一个偶数的话我们很容易想到，2肯定不会是这两个数的公约数，所以我们把偶数右移两位（&gt;&gt;）， 如果两个数都是奇数的话，我们就令他们进行相减，然后再把a和b取最小的传入，就会出现一奇一偶的两个数即可进行下一步的运算； */算法C++实现如下：int qGCD(int a, int b)&#123; if(a == 0) return b; if(b == 0) return a; if(!(a &amp; 1) &amp;&amp; !(b &amp; 1)) // a % 2 == 0 &amp;&amp; b % 2 == 0; return qGCD(a &gt;&gt; 1, b &gt;&gt; 1) &lt;&lt; 1; else if(!(b &amp; 1)) return qGCD(a, b &gt;&gt; 1); else if(!(a &amp; 1)) return qGCD(a &gt;&gt; 1, b); else return qGCD(abs(a - b), min(a, b));&#125;最小公倍数 最小公倍数，就是a b的乘积除以它们两个的最大公约数，就是它们的最小公倍数。代码如下：int MinMultiple( int a, int b)&#123; return (a * b)/gcd(a, b);&#125; 算法笔记中的数学模块分数的表示和简化12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;struct Fraction&#123; long long up,down;//分子 分母 &#125;; Fraction reduction(Fraction result)&#123;//分数的化简 if(result.down&lt;0)&#123;//若果分母小于0，让负号表示在分子上 result.down=-result.down; result.up=-result.up; &#125; if(result.up==0)result.down=1;//如果分子为0，令分母为1 else &#123; long long d=__gcd(abs(result.up),abs(result.down)); result.up/=d; result.down/=d; &#125; return result;&#125;//分数的加法Fraction add(Fraction f1,Fraction f2)&#123; Fraction result; result.up=f1.up*f2.down+f2.up*f1.down; result.down=f1.down*f2.down; return reduction(result); &#125; //分数的乘法除法减法类似void showResult(Fraction r)&#123;//分数的输出 r=reduction(r); if(r.down==1)cout&lt;&lt;r.up&lt;&lt;endl; else if(abs(r.up)&gt;r.down)&#123;//假分数 cout&lt;&lt;r.up/r.down&lt;&lt;&#x27; &#x27;&lt;&lt;abs(r.up)%r.down&lt;&lt;&#x27; &#x27;&lt;&lt;r.down&lt;&lt;endl; &#125;else &#123; cout&lt;&lt;r.up&lt;&lt;r.down&lt;&lt;endl; &#125; &#125; 最大公约数和最小公倍数1234567891011121314/*欧几里得算法基于这个定理：设a、b均为正整数，则gcd(a,b)=gcd(b,a%b) */int gcd(int a,int b)&#123; if(b==0)return a; else return gcd(b,a%b); /* return !b?a:gcd(b,a%b); */ &#125; //最小公倍数: lcm(a,b)=a*b/gcd(a,b) //为防止溢出可写为：a/gcd(a,b)*b 拓展欧几里得算法、同余方程、逆元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051扩展欧几里得算法给定两个非0整数a,b，求一组整数解(x,y)，使得ax+by=gcd(a,b)成立其中gcd(a,b)表示a和b的最大公约数 int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0)&#123; x=1; y=0; return a; &#125; int g=exgcd(b,a%b,x,y);//递归计算exgcd(b,a%b) int temp=x; x=y; y=temp-a/b*y; return g;//g是gcd /* 通过x=y(old); y=x(old)-a/b*y(old);来倒推结果 tips：a%b=a-(a/b)*b和ax1+by1=bx2+(a%b)y2退出上式 */&#125; 通过上面的方法求出的是一组解，ax+by=gcd(a,b)的通解为：x&#x27;=x+b/gcd*K (K为任意整数)y&#x27;=y-a/gcd*K 其中，最小的非负整数解为x=(x%(b/gcd)+b/gcd)%(b/gcd);y同理 再者：得到ax+by=c的解为（存在解的充要条件为c%gcd==0） x&#x27;=x+b/gcd*K=cx0/gcd+b/gcd*K; (K为任意整数,注意周期不能变为cb/gcd^2,因为周期会放大，漏解)y&#x27;=y-a/gcd*K=cy0/gcd-b/gcd*K;----------------- 同余式ax==c(mod m)的求解(如果m整除a-b即(a-b)%m==0,那么就说a与b模m同余 )设a，c，m是整数，其中m&gt;=1,则1、若c%gcd(a,m)!=0,则同余方程ax==c(mod m)无解2、若c%gcd(a,m)==0,则同余方程ax==c(mod m)恰好有gcd(a,m)个模m意义下不同的解，且解的形式为：x&#x27;=x+m/gcd(a,m)*K;其中K=0，1,....gcd(a,m)-1,x是ax+my=c的一个解--------------逆元 假设a、b、m是整数，m&gt;1,且有ab==1(mod m)成立，那么就说a和b互为模m的逆元如果gcd(a,m)!=1,那么同余式ax==1(mod m)无解，a不存在模m的逆元若果gcd(a,m)==1,那么同余式ax==1(mod m)在(0,m)上有唯一解int inverse(int a,int m)&#123; int x,y; int g=exgcd(a,m,x,y); return (x%m+m)%m;&#125; 费马小定理：设m是素数，a是任意整数且a！==0(mod m),则a^(m-1)==1(mod m);其中a^(m-1)=a*a^(m-2)=1(mod m);得到a^(m-2)%m就是a模m的逆元 素数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*素数=质数，是指除了1和本身之外，不能被其他数整除的一类数。1既不是素数也不是合数。 *///素数的判定bool isPrime(int n)&#123; if(n&lt;=1)return false; //int sqr=(int)sqrt(1.0*n); for(int i=2;i*i&lt;=n;i++)&#123; if(n%i==0)return false; &#125; return true;&#125; //素数表 //诶氏筛法int prime[maxn];bool isPrime[maxn];int sieve(int n)&#123;//n就是筛子的大小，如1~100的表，那么n=100 int num=0; memset(isPrime,true,sizeof(isPrime)); isPrime[0]=isPrime[1]=false; for(int i=2;i&lt;=n;i++)&#123;//从2开始到n if(isPrime[i])&#123; prime[num++]=i; for(int j=2;j*i&lt;=n;j++)&#123; isPrime[j*i]=false; &#125; &#125; &#125; return num;&#125; //欧拉筛法int eulerSieve_1(int n)&#123; int num=0; memset(isPrime,true,sizeof(isPrime)); isPrime[0]=isPrime[1]=false; for(int i=2;i&lt;=n;i++)&#123; //这个从prime的0下标开始存素数 if(isPrime[i])prime[num++]=i;//prine数组从0开始存 //第一次执行num++，prime[0]存入i，之后num为1，那么下面这个for中num为1 for(int j=0;j&lt;num&amp;&amp;i*prime[j]&lt;=n;j++)&#123; //这个从j从0开始到num，遍历一遍prime数组，所以遍历的次数为数组个数 isPrime[i*prime[j]]=false; if(i%prime[j]==0)break;//防止被晒多次 &#125; &#125; return num;&#125; 质因子分解1234567891011121314151617181920212223242526272829303132333435//质因子分解/*定理：对于一个正整数n来说，如果他存在[2,n]范围内的质因子，要么这些质因子全部小与等于sqrt(n)；要么只存在一个大于sqrt(n)的质因子，其余的质因子全部小于等于sqrt(n)。 */ 其中int范围内质因子的个数开到10就好了 其中有了素数表prime[],Pnum为素数的个数 结构体数组： struct factor&#123; int x,cnt;//x为质因子，cnt为个数 &#125;fac[10]; //质因子分解for(int i=0;i&lt;Punm&amp;&amp;prime[i]&lt;=sqrt(n);i++)&#123; if(n%prime[i]==0)&#123; fac[num].x=prime[i];//记录该因子 fac[num].cnt=0; while(n%prime[i]==0)&#123;//计算该因子的个数 fac[num].cnt++; n/=prime[i]; &#125; num++;//不同的质因子的个数 &#125; if(n==1)break; &#125; if(n!=1)&#123;//如果无法被根号n以内的质因子除尽 fac[num].x=n;//那么一定有一个大于根号n的质因子 fac[num].cnt=1;&#125; 高精度加减乘除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//高精度运算#include&lt;iostream&gt;#include&lt;string.h&gt; using namespace std;struct bign&#123; int d[1000]; int len; bign()&#123; memset(d,0,sizeof(d)); len=0; &#125;&#125;;bign change(char str[])&#123;//将str的整数转为bign bign a; a.len=strlen(str); for(int i=0;i&lt;a.len;i++)&#123; a.d[i]=str[a.len-i-1]-&#x27;0&#x27;;//逆着赋值 &#125; return a;&#125;int compare(bign a,bign b)&#123; if(a.len&gt;b.len)return 1;//a大 else if(a.len&lt;b.len)return -1;//a小 else &#123; for(int i=a.len-1;i&gt;=0;i--)&#123;//因为从d的0坐标开始存 if(a.d[i]&gt;b.d[i])return 1; else if(a.d[i]&lt;b.d[i])return -1; &#125; return 0;//相等 &#125;&#125; bign add(bign a,bign b)&#123; bign c; int carry=0; for(int i=0;i&lt;a.len||i&lt;b.len;i++)&#123;//以较长的作为界限 int temp=a.d[i]+b.d[i]+carry; c.d[c.len++]=temp%10; carry=temp/10; &#125; if(carry!=0)&#123; c.d[c.len++]=carry;//新增一位 &#125; return c;&#125;bign sub(bign a,bign b)&#123; bign c; for(int i=0;i&lt;a.len||i&lt;b.len;i++)&#123; if(a.d[i]&lt;b.d[i])&#123; a.d[i+1]--;//不够减，向高位借 a.d[i]+=10; &#125; c.d[c.len++]=a.d[i]-b.d[i];//计算结果储存起来 &#125; while(c.len-1&gt;=1&amp;&amp;c.d[c.len-1]==0)&#123; c.len--;//取出高为的0，并且保留最低位的0 &#125; return c; &#125;bign multi(bign a,int b)&#123; bign c; int carry;//进位 for(int i=0;i&lt;a.len;i++)&#123; int temp=a.d[i]*b+carry; c.d[c.len++]=temp%10; carry=temp/10; &#125; while(carry!=0)&#123;//乘法的进位可能不止一位 c.d[c.len++]=carry%10; carry/=10; &#125; return c;&#125;bign divide(bign a,int b,int &amp;r)&#123;//r为余数 bign c; c.len=a.len; for(int i=a.len-1;i&gt;=0;i--)&#123;//从高为开始除 r=r*10+a.d[i]; if(r&lt;b)c.d[i]=0;//不够除 else &#123;//够除 c.d[i]=r/b; r=r%b; &#125; &#125; while(c.len-1&gt;=1&amp;&amp;c.d[c.len-1]==0)&#123; c.len--; &#125; return c;&#125;void print(bign a)&#123; for(int i=a.len-1;i&gt;=0;i--)&#123; cout&lt;&lt;a.d[i]; &#125; cout&lt;&lt;endl;&#125;int main()&#123; char str1[1000],str2[1000]; int r=0; int c=-2; scanf(&quot;%s&quot;,str1); scanf(&quot;%s&quot;,str2); bign a=change(str1); bign b=change(str2); cout&lt;&lt;&quot;a是否小于b&quot;&lt;&lt;compare(a,b)&lt;&lt;endl; cout&lt;&lt;&quot;a+b=&quot;; print(add(a,b)); cout&lt;&lt;&quot;a-b=&quot;; if(compare(a,b)==1)print(sub(a,b)); else print(sub(b,a)); cout&lt;&lt;&quot;a*c=&quot;; if(c&lt;0)&#123; cout&lt;&lt;&quot;-&quot;;print(multi(a,-c)); &#125;else&#123; print(multi(a,c)); &#125; cout&lt;&lt;&quot;a/c=&quot;;if(c&lt;0)&#123; cout&lt;&lt;&quot;-&quot;;print(divide(a,-c,r)); &#125;else&#123; print(divide(a,c,r)); &#125;cout&lt;&lt;&quot; 余数为：&quot;&lt;&lt;r&lt;&lt;endl;&#125; 排列组合问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354n！中有(n/p+n/p^2+n/p^3+...)个质因子p，其中/为向下取整上式等于1~n中p的倍数的个数n/p,加上(n/p)!中质因子p的个数 int cal(int n,int p)&#123; int ans=0; while(n)&#123; ans+=n/p;//累加n/p^k n/=p; &#125; return ans;&#125; 或者递归写法：int cal(int n,int p)&#123; if(n&lt;p)return 0; return n/p+cal(n/p,p);&#125; ----------------组合数计算:方法二：递推公式计算 （n=67，m=33时溢出） long long C(long long n,long long m)&#123; if(m==0||m==n)return 1; return C(n-1,m)+C(n-1,m-1); &#125; 方法三：定义式变形来计算（n=62，m=31时溢出） long long C(long long n,long long m)&#123; long long ans=1; for(long long i=1;i&lt;=m;i++)&#123; ans=ans*(n-m+i)/i;//注意一定要先乘后除 &#125; return ans; &#125; ----------计算Cn m%p方法二的变形：递归 int res[1010][1010]=&#123;0&#125;;long long C(long long n,long long m)&#123; if(m==0||m==n)return 1; if(res[n][m]!=0)return res[n][m];//已经有值 return res[n][m]=(C(n-1,m)+C(n-1,m-1))%p; &#125; 递推：void calC()&#123; for(int i=0;i&lt;=n;i++)&#123; res[i][0]=res[i][i]=1;//初始化边界 &#125; for(int i=2;i&lt;=n;i++)&#123; for(int j=0;j&lt;=i;j++)&#123;//因为有C(i,i-j)=c(i,j)，所以计算一半，另一半就计算出来了 res[i][j]=(res[i-1][j]+res[i-1][j-1])%p;//递推计算C（i，j） res[i][i-j]=res[i][j]; &#125; &#125;&#125; 排列组合详解","categories":[],"tags":[],"author":"aoyuehan"},{"title":"洛谷训练场","slug":"洛谷训练场","date":"2019-07-08T00:29:00.000Z","updated":"2022-02-26T03:52:51.595Z","comments":true,"path":"2019/07/08/洛谷训练场/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/08/%E6%B4%9B%E8%B0%B7%E8%AE%AD%E7%BB%83%E5%9C%BA/","excerpt":"","text":"新手村 关卡1-1小鱼游泳时间，它发现自己从a时b分一直游泳到当天的c时d分，请你帮小鱼计算一下，它这天一共游了多少时间呢？一行内输入 4 个整数，分别表示 a, b, c, d 12345678910#include &lt;cstdio&gt;int main()&#123; int a, b, c, d; scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d); printf(&quot;%d %d&quot;, ((c - a) * 60 + d - b) / 60, ((c - a) * 60 + d - b) % 60); //求几时几分的 算法；其他比如几元几角得换成同一单位再进行计算 return 0;&#125; 2-2 输入包括7 行数据，分别表示周一到周日的日程安排。每行包括两个小于10 的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。输出一个数字。如果不会不高兴则输出0，如果会则输出最不高兴的是周几（用1, 2, 3, 4, 5, 6, 7 分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。 1234567891011121314151617181920212223#include &lt;cstdio&gt;int main()&#123; int a[10], b[10], i, sum = 0, ans = 0; for (i = 1; i &lt;= 7; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]); a[i] = a[i] + b[i]; //这种方法比较巧妙，如果有两种不同类型的数据，也有对应关系，用两个数组来做，这题把第一个数组的值覆盖掉了， //没多大坏处，而且还少定义了一个专门来存两个值的和的数组 &#125; for (i = 1; i &lt;= 7; ++i) &#123; if (a[i] &gt; 8 &amp;&amp; a[i] &gt; sum) &#123; ans = i; //ans是answer的简写 sum = a[i]; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 关卡2-3输入：12行数据，每行包含一个小于350的非负整数，分别表示11月到12月津津的预算。输出：一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出-X，X表示出现这种情况的第一个月；否则输出到年末津津手中会有多少钱。1234567891011121314151617181920212223#include &lt;cstdio&gt;int main()&#123; int n, k, y = 0, x = 0; n为预算，y为存到妈妈那里的钱，x自己手上有的钱 //分析题目，找到必须要定义的值，建立模型，这一题有用的数据就是，在手里的钱，在妈妈那里存的钱，每月的预算 for(int i = 1; i &lt;= 12; i++) &#123; scanf(&quot;%d&quot;, &amp;n); x = x + 300; if(x &lt; n) &#123; printf(&quot;%d&quot;, -i); return 0; &#125; x = x - n; k = x % 100; y = y + x - k; x = k; &#125; printf(&quot;%d\\n&quot;, x + y * 120 / 100); 存在妈妈那里的钱有20%利息 return 0;&#125; 2-4买铅笔问题 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std; int main() &#123; int need,num,price,total,min; int i; cin&gt;&gt;need; cin&gt;&gt;num&gt;&gt;price; if(need%num==0) total=(need/num)*price;//需要数与包装数恰好相等时的价格 else total=(need/num)*price+price;//需要数与包装数不等时的价格 min=total;//第一种包装花费的钱数 //这个if用的很好，要找出来几种情况来分情况讨论 for(i=1;i&lt;3;i++)//计算另外两种方案所需的价格 &#123; cin&gt;&gt;num&gt;&gt;price; if(need%num==0) total=(need/num)*price; else total=(need/num)*price+price; if(min&gt;total) min=total;//如果当前的花费比第一种小，令花费数等于当 前的钱数 &#125; cout&lt;&lt;min&lt;&lt;endl; return 0; &#125; 关卡3-1 将1,2,⋯,9共9个数分成3组，分别组成3个三位数，且使这3个三位数构成1:2:3的比例，试求出所有满足条件的33个三位数。 小技巧：分别得到每个数的个十百位，其中1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 &#x3D; 362880;1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 &#x3D; 45能判定数字是否重复 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main() &#123; int a, b, c; int x[10]; int m, n, i; for(a = 123; a &lt;= 333; a++) &#123; b = a * 2; c = a * 3; x[1] = a % 10; x[2] = a / 10 % 10; x[3] = a / 100; x[4] = b % 10; x[5] = b / 10 % 10; x[6] = b / 100; x[7] = c % 10; x[8] = c / 10 % 10; x[9] = c / 100; m = 1; n = 0; for(i = 1; i &lt;= 9; i++) m *= x[i]; for(i = 1; i &lt;= 9; i++) n += x[i]; if(m == 362880 &amp;&amp; n == 45) printf(&quot;%d %d %d\\n&quot;, a, b, c); &#125;&#125; 关卡3-2 一个很特别的for循环,原来for循环可以这么写 123456789101112#include &lt;cstdio&gt;using namespace std;int main() &#123; int k, n = 0; scanf(&quot;%d&quot;, &amp;k); for(double sum = 0; sum &lt;= k; n++,sum += 1.0 / n); //此时for循环要加 ；才可以 printf(&quot;%d&quot;, n); return 0;&#125; stdio.h是以往的C和C++的头文件，cstdio是标准C++（STL），且cstdio中的函数都是定义在一个名称空间std里面的，如果要调用这个名字空间的函数，必须得加std::或者在文件中声明using namespace std。 关卡3-4 小鱼的航程，这一题的for循环和if判断用的很好有一只小鱼，它平日每天游泳 250 公里，周末休息（实行双休日)，假设从周x(1≤x≤7) 开始算起，过了 n(n≤10^6 ) 天以后，小鱼一共累计游泳了多少公里呢？ 123456789101112131415161718192021222324#include&lt;cstdio&gt; int main()&#123; unsigned long long n, ans=0; int x; scanf(&quot;%d%lld&quot;, &amp;x, &amp;n); for(int i = 0; i &lt; n; i++) &#123; if((x != 6) &amp;&amp; (x != 7)) &#123; ans += 250; &#125; if(x == 7) &#123; x = 1; &#125; else &#123; x++; &#125; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; 关卡 3-5 试计算在区间 1到 n 的所有整数中，数字x(0≤x≤9)共出现了多少次？例如，在 1到 11 中，即在 1,2,3,4,5,6,7,8,9,10,11 中，数字 1 出现了 4 次。（考到了：优化，模拟，字符串，分离数位）有关各个位数的特点的可以用以下这种方法。 12345678910111213141516171819202122#include &lt;cstdio&gt;int main()&#123; long long n, x, b, c, ans=0; scanf(&quot;%lld%lld&quot;, &amp;n, &amp;x); for (long long i = 1; i &lt;= n; i++) &#123; b = i; while(b != 0) &#123; c = b % 10; b = b / 10; if(c == x) &#123; ans++; &#125; &#125; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; 关卡4-1校门外的树，首先想到的是要把后面的值从前面中减去，可是这样不太可行，可以转换方法，让前面中的在后面出现的（即要减去的值）变为0，这种问题要改变一下原本数据的特征值。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;using namespace std;int a[105];int b[105];int f[10005];int main()&#123; int l, n; int sum = 0; scanf(&quot;%d%d&quot;, &amp;L, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]); for(int i = 0; i &lt;= L; i++) &#123; f[i] = 1; //让树都有一个特征值 &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = a[i]; j &lt;= b[i]; j++) &#123; f[j] = 0; //若要减去这个值，可以把其特征值改变 &#125; &#125; for(int i = 0; i &lt;= l; i++) &#123; if(f[i] &gt; 0) &#123; sum += 1; &#125; &#125; printf(&quot;%d\\n&quot;, sum); return 0;&#125; 关卡4-5 他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101方法0：就是把任意两个数的和求出来，与数组里的值比较一遍，这样子不行，应为有时候是数a和数a与另一个数的和比较，这种情况是不满足要求的方法一：这种不行，因为不确定那两个数都在这一个数的前面#include &lt;cstdio&gt;#include &lt;algorithm&gt;int a[101], s, n, vk[101];int main() &#123; scanf(&quot;%d&quot;, &amp;n); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]); for(int i = 1; i &lt;= n - 2; i++) &#123; for(int j = i + 1; j &lt;= n - 1; j++) &#123; for(int k = j + 1; k &lt;= n; k++) &#123; if(a[i] + a[j] == a[k] &amp;&amp; vk[k] == 0) &#123; s++; vk[k] = 1; &#125; &#125; &#125; &#125; printf(&quot;%d\\n&quot;, s); return 0;&#125;方法二：#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int i, j, k, n, b, m; int a[100]; scanf(&quot;%d&quot;, &amp;n); //输入数据个数 for(i=0; i&lt;n; i++) //循环输入正整数值 &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; b = 0; for(i=0; i&lt;n-1; i++) //循环把数组中整数排序，冒泡排序 &#123; for(j=i+1; j&lt;n; j++) &#123; if(a[i] &gt; a[j]) &#123; b = a[i]; a[i] = a[j]; a[j] = b; &#125; &#125; &#125; m = 0;/*a[i]中数据以排序，故两个数之和等于a[i]的两个数必在第i个数a[i]之前把a[i]第二个数之前的数据逐个相加直到符合条件*/ for(i=2; i&lt;n; i++) //一层循环，从第2个数据开始遍历a[i] &#123; for(j=0; j&lt;i-1; j++) //二层循环，控制j从第0个数据开始到i-1遍历a[i] &#123; for(k=j+1; k&lt;i; k++) //三层循环，从k=j+1开始遍历到i &#123; if(a[j]+a[k] == a[i]) //比较如果i前有两个不同数据之和等于a[i]则m+1 &#123; m++; goto skip; //如果有一个符合条件的就用goto跳出多重循环，不用再比较其余的啦，这算是优化 &#125; &#125; &#125; skip: ; &#125; printf(&quot;%d\\n&quot;, m); return 0;&#125;方法四：#include &lt;iostream&gt;using namespace std;int main()&#123; int a[110]=&#123;0&#125;,b[110]=&#123;0&#125;; int n,count=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; b[i]=a[i]; &#125; for(int i=0;i&lt;n-1;i++)&#123; for(int j=i+1;j&lt;n;j++)&#123; int t=a[i]+a[j]; for(int p=0;p&lt;n;p++)&#123; if(b[p]==t &amp;&amp; p!=i &amp;&amp; p!=j)&#123; count++; b[p]=0; &#125; &#125; &#125; &#125; cout&lt;&lt;count; return 0;&#125; *关卡4-4可爱鱼的数目，即在本条鱼的前面，有多少个不如自己可爱的鱼的数目 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int i, j, n; int a[100], b[100]=&#123;0&#125;; //此时数组b一定都要初始化为0，不然没有改变数组的值的数组值是不确定的数 scanf(&quot;%d&quot;, &amp;n); for(i=0; i&lt;n; i++) //循环输入鱼的可爱数值 &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; int k; for(i=0; i&lt;n; i++) //第一层循环，控制i，第i个数据和前面的i-1个数据比较 &#123; for(j=0; j&lt;i; j++) //第二层循环，控制j，控制前i-1个数据和第i比较 &#123; if(a[i] &gt; a[j]) //第i个和前i-1个数据比较 &#123; b[i]++; &#125; &#125; &#125; for(i=0; i&lt;n; i++) //循环输出 &#123; printf(&quot;%d &quot;, b[i]); &#125; return 0;&#125; 关卡4-5 输入格式：第 1 行：一个整数 N 。1 ~ 10^6第 2 行：N个空格隔开的整数，表示连续 N 天的最高气温。输出格式：1 行：一个整数，表示最高气温一直上升的最长连续天数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071方法一：#include &lt;bits/stdc++.h&gt; using namespace std;int a[10000002];int n, sum = 1, ans;int main()&#123; scanf(&quot;%d&quot;, &amp;n); a[n + 1] = -1; for(int i = 1; i &lt;= n; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; for(int i = 2; i &lt;= n + 1; i++) &#123; if(a[i] &lt; a[i - 1]) &#123; ans = max(sum, ans); sum = 1; &#125; else &#123; sum++; &#125; &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125;方法二：#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int i, N, n, m; int temp[10000002]; //数组要开足够大，不然（..&gt;^^&gt;..） scanf(&quot;%d&quot;, &amp;N); for (i = 0; i &lt; N; i++) &#123; scanf(&quot;%d&quot;, &amp;temp[i]); &#125; n = 1; m = 0;/*有两种输入情况：一、输入连续型数据 （1 2 3 4 5 6）&#123;不过这种情况与题目无关...&#125; 二、输入非连续型 （1 2 3 2 4 5 6）*/ for (i = 0; i &lt; N-1; i++) //循环遍历 &#123; if (temp[i] &lt; temp[i+1]) //如果温度在持续上升，则n++计数 &#123; n++; //统计连续气温上升天数 /*对待第一种情况输入数据（1 2 3 4 5 6）做的判断*/ if (n &gt; m) //比较当前最高气温连续天数和历史气温连续天数，如果前者大则将n赋值给m &#123; m = n; &#125; &#125; else //如果降温了（连续升温被打断了） &#123; /*对待第二种情况输入数据（1 2 3 2 4 5 6）做的判断*/ if (n &gt; m) //比较当前最高气温连续天数和历史气温连续天数，如果前者大则将n赋值给m &#123; m = n; &#125; n = 1; //计数器n清零 &#125; &#125; printf(&quot;%d&quot;, m); return 0;&#125; long与int：标准只规定long不小于int的长度，int不小于short的长度。unsigned int （unsigned long）4字节8位可表达位数：2^32&#x3D;42 9496 7296范围：0 ～ 42 9496 7295 (42*10^8) int （long）4字节8位可表达位数：2^32&#x3D;42 9496 7296范围：-21 4748 3648 ～ 21 4748 3647 (21*10^8) long long (__int64)8字节8位可表达位数：2^64&#x3D;1844 6744 0737 0960 0000范围：-922 3372 0368 5477 5808 ～ 922 3372 0368 5477 5807 (922*10^16) unsigned long (unsigned __int64)8字节8位可表达位数：2^64&#x3D;1844 6744 0737 0960 0000范围：0 ～ 1844 6744 0737 0955 1615 (1844*10^16) 简单字符串 1 判断 ISBN书号是否正确 123456789101112131415161718192021#include&lt;cstdio&gt;char a[14], b[14], t1, t2;int t22 = 0;int main()&#123; scanf(&quot;%c-%c%c%c-%c%c%c%c%c-%c&quot;, &amp;a[1], &amp;a[2], &amp;a[3], &amp;a[4], &amp;a[5], &amp;a[6], &amp;a[7], &amp;a[8], &amp;a[9], &amp;t1); for(int i = 1; i &lt;= 9; ++i) t2 += (a[i] - &#x27;0&#x27;) * i; //字母变成数字的方法 t2 = t2 % 11 + &#x27;0&#x27;; if(t2 == &#x27;0&#x27; + 10) //数字变成字母的方法 t2 = &#x27;X&#x27;; if(t1 == t2) &#123; printf(&quot;Right&quot;); return 0; &#125; printf(&quot;%c-%c%c%c-%c%c%c%c%c-%c\\n&quot;, a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], t2); return 0;&#125; 判断是否上UFO 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;int main()&#123; char a[7] = &quot;&quot;, b[7] = &quot;&quot;; scanf(&quot;%[A-Z]\\n%[A-Z]&quot;, &amp;a, &amp;b); int c = 1, d = 1, i = 0; while(a[i] != &#x27;\\0&#x27;) &#123; c = c * (a[i] - &#x27;A&#x27; + 1); i++; &#125; c = c % 47; i = 0; while(b[i]!=&#x27;\\0&#x27;) &#123; d = d * (b[i] - &#x27;A&#x27; + 1); //这地方用的好，注意-&#x27;A&#x27;之后 要加1 i++; &#125; //其中还有一个方法来判断 /* scanf(&quot;%s&quot;,a); len=strlen(a); for(int i=0;i&lt;len;i++)&#123; d*=(a[i]-64); d=d%47; &#125; */ d = d % 47; if (c == d) printf(&quot;GO&quot;); else printf(&quot;STAY&quot;); return 0; &#125; 3 栅栏密码 1234567891011#include &lt;cstdio&gt;int main()&#123; int n, i; char a[50]; scanf(&quot;%d%s&quot;, &amp;n, a); for(i = 0; a[i] != &#x27;\\0&#x27;; i++) a[i] = &#x27;a&#x27; + (a[i] - &#x27;a&#x27; + n) % 26; //提供了一种方法，先把字母变成相应数字，然后加上对应的变化值，然后 对26取余，在加上&#x27;a&#x27;就能求出该字母 puts(a);&#125; 4 查找字符串a是否包含子串b,不是用strA.find(strB) &gt; 0 而是 strA.find(strB) !&#x3D; string:npos，其中string:npos是个特殊值，说明查找没有匹配； int idx &#x3D; str.find(“abc”);if (idx &#x3D;&#x3D; string::npos)比较式 idx &#x3D;&#x3D; string::npos 中，如果 idx 的值为-1，由于 idx 和字符串string::npos 型别不同，比较结果可能得到 false。 if(str.find(“abc”) ) （ 这样写也是错误的，找不到abc会返回-1，不为0为True。0为False ） 通常来说，find函数用于寻找某个序列的在string中第一次出现的位置。 #include&lt;iostream&gt; #include&lt;cstring&gt; using namespace std; int main()&#123; int counter=0,begin=-1,pos=-1; string s1,s2; getline(cin,s1); //整行输入 ，可以把cin流放进去 getline(cin,s2); for(int i=0;i&lt;s1.size();i++) s1[i]=toupper(s1[i]); 或者都变成小写字母用tolower方法 for(int i=0;i&lt;s2.size();i++) s2[i]=toupper(s2[i]); s1=&#39; &#39;+s1+&#39; &#39;; s2=&#39; &#39;+s2+&#39; &#39;; //这一步很重要，因为测试点有那种，比如给定单词的前面是空格，不加这个就判断不出来 while((begin=s2.find(s1,begin+1))!=string::npos)&#123; counter++; if(counter==1) pos=begin; &#125; if(pos!=-1) cout&lt;&lt;counter&lt;&lt;&quot; &quot;&lt;&lt;pos; else cout&lt;&lt;pos; return 0; &#125; 其中本题还可以用以下方法来获取字符串a中的单词 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 200000+10;string b[maxn];int main()&#123; string s; getline(cin,s); stringstream ss; ss&lt;&lt;s; //此时ss中就是由空格分开的 字符串 数组 int k=0; while(ss) &#123; ss&gt;&gt;b[k++]; &#125; for(int i=0;i&lt;k;i++) cout&lt;&lt;b[i]&lt;&lt;&quot;\\n&quot;;&#125; 相应的第二种解法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;int spc[666666];map&lt;string,int&gt;mp;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); string a,c; cin&gt;&gt;a; cin.get(); for(int i=0;i&lt;a.size();i++) a[i]=tolower(a[i]); string b; getline(cin,b); for(int i=0;i&lt;b.size();i++) if(isalpha(b[i])) b[i]=tolower(b[i]); stringstream s; s&lt;&lt;b; int ans; int sum=0; int k=0; int f=1; for(int i=0;i&lt;b.size();i++) if(isspace(b[i])) spc[k]++,f=1; else if(isalpha(b[i])&amp;&amp;f) k++,f=0; sum=spc[0]; f=1; int w=0; int cnt=1; while(s&gt;&gt;c) &#123; if(a==c&amp;&amp;f) &#123; f=0; w=sum; &#125; mp[c]++; sum+=c.size()+spc[cnt++]; &#125; if(mp[a]) cout&lt;&lt;mp[a]&lt;&lt;&quot; &quot;&lt;&lt;w; else cout&lt;&lt;-1;&#125; 输入格式：四行字符，由大写字母组成，每行不超过100个字符 输出格式：由若干行组成，前几行由空格和星号组成，最后一行则是由空格和字母组成的。在任何一行末尾不要打印不需要的多余空格。不要打印任何空行。 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;//这个头文件中有max ，min这样的函数using namespace std;int main()&#123; string s; char s1[800],s2[800],s3[800],s4[800],f; int sum[30],length=0,maxnum=0; cin.getline(s1,800); cin.getline(s2,800); cin.getline(s3,800); cin.getline(s4,800); int counter,begin=-1; strcat(s1,s2); //strcat 字符串拼接函数； //char *strcpy(char *dest, const char *src)把 src 所指向的字符串复制到 dest； //int strcmp(const char *str1, const char *str2) 如果返回值 &gt; 0，则表示 str2 小于 str1。如果返回值 &lt; 0，则表示 str1 小于 str2。如果返回值 = 0，则表示 str1 等于 str2。 strcat(s1,s3); //在s1的后面拼接s3字符串 strcat(s1,s4); s.assign(s1);//字符数组转化字符串，string转化char[],strcpy(ch,str.c_str()) for(char x=&#x27;A&#x27;;x&lt;=&#x27;Z&#x27;;x++)&#123; counter=0; while((begin=s.find(x,begin+1))!=string::npos)&#123; counter++; &#125; sum[length++]=counter; &#125; for(int i=0;i&lt;length;i++) maxnum=max(maxnum,sum[i]); for(int i=maxnum;i&gt;0;i--)&#123; for(int j=0;j&lt;26;j++)&#123; if(sum[j]&gt;=i) cout&lt;&lt;&quot;*&quot;; else cout&lt;&lt;&quot; &quot;; if(j!=25) cout&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125; for(char x=&#x27;A&#x27;;x&lt;=&#x27;Z&#x27;;x++) cout&lt;&lt;x&lt;&lt;&quot; &quot;; return 0;&#125; 津津的零花钱p1089 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;int main()&#123; int a[12],i; int b,d,c,e=0; double f; for(i=0;i&lt;12;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; for(i=0;i&lt;12;i++)&#123; b=-a[i]+300+e; if(b&gt;=100)&#123; c=b/100; f+=c*100; b=b-c*100; &#125; e=b; if(b&lt;0)&#123; printf(&quot;-%d\\n&quot;,i+1); break; &#125; &#125; if(i==12)&#123; //d=; printf(&quot;%d\\n&quot;,(int)((f*12+b*10)/10)); &#125;&#125; /*printf(&quot;%d\\n&quot;,(int)((f*12+b*10)/10));这样写就可以了， ((f*12+b*10)/10)这个数的结果是一个double类型，因为int和double类型的相遇，会自动专向更高级的double类型要是double类型用格式化%d输出，结果就为0相应的也可以这样写printf(&quot;%.0lf\\n&quot;,((f*12+b*10)/10));那个double类型的数乘以一个小数，因为乘不尽，在内存中会 截取有效长度，所以会少1，题目给的答案就是通过乘一个整数，再除一个整数来计算一个数乘以一个小数 重要，重要另一个问题是如果,double sum=0;int n=2; sum+=1/n;这样的sum值为1，而sum+=1.0/n;则sum为0.5；*/ 取整问题 1234567891011121314151617C语言有以下几种取整方法： 1、直接赋值给整数变量。如： int i = 2.5; 或 i = (int) 2.5; 这种方法采用的是舍去小数部分 2、C/C++中的整数除法运算符“/”本身就有取整功能(int / int)，但是整数除法对负数的取整结果和使用的C编译器有关。 3、floor函数。floor(x)返回的是小于或等于x的最大整数。如： floor(2.5) = 2 floor(-2.5) = -3 4、使用ceil函数。ceil(x)返回的是大于x的最小整数。如： ceil(2.5) = 3 ceil(-2.5) = -2 floor()是向负无穷大舍入，floor(-2.5) = -3；ceil()是向正无穷大舍入，ceil(-2.5) = -2。floor()和ceil（）函数在math.h头文件中定义","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"  ","slug":"","permalink":"https://zouyunkai.github.io/myblog/tags/"}],"author":"aoyuehan"},{"title":"山理工刷题_1","slug":"山理工刷题-1","date":"2019-07-04T14:08:00.000Z","updated":"2022-02-26T03:52:51.040Z","comments":true,"path":"2019/07/04/山理工刷题-1/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/04/%E5%B1%B1%E7%90%86%E5%B7%A5%E5%88%B7%E9%A2%98-1/","excerpt":"","text":"指针应用 1176从键盘输入一个字符串给str和一个字符给c，删除str中的所有字符c并输出删除后的字符串str。 1234567891011121314151617#include&lt;stdio.h&gt;int main()&#123; char str1[20], str2[20], c; int i = 0, j = 0; gets(str1); //gets来获取字符串到字符数组 scanf(&quot;%c&quot;, &amp;c); while(str1[i] != 0) &#123; if(str1[i] != c) &#123; str2[j] = str1[i]; j++; //j只能放在这里，放在这循环外面就不对了 &#125; i++; &#125; str2[j] = 0; puts(str2); // puts 用来输出字符串，put输出单个字符或单个字符数组 return 0;&#125; 2560指针的应用 判断回文 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;string.h&gt;int judge(char *s) // 传来的是cahr类型的指针&#123; int len = strlen(s); char *p = s,*q = s + len - 1; while(p &lt; q) &#123; if(*p == &#x27; &#x27;) &#123; p++; continue; &#125; if(*q == &#x27; &#x27;) &#123; q--; continue; &#125; if(*p == *q) &#123; p++; q--; &#125; else return 0; &#125; return 1;&#125; int main()&#123; char st[100200]; while(gets(st)) &#123; if(strcmp(st,&quot;2013&quot;) == 0) break; if(judge(st)) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); &#125;&#125; 1191输入一个不多于5位的正整数，要求：（1）求出它是几位数；（2）分别输出每一位数字；（3）按逆序输出各位数字。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main()&#123;int n;int count=0,i,a[5];scanf(&quot;%d&quot;,&amp;n);if (n&lt;=0 || n&gt;=100000)&#123; return 0; &#125; else&#123; while(1)&#123; a[count]=n%10; n=n/10; //很妙，这样就实现了每个数组存相应位的值 if(n==0) &#123; break; &#125; count++; &#125; printf(&quot;%d\\n&quot;,count+1); for (i=count;i&gt;=0;i--) if(i==0)printf(&quot;%d&quot;,a[i]); else printf(&quot;%d &quot;,a[i]); printf(&quot;\\n&quot;); for (i=0;i&lt;=count;i++) if(i==count)printf(&quot;%d&quot;,a[i]); else printf(&quot;%d &quot;,a[i]); printf(&quot;\\n&quot;); &#125; return 0; &#125; 排序算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int g; void bubblesort(int a[],int g); void selectsort(int a[],int g) ; while(1)&#123; if((cin&gt;&gt;g)==0)break; int a[g]; for(int i=0;i&lt;g;i++) cin&gt;&gt;a[i]; //selectsort(a,g); bubblesort(a,g); for(int i=0;i&lt;g;i++)&#123; if(i==g-1) cout&lt;&lt;a[i]&lt;&lt;endl; else cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; &#125;&#125;//冒泡排序 void bubblesort(int a[],int n) &#123; //把最小的冒到最后一个，倒数第二个，依次进行 int temp; for(int i=0;i&lt;=n-1;i++) //n-1是小一位数 ,因为外循环要比n-1次，如三次比两次就好了 for(int j=0;j&lt;=n-i-1;j++) //不能j=i+1 /*也可以这样写 for(int i=1;i&lt;n;i++) for(int j=0;j&lt;n-i;j++) //1 n 0 n-i */ if(a[j]&gt;a[j+1])&#123; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; //a[j+1]=temp;这行是a[j+1]而不是 a[j] //或者 swap(a[j],a[j+1]); &#125; &#125; //选择排序void selectsort(int a[],int n) &#123; //if(a[j]&lt;a[index]) index=j; index存放最小值（最大值）的下标 //就是把最小的换到第一个位置 ，第二小的换到第二位置，依次排列 int temp,index; for(int i=0;i&lt;n-1;i++)&#123; //比较n-1次就行了 0 n-1 i+1 n index=i; //假设i=0为最小值（最大值）的下标 for(int j=i+1;j&lt;n;j++) //是j&lt;n而不是n-1 if(a[j]&lt;a[index]) index=j; temp=a[index]; //最小值（最大值）与下标为i的换 a[index]=a[i]; a[i]=temp; &#125; &#125; 1188 给定n个正整数，根据各位数字之和从小到大进行排序。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int main()&#123; int n,m; void bubsort(int a[],int b[],int j); //void selectsort(int a[],int b[],int g); while(1)&#123; cin&gt;&gt;n; if(n==0)break; int a[n],m[n]; int sum[n]=&#123;0&#125;; for (int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; m[i]=a[i]; &#125; for(int i=0;i&lt;n;i++)&#123; while(m[i]&gt;0)&#123; sum[i]+=m[i]%10; m[i] =m[i]/10; &#125; &#125; bubsort(sum,a,n); for(int i=0;i&lt;n;i++)&#123; if(i==n-1)cout&lt;&lt;a[i]&lt;&lt;endl; else cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; &#125; &#125;&#125;void bubsort(int a[],int b[],int j)&#123; for(int i=1;i&lt;j;i++)&#123; for(int k=0;k&lt;j-i;k++)&#123; if(a[k]&gt;a[k+1])&#123; //这地方一定要加&#123; &#125;，不然就会错的 swap(a[k],a[k+1]); swap(b[k],b[k+1]); &#125; &#125; &#125;&#125; 1522输入矩阵的行数，再依次输入矩阵的每行元素，判断该矩阵是否为对称矩阵，若矩阵对称输出“yes”，不对称输出”no“。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;int main()&#123; int n,i,j,t; int a[20][20]; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; t=1; for(i=1; i&lt;=n; i++) &#123; for(j=1; j&lt;=n; j++) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(i=1; i&lt;=n; i++) &#123; for(j=1; j&lt;=n; j++) &#123; if(a[i][j]!=a[j][i]) &#123; t=0; break; //只要一次不相等就不是对称矩阵，就可以跳出整个循环 &#125; &#125; &#125; if(t==0) cout&lt;&lt;&quot;no&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl; &#125; return 0;&#125; 1172求一个矩阵的下三角之和（在对角线上和对角线的左下角的元素之和） 12345678910111213141516#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; int n,i,j,sum=0; scanf(&quot;%d&quot;,&amp;n); //输入数组大小 int a[n+1][n+1]; //定义数组 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); //循环输入数组 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) sum+=a[i][j]; //循环将矩阵下三角元素相加 printf(&quot;%d&quot;,sum); //输出结果 return 0; &#125; 1185 一个矩阵的主对角线是从左上角到右下角（对角线上的值是行等于列），但是从左下到右上的对角线特点不是行等于列（但是行号和列号相加是定值）； 2259输入包含多组测试数据.每组数据的第一行为两个整数 R 和 C(1 &lt;&#x3D; R, C &lt;&#x3D; 10 )，分别代表矩阵的行数和列数。接下来 R 行，每行为 C 个空格隔开的整数。对于每组测试数据，输出按照顺时针旋转后的矩阵。 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main()&#123; int r,c; while(cin&gt;&gt;r&gt;&gt;c)&#123; //这就是判断是否读取到文件末尾的方法，while(cin&gt;&gt;r&gt;&gt;c) int a[r][c],b[c][r]; for(int i=0;i&lt;r;i++)&#123; for(int j=0;j&lt;c;j++)&#123; cin&gt;&gt;a[i][j]; b[j][i]=a[i][j]; &#125; &#125; for(int i=0;i&lt;c;i++) for(int j=r-1;j&gt;=0;j--) if(j==0)cout&lt;&lt;b[i][j]&lt;&lt;endl; else cout&lt;&lt;b[i][j]&lt;&lt;&quot; &quot;; &#125;&#125; 2744 如果矩阵A在旋转一定角度后能和矩阵B完全一样则输出YES，否则输出NO。 拓展知识： 注：以上两幅图是我通过旋转图片90度的形式得到的，当然图片旋转后，图片上的数字的方向会变化，所以我修正了一下，得到了第二幅图。结果分析：经过对比以上两幅图，结果很明显，原矩阵经过顺时针旋转90度后，1.从行的角度看：原矩阵的第一行，变成了目标矩阵的最后一列。原矩阵的第二行，变成了目标矩阵的倒数第二列。原矩阵的第三行，变成了目标矩阵的倒数第三列。原矩阵的第四行，变成了目标矩阵的倒数第四列。…….2.从列的角度看：原矩阵的第一列，变成了目标矩阵的第一行，数字的方向相反。原矩阵的第二列，变成了目标矩阵的第二行，数字的方向相反。原矩阵的第三列，变成了目标矩阵的第三行，数字的方向相反。原矩阵的第四列，变成了目标矩阵的第四行，数字的方向相反。实际上就是位置[i][j]旋转90度后的新位置是[j][n-i] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 #include &lt;stdio.h&gt; void spin(int a[][50],int n,int m); //注意定义二维数组时列是不能省略的，此函数用来把矩阵顺时针旋转90度 int main()&#123; int i,j,k; int n; int mark; int flag; int a[50][50],b[50][50]; while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123; flag=0; for( i=0;i&lt;n;i++) for( j=0;j&lt;n;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); for( i=0;i&lt;n;i++) for( j=0;j&lt;n;j++) scanf(&quot;%d&quot;,&amp;b[i][j]); for( k=1;k&lt;=4;k++)&#123; //旋转判断四次就可以了，如果旋转360还不相等，就不可能相等了 mark=1; for( i=0;i&lt;n;i++)&#123; for( j=0;j&lt;n;j++) if(a[i][j]!=b[i][j])&#123; mark=0; &#125; if(mark==0) break; //这里用mark尽早跳出循环，不用mark在上面的if直接加break也可以，但是循环次数会增多，尽量减少多余的执行 &#125; if(i&gt;=n) &#123; flag=1; //如果上面的循环正常跳出来了，说明数组a旋转后与b相等了，让flag=1，直接跳出大循环就行了，后面没必要继续了。 break; &#125; spin(a,n,n); &#125; if(flag==1) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); //用flag的值判断矩阵a在旋转一定角度后是否与矩阵b相等 &#125; return 0; &#125; void spin(int a[][50],int n,int m) //这就对应着第二种情况，即第一行变成第一列，然后第二行变成第二列，以此类推，然后每行数字的方向相反 &#123; int temp; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++) &#123; temp=a[i][j]; a[i][j]=a[j][i]; a[j][i]=temp; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n/2;j++)&#123; temp=a[i][j]; a[i][j]=a[i][n-1-j]; a[i][n-1-j]=temp; &#125; &#125;&#125; 1168字符串里的大小写字母转换问题 1234567891011121314151617#include &lt;stdio.h&gt;int main()&#123; char c[80]; int i; gets(c); for(i=0;c[i];i++) &#123; if(c[i]&gt;=&#x27;A&#x27;&amp;&amp;c[i]&lt;=&#x27;Z&#x27;) c[i]+=32; else if(c[i]&gt;=&#x27;a&#x27;&amp;&amp;c[i]&lt;=&#x27;z&#x27;) c[i]-=32; &#125; puts(c); return 0;&#125; 1176 删除一个字符串里的指定字符 123456789101112131415 #include&lt;stdio.h&gt; #include&lt;string.h&gt; int main() &#123; char str[100],m; int i,len; gets(str); scanf(&quot;%c&quot;,&amp;m); len=strlen(str); for(i=0;i&lt;len;i++) &#123; if(str[i]!=m) printf(&quot;%c&quot;,str[i]); &#125; printf(&quot;\\n&quot;); &#125; 1219 字符统计问题 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char s[100001]; int i,n; int a,b,c,d; while(gets(s) != NULL)&#123; //数据至文件结束(EOF)为止。 n = strlen(s); a = 0; b = 0; c = 0; d = 0; for(i = 0; i &lt; n; i++)&#123; if((s[i] &gt;= &#x27;a&#x27; &amp;&amp; s[i] &lt;= &#x27;z&#x27;) || (s[i] &gt;= &#x27;A&#x27; &amp;&amp; s[i] &lt;= &#x27;Z&#x27;))&#123; a++; //大小写字母的数量 &#125; else if(s[i] &gt;= 48 &amp;&amp; s[i] &lt;= 57)&#123; b++; //匹配数字 &#125; else if(s[i] == &#x27; &#x27;)&#123; c++; //空格字符 &#125; else&#123; d++; //其他字符 &#125; &#125; printf(&quot;%d %d %d %d&quot;,a,b,c,d); printf(&quot;\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[],"author":"aoyuehan"},{"title":"山理工刷题_0","slug":"山理工刷题_0","date":"2019-07-04T06:26:00.000Z","updated":"2022-02-26T03:52:52.262Z","comments":true,"path":"2019/07/04/山理工刷题_0/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/07/04/%E5%B1%B1%E7%90%86%E5%B7%A5%E5%88%B7%E9%A2%98_0/","excerpt":"","text":"顺序结构设计 1167 知道c++如何保留小数点后两位小数#include #include &#x2F;&#x2F;要用 setprecision(2) 就要写这个头文件 using namespace std; int main(){ int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; double d&#x3D;(a+b+c)&#x2F;3.0; cout&lt;&lt;a+b+c &lt;&lt;” “&lt;&lt;abc &lt;&lt; “ “; cout.precision(3); &#x2F;&#x2F;第一种方法 cout.setf(ios::fixed); cout&lt;&lt;d&lt;&lt;” “; cout&lt;&lt;d&lt;&lt;endl; cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; d &lt;&lt; endl; &#x2F;&#x2F;第二种方法 cout &lt;&lt; setprecision(2) &lt;&lt; fixed &lt;&lt; d &lt;&lt; endl; &#x2F;&#x2F;第三种方法 ，这三种方法都会 四舍五入 &#x2F;&#x2F; C语言中%.2f也是会四舍五入的 &#x2F;&#x2F;使用setprecision(n)可控制输出流显示浮点数的数字个数。C++默认的流输出数值有效位是6。 &#x2F;&#x2F;setprecision(n)与setiosflags(ios::fixed)合用，可以控制小数点右边的数字个数。 setiosflags(ios::fixed)是用定点方式表示实数 &#x2F;&#x2F;用setiosflags(ios::scientific)来表示指数表示的输出形式 } 1189123456 cin&gt;&gt;d; a=d/100; //求百分位 b=d%100/10; //求十分位c=d%10; //求个位f=d/100.0; //不会变为整数，如输入123 f为1.23 //因为d/100会变为整数类型的，赋值给f一个整数类型的值，会截取整数部分 选择结构设计 1190 找三个数中的中间数 12345678910111213141516171819 #include &lt;iostream&gt; using namespace std; int main()&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(a&gt;=b) &#123; if(b&gt;=c) cout&lt;&lt;b;else &#123; if(a&gt;=c) cout&lt;&lt;c; else cout&lt;&lt;a;&#125; &#125; &#125; //else 总是和离他最近的if 配对 当a&#x2F;b时要判断一下b是否等于0 否则也会出现编译错误 swich语句要break countine while 循环结构设计 2555 12345678910111213141516 //压岁钱问题 #include &lt;stdio.h&gt;int main()&#123; int money=1000000, t, n; scanf(&quot;%d&quot;, &amp;t); while(t--) //t--来判断是否要结束 &#123; scanf(&quot;%d&quot;, &amp;n); if(money % n == 0) printf(&quot;%d\\n&quot;, money/n); else printf(&quot;No\\n&quot;); &#125; return 0;&#125; 2252有如下分段函数F(x) &#x3D; x^2 + 1 当x&gt; 0时；F(x) &#x3D; -x 当x&lt;0时；F(x) &#x3D; 100.0 当x&#x3D;0时；编程根据输入的不同x（x为实数），输出其对应的函数值 1234567891011121314151617 #include&lt;iostream&gt;#include&lt;sstream&gt;using namespace std;int main()&#123; double x; while(cin&gt;&gt;x) //可实现多组输入，每组一个实数x。处理到文件结束。 //while(scanf(&quot;%lf&quot;,&amp;x)!=EOF) 这样也可以 &#123; if(x&gt;0) printf(&quot;%.1lf\\n&quot;,x*x+1); //必须为lf才行，要不然超出float类型的范围时会会出现0.0000....001时为100.0 else if(x&lt;0) printf(&quot;%.1lf\\n&quot;,-x); else if(x==0) printf(&quot;100.0\\n&quot;); &#125;return 0;&#125; – for 循环结构设计 1123 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// 方法一 调用函数求1~n的各位阶乘 之和#include&lt;stdio.h&gt;double fact(int n);int main() &#123; int n,i; double sum=0; printf(&quot;Enter n:&quot;); scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) sum=sum+fact(i); printf(&quot;%lf&quot;,sum);&#125;double fact(int n)&#123; double result=1.0; for(int k=1;k&lt;=n;k++) result=result*k; return result;&#125; // 方法二 递归求n的阶乘 #include&lt;stdio.h&gt;int main()&#123; int fac(int a); int n; int y; printf(&quot;input a integer number:&quot;); scanf(&quot;%d&quot;,&amp;n); y=fac(n); printf(&quot;%d!=%d\\n&quot;,n,y); return 0; &#125;int fac(int n)&#123; int f; if(n&lt;0) printf(&quot;n&lt;0,data error!&quot;); else if(n==0||n==1) f=1; else f=fac(n-1)*n; return(f);&#125;//方法三 静态变量方法求n!#include &lt;stdio.h&gt;long Func (int n );int main( )&#123; int i,n; printf (&quot; Input n:&quot;); scanf(&quot;%d&quot;,&amp;n); for(i=1; i&lt;=n;i++) &#123; printf (&quot;%d!=%1d\\n&quot;,i,Func(i)); &#125; return 0;&#125;long Func(int n)&#123; static long p=1; p=p*n; return p;&#125;//方法四 用循环的方法求n！#include&lt;stdio.h&gt;int main()&#123; int a,sum=1,i; scanf(&quot;%d&quot;,&amp;a); for(i = 1;i &lt;= a;i++) &#123; sum *= i; &#125; printf(&quot;%d\\n&quot;,sum); return 0;&#125; 1134 invalid types &#96;int[int]’ for array subscrip 数组下标的类型“int[int]”无效 我的一个数组名写错了 数列求和是一类常见的问题，本题有一定的代表性：求s&#x3D;a+aa+aaa+aaaa+……+aa…aa(n位） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #include&lt;stdio.h&gt;#include&lt;math.h&gt;int main()&#123;int a,n,i,j,sum=0;scanf(&quot;%d%d&quot;,&amp;a,&amp;n);for(i=1;i&lt;=n;i++)for(j=1;j&lt;=i;j++) sum+=a*pow(10,j-1); //a*a*a*a.. 这种形式，10的0次方是1，然后乘了之后是a，然后再继续循环&#125;printf(&quot;%d\\n&quot;,sum);return 0;&#125;或者#include&lt;stdio.h&gt;int main()&#123;int a,n,i=0,m=0,sum=0;scanf(&quot;%d%d&quot;,&amp;a,&amp;n);while(i&lt;=n-1)&#123;m=a+m*10;sum+=m;i++; &#125;printf(&quot;%d\\n&quot;,sum);return 0;&#125;或者#include&lt;stdio.h&gt;int main()&#123;int sum=0,a,n,j=0;scanf(&quot;%d&quot;,&amp;a);scanf(&quot;%d&quot;,&amp;n);for(int i=0;i&lt;n;i++)&#123;i=a+i*10; //注意第一次是否要加a的那个初值 sum+=i; &#125; printf(&quot;%d\\n&quot;,sum); return 0;&#125; 1147 1234567891011121314151617181920212223242526272829//求n个整数中的绝对值最大的数思路：打擂法求最大值，首先输入第一个m， 求绝对值，令绝对值成为max，然后对后续n-1个数和他作比较，如果max小于fm则max= fm，然后就求出来了。 #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int n, i, m, fm, max, maxold;scanf(&quot;%d&quot;, &amp;n);scanf(&quot;%d&quot;, &amp;m); fm = m; if(m &lt; 0)&#123; fm = -m; &#125; max = fm; maxold = m; for(i = 1; i &lt; n; i++)&#123; scanf(&quot;%d&quot;, &amp;m); fm = m; if(m &lt; 0)&#123; fm = - m; &#125; if(max &lt; fm)&#123; max = fm; maxold = m; &#125; &#125;printf(&quot;%d\\n&quot;, maxold); return 0;&#125; 函数应用 1206 给出三边，求三角形的面积 123456789101112131415 #include&lt;iostream&gt;#include &lt;cmath&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; double fun(double,double,double); double a,b,c,d; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;setprecision(3)&lt;&lt;fixed&lt;&lt;fun(a,b,c);&#125; double fun(double a,double b,double c)&#123; //c++一定要写上函数返回值类型 double p=(a+b+c)/2.0; return sqrt(p*(p-a)*(p-b)*(p-c)); //海伦公式求三角形面积。如果三角形的三边为a, b, c且p=(a+b+c)/2，则三角形面积为（p*（p-a) * (p - b) * (p -c)）的平方根。&#125; 2557 这个分段函数长得是这个样子的： F(x) = log2(x) 0&lt;x&lt;10 = |x|+sin(x) x&lt;0 = 0 x=0 = x^2 x&gt;=10 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;#include&lt;math.h&gt;double f(double n)&#123; double x; if(n&gt;0&amp;&amp;n&lt;10) &#123; x=log2(n); &#125; else if(n&lt;0) &#123; x=fabs(n)+sin(n); &#125; else if(n==0) &#123; x=0; &#125; else if(n&gt;=10) &#123; x=n*n; &#125; return x;&#125;int main()&#123; int i; double m; scanf(&quot;%d&quot;,&amp;i); while(i--) //这种形式，就收到i个数，然后就i--,执行i次 &#123; scanf(&quot;%lf&quot;,&amp;m); printf(&quot;%.2lf\\n&quot;,f(m)); &#125; return 0;&#125; 1132123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//斐波那契数列是一组第一位和第二位为1，//从第三位开始，后一位是前两位和的一组递增数列，//像这样的：1、1、2、3、5、8、13、21、34、55.... #include&lt;stdio.h&gt; int fab(int n); int main()&#123; int n,c; printf(&quot;Enter n:&quot;); scanf(&quot;%d&quot;,&amp;n); c=fab(n); printf(&quot;%d&quot;,c); return 0; &#125; int fab(int n)&#123; int i,result=0; if(n==0) result=0; if(n==1) result=1; if(n&gt;1) result=result+fab(n-1)+fab(n-2); return result; &#125; //递归形式 #include&lt;stdio.h&gt; int Fibon1(int n)&#123; if (n == 1 || n == 2)&#123; return 1; &#125; else&#123; return Fibon1(n - 1) + Fibon1(n - 2); &#125; &#125; int main()&#123; int n = 0; int ret = 0; scanf(&quot;%d&quot;, &amp;n); ret = Fibon1(n); printf(&quot;ret=%d&quot;, ret); return 0; &#125; //非递归形式 #include&lt;stdio.h&gt; int Fibon2(int n) &#123; int num1 = 1; int num2 = 1; int tmp = 0; int i = 0; if (n &lt; 3)&#123; return 1; &#125; else&#123; for (i = 0; i&lt;=n-3; i++)&#123; tmp = num1 + num2; num1 = num2; num2 = tmp; &#125; return tmp; &#125; &#125; int main() &#123; int n = 0; int ret = 0; scanf(&quot;%d&quot;, &amp;n); ret = Fibon2(n); printf(&quot;ret=%d&quot;, ret); return 0; &#125; //用数组来完成 #include&lt;stdio.h&gt; int Fibon3(int n)&#123; List&lt;int&gt; list = new List&lt;int&gt;(); list.fib(1); list.fib(1); int count = list.Count; while (count &lt; n) &#123; list.fib(list[count - 2] + list[count - 1]); count = list.Count; &#125; return list[count - 1]; &#125; int main()&#123; int n = 0; int ret = 0; scanf(&quot;%d&quot;, &amp;n); ret = Fibon3(n); printf(&quot;ret=%d&quot;, 4ret); return 0; &#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"}],"tags":[{"name":"山理工","slug":"山理工","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%B1%B1%E7%90%86%E5%B7%A5/"}],"author":"aoyuehan"},{"title":"qctf 隐写  19.2.14","slug":"qctf-隐写-2-14","date":"2019-02-18T12:40:00.000Z","updated":"2022-02-26T03:52:52.837Z","comments":true,"path":"2019/02/18/qctf-隐写-2-14/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/02/18/qctf-%E9%9A%90%E5%86%99-2-14/","excerpt":"","text":"签到题如图： One该题为数据包分析将文件用WinHex打开，搜索ctf得到url编码 Two得到图片，对图片进行分析，这里我们需要用到一个工具binwalk将图片后缀改为zip解压，得到flag1.png和flag.zip,观察有相同的CRC32,说明这两个文件同一个文件，用Advanced Archive Password Recovery进行明文攻击注意：将图片压缩要用winrar进行zip压缩（2345好压，7z不行，跟要攻击的zip有关）得到zip的口令，解压得到flag2.txt，只有flag的一部分，所以此时想起flag中可能还存在另一半，将flag2.png用WinHex打开搜索ctf合二为一得到flag。 附zip伪加密：无加密：压缩源文件数据区的全局加密应当为00 00 且压缩源文件目录区的全局方式位标记应当为00 00伪加密：压缩源文件数据区的全局加密应当为00 00 且压缩源文件目录区的全局方式位标记应当为09 00真加密：压缩源文件数据区的全局加密应当为09 00 且压缩源文件目录区的全局方式位标记应当为09 00 Three LSB也就是最低有效位，原理是图片中的像素一般是由三种颜色构成，即三原色（绿红蓝），由这三种颜色可以组成其它各种颜色。 例如在PNG图片的储存中，每个颜色会有8bit，LSB隐写就是修改了像素中的最低的1bit。在人眼中看来是看不住来区别的，也把信息隐藏起来了。如：把A转成16进制的0*61在转成二进制的01100001，在修改为红色通道的最低位为这些二进制串。 如何判断图像是否更改，有两个方法，一种是MD5，当图片有过更改，MD5必然有改动，但难点是要找到原图；另一种就是用图片查看神器Stegsolve安装LSB隐写github项目项目的python脚本(代码要依赖cv2库和lsbsteg库)： 123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-from LSBSteg import LSBStegimport sysimport cv2iii=0while iii &lt; 5: select=input(&quot;请输入操作：加密输入encode，解密输入decode：&quot;+&#x27;\\n&#x27;) iii+=1 if select==&#x27;encode&#x27;: nume = input(&#x27;将文件放入此目录并输入文件名：&#x27;) steeg = LSBSteg(cv2.imread(nume)) str=input(&#x27;输入要放入其中的字符串：&#x27;) img_encoded = steeg.encode_text(str) cv2.imwrite(&quot;output.png&quot;, img_encoded) print(&quot;加密成功&quot;) sys.exit(0) elif select==&#x27;decode&#x27;: name=input(&quot;输入文件名:&quot;) im = cv2.imread(name) steg = LSBSteg(im) print(&quot;解密成功！密文是：&quot;,steg.decode_text()) sys.exit(0) else: print(&quot;输入错误，请重新输入\\n&quot;)","categories":[{"name":"ctf","slug":"ctf","permalink":"https://zouyunkai.github.io/myblog/categories/ctf/"}],"tags":[{"name":"隐写","slug":"隐写","permalink":"https://zouyunkai.github.io/myblog/tags/%E9%9A%90%E5%86%99/"}],"author":"aoyuehan"},{"title":"qctf Web 19.2.14","slug":"qctf-Web-2-14","date":"2019-02-18T07:24:00.000Z","updated":"2022-02-26T03:52:52.831Z","comments":true,"path":"2019/02/18/qctf-Web-2-14/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/02/18/qctf-Web-2-14/","excerpt":"","text":"签到题题目给出HTTP状态码404界面（请求的网页不存在）F12审查元素，在管理器中查看网络，看到有个js文件，响应载荷里出现 12String.fromCharCode(113,99,116,102,123,105,95,108,48,118,51,95,101,118,52,100,101,125)#String.fromCharCode()根据指定的 Unicode 编码中的序号值来返回一个字符串。 复制到控制台执行得到flag web1php代码审计 题目给出代码如下： 1234567891011121314&lt;?phperror_reporting(0); include_once(&#x27;flag.php&#x27;); highlight_file(&#x27;index.php&#x27;); $md51 = md5(&#x27;QNKCDZO&#x27;); $a = $_GET[&#x27;b&#x27;]; #GET请求转入参数b$md52 = md5($a); if(isset($a))&#123; if ($a != &#x27;QNKCDZO&#x27; &amp;&amp; $md51 == $md52) &#123; echo $flag; &#125; else &#123; echo &quot;false!!!&quot;; &#125;&#125; ?&gt; 阅读后我们发现要找到flag就要找到和‘QNKCDZO’md5加密后相同的字符串，并且该字符串MD5加密后的md52与md51不同，那么推测应该是利用PHP语言的弱类型的特性： 一个数字和一个字符串进行比较，PHP会把字符串转换成数字再进行比较。PHP转换的规则的是：若字符串以数字开头，则取开头数字作为转换结果，若无则输出0。例如：123abc转换后应该是123，而abc123转换后为0，0&#x3D;&#x3D;0这当然是成立的啦！所以，0 &#x3D;&#x3D;’abc123’是成立的。当有一个对比参数是整数的时候，会把另外一个参数强制转换为整数。 将QNKCDZO（不能加’’）进行MD5加密，密文为0e830400451993494058024219903391，发现密文为0e开头，PHP在进行比较运算时，如果遇到了0e\\d+这种字符串，就会将这种字符串解析为科学计数法(0的无论多少次方都是零),所以让两者相等我们只需再找到一个MD5加密后开头为0e的字符串即可。 使用get传参注意事项：1、使用get方式提交参数需要注意，参数中不能有\\。2、get方式传递date日期格式参数：startDate&#x3D;2011&#x2F;12&#x2F;02 10:50:25 ，使用yyyy&#x2F;mm&#x2F;dd HH:mm:ss格式传递 ，http协议是外国人定的，所以得用外国常用时间格式传递。3、使用GET请求方式给WEB服务器传递参数的格式：http：&#x2F;&#x2F;ww w.it315.org&#x2F;counter.jsp?name&#x3D;zhangsan&amp;password&#x3D;123。 给能传送参数的地址这样写 网址?参数名&#x3D;值&amp;参数名&#x3D;值 web2题目给出一段jsfuck的代码： 1[!+[]+!+[]+!+[]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]······ 复制到控制台执行得到 1&quot;3D45353D39333D38383D45353D39333D38383D45353D39333D38383D45353D39333D38382C3D45343D42443D41303D45383D41323D41423D45393D41413D39373D45343D42413D38362C3D0A3D45343D42383D38443D45363D39383D41463D45383D42463D39393D45343D42383D41412C3D45353D42303D42313D45393D39373D41453D45343D42443D41303D45383D41373D41333D0A3D45343D42413D38363D45353D38443D38413D45353D41343D41393D45363D42303D39343D45343D42383D38443D45363D42303D3934&quot; base16解码Quoted-printable解码得到flag附：Base16，32,64介绍 Base16，32,64解码 web3看到http状态码为302（重定向），并且消息头有hint，破解后知道用vim编辑器备份漏洞，查看index.php~得到分析代码得到flag出题人题解：intval() 函数用于获取变量的整数值。","categories":[{"name":"ctf","slug":"ctf","permalink":"https://zouyunkai.github.io/myblog/categories/ctf/"}],"tags":[{"name":"web","slug":"web","permalink":"https://zouyunkai.github.io/myblog/tags/web/"}],"author":"aoyuehan"},{"title":"qctf Crypto 19.2.14","slug":"qctf-Crypto-2-14","date":"2019-02-17T15:09:00.000Z","updated":"2022-02-26T03:52:52.299Z","comments":true,"path":"2019/02/17/qctf-Crypto-2-14/","link":"","permalink":"https://zouyunkai.github.io/myblog/2019/02/17/qctf-Crypto-2-14/","excerpt":"","text":"签到题题目：dpgs{j3yP0zr_g0_d1hpgs}hint: rotate by 13 places解：题目给出hint，即ROT13编码：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。在线ROT5&#x2F;13&#x2F;18&#x2F;47编码转换 crypto1题目：法治民主公正和谐法治自由公正公正法治诚信民主和谐法治公正爱国和谐民主平等和谐平等诚信平等和谐民主法治和谐平等诚信平等公正和谐和谐富强法治文明和谐和谐平等友善敬业平等公正自由民主和谐民主法治平等自由平等法治和谐平等诚信平等自由和谐和谐富强公正自由和谐和谐法治诚信和谐解：看到这道题，百度一下核心价值观编码 crypto2题目：与佛论禅,你能否参透佛意~~佛曰：冥帝皤僧梵遮實孕老罰穆室諳多缽曳逝佛佛侄是除哆地俱那死俱呼謹娑盧哆涅梵即怯利奢尼梵佛怯三奢隸諳孕諳栗曰涅冥利若冥醯呐參特漫缽彌侄道諳恐穆俱究苦有俱是恐婆婆不皤夜迦姪涅伊涅冥神罰竟實殿麼參奢訶俱尼隸奢竟奢謹孕數爍神冥實波冥故切夜怖豆穆解：题目给出提示“与佛论禅”在线解码 crypto3题目：p &#x3D; 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q &#x3D; 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e &#x3D; 65537c &#x3D; 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034Use RSA to find the secret messagethis problem comes from shiyanbar解：题目提示用RSA加密方式解密，已经给出p q e，利用三个参数生成私匙，利用私匙解密密文c得到flag。 1234567891011121314151617181920212223242526272829import mathp=9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q=11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e=65537c=83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034n=p*q #n为模数 （N，e）：公钥;（N，d）：私钥fn=long((p-1)*(q-1))#long() 函数：long(x, base=10)#x为字符串或数字。base(可选)为进制数，默认十进制。该函数返回一个长整型数i = 1while(True): x=(i*fn)+1 if(x%e==0): d=x/e break i=i+1print pow(c,d,n)#pow(x,y) 等价于 x**y 如4**2.5 结果为32.0；#pow(x,y,z) 等价于pow(x,y)%z 如pow(4,2.5,3)=4**2.5%3 结果为2.0#pow() 通过内置的方法直接调用，内置方法会把参数作为整型，而math模块#则会把参数转换为 float。例如：pow(4,2.5)=32;math.pow(4,2.5)=32.0 *RSA原理和例子","categories":[{"name":"ctf","slug":"ctf","permalink":"https://zouyunkai.github.io/myblog/categories/ctf/"}],"tags":[{"name":"crypto","slug":"crypto","permalink":"https://zouyunkai.github.io/myblog/tags/crypto/"}],"author":"aoyuehan"}],"categories":[{"name":"软考","slug":"软考","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%BD%AF%E8%80%83/"},{"name":"所长的跨学科工具箱","slug":"所长的跨学科工具箱","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%89%80%E9%95%BF%E7%9A%84%E8%B7%A8%E5%AD%A6%E7%A7%91%E5%B7%A5%E5%85%B7%E7%AE%B1/"},{"name":"面试","slug":"面试","permalink":"https://zouyunkai.github.io/myblog/categories/%E9%9D%A2%E8%AF%95/"},{"name":"杂记","slug":"杂记","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%9D%82%E8%AE%B0/"},{"name":"投资","slug":"投资","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%8A%95%E8%B5%84/"},{"name":"k8s","slug":"k8s","permalink":"https://zouyunkai.github.io/myblog/categories/k8s/"},{"name":"后端","slug":"后端","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%90%8E%E7%AB%AF/"},{"name":"大三实习","slug":"大三实习","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%A4%A7%E4%B8%89%E5%AE%9E%E4%B9%A0/"},{"name":"前端","slug":"前端","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%89%8D%E7%AB%AF/"},{"name":"acwing","slug":"acwing","permalink":"https://zouyunkai.github.io/myblog/categories/acwing/"},{"name":"云计算与大数据","slug":"云计算与大数据","permalink":"https://zouyunkai.github.io/myblog/categories/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"大数据","slug":"大数据","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"编译原理","slug":"编译原理","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"acwing蓝桥","slug":"acwing蓝桥","permalink":"https://zouyunkai.github.io/myblog/categories/acwing%E8%93%9D%E6%A1%A5/"},{"name":"pat","slug":"pat","permalink":"https://zouyunkai.github.io/myblog/categories/pat/"},{"name":"android开发","slug":"android开发","permalink":"https://zouyunkai.github.io/myblog/categories/android%E5%BC%80%E5%8F%91/"},{"name":"JAVA","slug":"JAVA","permalink":"https://zouyunkai.github.io/myblog/categories/JAVA/"},{"name":"前端项目总结","slug":"前端项目总结","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"},{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"编程刷题","slug":"编程刷题","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BC%96%E7%A8%8B%E5%88%B7%E9%A2%98/"},{"name":"软件工程","slug":"软件工程","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"算法分析与设计","slug":"算法分析与设计","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"name":"ACM","slug":"ACM","permalink":"https://zouyunkai.github.io/myblog/categories/ACM/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"上知天文下知地理","slug":"上知天文下知地理","permalink":"https://zouyunkai.github.io/myblog/categories/%E4%B8%8A%E7%9F%A5%E5%A4%A9%E6%96%87%E4%B8%8B%E7%9F%A5%E5%9C%B0%E7%90%86/"},{"name":"算法设计与分析","slug":"算法设计与分析","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"name":"javaScript","slug":"javaScript","permalink":"https://zouyunkai.github.io/myblog/categories/javaScript/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%89%91%E6%8C%87offer/"},{"name":"网络安全","slug":"网络安全","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Windows和office的使用技巧","slug":"Windows和office的使用技巧","permalink":"https://zouyunkai.github.io/myblog/categories/Windows%E5%92%8Coffice%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"c++面向对象","slug":"c-面向对象","permalink":"https://zouyunkai.github.io/myblog/categories/c-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"asp","slug":"asp","permalink":"https://zouyunkai.github.io/myblog/categories/asp/"},{"name":"java interview","slug":"java-interview","permalink":"https://zouyunkai.github.io/myblog/categories/java-interview/"},{"name":"动态规划","slug":"动态规划","permalink":"https://zouyunkai.github.io/myblog/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"操作系统","slug":"操作系统","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"窥探计算机底层的奥秘","slug":"窥探计算机底层的奥秘","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%AA%A5%E6%8E%A2%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E5%A5%A5%E7%A7%98/"},{"name":"计算方法","slug":"计算方法","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/"},{"name":"计算计网络","slug":"计算计网络","permalink":"https://zouyunkai.github.io/myblog/categories/%E8%AE%A1%E7%AE%97%E8%AE%A1%E7%BD%91%E7%BB%9C/"},{"name":"linux","slug":"linux","permalink":"https://zouyunkai.github.io/myblog/categories/linux/"},{"name":"JAVA开发","slug":"JAVA开发","permalink":"https://zouyunkai.github.io/myblog/categories/JAVA%E5%BC%80%E5%8F%91/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zouyunkai.github.io/myblog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C#","slug":"C","permalink":"https://zouyunkai.github.io/myblog/categories/C/"},{"name":"生活知识","slug":"生活知识","permalink":"https://zouyunkai.github.io/myblog/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"CTF","slug":"CTF","permalink":"https://zouyunkai.github.io/myblog/categories/CTF/"},{"name":"ctf","slug":"ctf","permalink":"https://zouyunkai.github.io/myblog/categories/ctf/"}],"tags":[{"name":"comparable and comparator","slug":"comparable-and-comparator","permalink":"https://zouyunkai.github.io/myblog/tags/comparable-and-comparator/"},{"name":"java 深浅拷贝","slug":"java-深浅拷贝","permalink":"https://zouyunkai.github.io/myblog/tags/java-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"java se","slug":"java-se","permalink":"https://zouyunkai.github.io/myblog/tags/java-se/"},{"name":"蓝桥杯算法","slug":"蓝桥杯算法","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%AE%97%E6%B3%95/"},{"name":"国王挖金子","slug":"国王挖金子","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%9B%BD%E7%8E%8B%E6%8C%96%E9%87%91%E5%AD%90/"},{"name":"计网笔记","slug":"计网笔记","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%AE%A1%E7%BD%91%E7%AC%94%E8%AE%B0/"},{"name":"棋盘覆盖","slug":"棋盘覆盖","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96/"},{"name":"FFT","slug":"FFT","permalink":"https://zouyunkai.github.io/myblog/tags/FFT/"},{"name":"数据库","slug":"数据库","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"递归与分治","slug":"递归与分治","permalink":"https://zouyunkai.github.io/myblog/tags/%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB/"},{"name":"linux教程","slug":"linux教程","permalink":"https://zouyunkai.github.io/myblog/tags/linux%E6%95%99%E7%A8%8B/"},{"name":"单调栈","slug":"单调栈","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"name":"单调队列","slug":"单调队列","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"},{"name":"codeforce","slug":"codeforce","permalink":"https://zouyunkai.github.io/myblog/tags/codeforce/"},{"name":"图论","slug":"图论","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"联盟周赛","slug":"联盟周赛","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%81%94%E7%9B%9F%E5%91%A8%E8%B5%9B/"},{"name":"iis配置","slug":"iis配置","permalink":"https://zouyunkai.github.io/myblog/tags/iis%E9%85%8D%E7%BD%AE/"},{"name":"面试","slug":"面试","permalink":"https://zouyunkai.github.io/myblog/tags/%E9%9D%A2%E8%AF%95/"},{"name":"牛客","slug":"牛客","permalink":"https://zouyunkai.github.io/myblog/tags/%E7%89%9B%E5%AE%A2/"},{"name":"训练","slug":"训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%AE%AD%E7%BB%83/"},{"name":"新生训练","slug":"新生训练","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83/"},{"name":"博弈论","slug":"博弈论","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"最短路径","slug":"最短路径","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"英文单词","slug":"英文单词","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%8B%B1%E6%96%87%E5%8D%95%E8%AF%8D/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"新生训练_02","slug":"新生训练-02","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%96%B0%E7%94%9F%E8%AE%AD%E7%BB%83-02/"},{"name":"DP","slug":"DP","permalink":"https://zouyunkai.github.io/myblog/tags/DP/"},{"name":"2019校赛","slug":"2019校赛","permalink":"https://zouyunkai.github.io/myblog/tags/2019%E6%A0%A1%E8%B5%9B/"},{"name":"html","slug":"html","permalink":"https://zouyunkai.github.io/myblog/tags/html/"},{"name":"java","slug":"java","permalink":"https://zouyunkai.github.io/myblog/tags/java/"},{"name":"杭电","slug":"杭电","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%9D%AD%E7%94%B5/"},{"name":"最小生成树","slug":"最小生成树","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"哈夫曼编码","slug":"哈夫曼编码","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"排序算法","slug":"排序算法","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"大数运算","slug":"大数运算","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97/"},{"name":"蓝桥省赛","slug":"蓝桥省赛","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%93%9D%E6%A1%A5%E7%9C%81%E8%B5%9B/"},{"name":"c#","slug":"c","permalink":"https://zouyunkai.github.io/myblog/tags/c/"},{"name":"qluoj","slug":"qluoj","permalink":"https://zouyunkai.github.io/myblog/tags/qluoj/"},{"name":"DFS","slug":"DFS","permalink":"https://zouyunkai.github.io/myblog/tags/DFS/"},{"name":"BFS","slug":"BFS","permalink":"https://zouyunkai.github.io/myblog/tags/BFS/"},{"name":"图","slug":"图","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%9B%BE/"},{"name":"哲学","slug":"哲学","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%93%B2%E5%AD%A6/"},{"name":"栈","slug":"栈","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://zouyunkai.github.io/myblog/tags/%E9%98%9F%E5%88%97/"},{"name":"递归","slug":"递归","permalink":"https://zouyunkai.github.io/myblog/tags/%E9%80%92%E5%BD%92/"},{"name":"KMP","slug":"KMP","permalink":"https://zouyunkai.github.io/myblog/tags/KMP/"},{"name":"CF","slug":"CF","permalink":"https://zouyunkai.github.io/myblog/tags/CF/"},{"name":"git","slug":"git","permalink":"https://zouyunkai.github.io/myblog/tags/git/"},{"name":"动态规划","slug":"动态规划","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"背包问题","slug":"背包问题","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"二分法","slug":"二分法","permalink":"https://zouyunkai.github.io/myblog/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"算法","slug":"算法","permalink":"https://zouyunkai.github.io/myblog/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心","slug":"贪心","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%B4%AA%E5%BF%83/"},{"name":"c","slug":"c","permalink":"https://zouyunkai.github.io/myblog/tags/c/"},{"name":"c++","slug":"c","permalink":"https://zouyunkai.github.io/myblog/tags/c/"},{"name":"c语言小知识","slug":"c语言小知识","permalink":"https://zouyunkai.github.io/myblog/tags/c%E8%AF%AD%E8%A8%80%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"name":"stl","slug":"stl","permalink":"https://zouyunkai.github.io/myblog/tags/stl/"},{"name":"web","slug":"web","permalink":"https://zouyunkai.github.io/myblog/tags/web/"},{"name":"sql","slug":"sql","permalink":"https://zouyunkai.github.io/myblog/tags/sql/"},{"name":"DOM","slug":"DOM","permalink":"https://zouyunkai.github.io/myblog/tags/DOM/"},{"name":"js","slug":"js","permalink":"https://zouyunkai.github.io/myblog/tags/js/"},{"name":"boos","slug":"boos","permalink":"https://zouyunkai.github.io/myblog/tags/boos/"},{"name":"mysql","slug":"mysql","permalink":"https://zouyunkai.github.io/myblog/tags/mysql/"},{"name":"快速幂","slug":"快速幂","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"},{"name":"模板","slug":"模板","permalink":"https://zouyunkai.github.io/myblog/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"素数","slug":"素数","permalink":"https://zouyunkai.github.io/myblog/tags/%E7%B4%A0%E6%95%B0/"},{"name":"param","slug":"param","permalink":"https://zouyunkai.github.io/myblog/tags/param/"},{"name":"java网络编程","slug":"java网络编程","permalink":"https://zouyunkai.github.io/myblog/tags/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"聊天室","slug":"聊天室","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%81%8A%E5%A4%A9%E5%AE%A4/"},{"name":"小游戏","slug":"小游戏","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"},{"name":"五子棋","slug":"五子棋","permalink":"https://zouyunkai.github.io/myblog/tags/%E4%BA%94%E5%AD%90%E6%A3%8B/"},{"name":"贪吃蛇","slug":"贪吃蛇","permalink":"https://zouyunkai.github.io/myblog/tags/%E8%B4%AA%E5%90%83%E8%9B%87/"},{"name":"C++字符串处理","slug":"C-字符串处理","permalink":"https://zouyunkai.github.io/myblog/tags/C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"},{"name":"java算法","slug":"java算法","permalink":"https://zouyunkai.github.io/myblog/tags/java%E7%AE%97%E6%B3%95/"},{"name":"  ","slug":"","permalink":"https://zouyunkai.github.io/myblog/tags/"},{"name":"山理工","slug":"山理工","permalink":"https://zouyunkai.github.io/myblog/tags/%E5%B1%B1%E7%90%86%E5%B7%A5/"},{"name":"隐写","slug":"隐写","permalink":"https://zouyunkai.github.io/myblog/tags/%E9%9A%90%E5%86%99/"},{"name":"crypto","slug":"crypto","permalink":"https://zouyunkai.github.io/myblog/tags/crypto/"}]}